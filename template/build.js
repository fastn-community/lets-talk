(function () {
  'use strict';

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues(rnds8);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).substr(1));
  }

  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    return stringify(rnds);
  }

  // NOTE: this list must be up-to-date with browsers listed in
  // test/acceptance/useragentstrings.yml
  const BROWSER_ALIASES_MAP = {
    'Amazon Silk': 'amazon_silk',
    'Android Browser': 'android',
    Bada: 'bada',
    BlackBerry: 'blackberry',
    Chrome: 'chrome',
    Chromium: 'chromium',
    Electron: 'electron',
    Epiphany: 'epiphany',
    Firefox: 'firefox',
    Focus: 'focus',
    Generic: 'generic',
    'Google Search': 'google_search',
    Googlebot: 'googlebot',
    'Internet Explorer': 'ie',
    'K-Meleon': 'k_meleon',
    Maxthon: 'maxthon',
    'Microsoft Edge': 'edge',
    'MZ Browser': 'mz',
    'NAVER Whale Browser': 'naver',
    Opera: 'opera',
    'Opera Coast': 'opera_coast',
    PhantomJS: 'phantomjs',
    Puffin: 'puffin',
    QupZilla: 'qupzilla',
    QQ: 'qq',
    QQLite: 'qqlite',
    Safari: 'safari',
    Sailfish: 'sailfish',
    'Samsung Internet for Android': 'samsung_internet',
    SeaMonkey: 'seamonkey',
    Sleipnir: 'sleipnir',
    Swing: 'swing',
    Tizen: 'tizen',
    'UC Browser': 'uc',
    Vivaldi: 'vivaldi',
    'WebOS Browser': 'webos',
    WeChat: 'wechat',
    'Yandex Browser': 'yandex',
    Roku: 'roku',
  };

  const BROWSER_MAP = {
    amazon_silk: 'Amazon Silk',
    android: 'Android Browser',
    bada: 'Bada',
    blackberry: 'BlackBerry',
    chrome: 'Chrome',
    chromium: 'Chromium',
    electron: 'Electron',
    epiphany: 'Epiphany',
    firefox: 'Firefox',
    focus: 'Focus',
    generic: 'Generic',
    googlebot: 'Googlebot',
    google_search: 'Google Search',
    ie: 'Internet Explorer',
    k_meleon: 'K-Meleon',
    maxthon: 'Maxthon',
    edge: 'Microsoft Edge',
    mz: 'MZ Browser',
    naver: 'NAVER Whale Browser',
    opera: 'Opera',
    opera_coast: 'Opera Coast',
    phantomjs: 'PhantomJS',
    puffin: 'Puffin',
    qupzilla: 'QupZilla',
    qq: 'QQ Browser',
    qqlite: 'QQ Browser Lite',
    safari: 'Safari',
    sailfish: 'Sailfish',
    samsung_internet: 'Samsung Internet for Android',
    seamonkey: 'SeaMonkey',
    sleipnir: 'Sleipnir',
    swing: 'Swing',
    tizen: 'Tizen',
    uc: 'UC Browser',
    vivaldi: 'Vivaldi',
    webos: 'WebOS Browser',
    wechat: 'WeChat',
    yandex: 'Yandex Browser',
  };

  const PLATFORMS_MAP = {
    tablet: 'tablet',
    mobile: 'mobile',
    desktop: 'desktop',
    tv: 'tv',
  };

  const OS_MAP = {
    WindowsPhone: 'Windows Phone',
    Windows: 'Windows',
    MacOS: 'macOS',
    iOS: 'iOS',
    Android: 'Android',
    WebOS: 'WebOS',
    BlackBerry: 'BlackBerry',
    Bada: 'Bada',
    Tizen: 'Tizen',
    Linux: 'Linux',
    ChromeOS: 'Chrome OS',
    PlayStation4: 'PlayStation 4',
    Roku: 'Roku',
  };

  const ENGINE_MAP = {
    EdgeHTML: 'EdgeHTML',
    Blink: 'Blink',
    Trident: 'Trident',
    Presto: 'Presto',
    Gecko: 'Gecko',
    WebKit: 'WebKit',
  };

  class Utils {
    /**
     * Get first matched item for a string
     * @param {RegExp} regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getFirstMatch(regexp, ua) {
      const match = ua.match(regexp);
      return (match && match.length > 0 && match[1]) || '';
    }

    /**
     * Get second matched item for a string
     * @param regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getSecondMatch(regexp, ua) {
      const match = ua.match(regexp);
      return (match && match.length > 1 && match[2]) || '';
    }

    /**
     * Match a regexp and return a constant or undefined
     * @param {RegExp} regexp
     * @param {String} ua
     * @param {*} _const Any const that will be returned if regexp matches the string
     * @return {*}
     */
    static matchAndReturnConst(regexp, ua, _const) {
      if (regexp.test(ua)) {
        return _const;
      }
      return undefined;
    }

    static getWindowsVersionName(version) {
      switch (version) {
        case 'NT': return 'NT';
        case 'XP': return 'XP';
        case 'NT 5.0': return '2000';
        case 'NT 5.1': return 'XP';
        case 'NT 5.2': return '2003';
        case 'NT 6.0': return 'Vista';
        case 'NT 6.1': return '7';
        case 'NT 6.2': return '8';
        case 'NT 6.3': return '8.1';
        case 'NT 10.0': return '10';
        default: return undefined;
      }
    }

    /**
     * Get macOS version name
     *    10.5 - Leopard
     *    10.6 - Snow Leopard
     *    10.7 - Lion
     *    10.8 - Mountain Lion
     *    10.9 - Mavericks
     *    10.10 - Yosemite
     *    10.11 - El Capitan
     *    10.12 - Sierra
     *    10.13 - High Sierra
     *    10.14 - Mojave
     *    10.15 - Catalina
     *
     * @example
     *   getMacOSVersionName("10.14") // 'Mojave'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getMacOSVersionName(version) {
      const v = version.split('.').splice(0, 2).map(s => parseInt(s, 10) || 0);
      v.push(0);
      if (v[0] !== 10) return undefined;
      switch (v[1]) {
        case 5: return 'Leopard';
        case 6: return 'Snow Leopard';
        case 7: return 'Lion';
        case 8: return 'Mountain Lion';
        case 9: return 'Mavericks';
        case 10: return 'Yosemite';
        case 11: return 'El Capitan';
        case 12: return 'Sierra';
        case 13: return 'High Sierra';
        case 14: return 'Mojave';
        case 15: return 'Catalina';
        default: return undefined;
      }
    }

    /**
     * Get Android version name
     *    1.5 - Cupcake
     *    1.6 - Donut
     *    2.0 - Eclair
     *    2.1 - Eclair
     *    2.2 - Froyo
     *    2.x - Gingerbread
     *    3.x - Honeycomb
     *    4.0 - Ice Cream Sandwich
     *    4.1 - Jelly Bean
     *    4.4 - KitKat
     *    5.x - Lollipop
     *    6.x - Marshmallow
     *    7.x - Nougat
     *    8.x - Oreo
     *    9.x - Pie
     *
     * @example
     *   getAndroidVersionName("7.0") // 'Nougat'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getAndroidVersionName(version) {
      const v = version.split('.').splice(0, 2).map(s => parseInt(s, 10) || 0);
      v.push(0);
      if (v[0] === 1 && v[1] < 5) return undefined;
      if (v[0] === 1 && v[1] < 6) return 'Cupcake';
      if (v[0] === 1 && v[1] >= 6) return 'Donut';
      if (v[0] === 2 && v[1] < 2) return 'Eclair';
      if (v[0] === 2 && v[1] === 2) return 'Froyo';
      if (v[0] === 2 && v[1] > 2) return 'Gingerbread';
      if (v[0] === 3) return 'Honeycomb';
      if (v[0] === 4 && v[1] < 1) return 'Ice Cream Sandwich';
      if (v[0] === 4 && v[1] < 4) return 'Jelly Bean';
      if (v[0] === 4 && v[1] >= 4) return 'KitKat';
      if (v[0] === 5) return 'Lollipop';
      if (v[0] === 6) return 'Marshmallow';
      if (v[0] === 7) return 'Nougat';
      if (v[0] === 8) return 'Oreo';
      if (v[0] === 9) return 'Pie';
      return undefined;
    }

    /**
     * Get version precisions count
     *
     * @example
     *   getVersionPrecision("1.10.3") // 3
     *
     * @param  {string} version
     * @return {number}
     */
    static getVersionPrecision(version) {
      return version.split('.').length;
    }

    /**
     * Calculate browser version weight
     *
     * @example
     *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
     *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
     *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
     *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
     *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
     *
     * @param {String} versionA versions versions to compare
     * @param {String} versionB versions versions to compare
     * @param {boolean} [isLoose] enable loose comparison
     * @return {Number} comparison result: -1 when versionA is lower,
     * 1 when versionA is bigger, 0 when both equal
     */
    /* eslint consistent-return: 1 */
    static compareVersions(versionA, versionB, isLoose = false) {
      // 1) get common precision for both versions, for example for "10.0" and "9" it should be 2
      const versionAPrecision = Utils.getVersionPrecision(versionA);
      const versionBPrecision = Utils.getVersionPrecision(versionB);

      let precision = Math.max(versionAPrecision, versionBPrecision);
      let lastPrecision = 0;

      const chunks = Utils.map([versionA, versionB], (version) => {
        const delta = precision - Utils.getVersionPrecision(version);

        // 2) "9" -> "9.0" (for precision = 2)
        const _version = version + new Array(delta + 1).join('.0');

        // 3) "9.0" -> ["000000000"", "000000009"]
        return Utils.map(_version.split('.'), chunk => new Array(20 - chunk.length).join('0') + chunk).reverse();
      });

      // adjust precision for loose comparison
      if (isLoose) {
        lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
      }

      // iterate in reverse order by reversed chunks array
      precision -= 1;
      while (precision >= lastPrecision) {
        // 4) compare: "000000009" > "000000010" = false (but "9" > "10" = true)
        if (chunks[0][precision] > chunks[1][precision]) {
          return 1;
        }

        if (chunks[0][precision] === chunks[1][precision]) {
          if (precision === lastPrecision) {
            // all version chunks are same
            return 0;
          }

          precision -= 1;
        } else if (chunks[0][precision] < chunks[1][precision]) {
          return -1;
        }
      }

      return undefined;
    }

    /**
     * Array::map polyfill
     *
     * @param  {Array} arr
     * @param  {Function} iterator
     * @return {Array}
     */
    static map(arr, iterator) {
      const result = [];
      let i;
      if (Array.prototype.map) {
        return Array.prototype.map.call(arr, iterator);
      }
      for (i = 0; i < arr.length; i += 1) {
        result.push(iterator(arr[i]));
      }
      return result;
    }

    /**
     * Array::find polyfill
     *
     * @param  {Array} arr
     * @param  {Function} predicate
     * @return {Array}
     */
    static find(arr, predicate) {
      let i;
      let l;
      if (Array.prototype.find) {
        return Array.prototype.find.call(arr, predicate);
      }
      for (i = 0, l = arr.length; i < l; i += 1) {
        const value = arr[i];
        if (predicate(value, i)) {
          return value;
        }
      }
      return undefined;
    }

    /**
     * Object::assign polyfill
     *
     * @param  {Object} obj
     * @param  {Object} ...objs
     * @return {Object}
     */
    static assign(obj, ...assigners) {
      const result = obj;
      let i;
      let l;
      if (Object.assign) {
        return Object.assign(obj, ...assigners);
      }
      for (i = 0, l = assigners.length; i < l; i += 1) {
        const assigner = assigners[i];
        if (typeof assigner === 'object' && assigner !== null) {
          const keys = Object.keys(assigner);
          keys.forEach((key) => {
            result[key] = assigner[key];
          });
        }
      }
      return obj;
    }

    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('Microsoft Edge') // edge
     *
     * @param  {string} browserName
     * @return {string}
     */
    static getBrowserAlias(browserName) {
      return BROWSER_ALIASES_MAP[browserName];
    }

    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('edge') // Microsoft Edge
     *
     * @param  {string} browserAlias
     * @return {string}
     */
    static getBrowserTypeByAlias(browserAlias) {
      return BROWSER_MAP[browserAlias] || '';
    }
  }

  /**
   * Browsers' descriptors
   *
   * The idea of descriptors is simple. You should know about them two simple things:
   * 1. Every descriptor has a method or property called `test` and a `describe` method.
   * 2. Order of descriptors is important.
   *
   * More details:
   * 1. Method or property `test` serves as a way to detect whether the UA string
   * matches some certain browser or not. The `describe` method helps to make a result
   * object with params that show some browser-specific things: name, version, etc.
   * 2. Order of descriptors is important because a Parser goes through them one by one
   * in course. For example, if you insert Chrome's descriptor as the first one,
   * more then a half of browsers will be described as Chrome, because they will pass
   * the Chrome descriptor's test.
   *
   * Descriptor's `test` could be a property with an array of RegExps, where every RegExp
   * will be applied to a UA string to test it whether it matches or not.
   * If a descriptor has two or more regexps in the `test` array it tests them one by one
   * with a logical sum operation. Parser stops if it has found any RegExp that matches the UA.
   *
   * Or `test` could be a method. In that case it gets a Parser instance and should
   * return true/false to get the Parser know if this browser descriptor matches the UA or not.
   */


  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;

  const browsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe(ua) {
        const browser = {
          name: 'Googlebot',
        };
        const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* Opera < 13.0 */
    {
      test: [/opera/i],
      describe(ua) {
        const browser = {
          name: 'Opera',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* Opera > 13.0 */
    {
      test: [/opr\/|opios/i],
      describe(ua) {
        const browser = {
          name: 'Opera',
        };
        const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/SamsungBrowser/i],
      describe(ua) {
        const browser = {
          name: 'Samsung Internet for Android',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/Whale/i],
      describe(ua) {
        const browser = {
          name: 'NAVER Whale Browser',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/MZBrowser/i],
      describe(ua) {
        const browser = {
          name: 'MZ Browser',
        };
        const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/focus/i],
      describe(ua) {
        const browser = {
          name: 'Focus',
        };
        const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/swing/i],
      describe(ua) {
        const browser = {
          name: 'Swing',
        };
        const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/coast/i],
      describe(ua) {
        const browser = {
          name: 'Opera Coast',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(ua) {
        const browser = {
          name: 'Opera Touch',
        };
        const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/yabrowser/i],
      describe(ua) {
        const browser = {
          name: 'Yandex Browser',
        };
        const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/ucbrowser/i],
      describe(ua) {
        const browser = {
          name: 'UC Browser',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/Maxthon|mxios/i],
      describe(ua) {
        const browser = {
          name: 'Maxthon',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/epiphany/i],
      describe(ua) {
        const browser = {
          name: 'Epiphany',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/puffin/i],
      describe(ua) {
        const browser = {
          name: 'Puffin',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/sleipnir/i],
      describe(ua) {
        const browser = {
          name: 'Sleipnir',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/k-meleon/i],
      describe(ua) {
        const browser = {
          name: 'K-Meleon',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/micromessenger/i],
      describe(ua) {
        const browser = {
          name: 'WeChat',
        };
        const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/qqbrowser/i],
      describe(ua) {
        const browser = {
          name: (/qqbrowserlite/i).test(ua) ? 'QQ Browser Lite' : 'QQ Browser',
        };
        const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/msie|trident/i],
      describe(ua) {
        const browser = {
          name: 'Internet Explorer',
        };
        const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/\sedg\//i],
      describe(ua) {
        const browser = {
          name: 'Microsoft Edge',
        };

        const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(ua) {
        const browser = {
          name: 'Microsoft Edge',
        };

        const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/vivaldi/i],
      describe(ua) {
        const browser = {
          name: 'Vivaldi',
        };
        const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/seamonkey/i],
      describe(ua) {
        const browser = {
          name: 'SeaMonkey',
        };
        const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/sailfish/i],
      describe(ua) {
        const browser = {
          name: 'Sailfish',
        };

        const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/silk/i],
      describe(ua) {
        const browser = {
          name: 'Amazon Silk',
        };
        const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/phantom/i],
      describe(ua) {
        const browser = {
          name: 'PhantomJS',
        };
        const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/slimerjs/i],
      describe(ua) {
        const browser = {
          name: 'SlimerJS',
        };
        const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua) {
        const browser = {
          name: 'BlackBerry',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua) {
        const browser = {
          name: 'WebOS Browser',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/bada/i],
      describe(ua) {
        const browser = {
          name: 'Bada',
        };
        const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/tizen/i],
      describe(ua) {
        const browser = {
          name: 'Tizen',
        };
        const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/qupzilla/i],
      describe(ua) {
        const browser = {
          name: 'QupZilla',
        };
        const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(ua) {
        const browser = {
          name: 'Firefox',
        };
        const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/electron/i],
      describe(ua) {
        const browser = {
          name: 'Electron',
        };
        const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/MiuiBrowser/i],
      describe(ua) {
        const browser = {
          name: 'Miui',
        };
        const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/chromium/i],
      describe(ua) {
        const browser = {
          name: 'Chromium',
        };
        const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(ua) {
        const browser = {
          name: 'Chrome',
        };
        const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },
    {
      test: [/GSA/i],
      describe(ua) {
        const browser = {
          name: 'Google Search',
        };
        const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* Android Browser */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua) {
        const browser = {
          name: 'Android Browser',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* PlayStation 4 */
    {
      test: [/playstation 4/i],
      describe(ua) {
        const browser = {
          name: 'PlayStation 4',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* Safari */
    {
      test: [/safari|applewebkit/i],
      describe(ua) {
        const browser = {
          name: 'Safari',
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);

        if (version) {
          browser.version = version;
        }

        return browser;
      },
    },

    /* Something else */
    {
      test: [/.*/i],
      describe(ua) {
        /* Here we try to make sure that there are explicit details about the device
         * in order to decide what regexp exactly we want to apply
         * (as there is a specific decision based on that conclusion)
         */
        const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
        const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
        const hasDeviceSpec = ua.search('\\(') !== -1;
        const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
        return {
          name: Utils.getFirstMatch(regexp, ua),
          version: Utils.getSecondMatch(regexp, ua),
        };
      },
    },
  ];

  var osParsersList = [
    /* Roku */
    {
      test: [/Roku\/DVP/],
      describe(ua) {
        const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
        return {
          name: OS_MAP.Roku,
          version,
        };
      },
    },

    /* Windows Phone */
    {
      test: [/windows phone/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.WindowsPhone,
          version,
        };
      },
    },

    /* Windows */
    {
      test: [/windows /i],
      describe(ua) {
        const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
        const versionName = Utils.getWindowsVersionName(version);

        return {
          name: OS_MAP.Windows,
          version,
          versionName,
        };
      },
    },

    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(ua) {
        const result = {
          name: OS_MAP.iOS,
        };
        const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
        if (version) {
          result.version = version;
        }
        return result;
      },
    },

    /* macOS */
    {
      test: [/macintosh/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, '.');
        const versionName = Utils.getMacOSVersionName(version);

        const os = {
          name: OS_MAP.MacOS,
          version,
        };
        if (versionName) {
          os.versionName = versionName;
        }
        return os;
      },
    },

    /* iOS */
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, '.');

        return {
          name: OS_MAP.iOS,
          version,
        };
      },
    },

    /* Android */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua) {
        const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
        const versionName = Utils.getAndroidVersionName(version);
        const os = {
          name: OS_MAP.Android,
          version,
        };
        if (versionName) {
          os.versionName = versionName;
        }
        return os;
      },
    },

    /* WebOS */
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
        const os = {
          name: OS_MAP.WebOS,
        };

        if (version && version.length) {
          os.version = version;
        }
        return os;
      },
    },

    /* BlackBerry */
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua)
          || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua)
          || Utils.getFirstMatch(/\bbb(\d+)/i, ua);

        return {
          name: OS_MAP.BlackBerry,
          version,
        };
      },
    },

    /* Bada */
    {
      test: [/bada/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);

        return {
          name: OS_MAP.Bada,
          version,
        };
      },
    },

    /* Tizen */
    {
      test: [/tizen/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);

        return {
          name: OS_MAP.Tizen,
          version,
        };
      },
    },

    /* Linux */
    {
      test: [/linux/i],
      describe() {
        return {
          name: OS_MAP.Linux,
        };
      },
    },

    /* Chrome OS */
    {
      test: [/CrOS/],
      describe() {
        return {
          name: OS_MAP.ChromeOS,
        };
      },
    },

    /* Playstation 4 */
    {
      test: [/PlayStation 4/],
      describe(ua) {
        const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.PlayStation4,
          version,
        };
      },
    },
  ];

  /*
   * Tablets go first since usually they have more specific
   * signs to detect.
   */

  var platformParsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe() {
        return {
          type: 'bot',
          vendor: 'Google',
        };
      },
    },

    /* Huawei */
    {
      test: [/huawei/i],
      describe(ua) {
        const model = Utils.getFirstMatch(/(can-l01)/i, ua) && 'Nova';
        const platform = {
          type: PLATFORMS_MAP.mobile,
          vendor: 'Huawei',
        };
        if (model) {
          platform.model = model;
        }
        return platform;
      },
    },

    /* Nexus Tablet */
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: 'Nexus',
        };
      },
    },

    /* iPad */
    {
      test: [/ipad/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: 'Apple',
          model: 'iPad',
        };
      },
    },

    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: 'Apple',
          model: 'iPad',
        };
      },
    },

    /* Amazon Kindle Fire */
    {
      test: [/kftt build/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: 'Amazon',
          model: 'Kindle Fire HD 7',
        };
      },
    },

    /* Another Amazon Tablet with Silk */
    {
      test: [/silk/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: 'Amazon',
        };
      },
    },

    /* Tablet */
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
        };
      },
    },

    /* iPod/iPhone */
    {
      test(parser) {
        const iDevice = parser.test(/ipod|iphone/i);
        const likeIDevice = parser.test(/like (ipod|iphone)/i);
        return iDevice && !likeIDevice;
      },
      describe(ua) {
        const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: 'Apple',
          model,
        };
      },
    },

    /* Nexus Mobile */
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: 'Nexus',
        };
      },
    },

    /* Mobile */
    {
      test: [/[^-]mobi/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
        };
      },
    },

    /* BlackBerry */
    {
      test(parser) {
        return parser.getBrowserName(true) === 'blackberry';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: 'BlackBerry',
        };
      },
    },

    /* Bada */
    {
      test(parser) {
        return parser.getBrowserName(true) === 'bada';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
        };
      },
    },

    /* Windows Phone */
    {
      test(parser) {
        return parser.getBrowserName() === 'windows phone';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: 'Microsoft',
        };
      },
    },

    /* Android Tablet */
    {
      test(parser) {
        const osMajorVersion = Number(String(parser.getOSVersion()).split('.')[0]);
        return parser.getOSName(true) === 'android' && (osMajorVersion >= 3);
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
        };
      },
    },

    /* Android Mobile */
    {
      test(parser) {
        return parser.getOSName(true) === 'android';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
        };
      },
    },

    /* desktop */
    {
      test(parser) {
        return parser.getOSName(true) === 'macos';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop,
          vendor: 'Apple',
        };
      },
    },

    /* Windows */
    {
      test(parser) {
        return parser.getOSName(true) === 'windows';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop,
        };
      },
    },

    /* Linux */
    {
      test(parser) {
        return parser.getOSName(true) === 'linux';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop,
        };
      },
    },

    /* PlayStation 4 */
    {
      test(parser) {
        return parser.getOSName(true) === 'playstation 4';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv,
        };
      },
    },

    /* Roku */
    {
      test(parser) {
        return parser.getOSName(true) === 'roku';
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv,
        };
      },
    },
  ];

  /*
   * More specific goes first
   */
  var enginesParsersList = [
    /* EdgeHTML */
    {
      test(parser) {
        return parser.getBrowserName(true) === 'microsoft edge';
      },
      describe(ua) {
        const isBlinkBased = /\sedg\//i.test(ua);

        // return blink if it's blink-based one
        if (isBlinkBased) {
          return {
            name: ENGINE_MAP.Blink,
          };
        }

        // otherwise match the version and return EdgeHTML
        const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);

        return {
          name: ENGINE_MAP.EdgeHTML,
          version,
        };
      },
    },

    /* Trident */
    {
      test: [/trident/i],
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Trident,
        };

        const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          engine.version = version;
        }

        return engine;
      },
    },

    /* Presto */
    {
      test(parser) {
        return parser.test(/presto/i);
      },
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Presto,
        };

        const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          engine.version = version;
        }

        return engine;
      },
    },

    /* Gecko */
    {
      test(parser) {
        const isGecko = parser.test(/gecko/i);
        const likeGecko = parser.test(/like gecko/i);
        return isGecko && !likeGecko;
      },
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Gecko,
        };

        const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          engine.version = version;
        }

        return engine;
      },
    },

    /* Blink */
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return {
          name: ENGINE_MAP.Blink,
        };
      },
    },

    /* WebKit */
    {
      test: [/(apple)?webkit/i],
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.WebKit,
        };

        const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);

        if (version) {
          engine.version = version;
        }

        return engine;
      },
    },
  ];

  /**
   * The main class that arranges the whole parsing process.
   */
  class Parser {
    /**
     * Create instance of Parser
     *
     * @param {String} UA User-Agent string
     * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
     * improvements if you need to make a more particular parsing
     * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
     *
     * @throw {Error} in case of empty UA String
     *
     * @constructor
     */
    constructor(UA, skipParsing = false) {
      if (UA === undefined || UA === null || UA === '') {
        throw new Error("UserAgent parameter can't be empty");
      }

      this._ua = UA;

      /**
       * @typedef ParsedResult
       * @property {Object} browser
       * @property {String|undefined} [browser.name]
       * Browser name, like `"Chrome"` or `"Internet Explorer"`
       * @property {String|undefined} [browser.version] Browser version as a String `"12.01.45334.10"`
       * @property {Object} os
       * @property {String|undefined} [os.name] OS name, like `"Windows"` or `"macOS"`
       * @property {String|undefined} [os.version] OS version, like `"NT 5.1"` or `"10.11.1"`
       * @property {String|undefined} [os.versionName] OS name, like `"XP"` or `"High Sierra"`
       * @property {Object} platform
       * @property {String|undefined} [platform.type]
       * platform type, can be either `"desktop"`, `"tablet"` or `"mobile"`
       * @property {String|undefined} [platform.vendor] Vendor of the device,
       * like `"Apple"` or `"Samsung"`
       * @property {String|undefined} [platform.model] Device model,
       * like `"iPhone"` or `"Kindle Fire HD 7"`
       * @property {Object} engine
       * @property {String|undefined} [engine.name]
       * Can be any of this: `WebKit`, `Blink`, `Gecko`, `Trident`, `Presto`, `EdgeHTML`
       * @property {String|undefined} [engine.version] String version of the engine
       */
      this.parsedResult = {};

      if (skipParsing !== true) {
        this.parse();
      }
    }

    /**
     * Get UserAgent string of current Parser instance
     * @return {String} User-Agent String of the current <Parser> object
     *
     * @public
     */
    getUA() {
      return this._ua;
    }

    /**
     * Test a UA string for a regexp
     * @param {RegExp} regex
     * @return {Boolean}
     */
    test(regex) {
      return regex.test(this._ua);
    }

    /**
     * Get parsed browser object
     * @return {Object}
     */
    parseBrowser() {
      this.parsedResult.browser = {};

      const browserDescriptor = Utils.find(browsersList, (_browser) => {
        if (typeof _browser.test === 'function') {
          return _browser.test(this);
        }

        if (_browser.test instanceof Array) {
          return _browser.test.some(condition => this.test(condition));
        }

        throw new Error("Browser's test function is not valid");
      });

      if (browserDescriptor) {
        this.parsedResult.browser = browserDescriptor.describe(this.getUA());
      }

      return this.parsedResult.browser;
    }

    /**
     * Get parsed browser object
     * @return {Object}
     *
     * @public
     */
    getBrowser() {
      if (this.parsedResult.browser) {
        return this.parsedResult.browser;
      }

      return this.parseBrowser();
    }

    /**
     * Get browser's name
     * @return {String} Browser's name or an empty string
     *
     * @public
     */
    getBrowserName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getBrowser().name).toLowerCase() || '';
      }
      return this.getBrowser().name || '';
    }


    /**
     * Get browser's version
     * @return {String} version of browser
     *
     * @public
     */
    getBrowserVersion() {
      return this.getBrowser().version;
    }

    /**
     * Get OS
     * @return {Object}
     *
     * @example
     * this.getOS();
     * {
     *   name: 'macOS',
     *   version: '10.11.12'
     * }
     */
    getOS() {
      if (this.parsedResult.os) {
        return this.parsedResult.os;
      }

      return this.parseOS();
    }

    /**
     * Parse OS and save it to this.parsedResult.os
     * @return {*|{}}
     */
    parseOS() {
      this.parsedResult.os = {};

      const os = Utils.find(osParsersList, (_os) => {
        if (typeof _os.test === 'function') {
          return _os.test(this);
        }

        if (_os.test instanceof Array) {
          return _os.test.some(condition => this.test(condition));
        }

        throw new Error("Browser's test function is not valid");
      });

      if (os) {
        this.parsedResult.os = os.describe(this.getUA());
      }

      return this.parsedResult.os;
    }

    /**
     * Get OS name
     * @param {Boolean} [toLowerCase] return lower-cased value
     * @return {String} name of the OS — macOS, Windows, Linux, etc.
     */
    getOSName(toLowerCase) {
      const { name } = this.getOS();

      if (toLowerCase) {
        return String(name).toLowerCase() || '';
      }

      return name || '';
    }

    /**
     * Get OS version
     * @return {String} full version with dots ('10.11.12', '5.6', etc)
     */
    getOSVersion() {
      return this.getOS().version;
    }

    /**
     * Get parsed platform
     * @return {{}}
     */
    getPlatform() {
      if (this.parsedResult.platform) {
        return this.parsedResult.platform;
      }

      return this.parsePlatform();
    }

    /**
     * Get platform name
     * @param {Boolean} [toLowerCase=false]
     * @return {*}
     */
    getPlatformType(toLowerCase = false) {
      const { type } = this.getPlatform();

      if (toLowerCase) {
        return String(type).toLowerCase() || '';
      }

      return type || '';
    }

    /**
     * Get parsed platform
     * @return {{}}
     */
    parsePlatform() {
      this.parsedResult.platform = {};

      const platform = Utils.find(platformParsersList, (_platform) => {
        if (typeof _platform.test === 'function') {
          return _platform.test(this);
        }

        if (_platform.test instanceof Array) {
          return _platform.test.some(condition => this.test(condition));
        }

        throw new Error("Browser's test function is not valid");
      });

      if (platform) {
        this.parsedResult.platform = platform.describe(this.getUA());
      }

      return this.parsedResult.platform;
    }

    /**
     * Get parsed engine
     * @return {{}}
     */
    getEngine() {
      if (this.parsedResult.engine) {
        return this.parsedResult.engine;
      }

      return this.parseEngine();
    }

    /**
     * Get engines's name
     * @return {String} Engines's name or an empty string
     *
     * @public
     */
    getEngineName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getEngine().name).toLowerCase() || '';
      }
      return this.getEngine().name || '';
    }

    /**
     * Get parsed platform
     * @return {{}}
     */
    parseEngine() {
      this.parsedResult.engine = {};

      const engine = Utils.find(enginesParsersList, (_engine) => {
        if (typeof _engine.test === 'function') {
          return _engine.test(this);
        }

        if (_engine.test instanceof Array) {
          return _engine.test.some(condition => this.test(condition));
        }

        throw new Error("Browser's test function is not valid");
      });

      if (engine) {
        this.parsedResult.engine = engine.describe(this.getUA());
      }

      return this.parsedResult.engine;
    }

    /**
     * Parse full information about the browser
     * @returns {Parser}
     */
    parse() {
      this.parseBrowser();
      this.parseOS();
      this.parsePlatform();
      this.parseEngine();

      return this;
    }

    /**
     * Get parsed result
     * @return {ParsedResult}
     */
    getResult() {
      return Utils.assign({}, this.parsedResult);
    }

    /**
     * Check if parsed browser matches certain conditions
     *
     * @param {Object} checkTree It's one or two layered object,
     * which can include a platform or an OS on the first layer
     * and should have browsers specs on the bottom-laying layer
     *
     * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
     * Returns `undefined` when the browser is no described in the checkTree object.
     *
     * @example
     * const browser = Bowser.getParser(window.navigator.userAgent);
     * if (browser.satisfies({chrome: '>118.01.1322' }))
     * // or with os
     * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
     * // or with platforms
     * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
     */
    satisfies(checkTree) {
      const platformsAndOSes = {};
      let platformsAndOSCounter = 0;
      const browsers = {};
      let browsersCounter = 0;

      const allDefinitions = Object.keys(checkTree);

      allDefinitions.forEach((key) => {
        const currentDefinition = checkTree[key];
        if (typeof currentDefinition === 'string') {
          browsers[key] = currentDefinition;
          browsersCounter += 1;
        } else if (typeof currentDefinition === 'object') {
          platformsAndOSes[key] = currentDefinition;
          platformsAndOSCounter += 1;
        }
      });

      if (platformsAndOSCounter > 0) {
        const platformsAndOSNames = Object.keys(platformsAndOSes);
        const OSMatchingDefinition = Utils.find(platformsAndOSNames, name => (this.isOS(name)));

        if (OSMatchingDefinition) {
          const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);

          if (osResult !== undefined) {
            return osResult;
          }
        }

        const platformMatchingDefinition = Utils.find(
          platformsAndOSNames,
          name => (this.isPlatform(name)),
        );
        if (platformMatchingDefinition) {
          const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);

          if (platformResult !== undefined) {
            return platformResult;
          }
        }
      }

      if (browsersCounter > 0) {
        const browserNames = Object.keys(browsers);
        const matchingDefinition = Utils.find(browserNames, name => (this.isBrowser(name, true)));

        if (matchingDefinition !== undefined) {
          return this.compareVersion(browsers[matchingDefinition]);
        }
      }

      return undefined;
    }

    /**
     * Check if the browser name equals the passed string
     * @param browserName The string to compare with the browser name
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {boolean}
     */
    isBrowser(browserName, includingAlias = false) {
      const defaultBrowserName = this.getBrowserName().toLowerCase();
      let browserNameLower = browserName.toLowerCase();
      const alias = Utils.getBrowserTypeByAlias(browserNameLower);

      if (includingAlias && alias) {
        browserNameLower = alias.toLowerCase();
      }
      return browserNameLower === defaultBrowserName;
    }

    compareVersion(version) {
      let expectedResults = [0];
      let comparableVersion = version;
      let isLoose = false;

      const currentBrowserVersion = this.getBrowserVersion();

      if (typeof currentBrowserVersion !== 'string') {
        return undefined;
      }

      if (version[0] === '>' || version[0] === '<') {
        comparableVersion = version.substr(1);
        if (version[1] === '=') {
          isLoose = true;
          comparableVersion = version.substr(2);
        } else {
          expectedResults = [];
        }
        if (version[0] === '>') {
          expectedResults.push(1);
        } else {
          expectedResults.push(-1);
        }
      } else if (version[0] === '=') {
        comparableVersion = version.substr(1);
      } else if (version[0] === '~') {
        isLoose = true;
        comparableVersion = version.substr(1);
      }

      return expectedResults.indexOf(
        Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose),
      ) > -1;
    }

    isOS(osName) {
      return this.getOSName(true) === String(osName).toLowerCase();
    }

    isPlatform(platformType) {
      return this.getPlatformType(true) === String(platformType).toLowerCase();
    }

    isEngine(engineName) {
      return this.getEngineName(true) === String(engineName).toLowerCase();
    }

    /**
     * Is anything? Check if the browser is called "anything",
     * the OS called "anything" or the platform called "anything"
     * @param {String} anything
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {Boolean}
     */
    is(anything, includingAlias = false) {
      return this.isBrowser(anything, includingAlias) || this.isOS(anything)
        || this.isPlatform(anything);
    }

    /**
     * Check if any of the given values satisfies this.is(anything)
     * @param {String[]} anythings
     * @returns {Boolean}
     */
    some(anythings = []) {
      return anythings.some(anything => this.is(anything));
    }
  }

  /*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   */

  /**
   * Bowser class.
   * Keep it simple as much as it can be.
   * It's supposed to work with collections of {@link Parser} instances
   * rather then solve one-instance problems.
   * All the one-instance stuff is located in Parser class.
   *
   * @class
   * @classdesc Bowser is a static object, that provides an API to the Parsers
   * @hideconstructor
   */
  class Bowser {
    /**
     * Creates a {@link Parser} instance
     *
     * @param {String} UA UserAgent string
     * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
     * explicitly. Same as `skipParsing` for {@link Parser}.
     * @returns {Parser}
     * @throws {Error} when UA is not a String
     *
     * @example
     * const parser = Bowser.getParser(window.navigator.userAgent);
     * const result = parser.getResult();
     */
    static getParser(UA, skipParsing = false) {
      if (typeof UA !== 'string') {
        throw new Error('UserAgent should be a string');
      }
      return new Parser(UA, skipParsing);
    }

    /**
     * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
     *
     * @param UA
     * @return {ParsedResult}
     *
     * @example
     * const result = Bowser.parse(window.navigator.userAgent);
     */
    static parse(UA) {
      return (new Parser(UA)).getResult();
    }

    static get BROWSER_MAP() {
      return BROWSER_MAP;
    }

    static get ENGINE_MAP() {
      return ENGINE_MAP;
    }

    static get OS_MAP() {
      return OS_MAP;
    }

    static get PLATFORMS_MAP() {
      return PLATFORMS_MAP;
    }
  }

  /**
   * Get the type of a JSON value.
   * Distinguishes between array, null and object.
   */
  function typeofJsonValue(value) {
      let t = typeof value;
      if (t == "object") {
          if (Array.isArray(value))
              return "array";
          if (value === null)
              return "null";
      }
      return t;
  }
  /**
   * Is this a JSON object (instead of an array or null)?
   */
  function isJsonObject(value) {
      return value !== null && typeof value == "object" && !Array.isArray(value);
  }

  // lookup table from base64 character to byte
  let encTable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
  // lookup table from base64 character *code* to byte because lookup by number is fast
  let decTable = [];
  for (let i = 0; i < encTable.length; i++)
      decTable[encTable[i].charCodeAt(0)] = i;
  // support base64url variants
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  function base64decode(base64Str) {
      // estimate byte size, not accounting for inner padding and whitespace
      let es = base64Str.length * 3 / 4;
      // if (es % 3 !== 0)
      // throw new Error('invalid base64 string');
      if (base64Str[base64Str.length - 2] == '=')
          es -= 2;
      else if (base64Str[base64Str.length - 1] == '=')
          es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, // position in byte array
      groupPos = 0, // position in base64 group
      b, // current byte
      p = 0 // previous byte
      ;
      for (let i = 0; i < base64Str.length; i++) {
          b = decTable[base64Str.charCodeAt(i)];
          if (b === undefined) {
              // noinspection FallThroughInSwitchStatementJS
              switch (base64Str[i]) {
                  case '=':
                      groupPos = 0; // reset state when padding found
                  case '\n':
                  case '\r':
                  case '\t':
                  case ' ':
                      continue; // skip white-space, and padding
                  default:
                      throw Error(`invalid base64 string.`);
              }
          }
          switch (groupPos) {
              case 0:
                  p = b;
                  groupPos = 1;
                  break;
              case 1:
                  bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                  p = b;
                  groupPos = 2;
                  break;
              case 2:
                  bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                  p = b;
                  groupPos = 3;
                  break;
              case 3:
                  bytes[bytePos++] = (p & 3) << 6 | b;
                  groupPos = 0;
                  break;
          }
      }
      if (groupPos == 1)
          throw Error(`invalid base64 string.`);
      return bytes.subarray(0, bytePos);
  }
  /**
   * Encodes a byte array to a base64 string.
   * Adds padding at the end.
   * Does not insert newlines.
   */
  function base64encode(bytes) {
      let base64 = '', groupPos = 0, // position in base64 group
      b, // current byte
      p = 0; // carry over from previous byte
      for (let i = 0; i < bytes.length; i++) {
          b = bytes[i];
          switch (groupPos) {
              case 0:
                  base64 += encTable[b >> 2];
                  p = (b & 3) << 4;
                  groupPos = 1;
                  break;
              case 1:
                  base64 += encTable[p | b >> 4];
                  p = (b & 15) << 2;
                  groupPos = 2;
                  break;
              case 2:
                  base64 += encTable[p | b >> 6];
                  base64 += encTable[b & 63];
                  groupPos = 0;
                  break;
          }
      }
      // padding required?
      if (groupPos) {
          base64 += encTable[p];
          base64 += '=';
          if (groupPos == 1)
              base64 += '=';
      }
      return base64;
  }

  /**
   * This handler implements the default behaviour for unknown fields.
   * When reading data, unknown fields are stored on the message, in a
   * symbol property.
   * When writing data, the symbol property is queried and unknown fields
   * are serialized into the output again.
   */
  var UnknownFieldHandler;
  (function (UnknownFieldHandler) {
      /**
       * The symbol used to store unknown fields for a message.
       * The property must conform to `UnknownFieldContainer`.
       */
      UnknownFieldHandler.symbol = Symbol.for("protobuf-ts/unknown");
      /**
       * Store an unknown field during binary read directly on the message.
       * This method is compatible with `BinaryReadOptions.readUnknownField`.
       */
      UnknownFieldHandler.onRead = (typeName, message, fieldNo, wireType, data) => {
          let container = is(message) ? message[UnknownFieldHandler.symbol] : message[UnknownFieldHandler.symbol] = [];
          container.push({ no: fieldNo, wireType, data });
      };
      /**
       * Write unknown fields stored for the message to the writer.
       * This method is compatible with `BinaryWriteOptions.writeUnknownFields`.
       */
      UnknownFieldHandler.onWrite = (typeName, message, writer) => {
          for (let { no, wireType, data } of UnknownFieldHandler.list(message))
              writer.tag(no, wireType).raw(data);
      };
      /**
       * List unknown fields stored for the message.
       * Note that there may be multiples fields with the same number.
       */
      UnknownFieldHandler.list = (message, fieldNo) => {
          if (is(message)) {
              let all = message[UnknownFieldHandler.symbol];
              return fieldNo ? all.filter(uf => uf.no == fieldNo) : all;
          }
          return [];
      };
      /**
       * Returns the last unknown field by field number.
       */
      UnknownFieldHandler.last = (message, fieldNo) => UnknownFieldHandler.list(message, fieldNo).slice(-1)[0];
      const is = (message) => message && Array.isArray(message[UnknownFieldHandler.symbol]);
  })(UnknownFieldHandler || (UnknownFieldHandler = {}));
  /**
   * Protobuf binary format wire types.
   *
   * A wire type provides just enough information to find the length of the
   * following value.
   *
   * See https://developers.google.com/protocol-buffers/docs/encoding#structure
   */
  var WireType;
  (function (WireType) {
      /**
       * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum
       */
      WireType[WireType["Varint"] = 0] = "Varint";
      /**
       * Used for fixed64, sfixed64, double.
       * Always 8 bytes with little-endian byte order.
       */
      WireType[WireType["Bit64"] = 1] = "Bit64";
      /**
       * Used for string, bytes, embedded messages, packed repeated fields
       *
       * Only repeated numeric types (types which use the varint, 32-bit,
       * or 64-bit wire types) can be packed. In proto3, such fields are
       * packed by default.
       */
      WireType[WireType["LengthDelimited"] = 2] = "LengthDelimited";
      /**
       * Used for groups
       * @deprecated
       */
      WireType[WireType["StartGroup"] = 3] = "StartGroup";
      /**
       * Used for groups
       * @deprecated
       */
      WireType[WireType["EndGroup"] = 4] = "EndGroup";
      /**
       * Used for fixed32, sfixed32, float.
       * Always 4 bytes with little-endian byte order.
       */
      WireType[WireType["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));

  // Copyright 2008 Google Inc.  All rights reserved.
  //
  // Redistribution and use in source and binary forms, with or without
  // modification, are permitted provided that the following conditions are
  // met:
  //
  // * Redistributions of source code must retain the above copyright
  // notice, this list of conditions and the following disclaimer.
  // * Redistributions in binary form must reproduce the above
  // copyright notice, this list of conditions and the following disclaimer
  // in the documentation and/or other materials provided with the
  // distribution.
  // * Neither the name of Google Inc. nor the names of its
  // contributors may be used to endorse or promote products derived from
  // this software without specific prior written permission.
  //
  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  //
  // Code generated by the Protocol Buffer compiler is owned by the owner
  // of the input file used when generating it.  This code is not
  // standalone and requires a support library to be linked with it.  This
  // support library is itself covered by the above license.
  /**
   * Read a 64 bit varint as two JS numbers.
   *
   * Returns tuple:
   * [0]: low bits
   * [0]: high bits
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175
   */
  function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
          let b = this.buf[this.pos++];
          lowBits |= (b & 0x7F) << shift;
          if ((b & 0x80) == 0) {
              this.assertBounds();
              return [lowBits, highBits];
          }
      }
      let middleByte = this.buf[this.pos++];
      // last four bits of the first 32 bit number
      lowBits |= (middleByte & 0x0F) << 28;
      // 3 upper bits are part of the next 32 bit number
      highBits = (middleByte & 0x70) >> 4;
      if ((middleByte & 0x80) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
          let b = this.buf[this.pos++];
          highBits |= (b & 0x7F) << shift;
          if ((b & 0x80) == 0) {
              this.assertBounds();
              return [lowBits, highBits];
          }
      }
      throw new Error('invalid varint');
  }
  /**
   * Write a 64 bit varint, given as two JS numbers, to the given bytes array.
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344
   */
  function varint64write(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
          const shift = lo >>> i;
          const hasNext = !((shift >>> 7) == 0 && hi == 0);
          const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
          bytes.push(byte);
          if (!hasNext) {
              return;
          }
      }
      const splitBits = ((lo >>> 28) & 0x0F) | ((hi & 0x07) << 4);
      const hasMoreBits = !((hi >> 3) == 0);
      bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xFF);
      if (!hasMoreBits) {
          return;
      }
      for (let i = 3; i < 31; i = i + 7) {
          const shift = hi >>> i;
          const hasNext = !((shift >>> 7) == 0);
          const byte = (hasNext ? shift | 0x80 : shift) & 0xFF;
          bytes.push(byte);
          if (!hasNext) {
              return;
          }
      }
      bytes.push((hi >>> 31) & 0x01);
  }
  // constants for binary math
  const TWO_PWR_32_DBL$1 = (1 << 16) * (1 << 16);
  /**
   * Parse decimal string of 64 bit integer value as two JS numbers.
   *
   * Returns tuple:
   * [0]: minus sign?
   * [1]: low bits
   * [2]: high bits
   *
   * Copyright 2008 Google Inc.
   */
  function int64fromString(dec) {
      // Check for minus sign.
      let minus = dec[0] == '-';
      if (minus)
          dec = dec.slice(1);
      // Work 6 decimal digits at a time, acting like we're converting base 1e6
      // digits to binary. This is safe to do with floating point math because
      // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
          // Note: Number('') is 0.
          const digit1e6 = Number(dec.slice(begin, end));
          highBits *= base;
          lowBits = lowBits * base + digit1e6;
          // Carry bits from lowBits to highBits
          if (lowBits >= TWO_PWR_32_DBL$1) {
              highBits = highBits + ((lowBits / TWO_PWR_32_DBL$1) | 0);
              lowBits = lowBits % TWO_PWR_32_DBL$1;
          }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return [minus, lowBits, highBits];
  }
  /**
   * Format 64 bit integer value (as two JS numbers) to decimal string.
   *
   * Copyright 2008 Google Inc.
   */
  function int64toString(bitsLow, bitsHigh) {
      // Skip the expensive conversion if the number is small enough to use the
      // built-in conversions.
      if ((bitsHigh >>> 0) <= 0x1FFFFF) {
          return '' + (TWO_PWR_32_DBL$1 * bitsHigh + (bitsLow >>> 0));
      }
      // What this code is doing is essentially converting the input number from
      // base-2 to base-1e7, which allows us to represent the 64-bit range with
      // only 3 (very large) digits. Those digits are then trivial to convert to
      // a base-10 string.
      // The magic numbers used here are -
      // 2^24 = 16777216 = (1,6777216) in base-1e7.
      // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.
      // Split 32:32 representation into 16:24:24 representation so our
      // intermediate digits don't overflow.
      let low = bitsLow & 0xFFFFFF;
      let mid = (((bitsLow >>> 24) | (bitsHigh << 8)) >>> 0) & 0xFFFFFF;
      let high = (bitsHigh >> 16) & 0xFFFF;
      // Assemble our three base-1e7 digits, ignoring carries. The maximum
      // value in a digit at this step is representable as a 48-bit integer, which
      // can be stored in a 64-bit floating point number.
      let digitA = low + (mid * 6777216) + (high * 6710656);
      let digitB = mid + (high * 8147497);
      let digitC = (high * 2);
      // Apply carries from A to B and from B to C.
      let base = 10000000;
      if (digitA >= base) {
          digitB += Math.floor(digitA / base);
          digitA %= base;
      }
      if (digitB >= base) {
          digitC += Math.floor(digitB / base);
          digitB %= base;
      }
      // Convert base-1e7 digits to base-10, with optional leading zeroes.
      function decimalFrom1e7(digit1e7, needLeadingZeros) {
          let partial = digit1e7 ? String(digit1e7) : '';
          if (needLeadingZeros) {
              return '0000000'.slice(partial.length) + partial;
          }
          return partial;
      }
      return decimalFrom1e7(digitC, /*needLeadingZeros=*/ 0) +
          decimalFrom1e7(digitB, /*needLeadingZeros=*/ digitC) +
          // If the final 1e7 digit didn't need leading zeros, we would have
          // returned via the trivial code path at the top.
          decimalFrom1e7(digitA, /*needLeadingZeros=*/ 1);
  }
  /**
   * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`
   *
   * Copyright 2008 Google Inc.  All rights reserved.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144
   */
  function varint32write(value, bytes) {
      if (value >= 0) {
          // write value as varint 32
          while (value > 0x7f) {
              bytes.push((value & 0x7f) | 0x80);
              value = value >>> 7;
          }
          bytes.push(value);
      }
      else {
          for (let i = 0; i < 9; i++) {
              bytes.push(value & 127 | 128);
              value = value >> 7;
          }
          bytes.push(1);
      }
  }
  /**
   * Read an unsigned 32 bit varint.
   *
   * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220
   */
  function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 0x7F;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 7;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 14;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 0x7F) << 21;
      if ((b & 0x80) == 0) {
          this.assertBounds();
          return result;
      }
      // Extract only last 4 bits
      b = this.buf[this.pos++];
      result |= (b & 0x0F) << 28;
      for (let readBytes = 5; ((b & 0x80) !== 0) && readBytes < 10; readBytes++)
          b = this.buf[this.pos++];
      if ((b & 0x80) != 0)
          throw new Error('invalid varint');
      this.assertBounds();
      // Result can have 32 bits, convert it to unsigned
      return result >>> 0;
  }

  let BI$1;
  function detectBi() {
      const dv = new DataView(new ArrayBuffer(8));
      const ok = globalThis.BigInt !== undefined
          && typeof dv.getBigInt64 === "function"
          && typeof dv.getBigUint64 === "function"
          && typeof dv.setBigInt64 === "function"
          && typeof dv.setBigUint64 === "function";
      BI$1 = ok ? {
          MIN: BigInt("-9223372036854775808"),
          MAX: BigInt("9223372036854775807"),
          UMIN: BigInt("0"),
          UMAX: BigInt("18446744073709551615"),
          C: BigInt,
          V: dv,
      } : undefined;
  }
  detectBi();
  function assertBi(bi) {
      if (!bi)
          throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  // used to validate from(string) input (when bigint is unavailable)
  const RE_DECIMAL_STR = /^-?[0-9]+$/;
  // constants for binary math
  const TWO_PWR_32_DBL = 0x100000000;
  const HALF_2_PWR_32 = 0x080000000;
  // base class for PbLong and PbULong provides shared code
  class SharedPbLong {
      /**
       * Create a new instance with the given bits.
       */
      constructor(lo, hi) {
          this.lo = lo | 0;
          this.hi = hi | 0;
      }
      /**
       * Is this instance equal to 0?
       */
      isZero() {
          return this.lo == 0 && this.hi == 0;
      }
      /**
       * Convert to a native number.
       */
      toNumber() {
          let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
          if (!Number.isSafeInteger(result))
              throw new Error("cannot convert to safe number");
          return result;
      }
  }
  /**
   * 64-bit unsigned integer as two 32-bit values.
   * Converts between `string`, `number` and `bigint` representations.
   */
  class PbULong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
          if (BI$1)
              // noinspection FallThroughInSwitchStatementJS
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      if (value == "")
                          throw new Error('string is no integer');
                      value = BI$1.C(value);
                  case "number":
                      if (value === 0)
                          return this.ZERO;
                      value = BI$1.C(value);
                  case "bigint":
                      if (!value)
                          return this.ZERO;
                      if (value < BI$1.UMIN)
                          throw new Error('signed value for ulong');
                      if (value > BI$1.UMAX)
                          throw new Error('ulong too large');
                      BI$1.V.setBigUint64(0, value, true);
                      return new PbULong(BI$1.V.getInt32(0, true), BI$1.V.getInt32(4, true));
              }
          else
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      value = value.trim();
                      if (!RE_DECIMAL_STR.test(value))
                          throw new Error('string is no integer');
                      let [minus, lo, hi] = int64fromString(value);
                      if (minus)
                          throw new Error('signed value for ulong');
                      return new PbULong(lo, hi);
                  case "number":
                      if (value == 0)
                          return this.ZERO;
                      if (!Number.isSafeInteger(value))
                          throw new Error('number is no integer');
                      if (value < 0)
                          throw new Error('signed value for ulong');
                      return new PbULong(value, value / TWO_PWR_32_DBL);
              }
          throw new Error('unknown value ' + typeof value);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
          return BI$1 ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
          assertBi(BI$1);
          BI$1.V.setInt32(0, this.lo, true);
          BI$1.V.setInt32(4, this.hi, true);
          return BI$1.V.getBigUint64(0, true);
      }
  }
  /**
   * ulong 0 singleton.
   */
  PbULong.ZERO = new PbULong(0, 0);
  /**
   * 64-bit signed integer as two 32-bit values.
   * Converts between `string`, `number` and `bigint` representations.
   */
  class PbLong extends SharedPbLong {
      /**
       * Create instance from a `string`, `number` or `bigint`.
       */
      static from(value) {
          if (BI$1)
              // noinspection FallThroughInSwitchStatementJS
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      if (value == "")
                          throw new Error('string is no integer');
                      value = BI$1.C(value);
                  case "number":
                      if (value === 0)
                          return this.ZERO;
                      value = BI$1.C(value);
                  case "bigint":
                      if (!value)
                          return this.ZERO;
                      if (value < BI$1.MIN)
                          throw new Error('signed long too small');
                      if (value > BI$1.MAX)
                          throw new Error('signed long too large');
                      BI$1.V.setBigInt64(0, value, true);
                      return new PbLong(BI$1.V.getInt32(0, true), BI$1.V.getInt32(4, true));
              }
          else
              switch (typeof value) {
                  case "string":
                      if (value == "0")
                          return this.ZERO;
                      value = value.trim();
                      if (!RE_DECIMAL_STR.test(value))
                          throw new Error('string is no integer');
                      let [minus, lo, hi] = int64fromString(value);
                      if (minus) {
                          if (hi > HALF_2_PWR_32 || (hi == HALF_2_PWR_32 && lo != 0))
                              throw new Error('signed long too small');
                      }
                      else if (hi >= HALF_2_PWR_32)
                          throw new Error('signed long too large');
                      let pbl = new PbLong(lo, hi);
                      return minus ? pbl.negate() : pbl;
                  case "number":
                      if (value == 0)
                          return this.ZERO;
                      if (!Number.isSafeInteger(value))
                          throw new Error('number is no integer');
                      return value > 0
                          ? new PbLong(value, value / TWO_PWR_32_DBL)
                          : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
              }
          throw new Error('unknown value ' + typeof value);
      }
      /**
       * Do we have a minus sign?
       */
      isNegative() {
          return (this.hi & HALF_2_PWR_32) !== 0;
      }
      /**
       * Negate two's complement.
       * Invert all the bits and add one to the result.
       */
      negate() {
          let hi = ~this.hi, lo = this.lo;
          if (lo)
              lo = ~lo + 1;
          else
              hi += 1;
          return new PbLong(lo, hi);
      }
      /**
       * Convert to decimal string.
       */
      toString() {
          if (BI$1)
              return this.toBigInt().toString();
          if (this.isNegative()) {
              let n = this.negate();
              return '-' + int64toString(n.lo, n.hi);
          }
          return int64toString(this.lo, this.hi);
      }
      /**
       * Convert to native bigint.
       */
      toBigInt() {
          assertBi(BI$1);
          BI$1.V.setInt32(0, this.lo, true);
          BI$1.V.setInt32(4, this.hi, true);
          return BI$1.V.getBigInt64(0, true);
      }
  }
  /**
   * long 0 singleton.
   */
  PbLong.ZERO = new PbLong(0, 0);

  const defaultsRead$1 = {
      readUnknownField: true,
      readerFactory: bytes => new BinaryReader(bytes),
  };
  /**
   * Make options for reading binary data form partial options.
   */
  function binaryReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead$1), options) : defaultsRead$1;
  }
  class BinaryReader {
      constructor(buf, textDecoder) {
          this.varint64 = varint64read; // dirty cast for `this`
          /**
           * Read a `uint32` field, an unsigned 32 bit varint.
           */
          this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`
          this.buf = buf;
          this.len = buf.length;
          this.pos = 0;
          this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
          this.textDecoder = textDecoder !== null && textDecoder !== undefined ? textDecoder : new TextDecoder("utf-8", {
              fatal: true,
              ignoreBOM: true,
          });
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
          let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
          if (fieldNo <= 0 || wireType < 0 || wireType > 5)
              throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
          return [fieldNo, wireType];
      }
      /**
       * Skip one element on the wire and return the skipped data.
       * Supports WireType.StartGroup since v2.0.0-alpha.23.
       */
      skip(wireType) {
          let start = this.pos;
          // noinspection FallThroughInSwitchStatementJS
          switch (wireType) {
              case WireType.Varint:
                  while (this.buf[this.pos++] & 0x80) {
                      // ignore
                  }
                  break;
              case WireType.Bit64:
                  this.pos += 4;
              case WireType.Bit32:
                  this.pos += 4;
                  break;
              case WireType.LengthDelimited:
                  let len = this.uint32();
                  this.pos += len;
                  break;
              case WireType.StartGroup:
                  // From descriptor.proto: Group type is deprecated, not supported in proto3.
                  // But we must still be able to parse and treat as unknown.
                  let t;
                  while ((t = this.tag()[1]) !== WireType.EndGroup) {
                      this.skip(t);
                  }
                  break;
              default:
                  throw new Error("cant skip wire type " + wireType);
          }
          this.assertBounds();
          return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
          if (this.pos > this.len)
              throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
          return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
          let zze = this.uint32();
          // decode zigzag
          return (zze >>> 1) ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
          return new PbLong(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
          return new PbULong(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
          let [lo, hi] = this.varint64();
          // decode zig zag
          let s = -(lo & 1);
          lo = ((lo >>> 1 | (hi & 1) << 31) ^ s);
          hi = (hi >>> 1 ^ s);
          return new PbLong(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
          let [lo, hi] = this.varint64();
          return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
          return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
          return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
          return new PbULong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
          return new PbLong(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
          return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
          return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
          let len = this.uint32();
          let start = this.pos;
          this.pos += len;
          this.assertBounds();
          return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
          return this.textDecoder.decode(this.bytes());
      }
  }

  /**
   * assert that condition is true or throw error (with message)
   */
  function assert(condition, msg) {
      if (!condition) {
          throw new Error(msg);
      }
  }
  const FLOAT32_MAX = 3.4028234663852886e+38, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 0xFFFFFFFF, INT32_MAX = 0X7FFFFFFF, INT32_MIN = -2147483648;
  function assertInt32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid int 32: ' + typeof arg);
      if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
          throw new Error('invalid int 32: ' + arg);
  }
  function assertUInt32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid uint 32: ' + typeof arg);
      if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
          throw new Error('invalid uint 32: ' + arg);
  }
  function assertFloat32(arg) {
      if (typeof arg !== "number")
          throw new Error('invalid float 32: ' + typeof arg);
      if (!Number.isFinite(arg))
          return;
      if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
          throw new Error('invalid float 32: ' + arg);
  }

  const defaultsWrite$1 = {
      writeUnknownFields: true,
      writerFactory: () => new BinaryWriter(),
  };
  /**
   * Make options for writing binary data form partial options.
   */
  function binaryWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite$1), options) : defaultsWrite$1;
  }
  class BinaryWriter {
      constructor(textEncoder) {
          /**
           * Previous fork states.
           */
          this.stack = [];
          this.textEncoder = textEncoder !== null && textEncoder !== undefined ? textEncoder : new TextEncoder();
          this.chunks = [];
          this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
          this.chunks.push(new Uint8Array(this.buf)); // flush the buffer
          let len = 0;
          for (let i = 0; i < this.chunks.length; i++)
              len += this.chunks[i].length;
          let bytes = new Uint8Array(len);
          let offset = 0;
          for (let i = 0; i < this.chunks.length; i++) {
              bytes.set(this.chunks[i], offset);
              offset += this.chunks[i].length;
          }
          this.chunks = [];
          return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
          this.stack.push({ chunks: this.chunks, buf: this.buf });
          this.chunks = [];
          this.buf = [];
          return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
          // get chunk of fork
          let chunk = this.finish();
          // restore previous state
          let prev = this.stack.pop();
          if (!prev)
              throw new Error('invalid state, fork stack empty');
          this.chunks = prev.chunks;
          this.buf = prev.buf;
          // write length of chunk as varint
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
          return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
          if (this.buf.length) {
              this.chunks.push(new Uint8Array(this.buf));
              this.buf = [];
          }
          this.chunks.push(chunk);
          return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
          assertUInt32(value);
          // write value as varint 32, inlined for speed
          while (value > 0x7f) {
              this.buf.push((value & 0x7f) | 0x80);
              value = value >>> 7;
          }
          this.buf.push(value);
          return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
          assertInt32(value);
          varint32write(value, this.buf);
          return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
          this.buf.push(value ? 1 : 0);
          return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
          this.uint32(value.byteLength); // write length of chunk as varint
          return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
          let chunk = this.textEncoder.encode(value);
          this.uint32(chunk.byteLength); // write length of chunk as varint
          return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
          assertFloat32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setFloat32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
          let chunk = new Uint8Array(8);
          new DataView(chunk.buffer).setFloat64(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
          assertUInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setUint32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
          assertInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setInt32(0, value, true);
          return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
          assertInt32(value);
          // zigzag encode
          value = ((value << 1) ^ (value >> 31)) >>> 0;
          varint32write(value, this.buf);
          return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
          let chunk = new Uint8Array(8);
          let view = new DataView(chunk.buffer);
          let long = PbLong.from(value);
          view.setInt32(0, long.lo, true);
          view.setInt32(4, long.hi, true);
          return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
          let chunk = new Uint8Array(8);
          let view = new DataView(chunk.buffer);
          let long = PbULong.from(value);
          view.setInt32(0, long.lo, true);
          view.setInt32(4, long.hi, true);
          return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
          let long = PbLong.from(value);
          varint64write(long.lo, long.hi, this.buf);
          return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
          let long = PbLong.from(value), 
          // zigzag encode
          sign = long.hi >> 31, lo = (long.lo << 1) ^ sign, hi = ((long.hi << 1) | (long.lo >>> 31)) ^ sign;
          varint64write(lo, hi, this.buf);
          return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
          let long = PbULong.from(value);
          varint64write(long.lo, long.hi, this.buf);
          return this;
      }
  }

  const defaultsWrite = {
      emitDefaultValues: false,
      enumAsInteger: false,
      useProtoFieldName: false,
      prettySpaces: 0,
  }, defaultsRead = {
      ignoreUnknownFields: false,
  };
  /**
   * Make options for reading JSON data from partial options.
   */
  function jsonReadOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  /**
   * Make options for writing JSON data from partial options.
   */
  function jsonWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }

  /**
   * The symbol used as a key on message objects to store the message type.
   *
   * Note that this is an experimental feature - it is here to stay, but
   * implementation details may change without notice.
   */
  const MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

  /**
   * Converts snake_case to lowerCamelCase.
   *
   * Should behave like protoc:
   * https://github.com/protocolbuffers/protobuf/blob/e8ae137c96444ea313485ed1118c5e43b2099cf1/src/google/protobuf/compiler/java/java_helpers.cc#L118
   */
  function lowerCamelCase(snakeCase) {
      let capNext = false;
      const sb = [];
      for (let i = 0; i < snakeCase.length; i++) {
          let next = snakeCase.charAt(i);
          if (next == '_') {
              capNext = true;
          }
          else if (/\d/.test(next)) {
              sb.push(next);
              capNext = true;
          }
          else if (capNext) {
              sb.push(next.toUpperCase());
              capNext = false;
          }
          else if (i == 0) {
              sb.push(next.toLowerCase());
          }
          else {
              sb.push(next);
          }
      }
      return sb.join('');
  }

  /**
   * Scalar value types. This is a subset of field types declared by protobuf
   * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE
   * are omitted, but the numerical values are identical.
   */
  var ScalarType;
  (function (ScalarType) {
      // 0 is reserved for errors.
      // Order is weird for historical reasons.
      ScalarType[ScalarType["DOUBLE"] = 1] = "DOUBLE";
      ScalarType[ScalarType["FLOAT"] = 2] = "FLOAT";
      // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
      // negative values are likely.
      ScalarType[ScalarType["INT64"] = 3] = "INT64";
      ScalarType[ScalarType["UINT64"] = 4] = "UINT64";
      // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
      // negative values are likely.
      ScalarType[ScalarType["INT32"] = 5] = "INT32";
      ScalarType[ScalarType["FIXED64"] = 6] = "FIXED64";
      ScalarType[ScalarType["FIXED32"] = 7] = "FIXED32";
      ScalarType[ScalarType["BOOL"] = 8] = "BOOL";
      ScalarType[ScalarType["STRING"] = 9] = "STRING";
      // Tag-delimited aggregate.
      // Group type is deprecated and not supported in proto3. However, Proto3
      // implementations should still be able to parse the group wire format and
      // treat group fields as unknown fields.
      // TYPE_GROUP = 10,
      // TYPE_MESSAGE = 11,  // Length-delimited aggregate.
      // New in version 2.
      ScalarType[ScalarType["BYTES"] = 12] = "BYTES";
      ScalarType[ScalarType["UINT32"] = 13] = "UINT32";
      // TYPE_ENUM = 14,
      ScalarType[ScalarType["SFIXED32"] = 15] = "SFIXED32";
      ScalarType[ScalarType["SFIXED64"] = 16] = "SFIXED64";
      ScalarType[ScalarType["SINT32"] = 17] = "SINT32";
      ScalarType[ScalarType["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  /**
   * JavaScript representation of 64 bit integral types. Equivalent to the
   * field option "jstype".
   *
   * By default, protobuf-ts represents 64 bit types as `bigint`.
   *
   * You can change the default behaviour by enabling the plugin parameter
   * `long_type_string`, which will represent 64 bit types as `string`.
   *
   * Alternatively, you can change the behaviour for individual fields
   * with the field option "jstype":
   *
   * ```protobuf
   * uint64 my_field = 1 [jstype = JS_STRING];
   * uint64 other_field = 2 [jstype = JS_NUMBER];
   * ```
   */
  var LongType;
  (function (LongType) {
      /**
       * Use JavaScript `bigint`.
       *
       * Field option `[jstype = JS_NORMAL]`.
       */
      LongType[LongType["BIGINT"] = 0] = "BIGINT";
      /**
       * Use JavaScript `string`.
       *
       * Field option `[jstype = JS_STRING]`.
       */
      LongType[LongType["STRING"] = 1] = "STRING";
      /**
       * Use JavaScript `number`.
       *
       * Large values will loose precision.
       *
       * Field option `[jstype = JS_NUMBER]`.
       */
      LongType[LongType["NUMBER"] = 2] = "NUMBER";
  })(LongType || (LongType = {}));
  /**
   * Protobuf 2.1.0 introduced packed repeated fields.
   * Setting the field option `[packed = true]` enables packing.
   *
   * In proto3, all repeated fields are packed by default.
   * Setting the field option `[packed = false]` disables packing.
   *
   * Packed repeated fields are encoded with a single tag,
   * then a length-delimiter, then the element values.
   *
   * Unpacked repeated fields are encoded with a tag and
   * value for each element.
   *
   * `bytes` and `string` cannot be packed.
   */
  var RepeatType;
  (function (RepeatType) {
      /**
       * The field is not repeated.
       */
      RepeatType[RepeatType["NO"] = 0] = "NO";
      /**
       * The field is repeated and should be packed.
       * Invalid for `bytes` and `string`, they cannot be packed.
       */
      RepeatType[RepeatType["PACKED"] = 1] = "PACKED";
      /**
       * The field is repeated but should not be packed.
       * The only valid repeat type for repeated `bytes` and `string`.
       */
      RepeatType[RepeatType["UNPACKED"] = 2] = "UNPACKED";
  })(RepeatType || (RepeatType = {}));
  /**
   * Turns PartialFieldInfo into FieldInfo.
   */
  function normalizeFieldInfo(field) {
      var _a, _b, _c, _d;
      field.localName = (_a = field.localName) !== null && _a !== undefined ? _a : lowerCamelCase(field.name);
      field.jsonName = (_b = field.jsonName) !== null && _b !== undefined ? _b : lowerCamelCase(field.name);
      field.repeat = (_c = field.repeat) !== null && _c !== undefined ? _c : RepeatType.NO;
      field.opt = (_d = field.opt) !== null && _d !== undefined ? _d : (field.repeat ? false : field.oneof ? false : field.kind == "message");
      return field;
  }

  /**
   * Is the given value a valid oneof group?
   *
   * We represent protobuf `oneof` as algebraic data types (ADT) in generated
   * code. But when working with messages of unknown type, the ADT does not
   * help us.
   *
   * This type guard checks if the given object adheres to the ADT rules, which
   * are as follows:
   *
   * 1) Must be an object.
   *
   * 2) Must have a "oneofKind" discriminator property.
   *
   * 3) If "oneofKind" is `undefined`, no member field is selected. The object
   * must not have any other properties.
   *
   * 4) If "oneofKind" is a `string`, the member field with this name is
   * selected.
   *
   * 5) If a member field is selected, the object must have a second property
   * with this name. The property must not be `undefined`.
   *
   * 6) No extra properties are allowed. The object has either one property
   * (no selection) or two properties (selection).
   *
   */
  function isOneofGroup(any) {
      if (typeof any != 'object' || any === null || !any.hasOwnProperty('oneofKind')) {
          return false;
      }
      switch (typeof any.oneofKind) {
          case "string":
              if (any[any.oneofKind] === undefined)
                  return false;
              return Object.keys(any).length == 2;
          case "undefined":
              return Object.keys(any).length == 1;
          default:
              return false;
      }
  }

  // noinspection JSMethodCanBeStatic
  class ReflectionTypeCheck {
      constructor(info) {
          var _a;
          this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
      }
      prepare() {
          if (this.data)
              return;
          const req = [], known = [], oneofs = [];
          for (let field of this.fields) {
              if (field.oneof) {
                  if (!oneofs.includes(field.oneof)) {
                      oneofs.push(field.oneof);
                      req.push(field.oneof);
                      known.push(field.oneof);
                  }
              }
              else {
                  known.push(field.localName);
                  switch (field.kind) {
                      case "scalar":
                      case "enum":
                          if (!field.opt || field.repeat)
                              req.push(field.localName);
                          break;
                      case "message":
                          if (field.repeat)
                              req.push(field.localName);
                          break;
                      case "map":
                          req.push(field.localName);
                          break;
                  }
              }
          }
          this.data = { req, known, oneofs: Object.values(oneofs) };
      }
      /**
       * Is the argument a valid message as specified by the
       * reflection information?
       *
       * Checks all field types recursively. The `depth`
       * specifies how deep into the structure the check will be.
       *
       * With a depth of 0, only the presence of fields
       * is checked.
       *
       * With a depth of 1 or more, the field types are checked.
       *
       * With a depth of 2 or more, the members of map, repeated
       * and message fields are checked.
       *
       * Message fields will be checked recursively with depth - 1.
       *
       * The number of map entries / repeated values being checked
       * is < depth.
       */
      is(message, depth, allowExcessProperties = false) {
          if (depth < 0)
              return true;
          if (message === null || message === undefined || typeof message != 'object')
              return false;
          this.prepare();
          let keys = Object.keys(message), data = this.data;
          // if a required field is missing in arg, this cannot be a T
          if (keys.length < data.req.length || data.req.some(n => !keys.includes(n)))
              return false;
          if (!allowExcessProperties) {
              // if the arg contains a key we dont know, this is not a literal T
              if (keys.some(k => !data.known.includes(k)))
                  return false;
          }
          // "With a depth of 0, only the presence and absence of fields is checked."
          // "With a depth of 1 or more, the field types are checked."
          if (depth < 1) {
              return true;
          }
          // check oneof group
          for (const name of data.oneofs) {
              const group = message[name];
              if (!isOneofGroup(group))
                  return false;
              if (group.oneofKind === undefined)
                  continue;
              const field = this.fields.find(f => f.localName === group.oneofKind);
              if (!field)
                  return false; // we found no field, but have a kind, something is wrong
              if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
                  return false;
          }
          // check types
          for (const field of this.fields) {
              if (field.oneof !== undefined)
                  continue;
              if (!this.field(message[field.localName], field, allowExcessProperties, depth))
                  return false;
          }
          return true;
      }
      field(arg, field, allowExcessProperties, depth) {
          let repeated = field.repeat;
          switch (field.kind) {
              case "scalar":
                  if (arg === undefined)
                      return field.opt;
                  if (repeated)
                      return this.scalars(arg, field.T, depth, field.L);
                  return this.scalar(arg, field.T, field.L);
              case "enum":
                  if (arg === undefined)
                      return field.opt;
                  if (repeated)
                      return this.scalars(arg, ScalarType.INT32, depth);
                  return this.scalar(arg, ScalarType.INT32);
              case "message":
                  if (arg === undefined)
                      return true;
                  if (repeated)
                      return this.messages(arg, field.T(), allowExcessProperties, depth);
                  return this.message(arg, field.T(), allowExcessProperties, depth);
              case "map":
                  if (typeof arg != 'object' || arg === null)
                      return false;
                  if (depth < 2)
                      return true;
                  if (!this.mapKeys(arg, field.K, depth))
                      return false;
                  switch (field.V.kind) {
                      case "scalar":
                          return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
                      case "enum":
                          return this.scalars(Object.values(arg), ScalarType.INT32, depth);
                      case "message":
                          return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
                  }
                  break;
          }
          return true;
      }
      message(arg, type, allowExcessProperties, depth) {
          if (allowExcessProperties) {
              return type.isAssignable(arg, depth);
          }
          return type.is(arg, depth);
      }
      messages(arg, type, allowExcessProperties, depth) {
          if (!Array.isArray(arg))
              return false;
          if (depth < 2)
              return true;
          if (allowExcessProperties) {
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!type.isAssignable(arg[i], depth - 1))
                      return false;
          }
          else {
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!type.is(arg[i], depth - 1))
                      return false;
          }
          return true;
      }
      scalar(arg, type, longType) {
          let argType = typeof arg;
          switch (type) {
              case ScalarType.UINT64:
              case ScalarType.FIXED64:
              case ScalarType.INT64:
              case ScalarType.SFIXED64:
              case ScalarType.SINT64:
                  switch (longType) {
                      case LongType.BIGINT:
                          return argType == "bigint";
                      case LongType.NUMBER:
                          return argType == "number" && !isNaN(arg);
                      default:
                          return argType == "string";
                  }
              case ScalarType.BOOL:
                  return argType == 'boolean';
              case ScalarType.STRING:
                  return argType == 'string';
              case ScalarType.BYTES:
                  return arg instanceof Uint8Array;
              case ScalarType.DOUBLE:
              case ScalarType.FLOAT:
                  return argType == 'number' && !isNaN(arg);
              default:
                  // case ScalarType.UINT32:
                  // case ScalarType.FIXED32:
                  // case ScalarType.INT32:
                  // case ScalarType.SINT32:
                  // case ScalarType.SFIXED32:
                  return argType == 'number' && Number.isInteger(arg);
          }
      }
      scalars(arg, type, depth, longType) {
          if (!Array.isArray(arg))
              return false;
          if (depth < 2)
              return true;
          if (Array.isArray(arg))
              for (let i = 0; i < arg.length && i < depth; i++)
                  if (!this.scalar(arg[i], type, longType))
                      return false;
          return true;
      }
      mapKeys(map, type, depth) {
          let keys = Object.keys(map);
          switch (type) {
              case ScalarType.INT32:
              case ScalarType.FIXED32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
              case ScalarType.UINT32:
                  return this.scalars(keys.slice(0, depth).map(k => parseInt(k)), type, depth);
              case ScalarType.BOOL:
                  return this.scalars(keys.slice(0, depth).map(k => k == 'true' ? true : k == 'false' ? false : k), type, depth);
              default:
                  return this.scalars(keys, type, depth, LongType.STRING);
          }
      }
  }

  /**
   * Utility method to convert a PbLong or PbUlong to a JavaScript
   * representation during runtime.
   *
   * Works with generated field information, `undefined` is equivalent
   * to `STRING`.
   */
  function reflectionLongConvert(long, type) {
      switch (type) {
          case LongType.BIGINT:
              return long.toBigInt();
          case LongType.NUMBER:
              return long.toNumber();
          default:
              // case undefined:
              // case LongType.STRING:
              return long.toString();
      }
  }

  /**
   * Reads proto3 messages in canonical JSON format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/proto3#json
   */
  class ReflectionJsonReader {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          var _a;
          if (this.fMap === undefined) {
              this.fMap = {};
              const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
              for (const field of fieldsInput) {
                  this.fMap[field.name] = field;
                  this.fMap[field.jsonName] = field;
                  this.fMap[field.localName] = field;
              }
          }
      }
      // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
      assert(condition, fieldName, jsonValue) {
          if (!condition) {
              let what = typeofJsonValue(jsonValue);
              if (what == "number" || what == "boolean")
                  what = jsonValue.toString();
              throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
          }
      }
      /**
       * Reads a message from canonical JSON format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(input, message, options) {
          this.prepare();
          const oneofsHandled = [];
          for (const [jsonKey, jsonValue] of Object.entries(input)) {
              const field = this.fMap[jsonKey];
              if (!field) {
                  if (!options.ignoreUnknownFields)
                      throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
                  continue;
              }
              const localName = field.localName;
              // handle oneof ADT
              let target; // this will be the target for the field value, whether it is member of a oneof or not
              if (field.oneof) {
                  if (jsonValue === null && (field.kind !== 'enum' || field.T()[0] !== 'google.protobuf.NullValue')) {
                      continue;
                  }
                  // since json objects are unordered by specification, it is not possible to take the last of multiple oneofs
                  if (oneofsHandled.includes(field.oneof))
                      throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
                  oneofsHandled.push(field.oneof);
                  target = message[field.oneof] = {
                      oneofKind: localName
                  };
              }
              else {
                  target = message;
              }
              // we have handled oneof above. we just have read the value into `target`.
              if (field.kind == 'map') {
                  if (jsonValue === null) {
                      continue;
                  }
                  // check input
                  this.assert(isJsonObject(jsonValue), field.name, jsonValue);
                  // our target to put map entries into
                  const fieldObj = target[localName];
                  // read entries
                  for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
                      this.assert(jsonObjValue !== null, field.name + " map value", null);
                      // read value
                      let val;
                      switch (field.V.kind) {
                          case "message":
                              val = field.V.T().internalJsonRead(jsonObjValue, options);
                              break;
                          case "enum":
                              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                              if (val === false)
                                  continue;
                              break;
                          case "scalar":
                              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                              break;
                      }
                      this.assert(val !== undefined, field.name + " map value", jsonObjValue);
                      // read key
                      let key = jsonObjKey;
                      if (field.K == ScalarType.BOOL)
                          key = key == "true" ? true : key == "false" ? false : key;
                      key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
                      fieldObj[key] = val;
                  }
              }
              else if (field.repeat) {
                  if (jsonValue === null)
                      continue;
                  // check input
                  this.assert(Array.isArray(jsonValue), field.name, jsonValue);
                  // our target to put array entries into
                  const fieldArr = target[localName];
                  // read array entries
                  for (const jsonItem of jsonValue) {
                      this.assert(jsonItem !== null, field.name, null);
                      let val;
                      switch (field.kind) {
                          case "message":
                              val = field.T().internalJsonRead(jsonItem, options);
                              break;
                          case "enum":
                              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                              if (val === false)
                                  continue;
                              break;
                          case "scalar":
                              val = this.scalar(jsonItem, field.T, field.L, field.name);
                              break;
                      }
                      this.assert(val !== undefined, field.name, jsonValue);
                      fieldArr.push(val);
                  }
              }
              else {
                  switch (field.kind) {
                      case "message":
                          if (jsonValue === null && field.T().typeName != 'google.protobuf.Value') {
                              this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                              continue;
                          }
                          target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
                          break;
                      case "enum":
                          let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
                          if (val === false)
                              continue;
                          target[localName] = val;
                          break;
                      case "scalar":
                          target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
                          break;
                  }
              }
          }
      }
      /**
       * Returns `false` for unrecognized string representations.
       *
       * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
       */
      enum(type, json, fieldName, ignoreUnknownFields) {
          if (type[0] == 'google.protobuf.NullValue')
              assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
          if (json === null)
              // we require 0 to be default value for all enums
              return 0;
          switch (typeof json) {
              case "number":
                  assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
                  return json;
              case "string":
                  let localEnumName = json;
                  if (type[2] && json.substring(0, type[2].length) === type[2])
                      // lookup without the shared prefix
                      localEnumName = json.substring(type[2].length);
                  let enumNumber = type[1][localEnumName];
                  if (typeof enumNumber === 'undefined' && ignoreUnknownFields) {
                      return false;
                  }
                  assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
                  return enumNumber;
          }
          assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
      }
      scalar(json, type, longType, fieldName) {
          let e;
          try {
              switch (type) {
                  // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
                  // Either numbers or strings are accepted. Exponent notation is also accepted.
                  case ScalarType.DOUBLE:
                  case ScalarType.FLOAT:
                      if (json === null)
                          return .0;
                      if (json === "NaN")
                          return Number.NaN;
                      if (json === "Infinity")
                          return Number.POSITIVE_INFINITY;
                      if (json === "-Infinity")
                          return Number.NEGATIVE_INFINITY;
                      if (json === "") {
                          e = "empty string";
                          break;
                      }
                      if (typeof json == "string" && json.trim().length !== json.length) {
                          e = "extra whitespace";
                          break;
                      }
                      if (typeof json != "string" && typeof json != "number") {
                          break;
                      }
                      let float = Number(json);
                      if (Number.isNaN(float)) {
                          e = "not a number";
                          break;
                      }
                      if (!Number.isFinite(float)) {
                          // infinity and -infinity are handled by string representation above, so this is an error
                          e = "too large or small";
                          break;
                      }
                      if (type == ScalarType.FLOAT)
                          assertFloat32(float);
                      return float;
                  // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
                  case ScalarType.INT32:
                  case ScalarType.FIXED32:
                  case ScalarType.SFIXED32:
                  case ScalarType.SINT32:
                  case ScalarType.UINT32:
                      if (json === null)
                          return 0;
                      let int32;
                      if (typeof json == "number")
                          int32 = json;
                      else if (json === "")
                          e = "empty string";
                      else if (typeof json == "string") {
                          if (json.trim().length !== json.length)
                              e = "extra whitespace";
                          else
                              int32 = Number(json);
                      }
                      if (int32 === undefined)
                          break;
                      if (type == ScalarType.UINT32)
                          assertUInt32(int32);
                      else
                          assertInt32(int32);
                      return int32;
                  // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
                  case ScalarType.INT64:
                  case ScalarType.SFIXED64:
                  case ScalarType.SINT64:
                      if (json === null)
                          return reflectionLongConvert(PbLong.ZERO, longType);
                      if (typeof json != "number" && typeof json != "string")
                          break;
                      return reflectionLongConvert(PbLong.from(json), longType);
                  case ScalarType.FIXED64:
                  case ScalarType.UINT64:
                      if (json === null)
                          return reflectionLongConvert(PbULong.ZERO, longType);
                      if (typeof json != "number" && typeof json != "string")
                          break;
                      return reflectionLongConvert(PbULong.from(json), longType);
                  // bool:
                  case ScalarType.BOOL:
                      if (json === null)
                          return false;
                      if (typeof json !== "boolean")
                          break;
                      return json;
                  // string:
                  case ScalarType.STRING:
                      if (json === null)
                          return "";
                      if (typeof json !== "string") {
                          e = "extra whitespace";
                          break;
                      }
                      try {
                          encodeURIComponent(json);
                      }
                      catch (e) {
                          e = "invalid UTF8";
                          break;
                      }
                      return json;
                  // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
                  // Either standard or URL-safe base64 encoding with/without paddings are accepted.
                  case ScalarType.BYTES:
                      if (json === null || json === "")
                          return new Uint8Array(0);
                      if (typeof json !== 'string')
                          break;
                      return base64decode(json);
              }
          }
          catch (error) {
              e = error.message;
          }
          this.assert(false, fieldName + (e ? " - " + e : ""), json);
      }
  }

  /**
   * Writes proto3 messages in canonical JSON format using reflection
   * information.
   *
   * https://developers.google.com/protocol-buffers/docs/proto3#json
   */
  class ReflectionJsonWriter {
      constructor(info) {
          var _a;
          this.fields = (_a = info.fields) !== null && _a !== undefined ? _a : [];
      }
      /**
       * Converts the message to a JSON object, based on the field descriptors.
       */
      write(message, options) {
          const json = {}, source = message;
          for (const field of this.fields) {
              // field is not part of a oneof, simply write as is
              if (!field.oneof) {
                  let jsonValue = this.field(field, source[field.localName], options);
                  if (jsonValue !== undefined)
                      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
                  continue;
              }
              // field is part of a oneof
              const group = source[field.oneof];
              if (group.oneofKind !== field.localName)
                  continue; // not selected, skip
              const opt = field.kind == 'scalar' || field.kind == 'enum'
                  ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
              let jsonValue = this.field(field, group[field.localName], opt);
              assert(jsonValue !== undefined);
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
          }
          return json;
      }
      field(field, value, options) {
          let jsonValue = undefined;
          if (field.kind == 'map') {
              assert(typeof value == "object" && value !== null);
              const jsonObj = {};
              switch (field.V.kind) {
                  case "scalar":
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          const val = this.scalar(field.V.T, entryValue, field.name, false, true);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
                  case "message":
                      const messageType = field.V.T();
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          const val = this.message(messageType, entryValue, field.name, options);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
                  case "enum":
                      const enumInfo = field.V.T();
                      for (const [entryKey, entryValue] of Object.entries(value)) {
                          assert(entryValue === undefined || typeof entryValue == 'number');
                          const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
                          assert(val !== undefined);
                          jsonObj[entryKey.toString()] = val; // JSON standard allows only (double quoted) string as property key
                      }
                      break;
              }
              if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
                  jsonValue = jsonObj;
          }
          else if (field.repeat) {
              assert(Array.isArray(value));
              const jsonArr = [];
              switch (field.kind) {
                  case "scalar":
                      for (let i = 0; i < value.length; i++) {
                          const val = this.scalar(field.T, value[i], field.name, field.opt, true);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
                  case "enum":
                      const enumInfo = field.T();
                      for (let i = 0; i < value.length; i++) {
                          assert(value[i] === undefined || typeof value[i] == 'number');
                          const val = this.enum(enumInfo, value[i], field.name, field.opt, true, options.enumAsInteger);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
                  case "message":
                      const messageType = field.T();
                      for (let i = 0; i < value.length; i++) {
                          const val = this.message(messageType, value[i], field.name, options);
                          assert(val !== undefined);
                          jsonArr.push(val);
                      }
                      break;
              }
              // add converted array to json output
              if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
                  jsonValue = jsonArr;
          }
          else {
              switch (field.kind) {
                  case "scalar":
                      jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
                      break;
                  case "enum":
                      jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
                      break;
                  case "message":
                      jsonValue = this.message(field.T(), value, field.name, options);
                      break;
              }
          }
          return jsonValue;
      }
      /**
       * Returns `null` as the default for google.protobuf.NullValue.
       */
      enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
          if (type[0] == 'google.protobuf.NullValue')
              return !emitDefaultValues && !optional ? undefined : null;
          if (value === undefined) {
              assert(optional);
              return undefined;
          }
          if (value === 0 && !emitDefaultValues && !optional)
              // we require 0 to be default value for all enums
              return undefined;
          assert(typeof value == 'number');
          assert(Number.isInteger(value));
          if (enumAsInteger || !type[1].hasOwnProperty(value))
              // if we don't now the enum value, just return the number
              return value;
          if (type[2])
              // restore the dropped prefix
              return type[2] + type[1][value];
          return type[1][value];
      }
      message(type, value, fieldName, options) {
          if (value === undefined)
              return options.emitDefaultValues ? null : undefined;
          return type.internalJsonWrite(value, options);
      }
      scalar(type, value, fieldName, optional, emitDefaultValues) {
          if (value === undefined) {
              assert(optional);
              return undefined;
          }
          const ed = emitDefaultValues || optional;
          // noinspection FallThroughInSwitchStatementJS
          switch (type) {
              // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
              case ScalarType.INT32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assertInt32(value);
                  return value;
              case ScalarType.FIXED32:
              case ScalarType.UINT32:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assertUInt32(value);
                  return value;
              // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
              // Either numbers or strings are accepted. Exponent notation is also accepted.
              case ScalarType.FLOAT:
                  assertFloat32(value);
              case ScalarType.DOUBLE:
                  if (value === 0)
                      return ed ? 0 : undefined;
                  assert(typeof value == 'number');
                  if (Number.isNaN(value))
                      return 'NaN';
                  if (value === Number.POSITIVE_INFINITY)
                      return 'Infinity';
                  if (value === Number.NEGATIVE_INFINITY)
                      return '-Infinity';
                  return value;
              // string:
              case ScalarType.STRING:
                  if (value === "")
                      return ed ? '' : undefined;
                  assert(typeof value == 'string');
                  return value;
              // bool:
              case ScalarType.BOOL:
                  if (value === false)
                      return ed ? false : undefined;
                  assert(typeof value == 'boolean');
                  return value;
              // JSON value will be a decimal string. Either numbers or strings are accepted.
              case ScalarType.UINT64:
              case ScalarType.FIXED64:
                  assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                  let ulong = PbULong.from(value);
                  if (ulong.isZero() && !ed)
                      return undefined;
                  return ulong.toString();
              // JSON value will be a decimal string. Either numbers or strings are accepted.
              case ScalarType.INT64:
              case ScalarType.SFIXED64:
              case ScalarType.SINT64:
                  assert(typeof value == 'number' || typeof value == 'string' || typeof value == 'bigint');
                  let long = PbLong.from(value);
                  if (long.isZero() && !ed)
                      return undefined;
                  return long.toString();
              // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
              // Either standard or URL-safe base64 encoding with/without paddings are accepted.
              case ScalarType.BYTES:
                  assert(value instanceof Uint8Array);
                  if (!value.byteLength)
                      return ed ? "" : undefined;
                  return base64encode(value);
          }
      }
  }

  /**
   * Creates the default value for a scalar type.
   */
  function reflectionScalarDefault(type, longType = LongType.STRING) {
      switch (type) {
          case ScalarType.BOOL:
              return false;
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
              return reflectionLongConvert(PbULong.ZERO, longType);
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
              return reflectionLongConvert(PbLong.ZERO, longType);
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
              return 0.0;
          case ScalarType.BYTES:
              return new Uint8Array(0);
          case ScalarType.STRING:
              return "";
          default:
              // case ScalarType.INT32:
              // case ScalarType.UINT32:
              // case ScalarType.SINT32:
              // case ScalarType.FIXED32:
              // case ScalarType.SFIXED32:
              return 0;
      }
  }

  /**
   * Reads proto3 messages in binary format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/encoding
   */
  class ReflectionBinaryReader {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          var _a;
          if (!this.fieldNoToField) {
              const fieldsInput = (_a = this.info.fields) !== null && _a !== undefined ? _a : [];
              this.fieldNoToField = new Map(fieldsInput.map(field => [field.no, field]));
          }
      }
      /**
       * Reads a message from binary format into the target message.
       *
       * Repeated fields are appended. Map entries are added, overwriting
       * existing keys.
       *
       * If a message field is already present, it will be merged with the
       * new data.
       */
      read(reader, message, options, length) {
          this.prepare();
          const end = length === undefined ? reader.len : reader.pos + length;
          while (reader.pos < end) {
              // read the tag and find the field
              const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
              if (!field) {
                  let u = options.readUnknownField;
                  if (u == "throw")
                      throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
                  let d = reader.skip(wireType);
                  if (u !== false)
                      (u === true ? UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
                  continue;
              }
              // target object for the field we are reading
              let target = message, repeated = field.repeat, localName = field.localName;
              // if field is member of oneof ADT, use ADT as target
              if (field.oneof) {
                  target = target[field.oneof];
                  // if other oneof member selected, set new ADT
                  if (target.oneofKind !== localName)
                      target = message[field.oneof] = {
                          oneofKind: localName
                      };
              }
              // we have handled oneof above, we just have read the value into `target[localName]`
              switch (field.kind) {
                  case "scalar":
                  case "enum":
                      let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                      let L = field.kind == "scalar" ? field.L : undefined;
                      if (repeated) {
                          let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                          if (wireType == WireType.LengthDelimited && T != ScalarType.STRING && T != ScalarType.BYTES) {
                              let e = reader.uint32() + reader.pos;
                              while (reader.pos < e)
                                  arr.push(this.scalar(reader, T, L));
                          }
                          else
                              arr.push(this.scalar(reader, T, L));
                      }
                      else
                          target[localName] = this.scalar(reader, T, L);
                      break;
                  case "message":
                      if (repeated) {
                          let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                          let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
                          arr.push(msg);
                      }
                      else
                          target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
                      break;
                  case "map":
                      let [mapKey, mapVal] = this.mapEntry(field, reader, options);
                      // safe to assume presence of map object, oneof cannot contain repeated values
                      target[localName][mapKey] = mapVal;
                      break;
              }
          }
      }
      /**
       * Read a map field, expecting key field = 1, value field = 2
       */
      mapEntry(field, reader, options) {
          let length = reader.uint32();
          let end = reader.pos + length;
          let key = undefined; // javascript only allows number or string for object properties
          let val = undefined;
          while (reader.pos < end) {
              let [fieldNo, wireType] = reader.tag();
              switch (fieldNo) {
                  case 1:
                      if (field.K == ScalarType.BOOL)
                          key = reader.bool().toString();
                      else
                          // long types are read as string, number types are okay as number
                          key = this.scalar(reader, field.K, LongType.STRING);
                      break;
                  case 2:
                      switch (field.V.kind) {
                          case "scalar":
                              val = this.scalar(reader, field.V.T, field.V.L);
                              break;
                          case "enum":
                              val = reader.int32();
                              break;
                          case "message":
                              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                              break;
                      }
                      break;
                  default:
                      throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
              }
          }
          if (key === undefined) {
              let keyRaw = reflectionScalarDefault(field.K);
              key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
          }
          if (val === undefined)
              switch (field.V.kind) {
                  case "scalar":
                      val = reflectionScalarDefault(field.V.T, field.V.L);
                      break;
                  case "enum":
                      val = 0;
                      break;
                  case "message":
                      val = field.V.T().create();
                      break;
              }
          return [key, val];
      }
      scalar(reader, type, longType) {
          switch (type) {
              case ScalarType.INT32:
                  return reader.int32();
              case ScalarType.STRING:
                  return reader.string();
              case ScalarType.BOOL:
                  return reader.bool();
              case ScalarType.DOUBLE:
                  return reader.double();
              case ScalarType.FLOAT:
                  return reader.float();
              case ScalarType.INT64:
                  return reflectionLongConvert(reader.int64(), longType);
              case ScalarType.UINT64:
                  return reflectionLongConvert(reader.uint64(), longType);
              case ScalarType.FIXED64:
                  return reflectionLongConvert(reader.fixed64(), longType);
              case ScalarType.FIXED32:
                  return reader.fixed32();
              case ScalarType.BYTES:
                  return reader.bytes();
              case ScalarType.UINT32:
                  return reader.uint32();
              case ScalarType.SFIXED32:
                  return reader.sfixed32();
              case ScalarType.SFIXED64:
                  return reflectionLongConvert(reader.sfixed64(), longType);
              case ScalarType.SINT32:
                  return reader.sint32();
              case ScalarType.SINT64:
                  return reflectionLongConvert(reader.sint64(), longType);
          }
      }
  }

  /**
   * Writes proto3 messages in binary format using reflection information.
   *
   * https://developers.google.com/protocol-buffers/docs/encoding
   */
  class ReflectionBinaryWriter {
      constructor(info) {
          this.info = info;
      }
      prepare() {
          if (!this.fields) {
              const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
              this.fields = fieldsInput.sort((a, b) => a.no - b.no);
          }
      }
      /**
       * Writes the message to binary format.
       */
      write(message, writer, options) {
          this.prepare();
          for (const field of this.fields) {
              let value, // this will be our field value, whether it is member of a oneof or not
              emitDefault, // whether we emit the default value (only true for oneof members)
              repeated = field.repeat, localName = field.localName;
              // handle oneof ADT
              if (field.oneof) {
                  const group = message[field.oneof];
                  if (group.oneofKind !== localName)
                      continue; // if field is not selected, skip
                  value = group[localName];
                  emitDefault = true;
              }
              else {
                  value = message[localName];
                  emitDefault = false;
              }
              // we have handled oneof above. we just have to honor `emitDefault`.
              switch (field.kind) {
                  case "scalar":
                  case "enum":
                      let T = field.kind == "enum" ? ScalarType.INT32 : field.T;
                      if (repeated) {
                          assert(Array.isArray(value));
                          if (repeated == RepeatType.PACKED)
                              this.packed(writer, T, field.no, value);
                          else
                              for (const item of value)
                                  this.scalar(writer, T, field.no, item, true);
                      }
                      else if (value === undefined)
                          assert(field.opt);
                      else
                          this.scalar(writer, T, field.no, value, emitDefault || field.opt);
                      break;
                  case "message":
                      if (repeated) {
                          assert(Array.isArray(value));
                          for (const item of value)
                              this.message(writer, options, field.T(), field.no, item);
                      }
                      else {
                          this.message(writer, options, field.T(), field.no, value);
                      }
                      break;
                  case "map":
                      assert(typeof value == 'object' && value !== null);
                      for (const [key, val] of Object.entries(value))
                          this.mapEntry(writer, options, field, key, val);
                      break;
              }
          }
          let u = options.writeUnknownFields;
          if (u !== false)
              (u === true ? UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
      }
      mapEntry(writer, options, field, key, value) {
          writer.tag(field.no, WireType.LengthDelimited);
          writer.fork();
          // javascript only allows number or string for object properties
          // we convert from our representation to the protobuf type
          let keyValue = key;
          switch (field.K) {
              case ScalarType.INT32:
              case ScalarType.FIXED32:
              case ScalarType.UINT32:
              case ScalarType.SFIXED32:
              case ScalarType.SINT32:
                  keyValue = Number.parseInt(key);
                  break;
              case ScalarType.BOOL:
                  assert(key == 'true' || key == 'false');
                  keyValue = key == 'true';
                  break;
          }
          // write key, expecting key field number = 1
          this.scalar(writer, field.K, 1, keyValue, true);
          // write value, expecting value field number = 2
          switch (field.V.kind) {
              case 'scalar':
                  this.scalar(writer, field.V.T, 2, value, true);
                  break;
              case 'enum':
                  this.scalar(writer, ScalarType.INT32, 2, value, true);
                  break;
              case 'message':
                  this.message(writer, options, field.V.T(), 2, value);
                  break;
          }
          writer.join();
      }
      message(writer, options, handler, fieldNo, value) {
          if (value === undefined)
              return;
          handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
          writer.join();
      }
      /**
       * Write a single scalar value.
       */
      scalar(writer, type, fieldNo, value, emitDefault) {
          let [wireType, method, isDefault] = this.scalarInfo(type, value);
          if (!isDefault || emitDefault) {
              writer.tag(fieldNo, wireType);
              writer[method](value);
          }
      }
      /**
       * Write an array of scalar values in packed format.
       */
      packed(writer, type, fieldNo, value) {
          if (!value.length)
              return;
          assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
          // write tag
          writer.tag(fieldNo, WireType.LengthDelimited);
          // begin length-delimited
          writer.fork();
          // write values without tags
          let [, method,] = this.scalarInfo(type);
          for (let i = 0; i < value.length; i++)
              writer[method](value[i]);
          // end length delimited
          writer.join();
      }
      /**
       * Get information for writing a scalar value.
       *
       * Returns tuple:
       * [0]: appropriate WireType
       * [1]: name of the appropriate method of IBinaryWriter
       * [2]: whether the given value is a default value
       *
       * If argument `value` is omitted, [2] is always false.
       */
      scalarInfo(type, value) {
          let t = WireType.Varint;
          let m;
          let i = value === undefined;
          let d = value === 0;
          switch (type) {
              case ScalarType.INT32:
                  m = "int32";
                  break;
              case ScalarType.STRING:
                  d = i || !value.length;
                  t = WireType.LengthDelimited;
                  m = "string";
                  break;
              case ScalarType.BOOL:
                  d = value === false;
                  m = "bool";
                  break;
              case ScalarType.UINT32:
                  m = "uint32";
                  break;
              case ScalarType.DOUBLE:
                  t = WireType.Bit64;
                  m = "double";
                  break;
              case ScalarType.FLOAT:
                  t = WireType.Bit32;
                  m = "float";
                  break;
              case ScalarType.INT64:
                  d = i || PbLong.from(value).isZero();
                  m = "int64";
                  break;
              case ScalarType.UINT64:
                  d = i || PbULong.from(value).isZero();
                  m = "uint64";
                  break;
              case ScalarType.FIXED64:
                  d = i || PbULong.from(value).isZero();
                  t = WireType.Bit64;
                  m = "fixed64";
                  break;
              case ScalarType.BYTES:
                  d = i || !value.byteLength;
                  t = WireType.LengthDelimited;
                  m = "bytes";
                  break;
              case ScalarType.FIXED32:
                  t = WireType.Bit32;
                  m = "fixed32";
                  break;
              case ScalarType.SFIXED32:
                  t = WireType.Bit32;
                  m = "sfixed32";
                  break;
              case ScalarType.SFIXED64:
                  d = i || PbLong.from(value).isZero();
                  t = WireType.Bit64;
                  m = "sfixed64";
                  break;
              case ScalarType.SINT32:
                  m = "sint32";
                  break;
              case ScalarType.SINT64:
                  d = i || PbLong.from(value).isZero();
                  m = "sint64";
                  break;
          }
          return [t, m, i || d];
      }
  }

  /**
   * Creates an instance of the generic message, using the field
   * information.
   */
  function reflectionCreate(type) {
      /**
       * This ternary can be removed in the next major version.
       * The `Object.create()` code path utilizes a new `messagePrototype`
       * property on the `IMessageType` which has this same `MESSAGE_TYPE`
       * non-enumerable property on it. Doing it this way means that we only
       * pay the cost of `Object.defineProperty()` once per `IMessageType`
       * class of once per "instance". The falsy code path is only provided
       * for backwards compatibility in cases where the runtime library is
       * updated without also updating the generated code.
       */
      const msg = type.messagePrototype
          ? Object.create(type.messagePrototype)
          : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
      for (let field of type.fields) {
          let name = field.localName;
          if (field.opt)
              continue;
          if (field.oneof)
              msg[field.oneof] = { oneofKind: undefined };
          else if (field.repeat)
              msg[name] = [];
          else
              switch (field.kind) {
                  case "scalar":
                      msg[name] = reflectionScalarDefault(field.T, field.L);
                      break;
                  case "enum":
                      // we require 0 to be default value for all enums
                      msg[name] = 0;
                      break;
                  case "map":
                      msg[name] = {};
                      break;
              }
      }
      return msg;
  }

  /**
   * Copy partial data into the target message.
   *
   * If a singular scalar or enum field is present in the source, it
   * replaces the field in the target.
   *
   * If a singular message field is present in the source, it is merged
   * with the target field by calling mergePartial() of the responsible
   * message type.
   *
   * If a repeated field is present in the source, its values replace
   * all values in the target array, removing extraneous values.
   * Repeated message fields are copied, not merged.
   *
   * If a map field is present in the source, entries are added to the
   * target map, replacing entries with the same key. Entries that only
   * exist in the target remain. Entries with message values are copied,
   * not merged.
   *
   * Note that this function differs from protobuf merge semantics,
   * which appends repeated fields.
   */
  function reflectionMergePartial(info, target, source) {
      let fieldValue, // the field value we are working with
      input = source, output; // where we want our field value to go
      for (let field of info.fields) {
          let name = field.localName;
          if (field.oneof) {
              const group = input[field.oneof]; // this is the oneof`s group in the source
              if ((group === null || group === undefined ? undefined : group.oneofKind) == undefined) { // the user is free to omit
                  continue; // we skip this field, and all other members too
              }
              fieldValue = group[name]; // our value comes from the the oneof group of the source
              output = target[field.oneof]; // and our output is the oneof group of the target
              output.oneofKind = group.oneofKind; // always update discriminator
              if (fieldValue == undefined) {
                  delete output[name]; // remove any existing value
                  continue; // skip further work on field
              }
          }
          else {
              fieldValue = input[name]; // we are using the source directly
              output = target; // we want our field value to go directly into the target
              if (fieldValue == undefined) {
                  continue; // skip further work on field, existing value is used as is
              }
          }
          if (field.repeat)
              output[name].length = fieldValue.length; // resize target array to match source array
          // now we just work with `fieldValue` and `output` to merge the value
          switch (field.kind) {
              case "scalar":
              case "enum":
                  if (field.repeat)
                      for (let i = 0; i < fieldValue.length; i++)
                          output[name][i] = fieldValue[i]; // not a reference type
                  else
                      output[name] = fieldValue; // not a reference type
                  break;
              case "message":
                  let T = field.T();
                  if (field.repeat)
                      for (let i = 0; i < fieldValue.length; i++)
                          output[name][i] = T.create(fieldValue[i]);
                  else if (output[name] === undefined)
                      output[name] = T.create(fieldValue); // nothing to merge with
                  else
                      T.mergePartial(output[name], fieldValue);
                  break;
              case "map":
                  // Map and repeated fields are simply overwritten, not appended or merged
                  switch (field.V.kind) {
                      case "scalar":
                      case "enum":
                          Object.assign(output[name], fieldValue); // elements are not reference types
                          break;
                      case "message":
                          let T = field.V.T();
                          for (let k of Object.keys(fieldValue))
                              output[name][k] = T.create(fieldValue[k]);
                          break;
                  }
                  break;
          }
      }
  }

  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  function reflectionEquals(info, a, b) {
      if (a === b)
          return true;
      if (!a || !b)
          return false;
      for (let field of info.fields) {
          let localName = field.localName;
          let val_a = field.oneof ? a[field.oneof][localName] : a[localName];
          let val_b = field.oneof ? b[field.oneof][localName] : b[localName];
          switch (field.kind) {
              case "enum":
              case "scalar":
                  let t = field.kind == "enum" ? ScalarType.INT32 : field.T;
                  if (!(field.repeat
                      ? repeatedPrimitiveEq(t, val_a, val_b)
                      : primitiveEq(t, val_a, val_b)))
                      return false;
                  break;
              case "map":
                  if (!(field.V.kind == "message"
                      ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b))
                      : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
                      return false;
                  break;
              case "message":
                  let T = field.T();
                  if (!(field.repeat
                      ? repeatedMsgEq(T, val_a, val_b)
                      : T.equals(val_a, val_b)))
                      return false;
                  break;
          }
      }
      return true;
  }
  const objectValues = Object.values;
  function primitiveEq(type, a, b) {
      if (a === b)
          return true;
      if (type !== ScalarType.BYTES)
          return false;
      let ba = a;
      let bb = b;
      if (ba.length !== bb.length)
          return false;
      for (let i = 0; i < ba.length; i++)
          if (ba[i] != bb[i])
              return false;
      return true;
  }
  function repeatedPrimitiveEq(type, a, b) {
      if (a.length !== b.length)
          return false;
      for (let i = 0; i < a.length; i++)
          if (!primitiveEq(type, a[i], b[i]))
              return false;
      return true;
  }
  function repeatedMsgEq(type, a, b) {
      if (a.length !== b.length)
          return false;
      for (let i = 0; i < a.length; i++)
          if (!type.equals(a[i], b[i]))
              return false;
      return true;
  }

  const baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
  /**
   * This standard message type provides reflection-based
   * operations to work with a message.
   */
  class MessageType {
      constructor(name, fields, options) {
          this.defaultCheckDepth = 16;
          this.typeName = name;
          this.fields = fields.map(normalizeFieldInfo);
          this.options = options !== null && options !== undefined ? options : {};
          this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [MESSAGE_TYPE]: { value: this } }));
          this.refTypeCheck = new ReflectionTypeCheck(this);
          this.refJsonReader = new ReflectionJsonReader(this);
          this.refJsonWriter = new ReflectionJsonWriter(this);
          this.refBinReader = new ReflectionBinaryReader(this);
          this.refBinWriter = new ReflectionBinaryWriter(this);
      }
      create(value) {
          let message = reflectionCreate(this);
          if (value !== undefined) {
              reflectionMergePartial(this, message, value);
          }
          return message;
      }
      /**
       * Clone the message.
       *
       * Unknown fields are discarded.
       */
      clone(message) {
          let copy = this.create();
          reflectionMergePartial(this, copy, message);
          return copy;
      }
      /**
       * Determines whether two message of the same type have the same field values.
       * Checks for deep equality, traversing repeated fields, oneof groups, maps
       * and messages recursively.
       * Will also return true if both messages are `undefined`.
       */
      equals(a, b) {
          return reflectionEquals(this, a, b);
      }
      /**
       * Is the given value assignable to our message type
       * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      is(arg, depth = this.defaultCheckDepth) {
          return this.refTypeCheck.is(arg, depth, false);
      }
      /**
       * Is the given value assignable to our message type,
       * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
       */
      isAssignable(arg, depth = this.defaultCheckDepth) {
          return this.refTypeCheck.is(arg, depth, true);
      }
      /**
       * Copy partial data into the target message.
       */
      mergePartial(target, source) {
          reflectionMergePartial(this, target, source);
      }
      /**
       * Create a new message from binary format.
       */
      fromBinary(data, options) {
          let opt = binaryReadOptions(options);
          return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
      }
      /**
       * Read a new message from a JSON value.
       */
      fromJson(json, options) {
          return this.internalJsonRead(json, jsonReadOptions(options));
      }
      /**
       * Read a new message from a JSON string.
       * This is equivalent to `T.fromJson(JSON.parse(json))`.
       */
      fromJsonString(json, options) {
          let value = JSON.parse(json);
          return this.fromJson(value, options);
      }
      /**
       * Write the message to canonical JSON value.
       */
      toJson(message, options) {
          return this.internalJsonWrite(message, jsonWriteOptions(options));
      }
      /**
       * Convert the message to canonical JSON string.
       * This is equivalent to `JSON.stringify(T.toJson(t))`
       */
      toJsonString(message, options) {
          var _a;
          let value = this.toJson(message, options);
          return JSON.stringify(value, null, (_a = options === null || options === undefined ? undefined : options.prettySpaces) !== null && _a !== undefined ? _a : 0);
      }
      /**
       * Write the message to binary format.
       */
      toBinary(message, options) {
          let opt = binaryWriteOptions(options);
          return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
      }
      /**
       * This is an internal method. If you just want to read a message from
       * JSON, use `fromJson()` or `fromJsonString()`.
       *
       * Reads JSON value and merges the fields into the target
       * according to protobuf rules. If the target is omitted,
       * a new instance is created first.
       */
      internalJsonRead(json, options, target) {
          if (json !== null && typeof json == "object" && !Array.isArray(json)) {
              let message = target !== null && target !== undefined ? target : this.create();
              this.refJsonReader.read(json, message, options);
              return message;
          }
          throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
      }
      /**
       * This is an internal method. If you just want to write a message
       * to JSON, use `toJson()` or `toJsonString().
       *
       * Writes JSON value and returns it.
       */
      internalJsonWrite(message, options) {
          return this.refJsonWriter.write(message, options);
      }
      /**
       * This is an internal method. If you just want to write a message
       * in binary format, use `toBinary()`.
       *
       * Serializes the message in binary format and appends it to the given
       * writer. Returns passed writer.
       */
      internalBinaryWrite(message, writer, options) {
          this.refBinWriter.write(message, writer, options);
          return writer;
      }
      /**
       * This is an internal method. If you just want to read a message from
       * binary data, use `fromBinary()`.
       *
       * Reads data from binary format and merges the fields into
       * the target according to protobuf rules. If the target is
       * omitted, a new instance is created first.
       */
      internalBinaryRead(reader, length, options, target) {
          let message = target !== null && target !== undefined ? target : this.create();
          this.refBinReader.read(reader, message, options, length);
          return message;
      }
  }

  const createCache = (lastNumberWeakMap) => {
      return (collection, nextNumber) => {
          lastNumberWeakMap.set(collection, nextNumber);
          return nextNumber;
      };
  };

  /*
   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it
   * is fairly new.
   */
  const MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
  const TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
  const TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
  const createGenerateUniqueNumber = (cache, lastNumberWeakMap) => {
      return (collection) => {
          const lastNumber = lastNumberWeakMap.get(collection);
          /*
           * Let's try the cheapest algorithm first. It might fail to produce a new
           * number, but it is so cheap that it is okay to take the risk. Just
           * increase the last number by one or reset it to 0 if we reached the upper
           * bound of SMIs (which stands for small integers). When the last number is
           * unknown it is assumed that the collection contains zero based consecutive
           * numbers.
           */
          let nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
          if (!collection.has(nextNumber)) {
              return cache(collection, nextNumber);
          }
          /*
           * If there are less than half of 2 ** 30 numbers stored in the collection,
           * the chance to generate a new random number in the range from 0 to 2 ** 30
           * is at least 50%. It's benifitial to use only SMIs because they perform
           * much better in any environment based on V8.
           */
          if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
              while (collection.has(nextNumber)) {
                  nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
              }
              return cache(collection, nextNumber);
          }
          // Quickly check if there is a theoretical chance to generate a new number.
          if (collection.size > MAX_SAFE_INTEGER$2) {
              throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');
          }
          // Otherwise use the full scale of safely usable integers.
          while (collection.has(nextNumber)) {
              nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER$2);
          }
          return cache(collection, nextNumber);
      };
  };

  const LAST_NUMBER_WEAK_MAP = new WeakMap();
  const cache = createCache(LAST_NUMBER_WEAK_MAP);
  const generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);

  const isCallNotification = (message) => {
      return message.method !== undefined && message.method === 'call';
  };

  const isClearResponse = (message) => {
      return message.error === null && typeof message.id === 'number';
  };

  const load = (url) => {
      // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
      const scheduledIntervalFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty
      const scheduledTimeoutFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty
      const unrespondedRequests = new Map();
      const worker = new Worker(url);
      worker.addEventListener('message', ({ data }) => {
          if (isCallNotification(data)) {
              const { params: { timerId, timerType } } = data;
              if (timerType === 'interval') {
                  const idOrFunc = scheduledIntervalFunctions.get(timerId);
                  if (typeof idOrFunc === 'number') {
                      const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                      if (timerIdAndTimerType === undefined ||
                          timerIdAndTimerType.timerId !== timerId ||
                          timerIdAndTimerType.timerType !== timerType) {
                          throw new Error('The timer is in an undefined state.');
                      }
                  }
                  else if (typeof idOrFunc !== 'undefined') {
                      idOrFunc();
                  }
                  else {
                      throw new Error('The timer is in an undefined state.');
                  }
              }
              else if (timerType === 'timeout') {
                  const idOrFunc = scheduledTimeoutFunctions.get(timerId);
                  if (typeof idOrFunc === 'number') {
                      const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                      if (timerIdAndTimerType === undefined ||
                          timerIdAndTimerType.timerId !== timerId ||
                          timerIdAndTimerType.timerType !== timerType) {
                          throw new Error('The timer is in an undefined state.');
                      }
                  }
                  else if (typeof idOrFunc !== 'undefined') {
                      idOrFunc();
                      // A timeout can be savely deleted because it is only called once.
                      scheduledTimeoutFunctions.delete(timerId);
                  }
                  else {
                      throw new Error('The timer is in an undefined state.');
                  }
              }
          }
          else if (isClearResponse(data)) {
              const { id } = data;
              const timerIdAndTimerType = unrespondedRequests.get(id);
              if (timerIdAndTimerType === undefined) {
                  throw new Error('The timer is in an undefined state.');
              }
              const { timerId, timerType } = timerIdAndTimerType;
              unrespondedRequests.delete(id);
              if (timerType === 'interval') {
                  scheduledIntervalFunctions.delete(timerId);
              }
              else {
                  scheduledTimeoutFunctions.delete(timerId);
              }
          }
          else {
              const { error: { message } } = data;
              throw new Error(message);
          }
      });
      const clearInterval = (timerId) => {
          const id = generateUniqueNumber(unrespondedRequests);
          unrespondedRequests.set(id, { timerId, timerType: 'interval' });
          scheduledIntervalFunctions.set(timerId, id);
          worker.postMessage({
              id,
              method: 'clear',
              params: { timerId, timerType: 'interval' }
          });
      };
      const clearTimeout = (timerId) => {
          const id = generateUniqueNumber(unrespondedRequests);
          unrespondedRequests.set(id, { timerId, timerType: 'timeout' });
          scheduledTimeoutFunctions.set(timerId, id);
          worker.postMessage({
              id,
              method: 'clear',
              params: { timerId, timerType: 'timeout' }
          });
      };
      const setInterval = (func, delay = 0) => {
          const timerId = generateUniqueNumber(scheduledIntervalFunctions);
          scheduledIntervalFunctions.set(timerId, () => {
              func();
              // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().
              if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {
                  worker.postMessage({
                      id: null,
                      method: 'set',
                      params: {
                          delay,
                          now: performance.now(),
                          timerId,
                          timerType: 'interval'
                      }
                  });
              }
          });
          worker.postMessage({
              id: null,
              method: 'set',
              params: {
                  delay,
                  now: performance.now(),
                  timerId,
                  timerType: 'interval'
              }
          });
          return timerId;
      };
      const setTimeout = (func, delay = 0) => {
          const timerId = generateUniqueNumber(scheduledTimeoutFunctions);
          scheduledTimeoutFunctions.set(timerId, func);
          worker.postMessage({
              id: null,
              method: 'set',
              params: {
                  delay,
                  now: performance.now(),
                  timerId,
                  timerType: 'timeout'
              }
          });
          return timerId;
      };
      return {
          clearInterval,
          clearTimeout,
          setInterval,
          setTimeout
      };
  };

  const createLoadOrReturnBroker = (loadBroker, worker) => {
      let broker = null;
      return () => {
          if (broker !== null) {
              return broker;
          }
          const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });
          const url = URL.createObjectURL(blob);
          broker = loadBroker(url);
          // Bug #1: Edge up until v18 didn't like the URL to be revoked directly.
          setTimeout(() => URL.revokeObjectURL(url));
          return broker;
      };
  };

  // This is the minified and stringified code of the worker-timers-worker package.
  const worker = `(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`; // tslint:disable-line:max-line-length

  const loadOrReturnBroker = createLoadOrReturnBroker(load, worker);
  const clearInterval$1 = (timerId) => loadOrReturnBroker().clearInterval(timerId);
  const clearTimeout$1 = (timerId) => loadOrReturnBroker().clearTimeout(timerId);
  const setInterval$1 = (func, delay) => loadOrReturnBroker().setInterval(func, delay);
  const setTimeout$1 = (func, delay) => loadOrReturnBroker().setTimeout(func, delay);

  var hd = /*#__PURE__*/Object.freeze({
    __proto__: null,
    clearInterval: clearInterval$1,
    clearTimeout: clearTimeout$1,
    setInterval: setInterval$1,
    setTimeout: setTimeout$1
  });

  var lib = {};

  var parser = {};

  var grammar = {exports: {}};

  var hasRequiredGrammar;

  function requireGrammar () {
  	if (hasRequiredGrammar) return grammar.exports;
  	hasRequiredGrammar = 1;
  	var grammar$1 = grammar.exports = {
  	  v: [{
  	    name: 'version',
  	    reg: /^(\d*)$/
  	  }],
  	  o: [{
  	    // o=- 20518 0 IN IP4 203.0.113.1
  	    // NB: sessionId will be a String in most cases because it is huge
  	    name: 'origin',
  	    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
  	    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
  	    format: '%s %s %d %s IP%d %s'
  	  }],
  	  // default parsing of these only (though some of these feel outdated)
  	  s: [{ name: 'name' }],
  	  i: [{ name: 'description' }],
  	  u: [{ name: 'uri' }],
  	  e: [{ name: 'email' }],
  	  p: [{ name: 'phone' }],
  	  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
  	  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  	  // k: [{}], // outdated thing ignored
  	  t: [{
  	    // t=0 0
  	    name: 'timing',
  	    reg: /^(\d*) (\d*)/,
  	    names: ['start', 'stop'],
  	    format: '%d %d'
  	  }],
  	  c: [{
  	    // c=IN IP4 10.47.197.26
  	    name: 'connection',
  	    reg: /^IN IP(\d) (\S*)/,
  	    names: ['version', 'ip'],
  	    format: 'IN IP%d %s'
  	  }],
  	  b: [{
  	    // b=AS:4000
  	    push: 'bandwidth',
  	    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
  	    names: ['type', 'limit'],
  	    format: '%s:%s'
  	  }],
  	  m: [{
  	    // m=video 51744 RTP/AVP 126 97 98 34 31
  	    // NB: special - pushes to session
  	    // TODO: rtp/fmtp should be filtered by the payloads found here?
  	    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
  	    names: ['type', 'port', 'protocol', 'payloads'],
  	    format: '%s %d %s %s'
  	  }],
  	  a: [
  	    {
  	      // a=rtpmap:110 opus/48000/2
  	      push: 'rtp',
  	      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
  	      names: ['payload', 'codec', 'rate', 'encoding'],
  	      format: function (o) {
  	        return (o.encoding)
  	          ? 'rtpmap:%d %s/%s/%s'
  	          : o.rate
  	            ? 'rtpmap:%d %s/%s'
  	            : 'rtpmap:%d %s';
  	      }
  	    },
  	    {
  	      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
  	      // a=fmtp:111 minptime=10; useinbandfec=1
  	      push: 'fmtp',
  	      reg: /^fmtp:(\d*) ([\S| ]*)/,
  	      names: ['payload', 'config'],
  	      format: 'fmtp:%d %s'
  	    },
  	    {
  	      // a=control:streamid=0
  	      name: 'control',
  	      reg: /^control:(.*)/,
  	      format: 'control:%s'
  	    },
  	    {
  	      // a=rtcp:65179 IN IP4 193.84.77.194
  	      name: 'rtcp',
  	      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
  	      names: ['port', 'netType', 'ipVer', 'address'],
  	      format: function (o) {
  	        return (o.address != null)
  	          ? 'rtcp:%d %s IP%d %s'
  	          : 'rtcp:%d';
  	      }
  	    },
  	    {
  	      // a=rtcp-fb:98 trr-int 100
  	      push: 'rtcpFbTrrInt',
  	      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
  	      names: ['payload', 'value'],
  	      format: 'rtcp-fb:%s trr-int %d'
  	    },
  	    {
  	      // a=rtcp-fb:98 nack rpsi
  	      push: 'rtcpFb',
  	      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
  	      names: ['payload', 'type', 'subtype'],
  	      format: function (o) {
  	        return (o.subtype != null)
  	          ? 'rtcp-fb:%s %s %s'
  	          : 'rtcp-fb:%s %s';
  	      }
  	    },
  	    {
  	      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
  	      // a=extmap:1/recvonly URI-gps-string
  	      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
  	      push: 'ext',
  	      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
  	      names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
  	      format: function (o) {
  	        return (
  	          'extmap:%d' +
  	          (o.direction ? '/%s' : '%v') +
  	          (o['encrypt-uri'] ? ' %s' : '%v') +
  	          ' %s' +
  	          (o.config ? ' %s' : '')
  	        );
  	      }
  	    },
  	    {
  	      // a=extmap-allow-mixed
  	      name: 'extmapAllowMixed',
  	      reg: /^(extmap-allow-mixed)/
  	    },
  	    {
  	      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
  	      push: 'crypto',
  	      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
  	      names: ['id', 'suite', 'config', 'sessionConfig'],
  	      format: function (o) {
  	        return (o.sessionConfig != null)
  	          ? 'crypto:%d %s %s %s'
  	          : 'crypto:%d %s %s';
  	      }
  	    },
  	    {
  	      // a=setup:actpass
  	      name: 'setup',
  	      reg: /^setup:(\w*)/,
  	      format: 'setup:%s'
  	    },
  	    {
  	      // a=connection:new
  	      name: 'connectionType',
  	      reg: /^connection:(new|existing)/,
  	      format: 'connection:%s'
  	    },
  	    {
  	      // a=mid:1
  	      name: 'mid',
  	      reg: /^mid:([^\s]*)/,
  	      format: 'mid:%s'
  	    },
  	    {
  	      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
  	      name: 'msid',
  	      reg: /^msid:(.*)/,
  	      format: 'msid:%s'
  	    },
  	    {
  	      // a=ptime:20
  	      name: 'ptime',
  	      reg: /^ptime:(\d*(?:\.\d*)*)/,
  	      format: 'ptime:%d'
  	    },
  	    {
  	      // a=maxptime:60
  	      name: 'maxptime',
  	      reg: /^maxptime:(\d*(?:\.\d*)*)/,
  	      format: 'maxptime:%d'
  	    },
  	    {
  	      // a=sendrecv
  	      name: 'direction',
  	      reg: /^(sendrecv|recvonly|sendonly|inactive)/
  	    },
  	    {
  	      // a=ice-lite
  	      name: 'icelite',
  	      reg: /^(ice-lite)/
  	    },
  	    {
  	      // a=ice-ufrag:F7gI
  	      name: 'iceUfrag',
  	      reg: /^ice-ufrag:(\S*)/,
  	      format: 'ice-ufrag:%s'
  	    },
  	    {
  	      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
  	      name: 'icePwd',
  	      reg: /^ice-pwd:(\S*)/,
  	      format: 'ice-pwd:%s'
  	    },
  	    {
  	      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
  	      name: 'fingerprint',
  	      reg: /^fingerprint:(\S*) (\S*)/,
  	      names: ['type', 'hash'],
  	      format: 'fingerprint:%s %s'
  	    },
  	    {
  	      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
  	      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
  	      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
  	      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
  	      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
  	      push:'candidates',
  	      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
  	      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
  	      format: function (o) {
  	        var str = 'candidate:%s %d %s %d %s %d typ %s';

  	        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

  	        // NB: candidate has three optional chunks, so %void middles one if it's missing
  	        str += (o.tcptype != null) ? ' tcptype %s' : '%v';

  	        if (o.generation != null) {
  	          str += ' generation %d';
  	        }

  	        str += (o['network-id'] != null) ? ' network-id %d' : '%v';
  	        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
  	        return str;
  	      }
  	    },
  	    {
  	      // a=end-of-candidates (keep after the candidates line for readability)
  	      name: 'endOfCandidates',
  	      reg: /^(end-of-candidates)/
  	    },
  	    {
  	      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
  	      name: 'remoteCandidates',
  	      reg: /^remote-candidates:(.*)/,
  	      format: 'remote-candidates:%s'
  	    },
  	    {
  	      // a=ice-options:google-ice
  	      name: 'iceOptions',
  	      reg: /^ice-options:(\S*)/,
  	      format: 'ice-options:%s'
  	    },
  	    {
  	      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
  	      push: 'ssrcs',
  	      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
  	      names: ['id', 'attribute', 'value'],
  	      format: function (o) {
  	        var str = 'ssrc:%d';
  	        if (o.attribute != null) {
  	          str += ' %s';
  	          if (o.value != null) {
  	            str += ':%s';
  	          }
  	        }
  	        return str;
  	      }
  	    },
  	    {
  	      // a=ssrc-group:FEC 1 2
  	      // a=ssrc-group:FEC-FR 3004364195 1080772241
  	      push: 'ssrcGroups',
  	      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
  	      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
  	      names: ['semantics', 'ssrcs'],
  	      format: 'ssrc-group:%s %s'
  	    },
  	    {
  	      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
  	      name: 'msidSemantic',
  	      reg: /^msid-semantic:\s?(\w*) (\S*)/,
  	      names: ['semantic', 'token'],
  	      format: 'msid-semantic: %s %s' // space after ':' is not accidental
  	    },
  	    {
  	      // a=group:BUNDLE audio video
  	      push: 'groups',
  	      reg: /^group:(\w*) (.*)/,
  	      names: ['type', 'mids'],
  	      format: 'group:%s %s'
  	    },
  	    {
  	      // a=rtcp-mux
  	      name: 'rtcpMux',
  	      reg: /^(rtcp-mux)/
  	    },
  	    {
  	      // a=rtcp-rsize
  	      name: 'rtcpRsize',
  	      reg: /^(rtcp-rsize)/
  	    },
  	    {
  	      // a=sctpmap:5000 webrtc-datachannel 1024
  	      name: 'sctpmap',
  	      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
  	      names: ['sctpmapNumber', 'app', 'maxMessageSize'],
  	      format: function (o) {
  	        return (o.maxMessageSize != null)
  	          ? 'sctpmap:%s %s %s'
  	          : 'sctpmap:%s %s';
  	      }
  	    },
  	    {
  	      // a=x-google-flag:conference
  	      name: 'xGoogleFlag',
  	      reg: /^x-google-flag:([^\s]*)/,
  	      format: 'x-google-flag:%s'
  	    },
  	    {
  	      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
  	      push: 'rids',
  	      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
  	      names: ['id', 'direction', 'params'],
  	      format: function (o) {
  	        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
  	      }
  	    },
  	    {
  	      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
  	      // a=imageattr:* send [x=800,y=640] recv *
  	      // a=imageattr:100 recv [x=320,y=240]
  	      push: 'imageattrs',
  	      reg: new RegExp(
  	        // a=imageattr:97
  	        '^imageattr:(\\d+|\\*)' +
  	        // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
  	        '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
  	        // recv [x=330,y=250]
  	        '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
  	      ),
  	      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
  	      format: function (o) {
  	        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
  	      }
  	    },
  	    {
  	      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
  	      // a=simulcast:recv 1;4,5 send 6;7
  	      name: 'simulcast',
  	      reg: new RegExp(
  	        // a=simulcast:
  	        '^simulcast:' +
  	        // send 1,2,3;~4,~5
  	        '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
  	        // space + recv 6;~7,~8
  	        '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
  	        // end
  	        '$'
  	      ),
  	      names: ['dir1', 'list1', 'dir2', 'list2'],
  	      format: function (o) {
  	        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
  	      }
  	    },
  	    {
  	      // old simulcast draft 03 (implemented by Firefox)
  	      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
  	      // a=simulcast: recv pt=97;98 send pt=97
  	      // a=simulcast: send rid=5;6;7 paused=6,7
  	      name: 'simulcast_03',
  	      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
  	      names: ['value'],
  	      format: 'simulcast: %s'
  	    },
  	    {
  	      // a=framerate:25
  	      // a=framerate:29.97
  	      name: 'framerate',
  	      reg: /^framerate:(\d+(?:$|\.\d+))/,
  	      format: 'framerate:%s'
  	    },
  	    {
  	      // RFC4570
  	      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
  	      name: 'sourceFilter',
  	      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
  	      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
  	      format: 'source-filter: %s %s %s %s %s'
  	    },
  	    {
  	      // a=bundle-only
  	      name: 'bundleOnly',
  	      reg: /^(bundle-only)/
  	    },
  	    {
  	      // a=label:1
  	      name: 'label',
  	      reg: /^label:(.+)/,
  	      format: 'label:%s'
  	    },
  	    {
  	      // RFC version 26 for SCTP over DTLS
  	      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
  	      name: 'sctpPort',
  	      reg: /^sctp-port:(\d+)$/,
  	      format: 'sctp-port:%s'
  	    },
  	    {
  	      // RFC version 26 for SCTP over DTLS
  	      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
  	      name: 'maxMessageSize',
  	      reg: /^max-message-size:(\d+)$/,
  	      format: 'max-message-size:%s'
  	    },
  	    {
  	      // RFC7273
  	      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
  	      push:'tsRefClocks',
  	      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
  	      names: ['clksrc', 'clksrcExt'],
  	      format: function (o) {
  	        return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
  	      }
  	    },
  	    {
  	      // RFC7273
  	      // a=mediaclk:direct=963214424
  	      name:'mediaClk',
  	      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
  	      names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
  	      format: function (o) {
  	        var str = 'mediaclk:';
  	        str += (o.id != null ? 'id=%s %s' : '%v%s');
  	        str += (o.mediaClockValue != null ? '=%s' : '');
  	        str += (o.rateNumerator != null ? ' rate=%s' : '');
  	        str += (o.rateDenominator != null ? '/%s' : '');
  	        return str;
  	      }
  	    },
  	    {
  	      // a=keywds:keywords
  	      name: 'keywords',
  	      reg: /^keywds:(.+)$/,
  	      format: 'keywds:%s'
  	    },
  	    {
  	      // a=content:main
  	      name: 'content',
  	      reg: /^content:(.+)/,
  	      format: 'content:%s'
  	    },
  	    // BFCP https://tools.ietf.org/html/rfc4583
  	    {
  	      // a=floorctrl:c-s
  	      name: 'bfcpFloorCtrl',
  	      reg: /^floorctrl:(c-only|s-only|c-s)/,
  	      format: 'floorctrl:%s'
  	    },
  	    {
  	      // a=confid:1
  	      name: 'bfcpConfId',
  	      reg: /^confid:(\d+)/,
  	      format: 'confid:%s'
  	    },
  	    {
  	      // a=userid:1
  	      name: 'bfcpUserId',
  	      reg: /^userid:(\d+)/,
  	      format: 'userid:%s'
  	    },
  	    {
  	      // a=floorid:1
  	      name: 'bfcpFloorId',
  	      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
  	      names: ['id', 'mStream'],
  	      format: 'floorid:%s mstrm:%s'
  	    },
  	    {
  	      // any a= that we don't understand is kept verbatim on media.invalid
  	      push: 'invalid',
  	      names: ['value']
  	    }
  	  ]
  	};

  	// set sensible defaults to avoid polluting the grammar with boring details
  	Object.keys(grammar$1).forEach(function (key) {
  	  var objs = grammar$1[key];
  	  objs.forEach(function (obj) {
  	    if (!obj.reg) {
  	      obj.reg = /(.*)/;
  	    }
  	    if (!obj.format) {
  	      obj.format = '%s';
  	    }
  	  });
  	});
  	return grammar.exports;
  }

  var hasRequiredParser;

  function requireParser () {
  	if (hasRequiredParser) return parser;
  	hasRequiredParser = 1;
  	(function (exports) {
  		var toIntIfInt = function (v) {
  		  return String(Number(v)) === v ? Number(v) : v;
  		};

  		var attachProperties = function (match, location, names, rawName) {
  		  if (rawName && !names) {
  		    location[rawName] = toIntIfInt(match[1]);
  		  }
  		  else {
  		    for (var i = 0; i < names.length; i += 1) {
  		      if (match[i+1] != null) {
  		        location[names[i]] = toIntIfInt(match[i+1]);
  		      }
  		    }
  		  }
  		};

  		var parseReg = function (obj, location, content) {
  		  var needsBlank = obj.name && obj.names;
  		  if (obj.push && !location[obj.push]) {
  		    location[obj.push] = [];
  		  }
  		  else if (needsBlank && !location[obj.name]) {
  		    location[obj.name] = {};
  		  }
  		  var keyLocation = obj.push ?
  		    {} :  // blank object that will be pushed
  		    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  		  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  		  if (obj.push) {
  		    location[obj.push].push(keyLocation);
  		  }
  		};

  		var grammar = requireGrammar();
  		var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

  		exports.parse = function (sdp) {
  		  var session = {}
  		    , media = []
  		    , location = session; // points at where properties go under (one of the above)

  		  // parse lines we understand
  		  sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
  		    var type = l[0];
  		    var content = l.slice(2);
  		    if (type === 'm') {
  		      media.push({rtp: [], fmtp: []});
  		      location = media[media.length-1]; // point at latest media line
  		    }

  		    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
  		      var obj = grammar[type][j];
  		      if (obj.reg.test(content)) {
  		        return parseReg(obj, location, content);
  		      }
  		    }
  		  });

  		  session.media = media; // link it up
  		  return session;
  		};

  		var paramReducer = function (acc, expr) {
  		  var s = expr.split(/=(.+)/, 2);
  		  if (s.length === 2) {
  		    acc[s[0]] = toIntIfInt(s[1]);
  		  } else if (s.length === 1 && expr.length > 1) {
  		    acc[s[0]] = undefined;
  		  }
  		  return acc;
  		};

  		exports.parseParams = function (str) {
  		  return str.split(/;\s?/).reduce(paramReducer, {});
  		};

  		// For backward compatibility - alias will be removed in 3.0.0
  		exports.parseFmtpConfig = exports.parseParams;

  		exports.parsePayloads = function (str) {
  		  return str.toString().split(' ').map(Number);
  		};

  		exports.parseRemoteCandidates = function (str) {
  		  var candidates = [];
  		  var parts = str.split(' ').map(toIntIfInt);
  		  for (var i = 0; i < parts.length; i += 3) {
  		    candidates.push({
  		      component: parts[i],
  		      ip: parts[i + 1],
  		      port: parts[i + 2]
  		    });
  		  }
  		  return candidates;
  		};

  		exports.parseImageAttributes = function (str) {
  		  return str.split(' ').map(function (item) {
  		    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
  		  });
  		};

  		exports.parseSimulcastStreamList = function (str) {
  		  return str.split(';').map(function (stream) {
  		    return stream.split(',').map(function (format) {
  		      var scid, paused = false;

  		      if (format[0] !== '~') {
  		        scid = toIntIfInt(format);
  		      } else {
  		        scid = toIntIfInt(format.substring(1, format.length));
  		        paused = true;
  		      }

  		      return {
  		        scid: scid,
  		        paused: paused
  		      };
  		    });
  		  });
  		}; 
  	} (parser));
  	return parser;
  }

  var writer;
  var hasRequiredWriter;

  function requireWriter () {
  	if (hasRequiredWriter) return writer;
  	hasRequiredWriter = 1;
  	var grammar = requireGrammar();

  	// customized util.format - discards excess arguments and can void middle ones
  	var formatRegExp = /%[sdv%]/g;
  	var format = function (formatStr) {
  	  var i = 1;
  	  var args = arguments;
  	  var len = args.length;
  	  return formatStr.replace(formatRegExp, function (x) {
  	    if (i >= len) {
  	      return x; // missing argument
  	    }
  	    var arg = args[i];
  	    i += 1;
  	    switch (x) {
  	    case '%%':
  	      return '%';
  	    case '%s':
  	      return String(arg);
  	    case '%d':
  	      return Number(arg);
  	    case '%v':
  	      return '';
  	    }
  	  });
  	  // NB: we discard excess arguments - they are typically undefined from makeLine
  	};

  	var makeLine = function (type, obj, location) {
  	  var str = obj.format instanceof Function ?
  	    (obj.format(obj.push ? location : location[obj.name])) :
  	    obj.format;

  	  var args = [type + '=' + str];
  	  if (obj.names) {
  	    for (var i = 0; i < obj.names.length; i += 1) {
  	      var n = obj.names[i];
  	      if (obj.name) {
  	        args.push(location[obj.name][n]);
  	      }
  	      else { // for mLine and push attributes
  	        args.push(location[obj.names[i]]);
  	      }
  	    }
  	  }
  	  else {
  	    args.push(location[obj.name]);
  	  }
  	  return format.apply(null, args);
  	};

  	// RFC specified order
  	// TODO: extend this with all the rest
  	var defaultOuterOrder = [
  	  'v', 'o', 's', 'i',
  	  'u', 'e', 'p', 'c',
  	  'b', 't', 'r', 'z', 'a'
  	];
  	var defaultInnerOrder = ['i', 'c', 'b', 'a'];


  	writer = function (session, opts) {
  	  opts = opts || {};
  	  // ensure certain properties exist
  	  if (session.version == null) {
  	    session.version = 0; // 'v=0' must be there (only defined version atm)
  	  }
  	  if (session.name == null) {
  	    session.name = ' '; // 's= ' must be there if no meaningful name set
  	  }
  	  session.media.forEach(function (mLine) {
  	    if (mLine.payloads == null) {
  	      mLine.payloads = '';
  	    }
  	  });

  	  var outerOrder = opts.outerOrder || defaultOuterOrder;
  	  var innerOrder = opts.innerOrder || defaultInnerOrder;
  	  var sdp = [];

  	  // loop through outerOrder for matching properties on session
  	  outerOrder.forEach(function (type) {
  	    grammar[type].forEach(function (obj) {
  	      if (obj.name in session && session[obj.name] != null) {
  	        sdp.push(makeLine(type, obj, session));
  	      }
  	      else if (obj.push in session && session[obj.push] != null) {
  	        session[obj.push].forEach(function (el) {
  	          sdp.push(makeLine(type, obj, el));
  	        });
  	      }
  	    });
  	  });

  	  // then for each media line, follow the innerOrder
  	  session.media.forEach(function (mLine) {
  	    sdp.push(makeLine('m', grammar.m[0], mLine));

  	    innerOrder.forEach(function (type) {
  	      grammar[type].forEach(function (obj) {
  	        if (obj.name in mLine && mLine[obj.name] != null) {
  	          sdp.push(makeLine(type, obj, mLine));
  	        }
  	        else if (obj.push in mLine && mLine[obj.push] != null) {
  	          mLine[obj.push].forEach(function (el) {
  	            sdp.push(makeLine(type, obj, el));
  	          });
  	        }
  	      });
  	    });
  	  });

  	  return sdp.join('\r\n') + '\r\n';
  	};
  	return writer;
  }

  var hasRequiredLib;

  function requireLib () {
  	if (hasRequiredLib) return lib;
  	hasRequiredLib = 1;
  	var parser = requireParser();
  	var writer = requireWriter();
  	var grammar = requireGrammar();

  	lib.grammar = grammar;
  	lib.write = writer;
  	lib.parse = parser.parse;
  	lib.parseParams = parser.parseParams;
  	lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
  	lib.parsePayloads = parser.parsePayloads;
  	lib.parseRemoteCandidates = parser.parseRemoteCandidates;
  	lib.parseImageAttributes = parser.parseImageAttributes;
  	lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  	return lib;
  }

  var libExports = requireLib();

  var Zg = Object.defineProperty, ev = Object.defineProperties;
  var tv = Object.getOwnPropertyDescriptors;
  var wo = Object.getOwnPropertySymbols, rv = Object.getPrototypeOf, Eu = Object.prototype.hasOwnProperty, Cu = Object.prototype.propertyIsEnumerable, sv = Reflect.get;
  var wu = Math.pow, ud = (s, t, e) => t in s ? Zg(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e, L = (s, t) => {
    for (var e in t || (t = {}))
      Eu.call(t, e) && ud(s, e, t[e]);
    if (wo)
      for (var e of wo(t))
        Cu.call(t, e) && ud(s, e, t[e]);
    return s;
  }, z = (s, t) => ev(s, tv(t));
  var na = (s, t) => {
    var e = {};
    for (var r in s)
      Eu.call(s, r) && t.indexOf(r) < 0 && (e[r] = s[r]);
    if (s != null && wo)
      for (var r of wo(s))
        t.indexOf(r) < 0 && Cu.call(s, r) && (e[r] = s[r]);
    return e;
  };
  var f = (s, t, e) => (ud(s, typeof t != "symbol" ? t + "" : t, e), e), pd = (s, t, e) => {
    if (!t.has(s))
      throw TypeError("Cannot " + e);
  };
  var o = (s, t, e) => (pd(s, t, "read from private field"), e ? e.call(s) : t.get(s)), E = (s, t, e) => {
    if (t.has(s))
      throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(s) : t.set(s, e);
  }, _ = (s, t, e, r) => (pd(s, t, "write to private field"), t.set(s, e), e);
  var Le = (s, t, e) => (pd(s, t, "access private method"), e), Pu = (s, t, e) => sv(rv(s), e, t);
  var u = (s, t, e) => new Promise((r, n) => {
    var i = (d) => {
      try {
        c(e.next(d));
      } catch (p) {
        n(p);
      }
    }, a = (d) => {
      try {
        c(e.throw(d));
      } catch (p) {
        n(p);
      }
    }, c = (d) => d.done ? r(d.value) : Promise.resolve(d.value).then(i, a);
    c((e = e.apply(s, t)).next());
  });
  var Ru = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function iv(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
  }
  var at = {}, av = {
    get exports() {
      return at;
    },
    set exports(s) {
      at = s;
    }
  }, qn = typeof Reflect == "object" ? Reflect : null, bu = qn && typeof qn.apply == "function" ? qn.apply : function(t, e, r) {
    return Function.prototype.apply.call(t, e, r);
  }, Lo;
  qn && typeof qn.ownKeys == "function" ? Lo = qn.ownKeys : Object.getOwnPropertySymbols ? Lo = function(t) {
    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
  } : Lo = function(t) {
    return Object.getOwnPropertyNames(t);
  };
  function ov(s) {
    console && console.warn && console.warn(s);
  }
  var Bh = Number.isNaN || function(t) {
    return t !== t;
  };
  function ye() {
    ye.init.call(this);
  }
  av.exports = ye;
  at.once = uv;
  ye.EventEmitter = ye;
  ye.prototype._events = undefined;
  ye.prototype._eventsCount = 0;
  ye.prototype._maxListeners = undefined;
  var ku = 10;
  function Uc(s) {
    if (typeof s != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
  }
  Object.defineProperty(ye, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return ku;
    },
    set: function(s) {
      if (typeof s != "number" || s < 0 || Bh(s))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
      ku = s;
    }
  });
  ye.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  ye.prototype.setMaxListeners = function(t) {
    if (typeof t != "number" || t < 0 || Bh(t))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
    return this._maxListeners = t, this;
  };
  function qh(s) {
    return s._maxListeners === undefined ? ye.defaultMaxListeners : s._maxListeners;
  }
  ye.prototype.getMaxListeners = function() {
    return qh(this);
  };
  ye.prototype.emit = function(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e.push(arguments[r]);
    var n = t === "error", i = this._events;
    if (i !== undefined)
      n = n && i.error === undefined;
    else if (!n)
      return false;
    if (n) {
      var a;
      if (e.length > 0 && (a = e[0]), a instanceof Error)
        throw a;
      var c = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
      throw c.context = a, c;
    }
    var d = i[t];
    if (d === undefined)
      return false;
    if (typeof d == "function")
      bu(d, this, e);
    else
      for (var p = d.length, h = Kh(d, p), r = 0; r < p; ++r)
        bu(h[r], this, e);
    return true;
  };
  function jh(s, t, e, r) {
    var n, i, a;
    if (Uc(e), i = s._events, i === undefined ? (i = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (i.newListener !== undefined && (s.emit(
      "newListener",
      t,
      e.listener ? e.listener : e
    ), i = s._events), a = i[t]), a === undefined)
      a = i[t] = e, ++s._eventsCount;
    else if (typeof a == "function" ? a = i[t] = r ? [e, a] : [a, e] : r ? a.unshift(e) : a.push(e), n = qh(s), n > 0 && a.length > n && !a.warned) {
      a.warned = true;
      var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = a.length, ov(c);
    }
    return s;
  }
  ye.prototype.addListener = function(t, e) {
    return jh(this, t, e, false);
  };
  ye.prototype.on = ye.prototype.addListener;
  ye.prototype.prependListener = function(t, e) {
    return jh(this, t, e, true);
  };
  function cv() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Gh(s, t, e) {
    var r = { fired: false, wrapFn: undefined, target: s, type: t, listener: e }, n = cv.bind(r);
    return n.listener = e, r.wrapFn = n, n;
  }
  ye.prototype.once = function(t, e) {
    return Uc(e), this.on(t, Gh(this, t, e)), this;
  };
  ye.prototype.prependOnceListener = function(t, e) {
    return Uc(e), this.prependListener(t, Gh(this, t, e)), this;
  };
  ye.prototype.removeListener = function(t, e) {
    var r, n, i, a, c;
    if (Uc(e), n = this._events, n === undefined)
      return this;
    if (r = n[t], r === undefined)
      return this;
    if (r === e || r.listener === e)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, r.listener || e));
    else if (typeof r != "function") {
      for (i = -1, a = r.length - 1; a >= 0; a--)
        if (r[a] === e || r[a].listener === e) {
          c = r[a].listener, i = a;
          break;
        }
      if (i < 0)
        return this;
      i === 0 ? r.shift() : dv(r, i), r.length === 1 && (n[t] = r[0]), n.removeListener !== undefined && this.emit("removeListener", t, c || e);
    }
    return this;
  };
  ye.prototype.off = ye.prototype.removeListener;
  ye.prototype.removeAllListeners = function(t) {
    var e, r, n;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== undefined && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
    if (arguments.length === 0) {
      var i = Object.keys(r), a;
      for (n = 0; n < i.length; ++n)
        a = i[n], a !== "removeListener" && this.removeAllListeners(a);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (e = r[t], typeof e == "function")
      this.removeListener(t, e);
    else if (e !== undefined)
      for (n = e.length - 1; n >= 0; n--)
        this.removeListener(t, e[n]);
    return this;
  };
  function Jh(s, t, e) {
    var r = s._events;
    if (r === undefined)
      return [];
    var n = r[t];
    return n === undefined ? [] : typeof n == "function" ? e ? [n.listener || n] : [n] : e ? lv(n) : Kh(n, n.length);
  }
  ye.prototype.listeners = function(t) {
    return Jh(this, t, true);
  };
  ye.prototype.rawListeners = function(t) {
    return Jh(this, t, false);
  };
  ye.listenerCount = function(s, t) {
    return typeof s.listenerCount == "function" ? s.listenerCount(t) : Wh.call(s, t);
  };
  ye.prototype.listenerCount = Wh;
  function Wh(s) {
    var t = this._events;
    if (t !== undefined) {
      var e = t[s];
      if (typeof e == "function")
        return 1;
      if (e !== undefined)
        return e.length;
    }
    return 0;
  }
  ye.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Lo(this._events) : [];
  };
  function Kh(s, t) {
    for (var e = new Array(t), r = 0; r < t; ++r)
      e[r] = s[r];
    return e;
  }
  function dv(s, t) {
    for (; t + 1 < s.length; t++)
      s[t] = s[t + 1];
    s.pop();
  }
  function lv(s) {
    for (var t = new Array(s.length), e = 0; e < t.length; ++e)
      t[e] = s[e].listener || s[e];
    return t;
  }
  function uv(s, t) {
    return new Promise(function(e, r) {
      function n(a) {
        s.removeListener(t, i), r(a);
      }
      function i() {
        typeof s.removeListener == "function" && s.removeListener("error", n), e([].slice.call(arguments));
      }
      zh(s, t, i, { once: true }), t !== "error" && pv(s, n, { once: true });
    });
  }
  function pv(s, t, e) {
    typeof s.on == "function" && zh(s, "error", t, e);
  }
  function zh(s, t, e, r) {
    if (typeof s.on == "function")
      r.once ? s.once(t, e) : s.on(t, e);
    else if (typeof s.addEventListener == "function")
      s.addEventListener(t, function n(i) {
        r.once && s.removeEventListener(t, n), e(i);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
  }
  var Q;
  (function(s) {
    s[s.MAJOR_EVENT = 0] = "MAJOR_EVENT", s[s.MINOR_EVENT = 1] = "MINOR_EVENT";
  })(Q || (Q = {}));
  var x;
  (function(s) {
    s.PRECALL_TEST_BEGIN = "precall_begin", s.PRECALL_TEST_COMPLETE = "precall_end", s.CALL_JOIN_BEGIN = "call_join", s.NET_QUALITY_TEST_BEGIN = "net_quality_test_begin", s.NET_QUALITY_TEST_END = "net_quality_test_end", s.WEBSOCKET_CONNECTED = "websocket_connected", s.TRANSPORT_CONNECTED = "transport_connected", s.AUDIO_ON = "audio_on", s.AUDIO_OFF = "audio_off", s.VIDEO_ON = "video_on", s.VIDEO_OFF = "video_off", s.PARTICIPANT_ROLE = "participant_role", s.PING_STAT = "ping_stat", s.DISCONNECT = "disconnect", s.RECONNECT_ATTEMPT = "reconnect_attempt", s.SCREENSHARE_START_REQUESTED = "screenshare_start_requested", s.SCREENSHARE_STARTED = "screenshare_started", s.SCREENSHARE_STOPPED = "screenshare_stopped", s.TAB_CHANGE = "tab_change", s.BROWSER_BACKGROUNDED = "browser_backgrounded", s.BROWSER_FOREGROUNDED = "browser_foregrounded", s.DOMINANT_SPEAKER = "dominant_speaker", s.AUDIO_DEVICES_UPDATES = "audio_devices_updates", s.VIDEO_DEVICES_UPDATES = "video_devices_updates", s.SPEAKER_DEVICES_UPDATES = "speaker_devices_updates", s.SELECTED_MICROHPONE_UPDATE = "selected_microphone_update", s.SELECTED_CAMERA_UPDATE = "selected_camera_update", s.SELECTED_SPEAKER_UPDATE = "selected_speaker_update", s.MEDIA_PERMISSION = "media_permission", s.LEGACY_SWITCH = "legacy_switch", s.AUDIO_PLAY_FAILED = "audio_play_failed", s.VIDEO_PLAY_FAILED = "video_play_failed", s.AUDIO_TRACK_MUTED = "audio_track_muted", s.VIDEO_TRACK_MUTED = "video_track_muted", s.IVS_PLAYER_REBUFFERING = "ivs_player_rebuffering", s.IVS_PLAYER_AUDIO_BLOCKED = "ivs_player_audio_blocked", s.IVS_PLAYER_PLAYBACK_BLOCKED = "ivs_player_playback_blocked", s.IVS_PLAYER_ERROR = "ivs_player_error", s.IVS_PLAYER_RECOVERABLE_ERROR = "ivs_player_recoverable_error", s.IVS_PLAYER_WORKER_ERROR = "ivs_player_worker_error", s.IVS_PLAYER_NETWORK_UNAVAILABLE = "ivs_player_network_unavailable", s.LIVESTREAM_LATENCY = "livestream_latency", s.IVS_PLAYER_ANALYTICS_EVENT = "ivs_player_analytics_event", s.IVS_PLAYER_PLAYBACK_RATE_CHANGED = "ivs_player_playback_rate_changed", s.IVS_PLAYER_QUALITY_CHANGED = "ivs_player_quality_changed", s.IVS_PLAYER_INITIALIZED = "ivs_player_initialized";
  })(x || (x = {}));
  const hv = /* @__PURE__ */ new Map([
    [x.PRECALL_TEST_BEGIN, Q.MINOR_EVENT],
    [x.PRECALL_TEST_COMPLETE, Q.MINOR_EVENT],
    [x.CALL_JOIN_BEGIN, Q.MAJOR_EVENT],
    [x.NET_QUALITY_TEST_BEGIN, Q.MINOR_EVENT],
    [x.NET_QUALITY_TEST_END, Q.MINOR_EVENT],
    [x.WEBSOCKET_CONNECTED, Q.MINOR_EVENT],
    [x.TRANSPORT_CONNECTED, Q.MAJOR_EVENT],
    [x.AUDIO_ON, Q.MINOR_EVENT],
    [x.AUDIO_OFF, Q.MINOR_EVENT],
    [x.VIDEO_ON, Q.MINOR_EVENT],
    [x.VIDEO_OFF, Q.MINOR_EVENT],
    [x.PARTICIPANT_ROLE, Q.MINOR_EVENT],
    [x.PING_STAT, Q.MAJOR_EVENT],
    [x.DISCONNECT, Q.MAJOR_EVENT],
    [x.RECONNECT_ATTEMPT, Q.MAJOR_EVENT],
    [x.SCREENSHARE_START_REQUESTED, Q.MINOR_EVENT],
    [x.SCREENSHARE_STARTED, Q.MINOR_EVENT],
    [x.SCREENSHARE_STOPPED, Q.MINOR_EVENT],
    [x.TAB_CHANGE, Q.MINOR_EVENT],
    [x.BROWSER_BACKGROUNDED, Q.MINOR_EVENT],
    [x.BROWSER_FOREGROUNDED, Q.MINOR_EVENT],
    [x.DOMINANT_SPEAKER, Q.MINOR_EVENT],
    [x.AUDIO_DEVICES_UPDATES, Q.MINOR_EVENT],
    [x.VIDEO_DEVICES_UPDATES, Q.MINOR_EVENT],
    [x.SPEAKER_DEVICES_UPDATES, Q.MINOR_EVENT],
    [x.SELECTED_MICROHPONE_UPDATE, Q.MINOR_EVENT],
    [x.SELECTED_CAMERA_UPDATE, Q.MINOR_EVENT],
    [x.SELECTED_SPEAKER_UPDATE, Q.MINOR_EVENT],
    [x.MEDIA_PERMISSION, Q.MINOR_EVENT],
    [x.LEGACY_SWITCH, Q.MINOR_EVENT],
    [x.AUDIO_PLAY_FAILED, Q.MINOR_EVENT],
    [x.VIDEO_PLAY_FAILED, Q.MINOR_EVENT],
    [x.AUDIO_TRACK_MUTED, Q.MINOR_EVENT],
    [x.VIDEO_TRACK_MUTED, Q.MINOR_EVENT],
    // IVS Player Events
    [x.IVS_PLAYER_REBUFFERING, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_AUDIO_BLOCKED, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_PLAYBACK_BLOCKED, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_ERROR, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_RECOVERABLE_ERROR, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_WORKER_ERROR, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_NETWORK_UNAVAILABLE, Q.MAJOR_EVENT],
    // We are keeping live latency as major, so that it
    // acts as a ping alternative for livestream viewer
    [x.LIVESTREAM_LATENCY, Q.MAJOR_EVENT],
    [x.IVS_PLAYER_ANALYTICS_EVENT, Q.MINOR_EVENT],
    [x.IVS_PLAYER_PLAYBACK_RATE_CHANGED, Q.MINOR_EVENT],
    [x.IVS_PLAYER_QUALITY_CHANGED, Q.MINOR_EVENT],
    [x.IVS_PLAYER_INITIALIZED, Q.MINOR_EVENT]
  ]);
  class mv {
    constructor() {
      f(this, "events");
      this.events = [];
    }
    add(t) {
      this.events.push(t);
    }
    flush() {
      return {
        entries: this.events.splice(0, 25)
      };
    }
  }
  class fv extends at {
    constructor({ logger: e, peerId: r, apiHostnames: n }) {
      super();
      f(this, "logger");
      f(this, "peerId");
      f(this, "eventStore");
      f(this, "apiEndpoint");
      this.logger = e, this.peerId = r, this.apiEndpoint = `https://${n.daCollector}/api/v1/message`, this.eventStore = new mv();
    }
    sendEventsChunkToServer(e) {
      return u(this, null, function* () {
        var n;
        const r = {
          payload: e,
          peerId: this.peerId
        };
        try {
          return yield fetch(this.apiEndpoint, {
            method: "POST",
            body: JSON.stringify(r)
          }), !0;
        } catch (i) {
          return this.logger.error("callStats::sendEventsChunkToServer::catch", { error: i }), (n = e.entries) == null || n.forEach((a) => {
            this.eventStore.add(a);
          }), false;
        }
      });
    }
    callEvent(e) {
      e.timestamp = new Date(), this.eventStore.add(e), this.emit(e.event, e.metaData), hv.get(e.event) === Q.MAJOR_EVENT && this.flush();
    }
    flush() {
      return u(this, null, function* () {
        var r;
        const e = this.eventStore.flush();
        return (r = e == null ? undefined : e.entries) != null && r.length ? (yield this.sendEventsChunkToServer(e), true) : false;
      });
    }
  }
  var Iu;
  (function(s) {
    s.CHROMIUM = "chromum", s.FIREFOX = "firefox", s.SAFARI = "safari";
  })(Iu || (Iu = {}));
  const fa = {
    DEVEL: "devel",
    PREPROD: "preprod",
    PROD: "prod"
  };
  var qt;
  (function(s) {
    s.AUDIO = "AUDIO", s.VIDEO = "VIDEO", s.SPEAKER = "SPEAKER", s.SCREENSHARE = "SCREENSHARE";
  })(qt || (qt = {}));
  var Au;
  (function(s) {
    s[s.INIT = 0] = "INIT", s[s.ACCEPTED = 1] = "ACCEPTED", s[s.DENIED = 2] = "DENIED", s[s.SYS_DENIED = 3] = "SYS_DENIED", s[s.FAILED = 4] = "FAILED", s[s.NOTFOUND = 5] = "NOTFOUND", s[s.NOT_APPLICABLE = 6] = "NOT_APPLICABLE";
  })(Au || (Au = {}));
  function zo({ packetsLost: s, packetsSent: t }) {
    return t > 0 ? s * 100 / t : 0;
  }
  function Yo({ packetsLost: s, packetsReceived: t }) {
    return t + s > 0 ? s * 100 / (t + s) : 0;
  }
  const Yh = 240, Qh = 720, Xh = 8, Zh = 3, Fc = 10, Vc = 0.02, Hc = 0.03;
  function Kr({ stat: s, weight: t, rangeMin: e, rangeMax: r, rangeRankingDirection: n }) {
    return s == null ? t : e === r ? n === "UP" ? s <= e ? t : 0 : s >= r ? t : 0 : n === "UP" ? (1 - Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e)) * t : n === "DOWN" ? Math.max(Math.min(r, Math.abs(s)) - e, 0) / (r - e) * t : t;
  }
  function em({ isLowQualityVideo: s, isVideoStuck: t, isVideoLagging: e, jitterQuality: r, packetsLostQuality: n }) {
    const i = 0.8 * ((s ? 0.85 : 1) * (e ? 0.7 : 1) * (t ? 0.5 : 1)) + 0.2 * (r * n);
    return Math.round((i + Number.EPSILON) * 100) / 100;
  }
  function tm({ packetsLost: s, packetsSent: t }) {
    return t > 0 ? s * 100 / t : 0;
  }
  function rm({ packetsLost: s, packetsSent: t, jitter: e }) {
    const n = Kr({
      stat: tm({
        packetsLost: s,
        packetsSent: t
      }),
      weight: 0.7,
      rangeMin: 0,
      rangeMax: Fc,
      rangeRankingDirection: "UP"
    }), a = Kr({
      stat: e,
      weight: 0.3,
      rangeMin: Vc,
      rangeMax: Hc,
      rangeRankingDirection: "UP"
    });
    return n + a;
  }
  function gv({ frameWidth: s, isScreenShare: t }) {
    return s < (t ? Qh : Yh);
  }
  function vv({ framesPerSecond: s, isScreenShare: t }) {
    return s < (t ? Zh : Xh);
  }
  function yv({ framesEncoded: s }) {
    return s === 0;
  }
  function sm$1({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsSent: r, jitter: n, isScreenShare: i, framesEncoded: a }) {
    const c = Kr({
      stat: tm({
        packetsLost: e,
        packetsSent: r
      }),
      weight: 1,
      rangeMin: 0,
      rangeMax: Fc,
      rangeRankingDirection: "UP"
    }), d = Kr({
      stat: n,
      weight: 1,
      rangeMin: Vc,
      rangeMax: Hc,
      rangeRankingDirection: "UP"
    }), p = gv({
      frameWidth: s,
      isScreenShare: i
    }), h = vv({
      framesPerSecond: t,
      isScreenShare: i
    }), m = yv({
      framesEncoded: a,
      isScreenShare: i
    });
    return em({
      isLowQualityVideo: p,
      isVideoLagging: h,
      isVideoStuck: m,
      jitterQuality: d,
      packetsLostQuality: c
    });
  }
  function nm({ packetsLost: s, packetsReceived: t }) {
    return t + s > 0 ? s * 100 / (t + s) : 0;
  }
  function im({ concealmentEvents: s, packetsLost: t, packetsReceived: e, jitter: r }) {
    const i = Kr({
      stat: s,
      weight: 0.2,
      rangeMin: 0,
      rangeMax: 3,
      rangeRankingDirection: "UP"
    }), a = 0.5, c = Kr({
      stat: nm({
        packetsLost: t,
        packetsReceived: e
      }),
      weight: a,
      rangeMin: 0,
      rangeMax: Fc,
      rangeRankingDirection: "UP"
    }), p = Kr({
      stat: r,
      weight: 0.3,
      rangeMin: Vc,
      rangeMax: Hc,
      rangeRankingDirection: "UP"
    });
    return i + c + p;
  }
  function Tv({ framesDecoded: s }) {
    return s === 0;
  }
  function _v({ framesPerSecond: s, isScreenShare: t }) {
    return s < (t ? Zh : Xh);
  }
  function Sv({ frameWidth: s, isScreenShare: t }) {
    return s < (t ? Qh : Yh);
  }
  function am({ frameWidth: s, framesPerSecond: t, packetsLost: e, packetsReceived: r, jitter: n, isScreenShare: i, framesDecoded: a }) {
    const c = Kr({
      stat: nm({
        packetsLost: e,
        packetsReceived: r
      }),
      weight: 1,
      rangeMin: 0,
      rangeMax: Fc,
      rangeRankingDirection: "UP"
    }), d = Kr({
      stat: n,
      weight: 1,
      rangeMin: Vc,
      rangeMax: Hc,
      rangeRankingDirection: "UP"
    }), p = Sv({
      frameWidth: s,
      isScreenShare: i
    }), h = _v({
      framesPerSecond: t,
      isScreenShare: i
    }), m = Tv({
      framesDecoded: a,
      isScreenShare: i
    });
    return em({
      isLowQualityVideo: p,
      isVideoLagging: h,
      isVideoStuck: m,
      jitterQuality: d,
      packetsLostQuality: c
    });
  }
  class Yr {
    constructor(t) {
      f(this, "pc1");
      f(this, "pc2");
      f(this, "constrainVideoBitrateKbps");
      f(this, "constrainOfferToRemoveVideoFec", false);
      f(this, "iceCandidateFilter");
      const e = new RTCPeerConnection(t), r = new RTCPeerConnection(t);
      this.pc1 = e, this.pc2 = r, this.iceCandidateFilter = Yr.noFilter, this.pc1.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc2)), this.pc2.addEventListener("icecandidate", this.onIceCandidate.bind(this, this.pc1));
    }
    static parseCandidate(t) {
      const e = "candidate:", r = t.indexOf(e) + e.length, n = t.substr(r).split(" ");
      return {
        type: n[7],
        protocol: n[2],
        address: n[4]
      };
    }
    static isNotHostCandidate(t) {
      return t.type !== "host";
    }
    static isHost(t) {
      return t.type === "host";
    }
    static isRelay(t) {
      return t.type === "relay";
    }
    static isReflexive(t) {
      return t.type === "srflx";
    }
    static noFilter(t) {
      return true;
    }
    onIceCandidate(t, e) {
      if (e.candidate) {
        const r = Yr.parseCandidate(e.candidate.candidate);
        this.iceCandidateFilter(r) && t.addIceCandidate(e.candidate);
      }
    }
    setIceCandidateFilter(t) {
      this.iceCandidateFilter = t;
    }
    // Constraint max video bitrate by modifying the SDP when creating an answer.
    constrainVideoBitrate(t) {
      this.constrainVideoBitrateKbps = t;
    }
    // Remove video FEC if available on the offer.
    disableVideoFec() {
      this.constrainOfferToRemoveVideoFec = true;
    }
    gotOffer(t) {
      this.constrainOfferToRemoveVideoFec && (t.sdp = t.sdp.replace(/(m=video 1 [^\r]+)(116 117)(\r\n)/g, `$1\r
`), t.sdp = t.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, ""), t.sdp = t.sdp.replace(/a=fmtp:98 apt=116\r\n/g, "")), this.pc1.setLocalDescription(t), this.pc2.setRemoteDescription(t), this.pc2.createAnswer().then(this.gotAnswer.bind(this), this.reportFatal.bind(this));
    }
    gotAnswer(t) {
      this.constrainVideoBitrateKbps && (t.sdp = t.sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r
b=AS:${this.constrainVideoBitrateKbps}\r
`)), this.pc2.setLocalDescription(t), this.pc1.setRemoteDescription(t);
    }
    establishConnection() {
      this.pc1.createOffer().then(this.gotOffer.bind(this), this.reportFatal.bind(this));
    }
    // eslint-disable-next-line class-methods-use-this
    reportFatal(t) {
      console.error("Error:", t);
    }
    getRoundTripTime() {
      return u(this, null, function* () {
        const [t, e] = yield Promise.all([this.pc1.getStats(), this.pc2.getStats()]);
        let r, n;
        if (t.forEach((i) => {
          i.type === "candidate-pair" && i.nominated === true && i.bytesSent > 0 && (r = i);
        }), e.forEach((i) => {
          i.type === "candidate-pair" && i.nominated === true && i.bytesReceived > 0 && (n = i);
        }), r && n)
          try {
            if (r.currentRoundTripTime && n.currentRoundTripTime)
              return {
                rtt: r.currentRoundTripTime,
                backendRTT: n.currentRoundTripTime
              };
            const i = (n.lastPacketReceivedTimestamp - r.lastPacketSentTimestamp) / 1e3;
            return {
              rtt: i,
              backendRTT: i
            };
          } catch (i) {
            return;
          }
      });
    }
    close() {
      this.pc1.close(), this.pc2.close();
    }
  }
  class om extends at {
    constructor(e) {
      super();
      f(this, "call");
      f(this, "timeOut");
      this.call = new Yr(e);
    }
    start(e = 1e4) {
      this.call.establishConnection(), this.timeOut = setTimeout(this.testFailed.bind(this), e);
    }
    testComplete(e) {
      clearTimeout(this.timeOut), this.call.close(), this.emit("done", e);
    }
    testFailed(e) {
      this.call.close(), this.emit("failed", e);
    }
  }
  const Ev = 8, Cv = 1 / 1e3;
  class wv extends om {
    constructor(e) {
      super(e);
      f(this, "senderChannel");
      f(this, "recieveChannel");
      f(this, "startTime");
      f(this, "lastBitrateMeasureTime");
      f(this, "sentPayloadBytes", 0);
      f(this, "recievedPayloadBytes", 0);
      f(this, "lastReceivedPayloadBytes", 0);
      f(this, "stopSending", false);
      f(this, "testProgress", 0);
      f(this, "samplePacket", "");
      f(this, "finalBitrateSum", 0);
      f(this, "bitRateSampels", 0);
      f(this, "maxNumberOfPacketsToSend", 0);
      f(this, "bytesToKeepBuffered", 0);
      f(this, "testDurationSeconds", 5);
      this.call.setIceCandidateFilter(Yr.isNotHostCandidate), this.senderChannel = this.call.pc1.createDataChannel(null);
      for (let r = 0; r < 1024 * 256; r += 1)
        this.samplePacket += "h";
      this.maxNumberOfPacketsToSend = 1, this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend, this.testDurationSeconds = 4, this.senderChannel.addEventListener("open", this.sendingStep.bind(this)), this.call.pc2.addEventListener("datachannel", this.onRecieverChannel.bind(this));
    }
    sendingStep() {
      const e = new Date();
      this.startTime || (this.startTime = e, this.lastBitrateMeasureTime = e);
      for (let n = 0; n !== this.maxNumberOfPacketsToSend && !(this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered); n += 1) {
        this.sentPayloadBytes += this.samplePacket.length;
        try {
          this.senderChannel.send(this.samplePacket);
        } catch (i) {
        }
      }
      const r = e.getTime() - this.startTime.getTime();
      r >= 1e3 * this.testDurationSeconds ? (this.stopSending = true, this.testProgress = 100) : (this.testProgress = r / (10 * this.testDurationSeconds), setTimeout(this.sendingStep.bind(this), 1));
    }
    onMessageRecieved(e) {
      this.recievedPayloadBytes += e.data.length;
      const r = new Date(), n = r.getTime() - this.lastBitrateMeasureTime.getTime();
      if (n >= 1e3) {
        const a = (this.recievedPayloadBytes - this.lastReceivedPayloadBytes) * Ev / (n / 1e3);
        this.finalBitrateSum += a, this.bitRateSampels += 1, this.lastReceivedPayloadBytes = this.recievedPayloadBytes, this.lastBitrateMeasureTime = r;
      }
      if (this.stopSending && this.sentPayloadBytes === this.recievedPayloadBytes) {
        const i = this.finalBitrateSum / this.bitRateSampels;
        this.testComplete({
          throughput: Math.round(i * Cv)
        });
      }
    }
    testComplete(e) {
      this.call.getRoundTripTime().then(({ rtt: r, backendRTT: n }) => super.testComplete({
        RTT: r,
        backendRTT: n,
        throughput: e.throughput
      }));
    }
    onRecieverChannel(e) {
      this.recieveChannel = e.channel, this.recieveChannel.addEventListener("message", this.onMessageRecieved.bind(this));
    }
  }
  class Ll extends om {
    constructor(e, r = Yr.noFilter) {
      super(e);
      f(this, "ch1");
      f(this, "ch2");
      this.call.setIceCandidateFilter(r);
      const n = this.call.pc1.createDataChannel(null);
      this.ch1 = n, n.addEventListener("open", () => {
        n.send("hello");
      }), n.addEventListener("message", this.onCh1Recieve.bind(this)), this.call.pc2.addEventListener("datachannel", this.dataChannelHandler.bind(this));
    }
    onCh1Recieve(e) {
      e.data !== "world" ? this.hangup("Invalid data transmitted.") : this.testComplete({
        connectivity: true
      });
    }
    onCh2Recieve(e) {
      if (e.data !== "hello")
        this.hangup("Invalid data transmitted.");
      else
        try {
          this.ch2.send("world");
        } catch (r) {
        }
    }
    dataChannelHandler(e) {
      const r = e.channel;
      this.ch2 = r, r.addEventListener("message", this.onCh2Recieve.bind(this));
    }
    hangup(e) {
      this.testFailed(e);
    }
  }
  class Pv extends Ll {
    constructor(t) {
      super(t, Yr.isHost);
    }
  }
  class Rv extends Ll {
    constructor(t) {
      super(t, Yr.isRelay);
    }
  }
  class bv extends Ll {
    constructor(t) {
      super(t, Yr.isReflexive);
    }
  }
  class kv {
    constructor() {
      f(this, "ipInformation", null);
    }
    getIPDetails(n) {
      return u(this, arguments, function* ({ peerId: t, apiHostnames: e, logger: r }) {
        var i;
        if (!this.ipInformation) {
          try {
            const a = `https://${e.location}`, d = yield (yield fetch(a)).json();
            if (((i = d.loc) == null ? void 0 : i.length) > 5)
              return this.ipInformation = d, d;
            throw Error("Insufficient data");
          } catch (a) {
            r.error("callstats::ipDetails:: failed to fetch ip using location service", { error: a });
          }
          try {
            const a = yield fetch(`https://${e.locationLegacy}/?token=3c493932b0624c&peerId=${t}`, {
              method: "POST"
            });
            this.ipInformation = yield a.json();
          } catch (a) {
            r.error("callstats::ipDetails:: failed to fetch ip using legacy location service", { error: a });
          }
        }
        return this.ipInformation;
      });
    }
    resetCache() {
      this.ipInformation = null;
    }
  }
  const xl$1 = new kv(), Du = [
    {
      urls: "turn:turn.dyte.in:443?transport=tcp",
      username: "dyte",
      credential: "dytein",
      credentialType: "password"
    },
    {
      urls: "turn:turn.dyte.in:3478?transport=udp",
      username: "dyte",
      credential: "dytein",
      credentialType: "password"
    }
  ];
  function Mu(s) {
    const [t, e] = s.split(",");
    return {
      coords: {
        latitude: Number(t),
        longitude: Number(e)
      }
    };
  }
  class cm {
    constructor() {
      f(this, "transport");
      f(this, "candidatePair");
      f(this, "outboundVideoRtp", /* @__PURE__ */ new Map());
      f(this, "inboundVideoRtp", /* @__PURE__ */ new Map());
      f(this, "outboundAudioRtp", /* @__PURE__ */ new Map());
      f(this, "inboundAudioRtp", /* @__PURE__ */ new Map());
      f(this, "remoteInboundRtp", /* @__PURE__ */ new Map());
      f(this, "producerStreamMap", /* @__PURE__ */ new Map());
      f(this, "consumerStreamMap", /* @__PURE__ */ new Map());
      f(this, "staleProducerStreamMap", false);
      f(this, "staleConsumerStreamMap", false);
    }
  }
  class dm extends at {
    constructor() {
      super();
      f(this, "observer");
      f(this, "outboundProducerMap", /* @__PURE__ */ new Map());
      f(this, "inboundConsumerMap", /* @__PURE__ */ new Map());
      f(this, "consumerPeerIdMap", /* @__PURE__ */ new Map());
      f(this, "pausedConsumerMap", /* @__PURE__ */ new Map());
      f(this, "pausedProducerMap", /* @__PURE__ */ new Map());
      f(this, "overallProducingTransportsStatsMap", {});
      f(this, "overallConsumingTransportsStatsMap", {});
      f(this, "overallConsumersStatsMap", {});
      f(this, "overallProducersStatsMap", {});
      f(this, "videoProducerToStatsMap", /* @__PURE__ */ new Map());
      f(this, "audioProducerToStatsMap", /* @__PURE__ */ new Map());
      f(this, "videoConsumerToStatsMap", /* @__PURE__ */ new Map());
      f(this, "audioConsumerToStatsMap", /* @__PURE__ */ new Map());
      f(this, "consumerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
      f(this, "consumerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
      f(this, "producerIdsWithFreezedVideo", /* @__PURE__ */ new Set());
      f(this, "producerIdsWithFreezedAudio", /* @__PURE__ */ new Set());
      f(this, "freezedProducingTransportIds", /* @__PURE__ */ new Set());
      f(this, "freezedConsumingTransportIds", /* @__PURE__ */ new Set());
      f(this, "screenShareProducers", /* @__PURE__ */ new Set());
      f(this, "screenShareConsumers", /* @__PURE__ */ new Set());
      f(this, "ipDetails");
      f(this, "callStatsInstance");
      this.observer = new at();
    }
    registerProducer(e) {
      return u(this, null, function* () {
        yield this.generateProducerStreamMap(e), e.observer.on("close", this.deregisterProducer.bind(this, e)), e.observer.on("pause", this.pauseProducer.bind(this, e.id)), e.observer.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
      });
    }
    pauseProducer(e) {
      this.pausedProducerMap.set(e, {
        lastReportCalculated: false
      });
    }
    resumeProducer(e) {
      this.pausedProducerMap.delete(e);
    }
    processInboundConsumerVideoStats(e, r, n) {
      var a, c;
      const i = ((c = (a = this == null ? undefined : this.callStatsInstance) == null ? undefined : a.consumerSharedMediaStatesMap) == null ? undefined : c.get(e)) || {};
      r.totalVideoPacketsReceived === n.packetsReceived ? (this.consumerIdsWithFreezedVideo.add(e), this.callStatsInstance && i.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "pause", e))) : (r.totalVideoPacketsReceived = n.packetsReceived, this.consumerIdsWithFreezedVideo.has(e) && (this.consumerIdsWithFreezedVideo.delete(e), this.callStatsInstance && i.video && (this.callStatsInstance.logger.debug("callstats::measurements::consumerVideoDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_video_status", "resume", e))));
    }
    processInboundConsumerAudioStats(e, r, n) {
      var a, c;
      const i = ((c = (a = this == null ? undefined : this.callStatsInstance) == null ? undefined : a.consumerSharedMediaStatesMap) == null ? undefined : c.get(e)) || {};
      r.totalAudioPacketsReceived === n.packetsReceived ? (this.consumerIdsWithFreezedAudio.add(e), this.callStatsInstance && i.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioFreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "pause", e))) : (r.totalAudioPacketsReceived = n.packetsReceived, this.consumerIdsWithFreezedAudio.has(e) && (this.consumerIdsWithFreezedAudio.delete(e), this.callStatsInstance && i.audio && (this.callStatsInstance.logger.debug("callStats::measurements::consumerAudioDefreezed", { consumerId: e }), this.callStatsInstance.eventHandler.emit("consumer_audio_status", "resume", e))));
    }
    processOutboundProducerVideoStats(e, r, n) {
      var a;
      const i = ((a = this == null ? undefined : this.callStatsInstance) == null ? undefined : a.currentUserMediaStates) || {};
      r.totalVideoPacketsSent === n.packetsSent ? (this.producerIdsWithFreezedVideo.add(e), this.callStatsInstance && i.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "pause", e))) : (r.totalVideoPacketsSent = n.packetsSent, this.producerIdsWithFreezedVideo.has(e) && (this.producerIdsWithFreezedVideo.delete(e), this.callStatsInstance && i.video && (this.callStatsInstance.logger.debug("callStats::measurements::producerVideoDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_video_status", "resume", e))));
    }
    processOutboundProducerAudioStats(e, r, n) {
      var a;
      const i = ((a = this == null ? undefined : this.callStatsInstance) == null ? undefined : a.currentUserMediaStates) || {};
      r.totalAudioPacketsSent === n.packetsSent ? (this.producerIdsWithFreezedAudio.add(e), this.callStatsInstance && i.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioFreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "pause", e))) : (r.totalAudioPacketsSent = n.packetsSent, this.producerIdsWithFreezedAudio.has(e) && (this.producerIdsWithFreezedAudio.delete(e), this.callStatsInstance && i.audio && (this.callStatsInstance.logger.debug("callStats::measurements::producerAudioDefreezed", { producerId: e }), this.callStatsInstance.eventHandler.emit("producer_audio_status", "resume", e))));
    }
    processProducingTransportStats(e, r, n) {
      var h;
      const i = ((h = this == null ? undefined : this.callStatsInstance) == null ? undefined : h.currentUserMediaStates) || {}, { audio: a, video: c, screen: d } = i, p = a || c || d;
      r.totalPacketsSent === n.packetsSent ? (this.freezedProducingTransportIds.add(e), this.callStatsInstance && p && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "pause", e))) : (r.totalPacketsSent = n.packetsSent, this.freezedProducingTransportIds.has(e) && (this.freezedProducingTransportIds.delete(e), this.callStatsInstance && p && (this.callStatsInstance.logger.debug("callStats::measurements::producingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("producing_transport_status", "resume", e))));
    }
    processConsumingTransportStats(e, r, n) {
      var c, d;
      const a = !!Array.from(((d = (c = this == null ? undefined : this.callStatsInstance) == null ? undefined : c.consumerSharedMediaStatesMap) == null ? undefined : d.values()) || []).reduce((p, h) => p || h.audio || h.video || h.screen, false);
      r.totalPacketsReceived === n.packetsSent ? (this.freezedConsumingTransportIds.add(e), this.callStatsInstance && a && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportFreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "pause", e))) : (r.totalPacketsReceived = n.packetsSent, this.freezedConsumingTransportIds.has(e) && (this.freezedConsumingTransportIds.delete(e), this.callStatsInstance && a && (this.callStatsInstance.logger.debug("callStats::measurements::consumingTransportDefreezed", { transportId: e }), this.callStatsInstance.eventHandler.emit("consuming_transport_status", "resume", e))));
    }
    registerConsumer(e) {
      return u(this, null, function* () {
        yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
          producerId: e.producerId,
          peerId: e.appData.peerId,
          appData: e.appData
        }), e.observer.on("close", this.deregisterConsumer.bind(this, e)), e.observer.on("pause", this.pauseConsumer.bind(this, e.id)), e.observer.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
      });
    }
    pauseConsumer(e) {
      this.pausedConsumerMap.set(e, {
        lastReportCalculated: false
      });
    }
    resumeConsumer(e) {
      this.pausedConsumerMap.delete(e);
    }
    generateProducerStreamMap(e, r = false) {
      return u(this, null, function* () {
        const n = yield e.getStats(), i = r ? this.getProducerStatsFromReport(this.parseRTCReport(n, ["outbound-rtp", "remote-inbound-rtp"], false, e.id))[0] : undefined;
        for (const a of n.values())
          switch (a.type) {
            case "outbound-rtp": {
              this.outboundProducerMap.set(a.id, e.id);
              break;
            }
          }
        return i;
      });
    }
    generateConsumerStreamMap(e, r = false) {
      return u(this, null, function* () {
        const n = yield e.getStats(), i = r ? this.getConsumerStatsFromReport(this.parseRTCReport(n, ["inbound-rtp"], false, e.id))[0] : undefined;
        for (const a of n.values())
          switch (a.type) {
            case "inbound-rtp": {
              this.inboundConsumerMap.set(a.id, e.id);
              break;
            }
          }
        return i;
      });
    }
    deregisterProducer(e) {
      this.outboundProducerMap.forEach((r, n) => {
        r === e.id && this.outboundProducerMap.delete(n);
      }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
    }
    deregisterConsumer(e) {
      this.inboundConsumerMap.forEach((r, n) => {
        r === e.id && this.inboundConsumerMap.delete(n);
      }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
    }
    // eslint-disable-next-line class-methods-use-this
    getIceCandidateStats(e) {
      var r;
      return {
        id: e.id,
        type: e.candidateType || e.type,
        address: e.address,
        port: e.port,
        url: e.url,
        protocol: (r = e.relayProtocol) != null ? r : e.protocol,
        networkType: e.networkType,
        relatedAddress: e.relatedAddress,
        relatedPort: e.relatedPort
      };
    }
    // eslint-disable-next-line class-methods-use-this
    getWorkingSimulcastVideoStats(e) {
      return e.find((n) => {
        const i = n.framesEncoded > 0, a = n.packetsSent > 0, c = n.frameWidth && n.frameHeight;
        return i && a && !!c;
      }) || e[e.length - 1];
    }
    parseRTCReport(e, r = [], n = false, i = undefined, a = undefined) {
      var b, A, I, $, V, O, q, B, ne, Y, we, Pe, Tt;
      const c = e, d = new cm(), p = r.length ? new Set(r) : undefined, h = [], m = [], g = [], T = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map();
      for (const M of c.values()) {
        if (p) {
          if (p.size === 0)
            break;
          if (p.has(M.type))
            n && p.delete(M.type);
          else
            continue;
        }
        switch (M.type) {
          case "local-candidate": {
            h.push(this.getIceCandidateStats(M));
            break;
          }
          case "remote-candidate": {
            m.push(this.getIceCandidateStats(M));
            break;
          }
          case "candidate-pair": {
            const { nominated: C } = M, { selected: k } = M, H = M, Ie = {
              nominated: C != null ? C : k,
              currentRoundTripTime: H.currentRoundTripTime,
              totalRoundTripTime: H.totalRoundTripTime,
              bytesReceived: H.bytesReceived,
              bytesSent: H.bytesSent,
              availableOutgoingBitrate: H.availableOutgoingBitrate,
              lastPacketReceivedTimestamp: H.lastPacketReceivedTimestamp,
              lastPacketSentTimestamp: H.lastPacketSentTimestamp,
              localCandidateId: H.localCandidateId,
              remoteCandidateId: H.remoteCandidateId,
              bytesDiscardedOnSend: H.bytesDiscardedOnSend,
              packetsSent: H.packetsSent,
              packetsReceived: H.packetsReceived,
              packetsDiscardedOnSend: H.packetsDiscardedOnSend
            };
            g.push(Ie), (M.nominated === true || M.selected === true) && (d.candidatePair = Ie);
            break;
          }
          case "transport": {
            const C = M;
            a && (a.producing && (this.overallProducingTransportsStatsMap[a.id] || (this.overallProducingTransportsStatsMap[a.id] = {
              totalPacketsSent: 0
            })), a.consuming && (this.overallConsumingTransportsStatsMap[a.id] || (this.overallConsumingTransportsStatsMap[a.id] = {
              totalPacketsReceived: 0
            })));
            const k = {
              bytesReceived: C.bytesReceived,
              bytesSent: C.bytesSent,
              packetsSent: C.packetsSent,
              packetsReceived: C.packetsReceived,
              dtlsCipher: C.dtlsCipher,
              // @ts-ignore
              dtlsState: C.dtlsState,
              // @ts-ignore
              iceRole: C.iceRole
            };
            if (d.transport = k, a) {
              if (a.producing) {
                const H = this.overallProducingTransportsStatsMap[a.id];
                this.processProducingTransportStats(a.id, H, k);
              }
              if (a.consuming) {
                const H = this.overallConsumingTransportsStatsMap[a.id];
                this.processConsumingTransportStats(a.id, H, k);
              }
            }
            break;
          }
          case "remote-inbound-rtp": {
            const C = M, k = {
              jitter: C.jitter,
              fractionLost: C.fractionLost,
              roundTripTime: C.roundTripTime,
              roundTripTimeMeasurements: C.roundTripTimeMeasurements,
              totalRoundTripTime: C.totalRoundTripTime,
              packetsLost: C.packetsLost
            };
            d.remoteInboundRtp.set(C.localId, k);
            break;
          }
          case "outbound-rtp": {
            const C = M, k = i || this.outboundProducerMap.get(M.id), H = this.pausedProducerMap.get(k);
            if (H) {
              if (H.lastReportCalculated === true)
                break;
              this.pausedProducerMap.set(k, {
                lastReportCalculated: true
              });
            }
            this.overallProducersStatsMap[k] || (this.overallProducersStatsMap[k] = {
              totalVideoPacketsSent: 0,
              totalAudioPacketsSent: 0
            });
            const Ie = this.overallProducersStatsMap[k];
            if (["video", "audio"].includes(C.mediaType) || ["video", "audio"].includes(C.kind)) {
              if (!this.outboundProducerMap.has(M.id)) {
                d.staleProducerStreamMap = true;
                break;
              }
              const Fe = this.callStatsInstance.producers.get(k);
              if (((b = Fe == null ? undefined : Fe.track) == null ? undefined : b.readyState) === "ended")
                break;
              d.producerStreamMap.has(k) || d.producerStreamMap.set(k, {
                outboundVideoRtpId: [],
                outboundAudioRtpId: []
              });
              const G = {
                bytesSent: C.bytesSent,
                packetsSent: C.packetsSent,
                nackCount: C.nackCount,
                ssrc: C.ssrc,
                mid: C.mid
              };
              if (C.mediaType === "video" || C.kind === "video") {
                if (C.decoderImplementation === "unknown")
                  break;
                const D = C, je = L({
                  frameHeight: D.frameHeight,
                  frameWidth: D.frameWidth,
                  framesEncoded: D.framesEncoded,
                  framesDropped: D.framesDropped,
                  framesPerSecond: D.framesPerSecond,
                  framesSent: D.framesSent,
                  keyFramesEncoded: D.keyFramesEncoded,
                  firCount: D.firCount,
                  encoderImplementation: D.encoderImplementation,
                  hugeFramesSent: D.hugeFramesSent,
                  pliCount: D.pliCount,
                  qpSum: D.qpSum,
                  qualityLimitationDurations: D.qualityLimitationDurations,
                  qualityLimitationReason: D.qualityLimitationReason,
                  qualityLimitationResolutionChanges: D.qualityLimitationResolutionChanges,
                  // temp sending target bitrate in total encode time
                  // to avoid the delay with making the backend changes
                  totalEncodeTime: D.targetBitrate,
                  totalPacketSendDelay: D.totalPacketSendDelay,
                  retransmittedBytesSent: D.retransmittedBytesSent,
                  retransmittedPacketsSent: D.retransmittedPacketsSent
                }, G);
                d.outboundVideoRtp.set(M.id, je), d.producerStreamMap.get(k).outboundVideoRtpId.push(M.id), this.processOutboundProducerVideoStats(k, Ie, je);
              } else if (C.mediaType === "audio" || C.kind === "audio") {
                const D = C, je = L({
                  retransmittedBytesSent: D.retransmittedBytesSent,
                  retransmittedPacketsSent: D.retransmittedPacketsSent
                }, G);
                d.outboundAudioRtp.set(M.id, je), d.producerStreamMap.get(k).outboundAudioRtpId.push(M.id), this.processOutboundProducerAudioStats(k, Ie, je);
              }
            } else
              this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${C.mediaType} kind: ${C.kind}`);
            break;
          }
          case "inbound-rtp": {
            const C = M, k = i || this.inboundConsumerMap.get(M.id), H = this.pausedConsumerMap.get(k);
            if (H) {
              if (H.lastReportCalculated === true)
                break;
              this.pausedConsumerMap.set(k, {
                lastReportCalculated: true
              });
            }
            if (C.ssrc === 1234)
              break;
            this.overallConsumersStatsMap[k] || (this.overallConsumersStatsMap[k] = {
              totalVideoPacketsReceived: 0,
              totalAudioPacketsReceived: 0
            });
            const Ie = this.overallConsumersStatsMap[k];
            if (["video", "audio"].includes(C.mediaType) || ["video", "audio"].includes(C.kind)) {
              if (!this.inboundConsumerMap.has(M.id)) {
                d.staleConsumerStreamMap = true;
                break;
              }
              d.consumerStreamMap.has(k) || d.consumerStreamMap.set(k, {
                inboundVideoRtpId: [],
                inboundAudioRtpId: []
              });
              const Fe = {
                bytesReceived: C.bytesReceived,
                packetsReceived: C.packetsReceived,
                packetsLost: C.packetsLost,
                jitter: C.jitter,
                nackCount: C.nackCount,
                jitterBufferDelay: C.jitterBufferDelay,
                jitterBufferEmittedCount: C.jitterBufferEmittedCount,
                lastPacketReceivedTimestamp: C.lastPacketReceivedTimestamp,
                ssrc: C.ssrc,
                mid: C.mid
              };
              if (C.mediaType === "video" || C.kind === "video") {
                if (C.decoderImplementation === "unknown")
                  break;
                const G = C, D = L({
                  frameHeight: G.frameHeight,
                  frameWidth: G.frameWidth,
                  framesDecoded: G.framesDecoded,
                  framesDropped: G.framesDropped,
                  framesPerSecond: G.framesPerSecond,
                  framesReceived: G.framesReceived,
                  keyFramesDecoded: G.keyFramesDecoded,
                  firCount: G.firCount,
                  decoderImplementation: G.decoderImplementation,
                  pliCount: G.pliCount,
                  totalProcessingDelay: G.totalProcessingDelay
                }, Fe);
                D.score = am({
                  frameWidth: D.frameWidth || 0,
                  framesDecoded: (D.framesDecoded || 0) - (((A = this.videoConsumerToStatsMap.get(k)) == null ? undefined : A.framesDecoded) || 0),
                  framesPerSecond: D.framesPerSecond || 0,
                  packetsLost: (D.packetsLost || 0) - (((I = this.videoConsumerToStatsMap.get(k)) == null ? undefined : I.packetsLost) || 0),
                  packetsReceived: (D.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(k)) == null ? undefined : $.packetsReceived) || 0),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k)
                }), y.set(k, {
                  score: +(D.score * 10).toFixed(),
                  frameWidth: D.frameWidth || 0,
                  frameHeight: D.frameHeight || 0,
                  framesPerSecond: D.framesPerSecond || 0,
                  packetsLostPercentage: Yo({
                    packetsLost: (D.packetsLost || 0) - (((V = this.videoConsumerToStatsMap.get(k)) == null ? undefined : V.packetsLost) || 0),
                    packetsReceived: (D.packetsReceived || 0) - (((O = this.videoConsumerToStatsMap.get(k)) == null ? undefined : O.packetsReceived) || 0)
                  }),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k),
                  bitrate: ((D.bytesReceived || 0) - (((q = this.videoConsumerToStatsMap.get(k)) == null ? undefined : q.bytesReceived) || 0)) * 8 / 7
                  // Bytes received in last 7 seconds
                }), this.videoConsumerToStatsMap.set(k, D), d.inboundVideoRtp.set(M.id, D), d.consumerStreamMap.get(k).inboundVideoRtpId.push(M.id), this.processInboundConsumerVideoStats(k, Ie, D);
              } else if (C.mediaType === "audio" || C.kind === "audio") {
                const G = C, D = L({
                  audioLevel: G.audioLevel,
                  concealedSampels: G.concealedSampels,
                  concealmentEvents: G.concealmentEvents,
                  totalAudioEnergy: G.totalAudioEnergy,
                  totalSamplesDuration: G.totalSamplesDuration,
                  totalSamplesReceived: G.totalSamplesReceived
                }, Fe);
                D.score = im({
                  concealmentEvents: (D.concealmentEvents || 0) - (((B = this.audioConsumerToStatsMap.get(k)) == null ? undefined : B.concealmentEvents) || 0),
                  packetsLost: (D.packetsLost || 0) - (((ne = this.audioConsumerToStatsMap.get(k)) == null ? undefined : ne.packetsLost) || 0),
                  packetsReceived: (D.packetsReceived || 0) - (((Y = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Y.packetsReceived) || 0),
                  jitter: D.jitter || 0
                }), y.set(k, {
                  score: +(D.score * 10).toFixed(),
                  packetsLostPercentage: Yo({
                    packetsLost: (D.packetsLost || 0) - (((we = this.audioConsumerToStatsMap.get(k)) == null ? undefined : we.packetsLost) || 0),
                    packetsReceived: (D.packetsReceived || 0) - (((Pe = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Pe.packetsReceived) || 0)
                  }),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k),
                  bitrate: ((D.bytesReceived || 0) - (((Tt = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Tt.bytesReceived) || 0)) * 8 / 7
                  // Bytes received in last 7 seconds
                }), this.audioConsumerToStatsMap.set(k, D), d.inboundAudioRtp.set(M.id, D), d.consumerStreamMap.get(k).inboundAudioRtpId.push(M.id), this.processInboundConsumerAudioStats(k, Ie, D);
              }
            } else
              this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${C.mediaType} kind: ${C.kind}`);
            break;
          }
        }
      }
      if (d.producerStreamMap.forEach((M, C) => {
        var k, H, Ie, Fe, G, D, je, kr, qi, ji, Gi, Ji, Wi, Ki, zi, Yi, Qi, Xi, Zi, ea, ta, ra, sa;
        if (M.outboundVideoRtpId.length > 0) {
          const _e = [];
          M.outboundVideoRtpId.forEach((ld) => {
            _e.push(d.outboundVideoRtp.get(ld));
          });
          const le = this.getWorkingSimulcastVideoStats(_e);
          le.score = sm$1({
            frameWidth: le.frameWidth || 0,
            framesPerSecond: le.framesPerSecond || 0,
            jitter: ((k = le.remoteData) == null ? undefined : k.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C),
            packetsSent: (le.packetsSent || 0) - (((H = this.videoProducerToStatsMap.get(C)) == null ? undefined : H.packetsSent) || 0),
            packetsLost: (((Ie = le.remoteData) == null ? undefined : Ie.packetsLost) || 0) - (((G = (Fe = this.videoProducerToStatsMap.get(C)) == null ? undefined : Fe.remoteData) == null ? undefined : G.packetsLost) || 0),
            framesEncoded: (le.framesEncoded || 0) - (((D = this.videoProducerToStatsMap.get(C)) == null ? undefined : D.framesEncoded) || 0)
          }), T.set(C, {
            score: +(le.score * 10).toFixed(),
            frameWidth: le.frameWidth || 0,
            frameHeight: le.frameHeight || 0,
            framesPerSecond: le.framesPerSecond || 0,
            jitter: ((je = le.remoteData) == null ? undefined : je.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C),
            packetsLostPercentage: zo({
              packetsSent: (le.packetsSent || 0) - (((kr = this.videoProducerToStatsMap.get(C)) == null ? undefined : kr.packetsSent) || 0),
              packetsLost: (((qi = le.remoteData) == null ? undefined : qi.packetsLost) || 0) - (((Gi = (ji = this.videoProducerToStatsMap.get(C)) == null ? undefined : ji.remoteData) == null ? undefined : Gi.packetsLost) || 0)
            }),
            bitrate: ((le.bytesSent || 0) - (((Ji = this.videoProducerToStatsMap.get(C)) == null ? undefined : Ji.bytesSent) || 0)) * 8 / 7,
            cpuLimitations: le.qualityLimitationReason === "cpu",
            bandwidthLimitations: le.qualityLimitationReason === "bandwidth"
          }), this.videoProducerToStatsMap.set(C, le);
        } else if (M.outboundAudioRtpId.length > 0) {
          const _e = d.outboundAudioRtp.get(M.outboundAudioRtpId[0]);
          _e.score = rm({
            packetsSent: (_e.packetsSent || 0) - (((Wi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Wi.packetsSent) || 0),
            packetsLost: (((Ki = _e.remoteData) == null ? undefined : Ki.packetsLost) || 0) - (((Yi = (zi = this.audioProducerToStatsMap.get(C)) == null ? undefined : zi.remoteData) == null ? undefined : Yi.packetsLost) || 0),
            jitter: ((Qi = _e.remoteData) == null ? undefined : Qi.jitter) || 0
          }), T.set(C, {
            score: +(_e.score * 10).toFixed(),
            bitrate: ((_e.bytesSent || 0) - (((Xi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Xi.bytesSent) || 0)) * 8 / 7,
            packetsLostPercentage: zo({
              packetsSent: (_e.packetsSent || 0) - (((Zi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Zi.packetsSent) || 0),
              packetsLost: (((ea = _e.remoteData) == null ? undefined : ea.packetsLost) || 0) - (((ra = (ta = this.audioProducerToStatsMap.get(C)) == null ? undefined : ta.remoteData) == null ? undefined : ra.packetsLost) || 0)
            }),
            jitter: ((sa = _e.remoteData) == null ? undefined : sa.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C)
          }), this.audioProducerToStatsMap.set(C, _e);
        }
      }), g.forEach((M) => {
        const C = h.find((H) => H.id === M.localCandidateId ? (M.localCandidateId = H.id, H) : null), k = m.find((H) => H.id === M.remoteCandidateId ? (M.remoteCandidateId = H.id, H) : null);
        C && (M.localCandidateType = C.type, M.localCandidateAddress = C.address, M.localCandidatePort = C.port, M.localCandidateProtocol = C.protocol, M.localCandidateUrl = C.url, M.localCandidateNetworkType = C.networkType, M.localCandidateRelatedAddress = C.relatedAddress, M.localCandidateRelatedPort = C.relatedPort), k && (M.remoteCandidateType = k.type, M.remoteCandidateAddress = k.address, M.remoteCandidatePort = k.port, M.remoteCandidateProtocol = k.protocol, M.remoteCandidateUrl = k.url);
      }), d.candidatePair && (d.transport ? (d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
        // candidateStats: result.candidatePair,
        bytesReceived: d.candidatePair.bytesReceived,
        bytesSent: d.candidatePair.bytesSent,
        totalRoundTripTime: d.candidatePair.totalRoundTripTime,
        availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
        roundTripTime: d.candidatePair.currentRoundTripTime
      }), d.transport && (d.transport.candidatePairs = g), d.transport && !d.transport.roundTripTime) {
        let M = 0, C = 0;
        d.remoteInboundRtp.forEach((k, H) => {
          k.roundTripTime && k.roundTripTime > M && (M = k.roundTripTime, C = k.totalRoundTripTime);
        }), d.transport.roundTripTime = M, d.transport.totalRoundTripTime = C;
      }
      if (y.size > 0)
        try {
          this.observer.emit("consumer_score", y);
        } catch (M) {
        }
      if (T.size > 0)
        try {
          this.observer.emit("producer_score", T);
        } catch (M) {
        }
      return d;
    }
    getProducersReport(e) {
      return u(this, null, function* () {
        const r = e.map((n) => this.generateProducerStreamMap(n, true));
        return r.length > 0 ? Promise.all(r) : undefined;
      });
    }
    getConsumersReport(e) {
      return u(this, null, function* () {
        const r = e.map((n) => this.generateConsumerStreamMap(n, true));
        return r.length > 0 ? Promise.all(r) : undefined;
      });
    }
    // eslint-disable-next-line class-methods-use-this
    getTransportReport(e) {
      return u(this, null, function* () {
        return e.getStats();
      });
    }
    getProcessedStats(e, r, n) {
      return u(this, null, function* () {
        const i = yield this.getTransportReport(e), a = { producing: n, consuming: r, id: e.id }, c = i, d = this.parseRTCReport(c, ["transport", "candidate-pair", "inbound-rtp", "outbound-rtp", "remote-inbound-rtp", "local-candidate", "remote-candidate"], false, undefined, a);
        if (!d)
          return;
        const p = {
          stats: d.transport,
          transportId: e.id,
          consuming: r,
          producing: n
        }, h = d.staleProducerStreamMap ? undefined : this.getProducerStatsFromReport(d), m = d.staleConsumerStreamMap ? undefined : this.getConsumerStatsFromReport(d);
        return {
          transportReport: p,
          producerReport: h,
          consumerReport: m
        };
      });
    }
    // eslint-disable-next-line class-methods-use-this
    getProducerStatsFromReport(e) {
      const r = [];
      try {
        e.producerStreamMap.forEach((n, i) => {
          var a, c;
          r.push({
            producerId: i,
            videoStats: n.outboundVideoRtpId.map((d) => e.outboundVideoRtp.get(d)),
            audioStats: n.outboundAudioRtpId.map((d) => e.outboundAudioRtp.get(d)),
            appData: ((c = (a = this.callStatsInstance.producers) == null ? void 0 : a.get(i)) == null ? void 0 : c.appData) || null
          });
        });
      } catch (n) {
        this.callStatsInstance.logger.error("callStats::measurements::getProducerStatsFromReport", {
          error: { reason: n.reason, message: n.message }
        });
      }
      return r;
    }
    getConsumerStatsFromReport(e) {
      const r = [];
      try {
        e.consumerStreamMap.forEach((n, i) => {
          const { peerId: a, producerId: c, appData: d } = this.consumerPeerIdMap.get(i);
          r.push({
            consumerId: i,
            peerId: a,
            producerId: c,
            appData: d,
            videoStats: n.inboundVideoRtpId.map((p) => e.inboundVideoRtp.get(p)),
            audioStats: n.inboundAudioRtpId.map((p) => e.inboundAudioRtp.get(p))
          });
        });
      } catch (n) {
        console.error("getConsumersReport: ", n, e);
      }
      return r;
    }
    // eslint-disable-next-line class-methods-use-this
    getUserLocation() {
      return u(this, null, function* () {
        return new Promise((e, r) => {
          try {
            navigator.geolocation ? navigator.geolocation.getCurrentPosition((n) => {
              e(n);
            }) : r();
          } catch (n) {
            r(n);
          }
        });
      });
    }
    // eslint-disable-next-line class-methods-use-this
    getConnectivity(e) {
      return u(this, null, function* () {
        try {
          const r = {
            iceServers: e || Du
          }, n = new Promise((h, m) => {
            try {
              const g = new Pv(r);
              g.addListener("done", h), g.addListener("failed", () => {
                h({ connectivity: !1 });
              }), g.start(2e3);
            } catch (g) {
              m(g);
            }
          }), i = new Promise((h, m) => {
            try {
              const g = new Rv(r);
              g.addListener("done", h), g.addListener("failed", () => {
                h({ connectivity: !1 });
              }), g.start(2e3);
            } catch (g) {
              m(g);
            }
          }), a = new Promise((h, m) => {
            try {
              const g = new bv(r);
              g.addListener("done", h), g.addListener("failed", () => {
                h({ connectivity: !1 });
              }), g.start(2e3);
            } catch (g) {
              m(g);
            }
          }), [c, d, p] = yield Promise.all([n, i, a]);
          return {
            host: c == null ? void 0 : c.connectivity,
            relay: d == null ? void 0 : d.connectivity,
            reflexive: p == null ? void 0 : p.connectivity
          };
        } catch (r) {
          return {
            host: false,
            relay: false,
            reflexive: false
          };
        }
      });
    }
    // eslint-disable-next-line class-methods-use-this
    getThroughput(e) {
      return u(this, null, function* () {
        try {
          const n = yield new Promise((i, a) => {
            try {
              const c = {
                iceServers: e || Du
              }, d = new wv(c);
              d.addListener("done", i), d.addListener("failed", a), d.start(1e4);
            } catch (c) {
              a(c);
            }
          });
          return {
            throughput: n.throughput,
            fractionalLoss: 0,
            RTT: n.RTT,
            jitter: 0,
            backendRTT: n.backendRTT
          };
        } catch (r) {
          return;
        }
      });
    }
    getIPDetails() {
      return u(this, null, function* () {
        var e, r;
        try {
          return this.ipDetails || (this.ipDetails = yield xl$1.getIPDetails({
            peerId: (e = this.callStatsInstance) == null ? void 0 : e.peerId,
            apiHostnames: (r = this.callStatsInstance) == null ? void 0 : r.apiHostnames,
            logger: this.callStatsInstance.logger
          })), this.ipDetails;
        } catch (n) {
          return;
        }
      });
    }
    getNetworkQuality(e) {
      return u(this, null, function* () {
        const [r, n] = yield Promise.all([
          this.getConnectivity(e),
          this.getThroughput(e)
        ]);
        return {
          connectivity: r,
          throughput: n == null ? undefined : n.throughput,
          fractionalLoss: n == null ? undefined : n.fractionalLoss,
          RTT: n == null ? undefined : n.RTT,
          jitter: n == null ? undefined : n.jitter,
          backendRTT: n == null ? undefined : n.backendRTT
        };
      });
    }
    getNetworkInfo(e, r = false) {
      return u(this, null, function* () {
        var c, d;
        if (r) {
          const p = yield this.getIPDetails();
          return {
            ipDetails: p,
            effectiveNetworkType: (c = navigator.connection) == null ? undefined : c.effectiveType,
            location: p != null && p.loc ? Mu(p == null ? undefined : p.loc) : undefined
            // userLocation,
          };
        }
        const [n, i, a] = yield Promise.all([
          this.getConnectivity(e),
          this.getThroughput(e),
          this.getIPDetails()
        ]);
        return {
          ipDetails: a,
          effectiveNetworkType: (d = navigator.connection) == null ? undefined : d.effectiveType,
          location: a != null && a.loc ? Mu(a == null ? undefined : a.loc) : undefined,
          turnConnectivity: n ? n.host || n.relay || n.reflexive : false,
          connectivity: n,
          throughput: i == null ? undefined : i.throughput,
          fractionalLoss: i == null ? undefined : i.fractionalLoss,
          RTT: i == null ? undefined : i.RTT,
          jitter: i == null ? undefined : i.jitter,
          backendRTT: i == null ? undefined : i.backendRTT
        };
      });
    }
  }
  class Iv extends dm {
  }
  class lm extends dm {
    constructor() {
      super(...arguments);
      f(this, "producerMap", /* @__PURE__ */ new Map());
      f(this, "consumerMap", /* @__PURE__ */ new Map());
    }
    registerProducer(e) {
      return u(this, null, function* () {
        this.producerMap.set(e.id, e), yield this.generateProducerStreamMap(e), e.observer.on("close", this.deregisterProducer.bind(this, e)), e.observer.on("pause", this.pauseProducer.bind(this, e.id)), e.observer.on("resume", this.resumeProducer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareProducers.add(e.id);
      });
    }
    registerConsumer(e) {
      return u(this, null, function* () {
        this.consumerMap.set(e.id, e), yield this.generateConsumerStreamMap(e), this.consumerPeerIdMap.set(e.id, {
          producerId: e.producerId,
          peerId: e.appData.peerId,
          appData: e.appData
        }), e.observer.on("close", this.deregisterConsumer.bind(this, e)), e.observer.on("pause", this.pauseConsumer.bind(this, e.id)), e.observer.on("resume", this.resumeConsumer.bind(this, e.id)), e.appData.screenShare === true && this.screenShareConsumers.add(e.id);
      });
    }
    generateConsumerStreamMap(e, r = false) {
      return u(this, null, function* () {
        const n = yield e.getStats(), i = this.parseRTCReport(n, ["inbound-rtp"], false, e.id), a = [...i.consumerStreamMap.values()][0], c = r ? this.getConsumerStatsFromParsedConsumerStats(i, a, e.id) : undefined;
        for (const d of n.values())
          switch (d.type) {
            case "inbound-rtp": {
              this.inboundConsumerMap.set(d.id, e.id);
              break;
            }
          }
        return c;
      });
    }
    deregisterProducer(e) {
      this.producerMap.delete(e.id), this.outboundProducerMap.forEach((r, n) => {
        r === e.id && this.outboundProducerMap.delete(n);
      }), this.pausedProducerMap.delete(e.id), this.screenShareProducers.delete(e.id);
    }
    deregisterConsumer(e) {
      this.consumerMap.delete(e.id), this.inboundConsumerMap.forEach((r, n) => {
        r === e.id && this.inboundConsumerMap.delete(n);
      }), this.consumerPeerIdMap.delete(e.id), this.pausedConsumerMap.delete(e.id), this.screenShareConsumers.delete(e.id);
    }
    // eslint-disable-next-line class-methods-use-this
    getIceCandidateStats(e) {
      var r;
      return {
        id: e.id,
        type: e.candidateType || e.type,
        address: e.address,
        port: e.port,
        url: e.url,
        protocol: (r = e.relayProtocol) != null ? r : e.protocol,
        networkType: e.networkType,
        relatedAddress: e.relatedAddress,
        relatedPort: e.relatedPort
      };
    }
    parseRTCReport(e, r = [], n = false, i = undefined, a = undefined) {
      var b, A, I, $, V, O, q, B, ne, Y, we, Pe, Tt;
      const c = e, d = new cm(), p = r.length ? new Set(r) : undefined, h = [], m = [], g = [], T = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map();
      for (const M of c.values()) {
        if (p) {
          if (p.size === 0)
            break;
          if (p.has(M.type))
            n && p.delete(M.type);
          else
            continue;
        }
        switch (M.type) {
          case "local-candidate": {
            h.push(this.getIceCandidateStats(M));
            break;
          }
          case "remote-candidate": {
            m.push(this.getIceCandidateStats(M));
            break;
          }
          case "candidate-pair": {
            const { nominated: C } = M, { selected: k } = M, H = M, Ie = {
              nominated: C != null ? C : k,
              currentRoundTripTime: H.currentRoundTripTime,
              totalRoundTripTime: H.totalRoundTripTime,
              bytesReceived: H.bytesReceived,
              bytesSent: H.bytesSent,
              availableOutgoingBitrate: H.availableOutgoingBitrate,
              lastPacketReceivedTimestamp: H.lastPacketReceivedTimestamp,
              lastPacketSentTimestamp: H.lastPacketSentTimestamp,
              localCandidateId: H.localCandidateId,
              remoteCandidateId: H.remoteCandidateId,
              bytesDiscardedOnSend: H.bytesDiscardedOnSend,
              packetsSent: H.packetsSent,
              packetsReceived: H.packetsReceived,
              packetsDiscardedOnSend: H.packetsDiscardedOnSend
            };
            g.push(Ie), (M.nominated === true || M.selected === true) && (d.candidatePair = Ie);
            break;
          }
          case "transport": {
            const C = M;
            a && (a.producing && (this.overallProducingTransportsStatsMap[a.id] || (this.overallProducingTransportsStatsMap[a.id] = {
              totalPacketsSent: 0
            })), a.consuming && (this.overallConsumingTransportsStatsMap[a.id] || (this.overallConsumingTransportsStatsMap[a.id] = {
              totalPacketsReceived: 0
            })));
            const k = {
              bytesReceived: C.bytesReceived,
              bytesSent: C.bytesSent,
              packetsSent: C.packetsSent,
              packetsReceived: C.packetsReceived,
              dtlsCipher: C.dtlsCipher,
              dtlsState: C.dtlsState,
              iceRole: C.iceRole
            };
            if (d.transport = k, a) {
              if (a.producing) {
                const H = this.overallProducingTransportsStatsMap[a.id];
                this.processProducingTransportStats(a.id, H, k);
              }
              if (a.consuming) {
                const H = this.overallConsumingTransportsStatsMap[a.id];
                this.processConsumingTransportStats(a.id, H, k);
              }
            }
            break;
          }
          case "remote-inbound-rtp": {
            const C = M, k = {
              jitter: C.jitter,
              fractionLost: C.fractionLost,
              roundTripTime: C.roundTripTime,
              roundTripTimeMeasurements: C.roundTripTimeMeasurements,
              totalRoundTripTime: C.totalRoundTripTime,
              packetsLost: C.packetsLost
            };
            d.remoteInboundRtp.set(C.localId, k);
            break;
          }
          case "outbound-rtp": {
            const C = M, k = i || this.outboundProducerMap.get(M.id), H = this.pausedProducerMap.get(k);
            if (H) {
              if (H.lastReportCalculated === true)
                break;
              this.pausedProducerMap.set(k, {
                lastReportCalculated: true
              });
            }
            this.overallProducersStatsMap[k] || (this.overallProducersStatsMap[k] = {
              totalVideoPacketsSent: 0,
              totalAudioPacketsSent: 0
            });
            const Ie = this.overallProducersStatsMap[k];
            if (["video", "audio"].includes(C.mediaType) || ["video", "audio"].includes(C.kind)) {
              if (!this.outboundProducerMap.has(M.id)) {
                d.staleProducerStreamMap = true;
                break;
              }
              const Fe = this.callStatsInstance.producers.get(k);
              if (((b = Fe == null ? undefined : Fe.track) == null ? undefined : b.readyState) === "ended")
                break;
              d.producerStreamMap.has(k) || d.producerStreamMap.set(k, {
                outboundVideoRtpId: [],
                outboundAudioRtpId: []
              });
              const G = {
                bytesSent: C.bytesSent,
                packetsSent: C.packetsSent,
                nackCount: C.nackCount,
                ssrc: C.ssrc,
                mid: C.mid
              };
              if (C.mediaType === "video" || C.kind === "video") {
                if (C.decoderImplementation === "unknown")
                  break;
                const D = C, je = L({
                  frameHeight: D.frameHeight,
                  frameWidth: D.frameWidth,
                  framesEncoded: D.framesEncoded,
                  framesDropped: D.framesDropped ? D.framesDropped : D.droppedFrames,
                  framesPerSecond: D.framesPerSecond ? D.framesPerSecond : D.framerateMean,
                  framesSent: D.framesSent,
                  keyFramesEncoded: D.keyFramesEncoded,
                  firCount: D.firCount,
                  encoderImplementation: D.encoderImplementation,
                  hugeFramesSent: D.hugeFramesSent,
                  pliCount: D.pliCount,
                  qpSum: D.qpSum,
                  qualityLimitationReason: D.qualityLimitationReason,
                  qualityLimitationDurations: D.qualityLimitationDurations,
                  qualityLimitationResolutionChanges: D.qualityLimitationResolutionChanges,
                  totalEncodeTime: D.totalEncodeTime,
                  totalPacketSendDelay: D.totalEncodeTime,
                  retransmittedBytesSent: D.retransmittedBytesSent,
                  retransmittedPacketsSent: D.retransmittedPacketsSent
                }, G);
                d.outboundVideoRtp.set(M.id, je), d.producerStreamMap.get(k).outboundVideoRtpId.push(M.id), this.processOutboundProducerVideoStats(k, Ie, je);
              } else if (C.mediaType === "audio" || C.kind === "audio") {
                const D = C, je = L({
                  retransmittedBytesSent: D.retransmittedBytesSent,
                  retransmittedPacketsSent: D.retransmittedPacketsSent
                }, G);
                d.outboundAudioRtp.set(M.id, je), d.producerStreamMap.get(k).outboundAudioRtpId.push(M.id), this.processOutboundProducerAudioStats(k, Ie, je);
              }
            } else
              this.callStatsInstance.logger.error(`Callstats: Unknown Outbound-rtp. mediatype: ${C.mediaType} kind: ${C.kind}`);
            break;
          }
          case "inbound-rtp": {
            const C = M, k = i || this.inboundConsumerMap.get(M.id), H = this.pausedConsumerMap.get(k);
            if (H) {
              if (H.lastReportCalculated === true)
                break;
              this.pausedConsumerMap.set(k, {
                lastReportCalculated: true
              });
            }
            if (C.ssrc === 1234)
              break;
            this.overallConsumersStatsMap[k] || (this.overallConsumersStatsMap[k] = {
              totalVideoPacketsReceived: 0,
              totalAudioPacketsReceived: 0
            });
            const Ie = this.overallConsumersStatsMap[k];
            if (["video", "audio"].includes(C.mediaType) || ["video", "audio"].includes(C.kind)) {
              if (!this.inboundConsumerMap.has(M.id)) {
                d.staleConsumerStreamMap = true;
                break;
              }
              d.consumerStreamMap.has(k) || d.consumerStreamMap.set(k, {
                inboundVideoRtpId: [],
                inboundAudioRtpId: []
              });
              const Fe = {
                bytesReceived: C.bytesReceived,
                packetsReceived: C.packetsReceived,
                packetsLost: C.packetsLost,
                jitter: C.jitter,
                nackCount: C.nackCount,
                jitterBufferDelay: C.jitterBufferDelay,
                jitterBufferEmittedCount: C.jitterBufferEmittedCount,
                lastPacketReceivedTimestamp: C.lastPacketReceivedTimestamp,
                ssrc: C.ssrc,
                mid: C.mid
              };
              if (C.mediaType === "video" || C.kind === "video") {
                if (C.decoderImplementation === "unknown")
                  break;
                const G = C, D = L({
                  frameHeight: G.frameHeight,
                  frameWidth: G.frameWidth,
                  framesDecoded: G.framesDecoded,
                  framesDropped: G.framesDropped ? G.framesDropped : G.droppedFrames,
                  framesPerSecond: G.framesPerSecond ? G.framesPerSecond : G.framerateMean,
                  framesReceived: G.framesReceived,
                  keyFramesDecoded: G.keyFramesDecoded,
                  firCount: G.firCount,
                  decoderImplementation: G.decoderImplementation,
                  pliCount: G.pliCount,
                  totalProcessingDelay: G.totalProcessingDelay
                }, Fe);
                D.score = am({
                  frameWidth: D.frameWidth || 0,
                  framesDecoded: (D.framesDecoded || 0) - (((A = this.videoConsumerToStatsMap.get(k)) == null ? undefined : A.framesDecoded) || 0),
                  framesPerSecond: D.framesPerSecond || 0,
                  packetsLost: (D.packetsLost || 0) - (((I = this.videoConsumerToStatsMap.get(k)) == null ? undefined : I.packetsLost) || 0),
                  packetsReceived: (D.packetsReceived || 0) - ((($ = this.videoConsumerToStatsMap.get(k)) == null ? undefined : $.packetsReceived) || 0),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k)
                }), y.set(k, {
                  score: +(D.score * 10).toFixed(),
                  frameWidth: D.frameWidth || 0,
                  frameHeight: D.frameHeight || 0,
                  framesPerSecond: D.framesPerSecond || 0,
                  packetsLostPercentage: Yo({
                    packetsLost: (D.packetsLost || 0) - (((V = this.videoConsumerToStatsMap.get(k)) == null ? undefined : V.packetsLost) || 0),
                    packetsReceived: (D.packetsReceived || 0) - (((O = this.videoConsumerToStatsMap.get(k)) == null ? undefined : O.packetsReceived) || 0)
                  }),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k),
                  bitrate: ((D.bytesReceived || 0) - (((q = this.videoConsumerToStatsMap.get(k)) == null ? undefined : q.bytesReceived) || 0)) * 8 / 7
                  // Bytes received in last 7 seconds
                }), this.videoConsumerToStatsMap.set(k, D), d.inboundVideoRtp.set(M.id, D), d.consumerStreamMap.get(k).inboundVideoRtpId.push(M.id), this.processInboundConsumerVideoStats(k, Ie, D);
              } else if (C.mediaType === "audio" || C.kind === "audio") {
                const G = C, D = L({
                  audioLevel: G.audioLevel,
                  concealedSampels: G.concealedSampels,
                  concealmentEvents: G.concealmentEvents,
                  totalAudioEnergy: G.totalAudioEnergy,
                  totalSamplesDuration: G.totalSamplesDuration,
                  totalSamplesReceived: G.totalSamplesReceived
                }, Fe);
                D.score = im({
                  concealmentEvents: (D.concealmentEvents || 0) - (((B = this.audioConsumerToStatsMap.get(k)) == null ? undefined : B.concealmentEvents) || 0),
                  packetsLost: (D.packetsLost || 0) - (((ne = this.audioConsumerToStatsMap.get(k)) == null ? undefined : ne.packetsLost) || 0),
                  packetsReceived: (D.packetsReceived || 0) - (((Y = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Y.packetsReceived) || 0),
                  jitter: D.jitter || 0
                }), y.set(k, {
                  score: +(D.score * 10).toFixed(),
                  packetsLostPercentage: Yo({
                    packetsLost: (D.packetsLost || 0) - (((we = this.audioConsumerToStatsMap.get(k)) == null ? undefined : we.packetsLost) || 0),
                    packetsReceived: (D.packetsReceived || 0) - (((Pe = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Pe.packetsReceived) || 0)
                  }),
                  jitter: D.jitter || 0,
                  isScreenShare: this.screenShareConsumers.has(k),
                  bitrate: ((D.bytesReceived || 0) - (((Tt = this.audioConsumerToStatsMap.get(k)) == null ? undefined : Tt.bytesReceived) || 0)) * 8 / 7
                  // Bytes received in last 7 seconds
                }), this.audioConsumerToStatsMap.set(k, D), d.inboundAudioRtp.set(M.id, D), d.consumerStreamMap.get(k).inboundAudioRtpId.push(M.id), this.processInboundConsumerAudioStats(k, Ie, D);
              }
            } else
              this.callStatsInstance.logger.error(`Callstats: Unknown Inbound-rtp. mediatype: ${C.mediaType} kind: ${C.kind}`);
            break;
          }
        }
      }
      if (d.producerStreamMap.forEach((M, C) => {
        var k, H, Ie, Fe, G, D, je, kr, qi, ji, Gi, Ji, Wi, Ki, zi, Yi, Qi, Xi, Zi, ea, ta, ra, sa;
        if (M.outboundVideoRtpId.length > 0) {
          const _e = [];
          M.outboundVideoRtpId.forEach((ld) => {
            _e.push(d.outboundVideoRtp.get(ld));
          });
          const le = this.getWorkingSimulcastVideoStats(_e);
          le.score = sm$1({
            frameWidth: le.frameWidth || 0,
            framesPerSecond: le.framesPerSecond || 0,
            jitter: ((k = le.remoteData) == null ? undefined : k.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C),
            packetsSent: (le.packetsSent || 0) - (((H = this.videoProducerToStatsMap.get(C)) == null ? undefined : H.packetsSent) || 0),
            packetsLost: (((Ie = le.remoteData) == null ? undefined : Ie.packetsLost) || 0) - (((G = (Fe = this.videoProducerToStatsMap.get(C)) == null ? undefined : Fe.remoteData) == null ? undefined : G.packetsLost) || 0),
            framesEncoded: (le.framesEncoded || 0) - (((D = this.videoProducerToStatsMap.get(C)) == null ? undefined : D.framesEncoded) || 0)
          }), T.set(C, {
            score: +(le.score * 10).toFixed(),
            frameWidth: le.frameWidth || 0,
            frameHeight: le.frameHeight || 0,
            framesPerSecond: le.framesPerSecond || 0,
            jitter: ((je = le.remoteData) == null ? undefined : je.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C),
            packetsLostPercentage: zo({
              packetsSent: (le.packetsSent || 0) - (((kr = this.videoProducerToStatsMap.get(C)) == null ? undefined : kr.packetsSent) || 0),
              packetsLost: (((qi = le.remoteData) == null ? undefined : qi.packetsLost) || 0) - (((Gi = (ji = this.videoProducerToStatsMap.get(C)) == null ? undefined : ji.remoteData) == null ? undefined : Gi.packetsLost) || 0)
            }),
            bitrate: ((le.bytesSent || 0) - (((Ji = this.videoProducerToStatsMap.get(C)) == null ? undefined : Ji.bytesSent) || 0)) * 8 / 7,
            cpuLimitations: le.qualityLimitationReason === "cpu",
            bandwidthLimitations: le.qualityLimitationReason === "bandwidth"
          }), this.videoProducerToStatsMap.set(C, le);
        } else if (M.outboundAudioRtpId.length > 0) {
          const _e = d.outboundAudioRtp.get(M.outboundAudioRtpId[0]);
          _e.score = rm({
            packetsSent: (_e.packetsSent || 0) - (((Wi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Wi.packetsSent) || 0),
            packetsLost: (((Ki = _e.remoteData) == null ? undefined : Ki.packetsLost) || 0) - (((Yi = (zi = this.audioProducerToStatsMap.get(C)) == null ? undefined : zi.remoteData) == null ? undefined : Yi.packetsLost) || 0),
            jitter: ((Qi = _e.remoteData) == null ? undefined : Qi.jitter) || 0
          }), T.set(C, {
            score: +(_e.score * 10).toFixed(),
            bitrate: ((_e.bytesSent || 0) - (((Xi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Xi.bytesSent) || 0)) * 8 / 7,
            packetsLostPercentage: zo({
              packetsSent: (_e.packetsSent || 0) - (((Zi = this.audioProducerToStatsMap.get(C)) == null ? undefined : Zi.packetsSent) || 0),
              packetsLost: (((ea = _e.remoteData) == null ? undefined : ea.packetsLost) || 0) - (((ra = (ta = this.audioProducerToStatsMap.get(C)) == null ? undefined : ta.remoteData) == null ? undefined : ra.packetsLost) || 0)
            }),
            jitter: ((sa = _e.remoteData) == null ? undefined : sa.jitter) || 0,
            isScreenShare: this.screenShareProducers.has(C)
          }), this.audioProducerToStatsMap.set(C, _e);
        }
      }), g.forEach((M) => {
        const C = h.find((H) => H.id === M.localCandidateId ? (M.localCandidateId = H.id, H) : null), k = m.find((H) => H.id === M.remoteCandidateId ? (M.remoteCandidateId = H.id, H) : null);
        C && (M.localCandidateType = C.type, M.localCandidateAddress = C.address, M.localCandidatePort = C.port, M.localCandidateProtocol = C.protocol, M.localCandidateUrl = C.url, M.localCandidateNetworkType = C.networkType, M.localCandidateRelatedAddress = C.relatedAddress, M.localCandidateRelatedPort = C.relatedPort), k && (M.remoteCandidateType = k.type, M.remoteCandidateAddress = k.address, M.remoteCandidatePort = k.port, M.remoteCandidateProtocol = k.protocol, M.remoteCandidateUrl = k.url);
      }), d.candidatePair && (d.transport ? (d.transport.bytesReceived = d.candidatePair.bytesReceived, d.transport.bytesSent = d.candidatePair.bytesSent, d.transport.totalRoundTripTime = d.candidatePair.totalRoundTripTime, d.transport.availableOutgoingBitrate = d.candidatePair.availableOutgoingBitrate, d.transport.roundTripTime = d.candidatePair.currentRoundTripTime) : d.transport = {
        // candidateStats: result.candidatePair,
        bytesReceived: d.candidatePair.bytesReceived,
        bytesSent: d.candidatePair.bytesSent,
        totalRoundTripTime: d.candidatePair.totalRoundTripTime,
        availableOutgoingBitrate: d.candidatePair.availableOutgoingBitrate,
        roundTripTime: d.candidatePair.currentRoundTripTime
      }), d.transport && (d.transport.candidatePairs = g), d.transport && !d.transport.roundTripTime) {
        let M = 0, C = 0;
        d.remoteInboundRtp.forEach((k, H) => {
          k.roundTripTime && k.roundTripTime > M && (M = k.roundTripTime, C = k.totalRoundTripTime);
        }), d.transport.roundTripTime = M, d.transport.totalRoundTripTime = C;
      }
      if (y.size > 0)
        try {
          this.observer.emit("consumer_score", y);
        } catch (M) {
        }
      if (T.size > 0)
        try {
          this.observer.emit("producer_score", T);
        } catch (M) {
        }
      return d;
    }
    getProducerStatsFromReport(e) {
      const r = [];
      try {
        e.producerStreamMap.forEach((n, i) => {
          const a = this.producerMap.get(i), c = a.track.getSettings(), d = n.outboundVideoRtpId.map((h) => {
            const m = e.outboundVideoRtp.get(h);
            return m.frameHeight || (m.frameHeight = c.height, m.frameWidth = c.width, m.framesPerSecond = c.frameRate), m;
          }), p = {
            producerId: i,
            appData: a.appData,
            videoStats: d,
            audioStats: n.outboundAudioRtpId.map((h) => e.outboundAudioRtp.get(h))
          };
          r.push(p);
        });
      } catch (n) {
        console.error("getProducersReport: ", n, e);
      }
      return r;
    }
    getConsumerStatsFromParsedConsumerStats(e, r, n) {
      let i;
      try {
        const { peerId: a, producerId: c, appData: d } = this.consumerPeerIdMap.get(n), p = r == null ? void 0 : r.inboundVideoRtpId.map((h) => {
          const g = this.consumerMap.get(n).track.getSettings(), T = e.inboundVideoRtp.get(h);
          return T.frameHeight || (T.frameHeight = g.height, T.frameWidth = g.width, T.framesPerSecond = g.frameRate), T;
        });
        i = {
          consumerId: n,
          peerId: a,
          producerId: c,
          appData: d,
          videoStats: p,
          audioStats: r == null ? void 0 : r.inboundAudioRtpId.map((h) => e.inboundAudioRtp.get(h))
        };
      } catch (a) {
        console.error("getConsumerStatsFromParsedConsumerStats: ", a, e);
      }
      return i;
    }
    getConsumerStatsFromReport(e) {
      const r = [];
      try {
        e.consumerStreamMap.forEach((n, i) => {
          r.push(this.getConsumerStatsFromParsedConsumerStats(e, n, i));
        });
      } catch (n) {
        console.error("getConsumerStatsFromReport: ", n, e);
      }
      return r;
    }
  }
  class Av extends lm {
  }
  function Qo(s, t, e, r) {
    if (s != null && s.logger && s.logger.error("Callstats::handleError", { error: r }), typeof e == "function" && r instanceof t)
      e.call(null, r, s);
    else
      throw r;
  }
  function Ou(s, t, e) {
    const r = s.value;
    return s.value = function(...n) {
      try {
        const i = r.apply(this, n);
        return i && i instanceof Promise ? i.catch((a) => {
          Qo(this, t, e, a);
        }) : i;
      } catch (i) {
        Qo(this, t, e, i);
      }
      return null;
    }, s;
  }
  const se = (s, t) => (e, r, n) => {
    const i = n.value;
    return n.value = function(...a) {
      try {
        const c = i.apply(this, a);
        return c && c instanceof Promise ? c.catch((d) => {
          Qo(this, s, t, d);
        }) : c;
      } catch (c) {
        Qo(this, s, t, c);
      }
      return null;
    }, n;
  }, Dv = (s, t) => (e, r, n) => {
    if (n)
      return Ou(n, s, t);
    for (const i of Reflect.ownKeys(e.prototype).filter((a) => a !== "constructor")) {
      const a = Object.getOwnPropertyDescriptor(e.prototype, i);
      a.value instanceof Function && Object.defineProperty(e.prototype, i, Ou(a, s, t));
    }
  };
  var ee = globalThis && globalThis.__decorate || function(s, t, e, r) {
    var n = arguments.length, i = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, a;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      i = Reflect.decorate(s, t, e, r);
    else
      for (var c = s.length - 1; c >= 0; c--)
        (a = s[c]) && (i = (n < 3 ? a(i) : n > 3 ? a(t, e, i) : a(t, e)) || i);
    return n > 3 && i && Object.defineProperty(t, e, i), i;
  };
  const te = console;
  let Z = class extends at {
    constructor(e = "https://api.testingv3.dyte.in", r = "Blink", n = fa.PROD, i, a, c, d) {
      super();
      f(this, "observer");
      f(this, "eventHandler");
      f(this, "measurements");
      f(this, "producingTransport");
      f(this, "consumingTransport");
      f(this, "producers", /* @__PURE__ */ new Map());
      f(this, "consumers", /* @__PURE__ */ new Map());
      f(this, "iceServers");
      f(this, "connectionInfoPromise");
      f(this, "pingStatsTimeout");
      f(this, "logger");
      f(this, "env");
      f(this, "apiHostnames");
      f(this, "peerId");
      f(this, "consumerSharedMediaStatesMap", /* @__PURE__ */ new Map());
      f(this, "currentUserMediaStates", {});
      switch (this.env = n, this.apiHostnames = d, this.logger = a, this.peerId = c, this.eventHandler = new fv({ logger: a, peerId: c, apiHostnames: d }), this.logger.debug("callStats::engineName: ", { engineName: r }), r) {
        case "Blink":
          this.measurements = new Iv();
          break;
        case "Gecko":
          this.measurements = new lm();
          break;
        case "WebKit":
          this.measurements = new Av();
          break;
        default:
          throw Error(`Unknown engineName! ${r}`);
      }
      this.measurements.callStatsInstance = this, this.registerProducer = this.registerProducer.bind(this), this.registerConsumer = this.registerConsumer.bind(this), this.observer = new at(), this.measurements.observer.on("consumer_score", (p) => {
        a.debug(`callStats::consumer_score ${[...p.entries()]}`), this.eventHandler.emit("consumer_score", p);
      }), this.measurements.observer.on("producer_score", (p) => {
        a.debug(`callStats::producer_score ${[...p.entries()]}`), this.eventHandler.emit("producer_score", p);
      });
    }
    registerIceServers(e) {
      this.iceServers = e;
    }
    registerConsumer(e) {
      var r;
      this.consumerSharedMediaStatesMap.has(e.id) || this.consumerSharedMediaStatesMap.set(e.id, {}), this.consumers.set(e.id, e), this.measurements.registerConsumer(e), this.logger.debug("callStats::registerConsumer", { consumerId: e.id, consumerkind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.observer.on("close", this.deRegisterConsumer.bind(this, e));
    }
    registerProducer(e) {
      var r;
      this.producers.set(e.id, e), this.measurements.registerProducer(e), this.logger.debug("callStats::registerProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) }), e.observer.on("close", this.deRegisterProducer.bind(this, e));
    }
    sendConsumerSharedMediaStateEvent(e, r) {
      this.consumerSharedMediaStatesMap.has(e) || this.consumerSharedMediaStatesMap.set(e, {});
      const n = this.consumerSharedMediaStatesMap.get(e);
      this.consumerSharedMediaStatesMap.set(e, Object.assign(n, r));
    }
    registerProducingTransport(e) {
      var n;
      this.producingTransport = e, e.observer.on("close", this.disconnectProducingTransport.bind(this, e)), e.observer.on("disconnect", this.disconnectProducingTransport.bind(this, e)), Array.from(
        // eslint-disable-next-line no-underscore-dangle
        ((n = e._producers) == null ? undefined : n.values()) || []
      ).forEach((i) => {
        this.registerProducer(i);
      }), e.observer.on("newproducer", this.registerProducer);
    }
    registerConsumingTransport(e) {
      var n;
      this.consumingTransport = e, e.observer.on("close", this.disconnectConsumingTransport.bind(this, e)), e.observer.on("disconnect", this.disconnectConsumingTransport.bind(this, e)), Array.from(
        // eslint-disable-next-line no-underscore-dangle
        ((n = e._consumers) == null ? undefined : n.values()) || []
      ).forEach((i) => {
        this.registerConsumer(i);
      }), e.observer.on("newconsumer", this.registerConsumer);
    }
    deRegisterConsumer(e) {
      this.consumers.delete(e.id);
    }
    deRegisterProducer(e) {
      var r;
      this.producers.delete(e.id), this.logger.debug("callStats::deRegisterProducer", { producerId: e.id, producerKind: e.kind, isScreenShare: !!((r = e.appData) != null && r.screenShare) });
    }
    disconnectConsumingTransport() {
      this.consumingTransport = undefined;
    }
    disconnectProducingTransport() {
      this.producingTransport = undefined;
    }
    callEvent(e) {
      this.eventHandler.callEvent(e);
    }
    sendPreCallTestBeginEvent(e = false) {
      this.connectionInfoPromise = this.measurements.getNetworkInfo(this.iceServers, e), this.eventHandler.callEvent({
        event: x.PRECALL_TEST_BEGIN,
        timestamp: new Date()
      }), this.connectionInfoPromise && this.connectionInfoPromise.then((r) => {
        this.eventHandler.callEvent({
          event: x.PRECALL_TEST_COMPLETE,
          metaData: {
            connectionInfo: r
          },
          timestamp: new Date()
        });
      });
    }
    sendScreenShareToggleEvent(e, r) {
      this.currentUserMediaStates.screen = e, this.eventHandler.callEvent({
        event: e ? x.SCREENSHARE_STARTED : x.SCREENSHARE_STOPPED,
        metaData: {
          ssrc: r
        },
        timestamp: new Date()
      });
    }
    sendScreenShareRequestedEvent() {
      this.eventHandler.callEvent({
        event: x.SCREENSHARE_START_REQUESTED,
        timestamp: new Date()
      });
    }
    sendActiveSpeakerEvent(e) {
      this.eventHandler.callEvent({
        event: x.DOMINANT_SPEAKER,
        metaData: {
          peerId: e
        },
        timestamp: new Date()
      });
    }
    devices(e, r) {
      this.eventHandler.callEvent({
        event: e === qt.AUDIO && x.AUDIO_DEVICES_UPDATES || e === qt.VIDEO && x.VIDEO_DEVICES_UPDATES || e === qt.SPEAKER && x.SPEAKER_DEVICES_UPDATES,
        metaData: {
          deviceList: r
        },
        timestamp: new Date()
      });
    }
    selectedDevice(e, r) {
      this.eventHandler.callEvent({
        event: e === qt.AUDIO && x.SELECTED_MICROHPONE_UPDATE || e === qt.VIDEO && x.SELECTED_CAMERA_UPDATE || e === qt.SPEAKER && x.SELECTED_SPEAKER_UPDATE,
        metaData: {
          device: r
        },
        timestamp: new Date()
      });
    }
    mediaPermission(e, r) {
      this.eventHandler.callEvent({
        event: x.MEDIA_PERMISSION,
        metaData: {
          deviceType: e,
          permission: r
        },
        timestamp: new Date()
      });
    }
    mediaPlaybackFailed(e) {
      this.eventHandler.callEvent({
        event: e === qt.AUDIO && x.AUDIO_PLAY_FAILED || e === qt.VIDEO && x.VIDEO_PLAY_FAILED,
        metaData: {
          deviceType: e
        },
        timestamp: new Date()
      });
    }
    mediaTrackMuted(e) {
      this.eventHandler.callEvent({
        event: e === qt.AUDIO && x.AUDIO_TRACK_MUTED || e === qt.VIDEO && x.VIDEO_TRACK_MUTED,
        metaData: {
          deviceType: e
        },
        timestamp: new Date()
      });
    }
    tabChanged(e) {
      this.eventHandler.callEvent({
        event: x.TAB_CHANGE,
        metaData: { isMeetingsTabActive: e },
        timestamp: new Date()
      });
    }
    browserBackgrounded() {
      this.eventHandler.callEvent({
        event: x.BROWSER_BACKGROUNDED,
        timestamp: new Date()
      });
    }
    browserForegrounded() {
      this.eventHandler.callEvent({
        event: x.BROWSER_FOREGROUNDED,
        timestamp: new Date()
      });
    }
    legacySwitch(e) {
      this.eventHandler.callEvent({
        event: x.LEGACY_SWITCH,
        metadata: { on: e },
        timestamp: new Date()
      });
    }
    getPreCallTestResults() {
      return u(this, null, function* () {
        return this.connectionInfoPromise;
      });
    }
    sendCallJoinBeginEvent(e) {
      e = z(L({}, e), {
        meetingEnv: this.env
      }), e.deviceInfo = z(L({}, e.deviceInfo), {
        userAgent: navigator.userAgent,
        cpus: navigator.hardwareConcurrency,
        memory: navigator.deviceMemory
      }), this.eventHandler.callEvent({
        event: x.CALL_JOIN_BEGIN,
        metaData: {
          peerMetaData: e
        },
        timestamp: new Date()
      });
    }
    sendNetworkQualityTestBeginEvent(e) {
      this.eventHandler.callEvent({
        event: x.NET_QUALITY_TEST_BEGIN,
        timestamp: new Date()
      }), new Promise((n, i) => u(this, null, function* () {
        const a = [];
        try {
          for (const c of e)
            try {
              if (c.iceServers && c.iceServers.length > 0) {
                const d = yield this.measurements.getNetworkQuality(c.iceServers);
                a.push(z(L({}, c), {
                  networkResults: d
                }));
              }
            } catch (d) {
              console.warn("Error handling ", d);
            }
          n({
            regionData: a
          });
        } catch (c) {
          console.warn("Error in callstats, ", c), i(c);
        }
      })).then((n) => {
        this.eventHandler.callEvent({
          event: x.NET_QUALITY_TEST_END,
          timestamp: new Date(),
          metaData: n
        });
      });
    }
    sendWebSocketConnectedEvent() {
      this.eventHandler.callEvent({
        event: x.WEBSOCKET_CONNECTED,
        timestamp: new Date()
      });
    }
    sendTransportConnectedEvent() {
      this.eventHandler.callEvent({
        event: x.TRANSPORT_CONNECTED,
        timestamp: new Date()
      });
    }
    sendAudioToggleEvent(e) {
      this.currentUserMediaStates.audio = e;
      let r;
      e ? r = x.AUDIO_ON : r = x.AUDIO_OFF, this.eventHandler.callEvent({
        event: r,
        timestamp: new Date()
      });
    }
    sendVideoToggleEvent(e) {
      this.currentUserMediaStates.video = e;
      let r;
      e ? r = x.VIDEO_ON : r = x.VIDEO_OFF, this.eventHandler.callEvent({
        event: r,
        timestamp: new Date()
      });
    }
    sendParticipantRoleToggleEvent(e) {
      this.eventHandler.callEvent({
        event: x.PARTICIPANT_ROLE,
        timestamp: new Date(),
        metaData: e
      });
    }
    startPingStats(e = 7e3) {
      this.sendPingStatsEvent(false), this.pingStatsTimeout = setInterval(this.sendPingStatsEvent.bind(this), e);
    }
    stopPingStats() {
      clearInterval(this.pingStatsTimeout);
    }
    sendPingStatsEvent(e = true) {
      return u(this, null, function* () {
        let r, n;
        if (this.producingTransport && (r = yield this.measurements.getProcessedStats(this.producingTransport, false, true), !r || !(r != null && r.producerReport))) {
          this.logger.debug("callStats::sendPingStatsEvent::staleProducingTransport", { disclaimer: "Stale producer? Regenerating Stream Maps!" });
          const a = yield this.measurements.getProducersReport([...this.producers.values()]);
          r && a ? r.producerReport = a : (r = yield this.measurements.getProcessedStats(this.producingTransport, false, true), (!r || !(r != null && r.producerReport)) && this.logger.debug("callStats::sendPingStatsEvent::noProducingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
        }
        if (this.consumingTransport && (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), !n || !n.consumerReport)) {
          this.logger.debug("callStats::sendPingStatsEvent::staleConsumingTransport", { disclaimer: "Stale consumer? Regenerating Stream Maps!" });
          const a = yield this.measurements.getConsumersReport([...this.consumers.values()]);
          n && a ? n.consumerReport = a : (n = yield this.measurements.getProcessedStats(this.consumingTransport, true, false), (!n || !n.consumerReport) && this.logger.debug("callStats::sendPingStatsEvent::noConsumingTransportReport", { disclaimer: "Stream maps invalid despite regenerating!" }));
        }
        const i = {
          producingTransportStats: r ? r == null ? undefined : r.transportReport : undefined,
          consumingTransportStats: n ? n == null ? undefined : n.transportReport : undefined,
          producerStats: [].concat((r == null ? undefined : r.producerReport) || []).concat((n == null ? undefined : n.producerReport) || []),
          consumerStats: [].concat((n == null ? undefined : n.consumerReport) || []).concat((r == null ? undefined : r.consumerReport) || [])
        };
        if (e && i.producerStats.length === 0 && i.consumerStats.length === 0) {
          yield this.eventHandler.flush();
          return;
        }
        this.eventHandler.callEvent({
          event: x.PING_STAT,
          metaData: i,
          timestamp: new Date()
        });
      });
    }
    sendIVSPlayerRebufferEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_REBUFFERING,
        timestamp: new Date()
      });
    }
    sendIVSPlayerAudioBlockEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_AUDIO_BLOCKED,
        timestamp: new Date()
      });
    }
    sendIVSPlayerPlaybackBlockedEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_PLAYBACK_BLOCKED,
        timestamp: new Date()
      });
    }
    sendIVSPlayerNetworkUnavailableEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_NETWORK_UNAVAILABLE,
        timestamp: new Date()
      });
    }
    sendIVSPlayerInitializedEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_INITIALIZED,
        timestamp: new Date()
      });
    }
    sendIVSPlayerWorkerErrorEvent() {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_WORKER_ERROR,
        timestamp: new Date()
      });
    }
    sendIVSPlayerErrorEvent(e) {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_ERROR,
        timestamp: new Date(),
        metaData: e
      });
    }
    sendIVSPlayerRecoverableErrorEvent(e) {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_RECOVERABLE_ERROR,
        timestamp: new Date(),
        metaData: e
      });
    }
    sendIVSPlayerAnalyticsEvent(e) {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_ANALYTICS_EVENT,
        timestamp: new Date(),
        metaData: e
      });
    }
    sendIVSPlayerPlaybackRateChangedEvent(e) {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_PLAYBACK_RATE_CHANGED,
        timestamp: new Date(),
        metaData: {
          updatedPlaybackRate: e
        }
      });
    }
    sendIVSPlayerQualityChanged(e) {
      this.eventHandler.callEvent({
        event: x.IVS_PLAYER_QUALITY_CHANGED,
        timestamp: new Date(),
        metaData: e
      });
    }
    sendPlayerLiveLatency(e) {
      this.eventHandler.callEvent({
        event: x.LIVESTREAM_LATENCY,
        timestamp: new Date(),
        metaData: {
          latency: e
        }
      });
    }
    sendDisconnectEvent() {
      this.eventHandler.callEvent({
        event: x.DISCONNECT,
        timestamp: new Date()
      });
    }
    sendReconnectEvent() {
      this.eventHandler.callEvent({
        event: x.RECONNECT_ATTEMPT,
        timestamp: new Date()
      });
    }
  };
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "registerIceServers", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "registerConsumer", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "registerProducer", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendConsumerSharedMediaStateEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "registerProducingTransport", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "registerConsumingTransport", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "deRegisterConsumer", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "deRegisterProducer", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "disconnectConsumingTransport", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "disconnectProducingTransport", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendPreCallTestBeginEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendScreenShareToggleEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendScreenShareRequestedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendActiveSpeakerEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "devices", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "selectedDevice", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "mediaPermission", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "mediaPlaybackFailed", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "mediaTrackMuted", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "tabChanged", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "browserBackgrounded", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "browserForegrounded", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "legacySwitch", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "getPreCallTestResults", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendCallJoinBeginEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendNetworkQualityTestBeginEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendWebSocketConnectedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendTransportConnectedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendAudioToggleEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendVideoToggleEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendParticipantRoleToggleEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "startPingStats", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "stopPingStats", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendPingStatsEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerRebufferEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerAudioBlockEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerPlaybackBlockedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerNetworkUnavailableEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerInitializedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerWorkerErrorEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerErrorEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerRecoverableErrorEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerAnalyticsEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerPlaybackRateChangedEvent", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendIVSPlayerQualityChanged", null);
  ee([
    se(TypeError, (s, t) => te.error(t, s))
  ], Z.prototype, "sendPlayerLiveLatency", null);
  Z = ee([
    Dv(TypeError, (s, t) => te.error(t, s))
  ], Z);
  const Mv = Z;
  class Ov extends at {
    constructor() {
      super(...arguments);
      f(this, "stats");
      f(this, "roomURL");
      f(this, "peerId");
      f(this, "backend");
      f(this, "iceServers");
      f(this, "initialized", false);
      f(this, "stalled", false);
      // Initialization will never occur
      f(this, "ipInformation");
      f(this, "logger");
    }
    initialize(m) {
      return u(this, arguments, function* ({ peerId: e, engineName: r, env: n = fa.PROD, iceServers: i, apiBase: a = "https://api.cluster.dyte.in", flags: c, logger: d = console, apiHostnames: p, skipConnectivityChecks: h = false }) {
        var g, T, y;
        try {
          this.peerId = e, this.logger = d, this.ipInformation = yield xl$1.getIPDetails({ peerId: e, apiHostnames: p, logger: d }), this.backend = new Mv(a, r, n, c, d, e, p), this.iceServers = i, (g = this.backend) == null || g.registerIceServers(this.iceServers), this.initialized = !0, (y = (T = this.backend) == null ? void 0 : T.eventHandler) == null || y.emit("initialized", this.ipInformation), this.emit("initialized", this.ipInformation), this.startPreCallTest(h);
        } catch (b) {
          this.logger.error("callStats::CallStatsIntegration: ", { error: b }), this.stallCallStats();
        }
      });
    }
    setRoomName(e) {
      this.roomURL = e;
    }
    configureSendTransport(e) {
      var r;
      (r = this.backend) == null || r.registerProducingTransport(e);
    }
    configureRecvTransport(e) {
      var r;
      (r = this.backend) == null || r.registerConsumingTransport(e);
    }
    candidateRegionalNetworkQualityTest(e) {
      return u(this, null, function* () {
        var r;
        try {
          (r = this.backend) == null || r.sendNetworkQualityTestBeginEvent(e);
        } catch (n) {
          this.logger.error("callStats::sendNetworkQualityTestBeginEvent", { error: { reason: n.reason } });
        }
      });
    }
    roomJoined(e) {
      return u(this, null, function* () {
        var r, n;
        (r = this.backend) == null || r.sendCallJoinBeginEvent(e), this.backend, (n = this.backend) == null || n.startPingStats();
      });
    }
    audioOff() {
      var e;
      (e = this.backend) == null || e.sendAudioToggleEvent(false);
    }
    audioOn() {
      var e;
      (e = this.backend) == null || e.sendAudioToggleEvent(true);
    }
    videoOff() {
      var e;
      (e = this.backend) == null || e.sendVideoToggleEvent(false);
    }
    videoOn() {
      var e;
      (e = this.backend) == null || e.sendVideoToggleEvent(true);
    }
    callEnded() {
      var e, r;
      (e = this.backend) == null || e.stopPingStats(), (r = this.backend) == null || r.sendDisconnectEvent();
    }
    screenShareStart(e) {
      var r;
      (r = this.backend) == null || r.sendScreenShareToggleEvent(true, e);
    }
    consumerSharedMediaState(e, r) {
      var n;
      (n = this.backend) == null || n.sendConsumerSharedMediaStateEvent(e, r);
    }
    screenShareStop(e) {
      var r;
      (r = this.backend) == null || r.sendScreenShareToggleEvent(false, e);
    }
    screenShareRequested() {
      var e;
      (e = this.backend) == null || e.sendScreenShareRequestedEvent();
    }
    activeSpeaker(e) {
      var r;
      e === this.peerId && ((r = this.backend) == null || r.sendActiveSpeakerEvent(e));
    }
    devices(e, r) {
      var n;
      (n = this.backend) == null || n.devices(e, r);
    }
    selectedDevice(e, r) {
      var n;
      (n = this.backend) == null || n.selectedDevice(e, r);
    }
    mediaPermission(e, r) {
      var n;
      (n = this.backend) == null || n.mediaPermission(e, r);
    }
    mediaPlaybackFailed(e) {
      var r;
      (r = this.backend) == null || r.mediaPlaybackFailed(e);
    }
    mediaTrackMuted(e) {
      var r;
      (r = this.backend) == null || r.mediaTrackMuted(e);
    }
    tabChanged(e = false) {
      var r;
      (r = this.backend) == null || r.tabChanged(e);
    }
    browserBackgrounded() {
      var e;
      (e = this.backend) == null || e.browserBackgrounded();
    }
    browserForegrounded() {
      var e;
      (e = this.backend) == null || e.browserForegrounded();
    }
    legacySwitch(e) {
      var r;
      (r = this.backend) == null || r.legacySwitch(e);
    }
    startPreCallTest(e = false) {
      return u(this, null, function* () {
        var r;
        (r = this.backend) == null || r.sendPreCallTestBeginEvent(e);
      });
    }
    onPreCallTestResults(e) {
      var r;
      return (r = this.backend) == null || r.eventHandler.once("precall_end", e), e;
    }
    onReceivingConsumerAudioStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_audio_status", e);
    }
    onReceivingConsumerVideoStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_video_status", e);
    }
    onReceivingProducerAudioStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_audio_status", e);
    }
    onReceivingProducerVideoStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_video_status", e);
    }
    onReceivingProducingTransportStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producing_transport_status", e);
    }
    onReceivingConsumingTransportStatus(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consuming_transport_status", e);
    }
    onProducerScore(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("producer_score", e);
    }
    onConsumerScore(e) {
      var r;
      (r = this.backend) == null || r.eventHandler.on("consumer_score", e);
    }
    onSafeInitialization(e) {
      if (this.initialized)
        e(this.ipInformation, false);
      else if (!this.stalled) {
        const r = (n) => {
          e(n, true);
        };
        return this.once("initialized", r), r;
      }
      return () => {
      };
    }
    removeInitializationListener(e) {
      this.removeListener("initialized", e);
    }
    stallCallStats() {
      this.stalled = true, this.removeAllListeners("initialized");
    }
    ivsPlayerEvent(e, r) {
      var n, i, a, c, d, p, h, m, g, T, y;
      switch (e) {
        case "PlayerRebuffering":
          (n = this.backend) == null || n.sendIVSPlayerRebufferEvent();
          break;
        case "PlayerAudioBlocked":
          (i = this.backend) == null || i.sendIVSPlayerAudioBlockEvent();
          break;
        case "PlayerPlaybackBlocked":
          (a = this.backend) == null || a.sendIVSPlayerPlaybackBlockedEvent();
          break;
        case "PlayerNetworkUnavailable":
          (c = this.backend) == null || c.sendIVSPlayerNetworkUnavailableEvent();
          break;
        case "PlayerInitialized":
          (d = this.backend) == null || d.sendIVSPlayerInitializedEvent();
          break;
        case "PlayerWorkerError":
          (p = this.backend) == null || p.sendIVSPlayerWorkerErrorEvent();
          break;
        case "PlayerError":
          (h = this.backend) == null || h.sendIVSPlayerErrorEvent(r);
          break;
        case "PlayerRecoverableError":
          (m = this.backend) == null || m.sendIVSPlayerRecoverableErrorEvent(r);
          break;
        case "PlayerAnalyticsEvent":
          (g = this.backend) == null || g.sendIVSPlayerAnalyticsEvent(r);
          break;
        case "PlayerPlaybackRateChanged":
          (T = this.backend) == null || T.sendIVSPlayerPlaybackRateChangedEvent(r);
          break;
        case "PlayerQualityChanged":
          (y = this.backend) == null || y.sendIVSPlayerQualityChanged(r);
          break;
      }
    }
    livestreamLatency(e) {
      var r;
      (r = this.backend) == null || r.sendPlayerLiveLatency(e);
    }
  }
  const U = new Ov();
  U.setMaxListeners(30);
  function Nv(s) {
    const { length: t } = this, e = s >= 0 ? s : t + s;
    return e < 0 || e >= t ? undefined : this[e];
  }
  Array.prototype.at || Object.assign(Array.prototype, { at: Nv });
  function Lv(s) {
    const { length: t } = this, e = s >= 0 ? s : t + s;
    return e < 0 || e >= t ? undefined : this[e];
  }
  String.prototype.at || Object.assign(String.prototype, { at: Lv });
  var Yd = {}, xv = {
    get exports() {
      return Yd;
    },
    set exports(s) {
      Yd = s;
    }
  }, Xo = {}, $v = {
    get exports() {
      return Xo;
    },
    set exports(s) {
      Xo = s;
    }
  }, um = function(t, e) {
    return function() {
      for (var n = new Array(arguments.length), i = 0; i < n.length; i++)
        n[i] = arguments[i];
      return t.apply(e, n);
    };
  }, Uv = um, Ls = Object.prototype.toString;
  function $l(s) {
    return Array.isArray(s);
  }
  function Qd(s) {
    return typeof s == "undefined";
  }
  function Fv(s) {
    return s !== null && !Qd(s) && s.constructor !== null && !Qd(s.constructor) && typeof s.constructor.isBuffer == "function" && s.constructor.isBuffer(s);
  }
  function pm(s) {
    return Ls.call(s) === "[object ArrayBuffer]";
  }
  function Vv(s) {
    return Ls.call(s) === "[object FormData]";
  }
  function Hv(s) {
    var t;
    return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? t = ArrayBuffer.isView(s) : t = s && s.buffer && pm(s.buffer), t;
  }
  function Bv(s) {
    return typeof s == "string";
  }
  function qv(s) {
    return typeof s == "number";
  }
  function hm(s) {
    return s !== null && typeof s == "object";
  }
  function xo(s) {
    if (Ls.call(s) !== "[object Object]")
      return false;
    var t = Object.getPrototypeOf(s);
    return t === null || t === Object.prototype;
  }
  function jv(s) {
    return Ls.call(s) === "[object Date]";
  }
  function Gv(s) {
    return Ls.call(s) === "[object File]";
  }
  function Jv(s) {
    return Ls.call(s) === "[object Blob]";
  }
  function mm(s) {
    return Ls.call(s) === "[object Function]";
  }
  function Wv(s) {
    return hm(s) && mm(s.pipe);
  }
  function Kv(s) {
    return Ls.call(s) === "[object URLSearchParams]";
  }
  function zv(s) {
    return s.trim ? s.trim() : s.replace(/^\s+|\s+$/g, "");
  }
  function Yv() {
    return typeof navigator != "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? false : typeof window != "undefined" && typeof document != "undefined";
  }
  function Ul(s, t) {
    if (!(s === null || typeof s == "undefined"))
      if (typeof s != "object" && (s = [s]), $l(s))
        for (var e = 0, r = s.length; e < r; e++)
          t.call(null, s[e], e, s);
      else
        for (var n in s)
          Object.prototype.hasOwnProperty.call(s, n) && t.call(null, s[n], n, s);
  }
  function Xd() {
    var s = {};
    function t(n, i) {
      xo(s[i]) && xo(n) ? s[i] = Xd(s[i], n) : xo(n) ? s[i] = Xd({}, n) : $l(n) ? s[i] = n.slice() : s[i] = n;
    }
    for (var e = 0, r = arguments.length; e < r; e++)
      Ul(arguments[e], t);
    return s;
  }
  function Qv(s, t, e) {
    return Ul(t, function(n, i) {
      e && typeof n == "function" ? s[i] = Uv(n, e) : s[i] = n;
    }), s;
  }
  function Xv(s) {
    return s.charCodeAt(0) === 65279 && (s = s.slice(1)), s;
  }
  var It = {
    isArray: $l,
    isArrayBuffer: pm,
    isBuffer: Fv,
    isFormData: Vv,
    isArrayBufferView: Hv,
    isString: Bv,
    isNumber: qv,
    isObject: hm,
    isPlainObject: xo,
    isUndefined: Qd,
    isDate: jv,
    isFile: Gv,
    isBlob: Jv,
    isFunction: mm,
    isStream: Wv,
    isURLSearchParams: Kv,
    isStandardBrowserEnv: Yv,
    forEach: Ul,
    merge: Xd,
    extend: Qv,
    trim: zv,
    stripBOM: Xv
  }, Mn = It;
  function Nu(s) {
    return encodeURIComponent(s).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var fm = function(t, e, r) {
    if (!e)
      return t;
    var n;
    if (r)
      n = r(e);
    else if (Mn.isURLSearchParams(e))
      n = e.toString();
    else {
      var i = [];
      Mn.forEach(e, function(d, p) {
        d === null || typeof d == "undefined" || (Mn.isArray(d) ? p = p + "[]" : d = [d], Mn.forEach(d, function(m) {
          Mn.isDate(m) ? m = m.toISOString() : Mn.isObject(m) && (m = JSON.stringify(m)), i.push(Nu(p) + "=" + Nu(m));
        }));
      }), n = i.join("&");
    }
    if (n) {
      var a = t.indexOf("#");
      a !== -1 && (t = t.slice(0, a)), t += (t.indexOf("?") === -1 ? "?" : "&") + n;
    }
    return t;
  }, Zv = It;
  function Bc() {
    this.handlers = [];
  }
  Bc.prototype.use = function(t, e, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: e,
      synchronous: r ? r.synchronous : false,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  };
  Bc.prototype.eject = function(t) {
    this.handlers[t] && (this.handlers[t] = null);
  };
  Bc.prototype.forEach = function(t) {
    Zv.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  };
  var ey = Bc, ty = It, ry = function(t, e) {
    ty.forEach(t, function(n, i) {
      i !== e && i.toUpperCase() === e.toUpperCase() && (t[e] = n, delete t[i]);
    });
  }, gm = function(t, e, r, n, i) {
    return t.config = e, r && (t.code = r), t.request = n, t.response = i, t.isAxiosError = true, t.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }, t;
  }, md$1, Lu;
  function vm() {
    if (Lu)
      return md$1;
    Lu = 1;
    var s = gm;
    return md$1 = function(e, r, n, i, a) {
      var c = new Error(e);
      return s(c, r, n, i, a);
    }, md$1;
  }
  var fd, xu;
  function sy() {
    if (xu)
      return fd;
    xu = 1;
    var s = vm();
    return fd = function(e, r, n) {
      var i = n.config.validateStatus;
      !n.status || !i || i(n.status) ? e(n) : r(s(
        "Request failed with status code " + n.status,
        n.config,
        null,
        n.request,
        n
      ));
    }, fd;
  }
  var gd, $u;
  function ny() {
    if ($u)
      return gd;
    $u = 1;
    var s = It;
    return gd = s.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function() {
        return {
          write: function(r, n, i, a, c, d) {
            var p = [];
            p.push(r + "=" + encodeURIComponent(n)), s.isNumber(i) && p.push("expires=" + new Date(i).toGMTString()), s.isString(a) && p.push("path=" + a), s.isString(c) && p.push("domain=" + c), d === true && p.push("secure"), document.cookie = p.join("; ");
          },
          read: function(r) {
            var n = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
            return n ? decodeURIComponent(n[3]) : null;
          },
          remove: function(r) {
            this.write(r, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function() {
        return {
          write: function() {
          },
          read: function() {
            return null;
          },
          remove: function() {
          }
        };
      }()
    ), gd;
  }
  var vd, Uu;
  function iy() {
    return Uu || (Uu = 1, vd = function(t) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
    }), vd;
  }
  var yd, Fu;
  function ay() {
    return Fu || (Fu = 1, yd = function(t, e) {
      return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
    }), yd;
  }
  var Td, Vu;
  function oy() {
    if (Vu)
      return Td;
    Vu = 1;
    var s = iy(), t = ay();
    return Td = function(r, n) {
      return r && !s(n) ? t(r, n) : n;
    }, Td;
  }
  var _d, Hu;
  function cy() {
    if (Hu)
      return _d;
    Hu = 1;
    var s = It, t = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    return _d = function(r) {
      var n = {}, i, a, c;
      return r && s.forEach(r.split(`
`), function(p) {
        if (c = p.indexOf(":"), i = s.trim(p.substr(0, c)).toLowerCase(), a = s.trim(p.substr(c + 1)), i) {
          if (n[i] && t.indexOf(i) >= 0)
            return;
          i === "set-cookie" ? n[i] = (n[i] ? n[i] : []).concat([a]) : n[i] = n[i] ? n[i] + ", " + a : a;
        }
      }), n;
    }, _d;
  }
  var Sd, Bu;
  function dy() {
    if (Bu)
      return Sd;
    Bu = 1;
    var s = It;
    return Sd = s.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function() {
        var e = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"), n;
        function i(a) {
          var c = a;
          return e && (r.setAttribute("href", c), c = r.href), r.setAttribute("href", c), {
            href: r.href,
            protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
            host: r.host,
            search: r.search ? r.search.replace(/^\?/, "") : "",
            hash: r.hash ? r.hash.replace(/^#/, "") : "",
            hostname: r.hostname,
            port: r.port,
            pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
          };
        }
        return n = i(window.location.href), function(c) {
          var d = s.isString(c) ? i(c) : c;
          return d.protocol === n.protocol && d.host === n.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function() {
        return function() {
          return true;
        };
      }()
    ), Sd;
  }
  var Ed, qu;
  function qc() {
    if (qu)
      return Ed;
    qu = 1;
    function s(t) {
      this.message = t;
    }
    return s.prototype.toString = function() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    }, s.prototype.__CANCEL__ = true, Ed = s, Ed;
  }
  var Cd, ju;
  function Gu() {
    if (ju)
      return Cd;
    ju = 1;
    var s = It, t = sy(), e = ny(), r = fm, n = oy(), i = cy(), a = dy(), c = vm(), d = jc(), p = qc();
    return Cd = function(m) {
      return new Promise(function(T, y) {
        var b = m.data, A = m.headers, I = m.responseType, $;
        function V() {
          m.cancelToken && m.cancelToken.unsubscribe($), m.signal && m.signal.removeEventListener("abort", $);
        }
        s.isFormData(b) && delete A["Content-Type"];
        var O = new XMLHttpRequest();
        if (m.auth) {
          var q = m.auth.username || "", B = m.auth.password ? unescape(encodeURIComponent(m.auth.password)) : "";
          A.Authorization = "Basic " + btoa(q + ":" + B);
        }
        var ne = n(m.baseURL, m.url);
        O.open(m.method.toUpperCase(), r(ne, m.params, m.paramsSerializer), true), O.timeout = m.timeout;
        function Y() {
          if (O) {
            var Pe = "getAllResponseHeaders" in O ? i(O.getAllResponseHeaders()) : null, Tt = !I || I === "text" || I === "json" ? O.responseText : O.response, M = {
              data: Tt,
              status: O.status,
              statusText: O.statusText,
              headers: Pe,
              config: m,
              request: O
            };
            t(function(k) {
              T(k), V();
            }, function(k) {
              y(k), V();
            }, M), O = null;
          }
        }
        if ("onloadend" in O ? O.onloadend = Y : O.onreadystatechange = function() {
          !O || O.readyState !== 4 || O.status === 0 && !(O.responseURL && O.responseURL.indexOf("file:") === 0) || setTimeout(Y);
        }, O.onabort = function() {
          O && (y(c("Request aborted", m, "ECONNABORTED", O)), O = null);
        }, O.onerror = function() {
          y(c("Network Error", m, null, O)), O = null;
        }, O.ontimeout = function() {
          var Tt = m.timeout ? "timeout of " + m.timeout + "ms exceeded" : "timeout exceeded", M = m.transitional || d.transitional;
          m.timeoutErrorMessage && (Tt = m.timeoutErrorMessage), y(c(
            Tt,
            m,
            M.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            O
          )), O = null;
        }, s.isStandardBrowserEnv()) {
          var we = (m.withCredentials || a(ne)) && m.xsrfCookieName ? e.read(m.xsrfCookieName) : undefined;
          we && (A[m.xsrfHeaderName] = we);
        }
        "setRequestHeader" in O && s.forEach(A, function(Tt, M) {
          typeof b == "undefined" && M.toLowerCase() === "content-type" ? delete A[M] : O.setRequestHeader(M, Tt);
        }), s.isUndefined(m.withCredentials) || (O.withCredentials = !!m.withCredentials), I && I !== "json" && (O.responseType = m.responseType), typeof m.onDownloadProgress == "function" && O.addEventListener("progress", m.onDownloadProgress), typeof m.onUploadProgress == "function" && O.upload && O.upload.addEventListener("progress", m.onUploadProgress), (m.cancelToken || m.signal) && ($ = function(Pe) {
          O && (y(!Pe || Pe && Pe.type ? new p("canceled") : Pe), O.abort(), O = null);
        }, m.cancelToken && m.cancelToken.subscribe($), m.signal && (m.signal.aborted ? $() : m.signal.addEventListener("abort", $))), b || (b = null), O.send(b);
      });
    }, Cd;
  }
  var wd, Ju;
  function jc() {
    if (Ju)
      return wd;
    Ju = 1;
    var s = It, t = ry, e = gm, r = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function n(d, p) {
      !s.isUndefined(d) && s.isUndefined(d["Content-Type"]) && (d["Content-Type"] = p);
    }
    function i() {
      var d;
      return (typeof XMLHttpRequest != "undefined" || typeof process != "undefined" && Object.prototype.toString.call(process) === "[object process]") && (d = Gu()), d;
    }
    function a(d, p, h) {
      if (s.isString(d))
        try {
          return (p || JSON.parse)(d), s.trim(d);
        } catch (m) {
          if (m.name !== "SyntaxError")
            throw m;
        }
      return (0, JSON.stringify)(d);
    }
    var c = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: i(),
      transformRequest: [function(p, h) {
        return t(h, "Accept"), t(h, "Content-Type"), s.isFormData(p) || s.isArrayBuffer(p) || s.isBuffer(p) || s.isStream(p) || s.isFile(p) || s.isBlob(p) ? p : s.isArrayBufferView(p) ? p.buffer : s.isURLSearchParams(p) ? (n(h, "application/x-www-form-urlencoded;charset=utf-8"), p.toString()) : s.isObject(p) || h && h["Content-Type"] === "application/json" ? (n(h, "application/json"), a(p)) : p;
      }],
      transformResponse: [function(p) {
        var h = this.transitional || c.transitional, m = h && h.silentJSONParsing, g = h && h.forcedJSONParsing, T = !m && this.responseType === "json";
        if (T || g && s.isString(p) && p.length)
          try {
            return JSON.parse(p);
          } catch (y) {
            if (T)
              throw y.name === "SyntaxError" ? e(y, this, "E_JSON_PARSE") : y;
          }
        return p;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function(p) {
        return p >= 200 && p < 300;
      },
      headers: {
        common: {
          Accept: "application/json, text/plain, */*"
        }
      }
    };
    return s.forEach(["delete", "get", "head"], function(p) {
      c.headers[p] = {};
    }), s.forEach(["post", "put", "patch"], function(p) {
      c.headers[p] = s.merge(r);
    }), wd = c, wd;
  }
  var ly = It, uy = jc(), py = function(t, e, r) {
    var n = this || uy;
    return ly.forEach(r, function(a) {
      t = a.call(n, t, e);
    }), t;
  }, Pd, Wu;
  function ym() {
    return Wu || (Wu = 1, Pd = function(t) {
      return !!(t && t.__CANCEL__);
    }), Pd;
  }
  var Ku = It, Rd = py, hy = ym(), my = jc(), fy = qc();
  function bd(s) {
    if (s.cancelToken && s.cancelToken.throwIfRequested(), s.signal && s.signal.aborted)
      throw new fy("canceled");
  }
  var gy = function(t) {
    bd(t), t.headers = t.headers || {}, t.data = Rd.call(
      t,
      t.data,
      t.headers,
      t.transformRequest
    ), t.headers = Ku.merge(
      t.headers.common || {},
      t.headers[t.method] || {},
      t.headers
    ), Ku.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function(n) {
        delete t.headers[n];
      }
    );
    var e = t.adapter || my.adapter;
    return e(t).then(function(n) {
      return bd(t), n.data = Rd.call(
        t,
        n.data,
        n.headers,
        t.transformResponse
      ), n;
    }, function(n) {
      return hy(n) || (bd(t), n && n.response && (n.response.data = Rd.call(
        t,
        n.response.data,
        n.response.headers,
        t.transformResponse
      ))), Promise.reject(n);
    });
  }, Ot = It, Tm = function(t, e) {
    e = e || {};
    var r = {};
    function n(h, m) {
      return Ot.isPlainObject(h) && Ot.isPlainObject(m) ? Ot.merge(h, m) : Ot.isPlainObject(m) ? Ot.merge({}, m) : Ot.isArray(m) ? m.slice() : m;
    }
    function i(h) {
      if (Ot.isUndefined(e[h])) {
        if (!Ot.isUndefined(t[h]))
          return n(undefined, t[h]);
      } else
        return n(t[h], e[h]);
    }
    function a(h) {
      if (!Ot.isUndefined(e[h]))
        return n(undefined, e[h]);
    }
    function c(h) {
      if (Ot.isUndefined(e[h])) {
        if (!Ot.isUndefined(t[h]))
          return n(undefined, t[h]);
      } else
        return n(undefined, e[h]);
    }
    function d(h) {
      if (h in e)
        return n(t[h], e[h]);
      if (h in t)
        return n(undefined, t[h]);
    }
    var p = {
      url: a,
      method: a,
      data: a,
      baseURL: c,
      transformRequest: c,
      transformResponse: c,
      paramsSerializer: c,
      timeout: c,
      timeoutMessage: c,
      withCredentials: c,
      adapter: c,
      responseType: c,
      xsrfCookieName: c,
      xsrfHeaderName: c,
      onUploadProgress: c,
      onDownloadProgress: c,
      decompress: c,
      maxContentLength: c,
      maxBodyLength: c,
      transport: c,
      httpAgent: c,
      httpsAgent: c,
      cancelToken: c,
      socketPath: c,
      responseEncoding: c,
      validateStatus: d
    };
    return Ot.forEach(Object.keys(t).concat(Object.keys(e)), function(m) {
      var g = p[m] || i, T = g(m);
      Ot.isUndefined(T) && g !== d || (r[m] = T);
    }), r;
  }, kd, zu;
  function _m() {
    return zu || (zu = 1, kd = {
      version: "0.25.0"
    }), kd;
  }
  var vy = _m().version, Fl = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(s, t) {
    Fl[s] = function(r) {
      return typeof r === s || "a" + (t < 1 ? "n " : " ") + s;
    };
  });
  var Yu = {};
  Fl.transitional = function(t, e, r) {
    function n(i, a) {
      return "[Axios v" + vy + "] Transitional option '" + i + "'" + a + (r ? ". " + r : "");
    }
    return function(i, a, c) {
      if (t === false)
        throw new Error(n(a, " has been removed" + (e ? " in " + e : "")));
      return e && !Yu[a] && (Yu[a] = true, console.warn(
        n(
          a,
          " has been deprecated since v" + e + " and will be removed in the near future"
        )
      )), t ? t(i, a, c) : true;
    };
  };
  function yy(s, t, e) {
    if (typeof s != "object")
      throw new TypeError("options must be an object");
    for (var r = Object.keys(s), n = r.length; n-- > 0; ) {
      var i = r[n], a = t[i];
      if (a) {
        var c = s[i], d = c === undefined || a(c, i, s);
        if (d !== true)
          throw new TypeError("option " + i + " must be " + d);
        continue;
      }
      if (e !== true)
        throw Error("Unknown option " + i);
    }
  }
  var Ty = {
    assertOptions: yy,
    validators: Fl
  }, Sm = It, _y = fm, Qu = ey, Xu = gy, Gc = Tm, Em = Ty, On = Em.validators;
  function po(s) {
    this.defaults = s, this.interceptors = {
      request: new Qu(),
      response: new Qu()
    };
  }
  po.prototype.request = function(t, e) {
    if (typeof t == "string" ? (e = e || {}, e.url = t) : e = t || {}, !e.url)
      throw new Error("Provided config url is not valid");
    e = Gc(this.defaults, e), e.method ? e.method = e.method.toLowerCase() : this.defaults.method ? e.method = this.defaults.method.toLowerCase() : e.method = "get";
    var r = e.transitional;
    r !== undefined && Em.assertOptions(r, {
      silentJSONParsing: On.transitional(On.boolean),
      forcedJSONParsing: On.transitional(On.boolean),
      clarifyTimeoutError: On.transitional(On.boolean)
    }, false);
    var n = [], i = true;
    this.interceptors.request.forEach(function(T) {
      typeof T.runWhen == "function" && T.runWhen(e) === false || (i = i && T.synchronous, n.unshift(T.fulfilled, T.rejected));
    });
    var a = [];
    this.interceptors.response.forEach(function(T) {
      a.push(T.fulfilled, T.rejected);
    });
    var c;
    if (!i) {
      var d = [Xu, undefined];
      for (Array.prototype.unshift.apply(d, n), d = d.concat(a), c = Promise.resolve(e); d.length; )
        c = c.then(d.shift(), d.shift());
      return c;
    }
    for (var p = e; n.length; ) {
      var h = n.shift(), m = n.shift();
      try {
        p = h(p);
      } catch (g) {
        m(g);
        break;
      }
    }
    try {
      c = Xu(p);
    } catch (g) {
      return Promise.reject(g);
    }
    for (; a.length; )
      c = c.then(a.shift(), a.shift());
    return c;
  };
  po.prototype.getUri = function(t) {
    if (!t.url)
      throw new Error("Provided config url is not valid");
    return t = Gc(this.defaults, t), _y(t.url, t.params, t.paramsSerializer).replace(/^\?/, "");
  };
  Sm.forEach(["delete", "get", "head", "options"], function(t) {
    po.prototype[t] = function(e, r) {
      return this.request(Gc(r || {}, {
        method: t,
        url: e,
        data: (r || {}).data
      }));
    };
  });
  Sm.forEach(["post", "put", "patch"], function(t) {
    po.prototype[t] = function(e, r, n) {
      return this.request(Gc(n || {}, {
        method: t,
        url: e,
        data: r
      }));
    };
  });
  var Sy = po, Id, Zu;
  function Ey() {
    if (Zu)
      return Id;
    Zu = 1;
    var s = qc();
    function t(e) {
      if (typeof e != "function")
        throw new TypeError("executor must be a function.");
      var r;
      this.promise = new Promise(function(a) {
        r = a;
      });
      var n = this;
      this.promise.then(function(i) {
        if (n._listeners) {
          var a, c = n._listeners.length;
          for (a = 0; a < c; a++)
            n._listeners[a](i);
          n._listeners = null;
        }
      }), this.promise.then = function(i) {
        var a, c = new Promise(function(d) {
          n.subscribe(d), a = d;
        }).then(i);
        return c.cancel = function() {
          n.unsubscribe(a);
        }, c;
      }, e(function(a) {
        n.reason || (n.reason = new s(a), r(n.reason));
      });
    }
    return t.prototype.throwIfRequested = function() {
      if (this.reason)
        throw this.reason;
    }, t.prototype.subscribe = function(r) {
      if (this.reason) {
        r(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(r) : this._listeners = [r];
    }, t.prototype.unsubscribe = function(r) {
      if (this._listeners) {
        var n = this._listeners.indexOf(r);
        n !== -1 && this._listeners.splice(n, 1);
      }
    }, t.source = function() {
      var r, n = new t(function(a) {
        r = a;
      });
      return {
        token: n,
        cancel: r
      };
    }, Id = t, Id;
  }
  var Ad, ep;
  function Cy() {
    return ep || (ep = 1, Ad = function(t) {
      return function(r) {
        return t.apply(null, r);
      };
    }), Ad;
  }
  var Dd, tp;
  function wy() {
    if (tp)
      return Dd;
    tp = 1;
    var s = It;
    return Dd = function(e) {
      return s.isObject(e) && e.isAxiosError === true;
    }, Dd;
  }
  var rp = It, Py = um, $o = Sy, Ry = Tm, by = jc();
  function Cm(s) {
    var t = new $o(s), e = Py($o.prototype.request, t);
    return rp.extend(e, $o.prototype, t), rp.extend(e, t), e.create = function(n) {
      return Cm(Ry(s, n));
    }, e;
  }
  var Rr = Cm(by);
  Rr.Axios = $o;
  Rr.Cancel = qc();
  Rr.CancelToken = Ey();
  Rr.isCancel = ym();
  Rr.VERSION = _m().version;
  Rr.all = function(t) {
    return Promise.all(t);
  };
  Rr.spread = Cy();
  Rr.isAxiosError = wy();
  $v.exports = Rr;
  Xo.default = Rr;
  (function(s) {
    s.exports = Xo;
  })(xv);
  const Zo = /* @__PURE__ */ iv(Yd);
  function ky() {
    this.__data__ = [], this.size = 0;
  }
  function ho(s, t) {
    return s === t || s !== s && t !== t;
  }
  function Jc(s, t) {
    for (var e = s.length; e--; )
      if (ho(s[e][0], t))
        return e;
    return -1;
  }
  var Iy = Array.prototype, Ay = Iy.splice;
  function Dy(s) {
    var t = this.__data__, e = Jc(t, s);
    if (e < 0)
      return false;
    var r = t.length - 1;
    return e == r ? t.pop() : Ay.call(t, e, 1), --this.size, true;
  }
  function My(s) {
    var t = this.__data__, e = Jc(t, s);
    return e < 0 ? undefined : t[e][1];
  }
  function Oy(s) {
    return Jc(this.__data__, s) > -1;
  }
  function Ny(s, t) {
    var e = this.__data__, r = Jc(e, s);
    return r < 0 ? (++this.size, e.push([s, t])) : e[r][1] = t, this;
  }
  function Xr(s) {
    var t = -1, e = s == null ? 0 : s.length;
    for (this.clear(); ++t < e; ) {
      var r = s[t];
      this.set(r[0], r[1]);
    }
  }
  Xr.prototype.clear = ky;
  Xr.prototype.delete = Dy;
  Xr.prototype.get = My;
  Xr.prototype.has = Oy;
  Xr.prototype.set = Ny;
  function Ly() {
    this.__data__ = new Xr(), this.size = 0;
  }
  function xy(s) {
    var t = this.__data__, e = t.delete(s);
    return this.size = t.size, e;
  }
  function $y(s) {
    return this.__data__.get(s);
  }
  function Uy(s) {
    return this.__data__.has(s);
  }
  var Fy = typeof global == "object" && global && global.Object === Object && global;
  const wm = Fy;
  var Vy = typeof self == "object" && self && self.Object === Object && self, Hy = wm || Vy || Function("return this")();
  const ir = Hy;
  var By = ir.Symbol;
  const Ms = By;
  var Pm = Object.prototype, qy = Pm.hasOwnProperty, jy = Pm.toString, aa = Ms ? Ms.toStringTag : undefined;
  function Gy(s) {
    var t = qy.call(s, aa), e = s[aa];
    try {
      s[aa] = void 0;
      var r = !0;
    } catch (i) {
    }
    var n = jy.call(s);
    return r && (t ? s[aa] = e : delete s[aa]), n;
  }
  var Jy = Object.prototype, Wy = Jy.toString;
  function Ky(s) {
    return Wy.call(s);
  }
  var zy = "[object Null]", Yy = "[object Undefined]", sp = Ms ? Ms.toStringTag : undefined;
  function Pn(s) {
    return s == null ? s === undefined ? Yy : zy : sp && sp in Object(s) ? Gy(s) : Ky(s);
  }
  function nr(s) {
    var t = typeof s;
    return s != null && (t == "object" || t == "function");
  }
  var Qy = "[object AsyncFunction]", Xy = "[object Function]", Zy = "[object GeneratorFunction]", eT = "[object Proxy]";
  function Vl(s) {
    if (!nr(s))
      return false;
    var t = Pn(s);
    return t == Xy || t == Zy || t == Qy || t == eT;
  }
  var tT = ir["__core-js_shared__"];
  const Md = tT;
  var np = function() {
    var s = /[^.]+$/.exec(Md && Md.keys && Md.keys.IE_PROTO || "");
    return s ? "Symbol(src)_1." + s : "";
  }();
  function rT(s) {
    return !!np && np in s;
  }
  var sT = Function.prototype, nT = sT.toString;
  function Rn(s) {
    if (s != null) {
      try {
        return nT.call(s);
      } catch (t) {
      }
      try {
        return s + "";
      } catch (t) {
      }
    }
    return "";
  }
  var iT = /[\\^$.*+?()[\]{}|]/g, aT = /^\[object .+?Constructor\]$/, oT = Function.prototype, cT = Object.prototype, dT = oT.toString, lT = cT.hasOwnProperty, uT = RegExp(
    "^" + dT.call(lT).replace(iT, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function pT(s) {
    if (!nr(s) || rT(s))
      return false;
    var t = Vl(s) ? uT : aT;
    return t.test(Rn(s));
  }
  function hT(s, t) {
    return s == null ? undefined : s[t];
  }
  function bn(s, t) {
    var e = hT(s, t);
    return pT(e) ? e : undefined;
  }
  var mT = bn(ir, "Map");
  const _a = mT;
  var fT = bn(Object, "create");
  const Sa = fT;
  function gT() {
    this.__data__ = Sa ? Sa(null) : {}, this.size = 0;
  }
  function vT(s) {
    var t = this.has(s) && delete this.__data__[s];
    return this.size -= t ? 1 : 0, t;
  }
  var yT = "__lodash_hash_undefined__", TT = Object.prototype, _T = TT.hasOwnProperty;
  function ST(s) {
    var t = this.__data__;
    if (Sa) {
      var e = t[s];
      return e === yT ? undefined : e;
    }
    return _T.call(t, s) ? t[s] : undefined;
  }
  var ET = Object.prototype, CT = ET.hasOwnProperty;
  function wT(s) {
    var t = this.__data__;
    return Sa ? t[s] !== undefined : CT.call(t, s);
  }
  var PT = "__lodash_hash_undefined__";
  function RT(s, t) {
    var e = this.__data__;
    return this.size += this.has(s) ? 0 : 1, e[s] = Sa && t === undefined ? PT : t, this;
  }
  function Tn(s) {
    var t = -1, e = s == null ? 0 : s.length;
    for (this.clear(); ++t < e; ) {
      var r = s[t];
      this.set(r[0], r[1]);
    }
  }
  Tn.prototype.clear = gT;
  Tn.prototype.delete = vT;
  Tn.prototype.get = ST;
  Tn.prototype.has = wT;
  Tn.prototype.set = RT;
  function bT() {
    this.size = 0, this.__data__ = {
      hash: new Tn(),
      map: new (_a || Xr)(),
      string: new Tn()
    };
  }
  function kT(s) {
    var t = typeof s;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? s !== "__proto__" : s === null;
  }
  function Wc(s, t) {
    var e = s.__data__;
    return kT(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
  }
  function IT(s) {
    var t = Wc(this, s).delete(s);
    return this.size -= t ? 1 : 0, t;
  }
  function AT(s) {
    return Wc(this, s).get(s);
  }
  function DT(s) {
    return Wc(this, s).has(s);
  }
  function MT(s, t) {
    var e = Wc(this, s), r = e.size;
    return e.set(s, t), this.size += e.size == r ? 0 : 1, this;
  }
  function kn(s) {
    var t = -1, e = s == null ? 0 : s.length;
    for (this.clear(); ++t < e; ) {
      var r = s[t];
      this.set(r[0], r[1]);
    }
  }
  kn.prototype.clear = bT;
  kn.prototype.delete = IT;
  kn.prototype.get = AT;
  kn.prototype.has = DT;
  kn.prototype.set = MT;
  var OT = 200;
  function NT(s, t) {
    var e = this.__data__;
    if (e instanceof Xr) {
      var r = e.__data__;
      if (!_a || r.length < OT - 1)
        return r.push([s, t]), this.size = ++e.size, this;
      e = this.__data__ = new kn(r);
    }
    return e.set(s, t), this.size = e.size, this;
  }
  function Cr(s) {
    var t = this.__data__ = new Xr(s);
    this.size = t.size;
  }
  Cr.prototype.clear = Ly;
  Cr.prototype.delete = xy;
  Cr.prototype.get = $y;
  Cr.prototype.has = Uy;
  Cr.prototype.set = NT;
  function LT(s, t) {
    for (var e = -1, r = s == null ? 0 : s.length; ++e < r && t(s[e], e, s) !== false; )
      ;
    return s;
  }
  var xT = function() {
    try {
      var s = bn(Object, "defineProperty");
      return s({}, "", {}), s;
    } catch (t) {
    }
  }();
  const ec = xT;
  function Hl(s, t, e) {
    t == "__proto__" && ec ? ec(s, t, {
      configurable: true,
      enumerable: true,
      value: e,
      writable: true
    }) : s[t] = e;
  }
  var $T = Object.prototype, UT = $T.hasOwnProperty;
  function Rm(s, t, e) {
    var r = s[t];
    (!(UT.call(s, t) && ho(r, e)) || e === undefined && !(t in s)) && Hl(s, t, e);
  }
  function mo(s, t, e, r) {
    var n = !e;
    e || (e = {});
    for (var i = -1, a = t.length; ++i < a; ) {
      var c = t[i], d = undefined;
      d === undefined && (d = s[c]), n ? Hl(e, c, d) : Rm(e, c, d);
    }
    return e;
  }
  function FT(s, t) {
    for (var e = -1, r = Array(s); ++e < s; )
      r[e] = t(e);
    return r;
  }
  function Pr(s) {
    return s != null && typeof s == "object";
  }
  var VT = "[object Arguments]";
  function ip(s) {
    return Pr(s) && Pn(s) == VT;
  }
  var bm = Object.prototype, HT = bm.hasOwnProperty, BT = bm.propertyIsEnumerable, qT = ip(function() {
    return arguments;
  }()) ? ip : function(s) {
    return Pr(s) && HT.call(s, "callee") && !BT.call(s, "callee");
  };
  const tc = qT;
  var jT = Array.isArray;
  const Os = jT;
  function GT() {
    return false;
  }
  var km = typeof exports == "object" && exports && !exports.nodeType && exports, ap = km && typeof module == "object" && module && !module.nodeType && module, JT = ap && ap.exports === km, op = JT ? ir.Buffer : undefined, WT = op ? op.isBuffer : undefined, KT = WT || GT;
  const Di = KT;
  var zT = 9007199254740991, YT = /^(?:0|[1-9]\d*)$/;
  function Im(s, t) {
    var e = typeof s;
    return t = t == null ? zT : t, !!t && (e == "number" || e != "symbol" && YT.test(s)) && s > -1 && s % 1 == 0 && s < t;
  }
  var QT = 9007199254740991;
  function Am(s) {
    return typeof s == "number" && s > -1 && s % 1 == 0 && s <= QT;
  }
  var XT = "[object Arguments]", ZT = "[object Array]", e_ = "[object Boolean]", t_ = "[object Date]", r_ = "[object Error]", s_ = "[object Function]", n_ = "[object Map]", i_ = "[object Number]", a_ = "[object Object]", o_ = "[object RegExp]", c_ = "[object Set]", d_ = "[object String]", l_ = "[object WeakMap]", u_ = "[object ArrayBuffer]", p_ = "[object DataView]", h_ = "[object Float32Array]", m_ = "[object Float64Array]", f_ = "[object Int8Array]", g_ = "[object Int16Array]", v_ = "[object Int32Array]", y_ = "[object Uint8Array]", T_ = "[object Uint8ClampedArray]", __ = "[object Uint16Array]", S_ = "[object Uint32Array]", be = {};
  be[h_] = be[m_] = be[f_] = be[g_] = be[v_] = be[y_] = be[T_] = be[__] = be[S_] = true;
  be[XT] = be[ZT] = be[u_] = be[e_] = be[p_] = be[t_] = be[r_] = be[s_] = be[n_] = be[i_] = be[a_] = be[o_] = be[c_] = be[d_] = be[l_] = false;
  function E_(s) {
    return Pr(s) && Am(s.length) && !!be[Pn(s)];
  }
  function Bl(s) {
    return function(t) {
      return s(t);
    };
  }
  var Dm = typeof exports == "object" && exports && !exports.nodeType && exports, ga = Dm && typeof module == "object" && module && !module.nodeType && module, C_ = ga && ga.exports === Dm, Od = C_ && wm.process, w_ = function() {
    try {
      var s = ga && ga.require && ga.require("util").types;
      return s || Od && Od.binding && Od.binding("util");
    } catch (t) {
    }
  }();
  const Mi = w_;
  var cp = Mi && Mi.isTypedArray, P_ = cp ? Bl(cp) : E_;
  const Kc = P_;
  var R_ = Object.prototype, b_ = R_.hasOwnProperty;
  function Mm(s, t) {
    var e = Os(s), r = !e && tc(s), n = !e && !r && Di(s), i = !e && !r && !n && Kc(s), a = e || r || n || i, c = a ? FT(s.length, String) : [], d = c.length;
    for (var p in s)
      (t || b_.call(s, p)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
      (p == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      n && (p == "offset" || p == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      i && (p == "buffer" || p == "byteLength" || p == "byteOffset") || // Skip index properties.
      Im(p, d))) && c.push(p);
    return c;
  }
  var k_ = Object.prototype;
  function zc(s) {
    var t = s && s.constructor, e = typeof t == "function" && t.prototype || k_;
    return s === e;
  }
  function Om(s, t) {
    return function(e) {
      return s(t(e));
    };
  }
  var I_ = Om(Object.keys, Object);
  const A_ = I_;
  var D_ = Object.prototype, M_ = D_.hasOwnProperty;
  function Nm(s) {
    if (!zc(s))
      return A_(s);
    var t = [];
    for (var e in Object(s))
      M_.call(s, e) && e != "constructor" && t.push(e);
    return t;
  }
  function fo(s) {
    return s != null && Am(s.length) && !Vl(s);
  }
  function ql(s) {
    return fo(s) ? Mm(s) : Nm(s);
  }
  function N_(s) {
    var t = [];
    if (s != null)
      for (var e in Object(s))
        t.push(e);
    return t;
  }
  var L_ = Object.prototype, x_ = L_.hasOwnProperty;
  function $_(s) {
    if (!nr(s))
      return N_(s);
    var t = zc(s), e = [];
    for (var r in s)
      r == "constructor" && (t || !x_.call(s, r)) || e.push(r);
    return e;
  }
  function go(s) {
    return fo(s) ? Mm(s, true) : $_(s);
  }
  var Lm = typeof exports == "object" && exports && !exports.nodeType && exports, dp = Lm && typeof module == "object" && module && !module.nodeType && module, F_ = dp && dp.exports === Lm, lp = F_ ? ir.Buffer : undefined, up = lp ? lp.allocUnsafe : undefined;
  function xm(s, t) {
    if (t)
      return s.slice();
    var e = s.length, r = up ? up(e) : new s.constructor(e);
    return s.copy(r), r;
  }
  function $m(s, t) {
    var e = -1, r = s.length;
    for (t || (t = Array(r)); ++e < r; )
      t[e] = s[e];
    return t;
  }
  function V_(s, t) {
    for (var e = -1, r = s == null ? 0 : s.length, n = 0, i = []; ++e < r; ) {
      var a = s[e];
      t(a, e, s) && (i[n++] = a);
    }
    return i;
  }
  function Um() {
    return [];
  }
  var H_ = Object.prototype, B_ = H_.propertyIsEnumerable, pp = Object.getOwnPropertySymbols, q_ = pp ? function(s) {
    return s == null ? [] : (s = Object(s), V_(pp(s), function(t) {
      return B_.call(s, t);
    }));
  } : Um;
  const jl = q_;
  function Fm(s, t) {
    for (var e = -1, r = t.length, n = s.length; ++e < r; )
      s[n + e] = t[e];
    return s;
  }
  var G_ = Om(Object.getPrototypeOf, Object);
  const Gl = G_;
  function Hm(s, t, e) {
    var r = t(s);
    return Os(s) ? r : Fm(r, e(s));
  }
  function Zd(s) {
    return Hm(s, ql, jl);
  }
  var Y_ = bn(ir, "DataView");
  const el = Y_;
  var Q_ = bn(ir, "Promise");
  const tl = Q_;
  var X_ = bn(ir, "Set");
  const rl = X_;
  var Z_ = bn(ir, "WeakMap");
  const sl = Z_;
  var hp = "[object Map]", eS = "[object Object]", mp = "[object Promise]", fp = "[object Set]", gp = "[object WeakMap]", vp = "[object DataView]", tS = Rn(el), rS = Rn(_a), sS = Rn(tl), nS = Rn(rl), iS = Rn(sl), Vs = Pn;
  (el && Vs(new el(new ArrayBuffer(1))) != vp || _a && Vs(new _a()) != hp || tl && Vs(tl.resolve()) != mp || rl && Vs(new rl()) != fp || sl && Vs(new sl()) != gp) && (Vs = function(s) {
    var t = Pn(s), e = t == eS ? s.constructor : undefined, r = e ? Rn(e) : "";
    if (r)
      switch (r) {
        case tS:
          return vp;
        case rS:
          return hp;
        case sS:
          return mp;
        case nS:
          return fp;
        case iS:
          return gp;
      }
    return t;
  });
  const Oi = Vs;
  var aS = Object.prototype, oS = aS.hasOwnProperty;
  function cS(s) {
    var t = s.length, e = new s.constructor(t);
    return t && typeof s[0] == "string" && oS.call(s, "index") && (e.index = s.index, e.input = s.input), e;
  }
  var dS = ir.Uint8Array;
  const rc = dS;
  function Jl(s) {
    var t = new s.constructor(s.byteLength);
    return new rc(t).set(new rc(s)), t;
  }
  function lS(s, t) {
    var e = Jl(s.buffer) ;
    return new s.constructor(e, s.byteOffset, s.byteLength);
  }
  var uS = /\w*$/;
  function pS(s) {
    var t = new s.constructor(s.source, uS.exec(s));
    return t.lastIndex = s.lastIndex, t;
  }
  var yp = Ms ? Ms.prototype : undefined, Tp = yp ? yp.valueOf : undefined;
  function hS(s) {
    return Tp ? Object(Tp.call(s)) : {};
  }
  function Bm(s, t) {
    var e = t ? Jl(s.buffer) : s.buffer;
    return new s.constructor(e, s.byteOffset, s.length);
  }
  var mS = "[object Boolean]", fS = "[object Date]", gS = "[object Map]", vS = "[object Number]", yS = "[object RegExp]", TS = "[object Set]", _S = "[object String]", SS = "[object Symbol]", ES = "[object ArrayBuffer]", CS = "[object DataView]", wS = "[object Float32Array]", PS = "[object Float64Array]", RS = "[object Int8Array]", bS = "[object Int16Array]", kS = "[object Int32Array]", IS = "[object Uint8Array]", AS = "[object Uint8ClampedArray]", DS = "[object Uint16Array]", MS = "[object Uint32Array]";
  function OS(s, t, e) {
    var r = s.constructor;
    switch (t) {
      case ES:
        return Jl(s);
      case mS:
      case fS:
        return new r(+s);
      case CS:
        return lS(s);
      case wS:
      case PS:
      case RS:
      case bS:
      case kS:
      case IS:
      case AS:
      case DS:
      case MS:
        return Bm(s, e);
      case gS:
        return new r();
      case vS:
      case _S:
        return new r(s);
      case yS:
        return pS(s);
      case TS:
        return new r();
      case SS:
        return hS(s);
    }
  }
  var _p = Object.create, NS = function() {
    function s() {
    }
    return function(t) {
      if (!nr(t))
        return {};
      if (_p)
        return _p(t);
      s.prototype = t;
      var e = new s();
      return s.prototype = undefined, e;
    };
  }();
  const LS = NS;
  function qm(s) {
    return typeof s.constructor == "function" && !zc(s) ? LS(Gl(s)) : {};
  }
  var xS = "[object Map]";
  function $S(s) {
    return Pr(s) && Oi(s) == xS;
  }
  var Sp = Mi && Mi.isMap, US = Sp ? Bl(Sp) : $S;
  const FS = US;
  var VS = "[object Set]";
  function HS(s) {
    return Pr(s) && Oi(s) == VS;
  }
  var Ep = Mi && Mi.isSet, BS = Ep ? Bl(Ep) : HS;
  const qS = BS;
  var jS = 1, jm = "[object Arguments]", WS = "[object Array]", KS = "[object Boolean]", zS = "[object Date]", YS = "[object Error]", Gm = "[object Function]", QS = "[object GeneratorFunction]", XS = "[object Map]", ZS = "[object Number]", Jm = "[object Object]", eE = "[object RegExp]", tE = "[object Set]", rE = "[object String]", sE = "[object Symbol]", nE = "[object WeakMap]", iE = "[object ArrayBuffer]", aE = "[object DataView]", oE = "[object Float32Array]", cE = "[object Float64Array]", dE = "[object Int8Array]", lE = "[object Int16Array]", uE = "[object Int32Array]", pE = "[object Uint8Array]", hE = "[object Uint8ClampedArray]", mE = "[object Uint16Array]", fE = "[object Uint32Array]", Ce = {};
  Ce[jm] = Ce[WS] = Ce[iE] = Ce[aE] = Ce[KS] = Ce[zS] = Ce[oE] = Ce[cE] = Ce[dE] = Ce[lE] = Ce[uE] = Ce[XS] = Ce[ZS] = Ce[Jm] = Ce[eE] = Ce[tE] = Ce[rE] = Ce[sE] = Ce[pE] = Ce[hE] = Ce[mE] = Ce[fE] = true;
  Ce[YS] = Ce[Gm] = Ce[nE] = false;
  function Uo(s, t, e, r, n, i) {
    var a, c = t & jS;
    if (a !== undefined)
      return a;
    if (!nr(s))
      return s;
    var h = Os(s);
    if (h) {
      if (a = cS(s), false)
        ;
    } else {
      var m = Oi(s), g = m == Gm || m == QS;
      if (Di(s))
        return xm(s, c);
      if (m == Jm || m == jm || g && !n) {
        if (a = g ? {} : qm(s), false)
          ;
      } else {
        if (!Ce[m])
          return n ? s : {};
        a = OS(s, m, c);
      }
    }
    i || (i = new Cr());
    var T = i.get(s);
    if (T)
      return T;
    i.set(s, a), qS(s) ? s.forEach(function(A) {
      a.add(Uo(A, t, e, A, s, i));
    }) : FS(s) && s.forEach(function(A, I) {
      a.set(I, Uo(A, t, e, I, s, i));
    });
    var y = Zd , b = h ? undefined : y(s);
    return LT(b || s, function(A, I) {
      b && (I = A, A = s[I]), Rm(a, I, Uo(A, t, e, I, s, i));
    }), a;
  }
  var gE = 1, vE = 4;
  function Wl(s) {
    return Uo(s, gE | vE);
  }
  var yE = "[object Symbol]";
  function TE(s) {
    return typeof s == "symbol" || Pr(s) && Pn(s) == yE;
  }
  var _E = Object.defineProperty, SE = (s, t) => {
    for (var e in t)
      _E(s, e, { get: t[e], enumerable: true });
  }, EE = {};
  SE(EE, {
    permissions: () => CE,
    theme: () => wE
  });
  var gt = /* @__PURE__ */ ((s) => (s.GroupCall = "GROUP_CALL", s.Webinar = "WEBINAR", s.AudioRoom = "AUDIO_ROOM", s.Livestream = "LIVESTREAM", s.Chat = "CHAT", s))(gt || {}), W = /* @__PURE__ */ ((s) => (s.Allowed = "ALLOWED", s.NotAllowed = "NOT_ALLOWED", s.CanRequest = "CAN_REQUEST", s))(W || {}), CE = {
    view_type: "GROUP_CALL",
    accept_waiting_requests: false,
    accept_present_requests: false,
    request_produce: false,
    can_allow_participant_audio: false,
    can_allow_participant_screensharing: false,
    can_allow_participant_video: false,
    can_spotlight: false,
    request_kick_participant: false,
    kick_participant: false,
    pin_participant: false,
    can_edit_display_name: false,
    can_record: false,
    can_livestream: false,
    can_present: true,
    waiting_room_type: "SKIP_ON_ACCEPT",
    recorder_type: "NONE",
    plugins: {
      can_close: true,
      can_start: true
    },
    polls: {
      can_create: true,
      can_vote: true,
      can_view: true
    },
    produce: {
      video: {
        allow: true,
        quality: "vga",
        frame_rate: 24
      },
      audio: true,
      screenshare: {
        allow: true,
        quality: "hd",
        frame_rate: 5
      }
    },
    chat: {
      public: {
        can_send: true,
        text: true,
        files: true
      },
      private: {
        can_send: false,
        can_receive: false,
        text: false,
        files: false
      }
    },
    connected_meetings: {
      can_alter_connected_meetings: false,
      can_switch_connected_meetings: false,
      can_switch_to_parent_meeting: false
    },
    reactions: false,
    hidden_participant: false,
    is_recorder: false,
    show_participant_list: true,
    can_change_participant_role: false,
    can_change_theme: false,
    max_screenshare_count: 1
  }, wE = {
    setup_screen: {
      is_enabled: true
    },
    alone_here: {
      is_enabled: true
    },
    waiting_room: {
      is_enabled: false,
      enable_preview: true
    },
    control_bar: {
      is_enabled: true,
      elements: {
        plugins: true,
        screenshare: true,
        invite: true,
        participants: true,
        chat: true,
        reactions: false,
        polls: true,
        fullscreen: true,
        layout: true
      }
    },
    header: {
      is_enabled: true,
      elements: {
        timer: true,
        title: true,
        participant_count: true,
        change_layout: true
      }
    },
    pip_mode: true,
    auto_tune: true,
    grid: {
      multi: {
        maxVideoCount: 6,
        videoFit: "cover"
      },
      single: {
        maxVideoCount: 6,
        videoFit: "cover"
      },
      defaultView: "multi"
    },
    controls: {
      pip_toggle: false
    }
  }, Wm = "hXgU8Wc8pwuGNq9ms5q9Hh", Th;
  typeof process != "undefined" && (Th = process == null ? undefined : process.env) != null && Th.FLAGSMITH_ENVIRONMENT_KEY && (Wm = process.env.FLAGSMITH_ENVIRONMENT_KEY);
  function PE(s = []) {
    const t = {};
    return s.forEach((e) => {
      t[e.feature.name] = {
        enabled: e.enabled,
        value: e.feature_state_value
      };
    }), t;
  }
  var RE = class {
    constructor(s = Wm) {
      f(this, "flags", {});
      f(this, "environmentKey", null);
      this.environmentKey = s, this.identify = this.identify.bind(this), this.getValue = this.getValue.bind(this), this.hasFeature = this.hasFeature.bind(this), this.getAllFlags = this.getAllFlags.bind(this);
    }
    identify(i) {
      return u(this, arguments, function* (s, t = {}, e = false, r = 5e3, n = "edge.api.flagsmith.com") {
        const a = JSON.parse(JSON.stringify(t)), c = Object.entries(a).map((d) => ({
          trait_key: d[0],
          trait_value: d[1]
        }));
        try {
          const d = "_" + (Math.random() + 1).toString(36).substring(2), p = yield Zo.post(
            `https://${n}/api/v1/identities/`,
            {
              identifier: s + (e ? d : ""),
              traits: c
            },
            {
              headers: {
                "Content-Type": "application/json",
                "X-Environment-Key": this.environmentKey
              },
              timeout: r
            }
          );
          this.flags = PE(p.data.flags || []);
        } catch (d) {
        }
        return this.flags;
      });
    }
    getValue(s) {
      return this.flags && this.flags[s] && this.flags[s].value;
    }
    hasFeature(s) {
      return this.flags && this.flags[s] && this.flags[s].enabled;
    }
    getAllFlags() {
      return this.flags;
    }
  }, K = new RE(), Km = [-2, -1, 0, 1, 2], bE = [0, 1, 2, 3, 4];
  function kE(s) {
    s = s.trim();
    let t = "0", e = "0", r = "0";
    return s.length == 4 ? (t = "0x" + s[1] + s[1], e = "0x" + s[2] + s[2], r = "0x" + s[3] + s[3]) : s.length > 6 && (t = "0x" + s[1] + s[2], e = "0x" + s[3] + s[4], r = "0x" + s[5] + s[6]), [+t, +e, +r];
  }
  var IE = (s, t, e) => {
    let r, n, i;
    if (t == 0)
      r = n = i = e;
    else {
      const a = (p, h, m) => (m < 0 && (m += 1), m > 1 && (m -= 1), m < 0.16666666666666666 ? p + (h - p) * 6 * m : m < 0.5 ? h : m < 0.6666666666666666 ? p + (h - p) * (0.6666666666666666 - m) * 6 : p), c = e < 0.5 ? e * (1 + t) : e + t - e * t, d = 2 * e - c;
      r = a(d, c, s + 1 / 3), n = a(d, c, s), i = a(d, c, s - 1 / 3);
    }
    return [Math.round(r * 255), Math.round(n * 255), Math.round(i * 255)];
  }, AE = (s, t, e) => {
    s /= 255, t /= 255, e /= 255;
    const r = Math.max(s, t, e), n = Math.min(s, t, e);
    let i, a;
    const c = (r + n) / 2;
    if (r == n)
      i = a = 0;
    else {
      const d = r - n;
      switch (a = c > 0.5 ? d / (2 - r - n) : d / (r + n), r) {
        case s:
          i = (t - e) / d + (t < e ? 6 : 0);
          break;
        case t:
          i = (e - s) / d + 2;
          break;
        case e:
          i = (s - t) / d + 4;
          break;
      }
      i /= 6;
    }
    return [i, a, c];
  }, DE = (s, t, e) => {
    const r = (n) => n.toString(16).padStart(2, "0");
    return `#${r(s)}${r(t)}${r(e)}`;
  }, zm = (s, t = Km, e = 0.4) => {
    const r = [], [n, i, a] = kE(s), [c, d, p] = AE(n, i, a), h = Math.round(p * 100);
    h > 70 ? e = 0.8 : h > 60 ? e = 0.9 : h < 10 ? e = 0.075 : h < 42 && (e = 0.3);
    const m = t.findIndex((A) => A === 0);
    if (m === -1)
      throw new Error("Invalid reducer provided, it must contain atleast one zero");
    const g = 5 - m, T = m + 1, y = (100 - h) / g, b = h / T;
    for (const A of t) {
      let I;
      A < 0 ? I = h + A * b * e : A > 0 ? I = h + A * y * e : I = h;
      const [$, V, O] = IE(c, d, I / 100);
      r.push(DE($, V, O));
    }
    return r;
  }, ME = (s) => {
    const [t, e, r, n, i] = zm(s, Km);
    return { 300: t, 400: e, 500: r, 600: n, 700: i };
  }, OE = (s) => {
    const [t, e, r, n, i] = zm(s, bE);
    return { 1e3: t, 900: e, 800: r, 700: n, 600: i };
  }, NE = {
    border_radius: "rounded",
    border_width: "thin",
    spacing_base: 4,
    theme: "dark",
    colors: {
      brand: ME("#2160FD"),
      background: OE("#141414"),
      danger: "#FF2D2D",
      text: "#EEEEEE",
      text_on_brand: "#EEEEEE",
      success: "#62A504",
      video_bg: "#191919",
      warning: "#FFCD07"
    }
  };
  function Ym() {
    return Wl(NE);
  }
  var LE = {
    permissions: {
      // webinar
      can_accept_production_requests: false,
      can_edit_display_name: true,
      accept_waiting_requests: false,
      disable_participant_audio: false,
      disable_participant_screensharing: false,
      disable_participant_video: false,
      can_spotlight: false,
      kick_participant: false,
      pin_participant: false,
      can_record: false,
      can_livestream: false,
      waiting_room_type: "SKIP",
      plugins: {
        can_close: true,
        can_start: true,
        can_edit_config: false,
        config: {}
      },
      polls: {
        can_create: true,
        can_vote: true,
        can_view: true
      },
      media: {
        video: {
          can_produce: "ALLOWED",
          can_consume: "ALLOWED"
          /* Allowed */
        },
        audio: {
          can_produce: "ALLOWED"
          /* Allowed */
        },
        screenshare: {
          can_produce: "ALLOWED",
          can_consume: "ALLOWED"
          /* Allowed */
        }
      },
      chat: {
        public: {
          can_send: true,
          text: true,
          files: true
        },
        private: {
          can_send: false,
          can_receive: false,
          text: false,
          files: false
        },
        channel: {
          // Make sure these are the same in default to ensure consistency in developer portal
          can_create: "ALL",
          can_delete: "ALL",
          can_update: "ALL",
          // end same
          can_read_all: false
        },
        message: {
          // Make sure these are the same in default to ensure consistency in developer portal
          can_delete: "ALL",
          can_edit: "ALL",
          // end same
          delete_cutoff_time_seconds: 0,
          edit_cutoff_time_seconds: 0
        }
      },
      hidden_participant: false,
      is_recorder: false,
      recorder_type: "NONE",
      show_participant_list: true,
      transcription_enabled: false,
      can_change_participant_permissions: false,
      connected_meetings: {
        can_alter_connected_meetings: false,
        can_switch_connected_meetings: false,
        can_switch_to_parent_meeting: false
      },
      stage_enabled: false,
      stage_access: undefined,
      accept_stage_requests: false
    },
    ui: {
      oldTheme: {
        setup_screen: {
          is_enabled: false
        },
        alone_here: {
          is_enabled: false
        },
        waiting_room: {
          is_enabled: false,
          enable_preview: true
        },
        control_bar: {
          is_enabled: true,
          elements: {
            plugins: true,
            screenshare: true,
            invite: false,
            participants: true,
            chat: true,
            reactions: false,
            polls: true,
            fullscreen: true,
            layout: true
          }
        },
        header: {
          is_enabled: true,
          elements: {
            timer: true,
            title: true,
            participant_count: true,
            change_layout: true
          }
        },
        pip_mode: true,
        auto_tune: true,
        colors: {
          primary: "#2160FD",
          secondary: "#1A1A1A",
          text: "#EEEEEE",
          background: "#1A1A1A",
          textPrimary: "#EEEEEE",
          videoBackground: "#1A1A1A"
        },
        dimensions: {
          mode: "fillParent"
        },
        grid: {
          multi: {
            maxVideoCount: 6,
            videoFit: "cover"
          },
          single: {
            maxVideoCount: 6,
            videoFit: "cover"
          },
          defaultView: "MULTI"
        },
        controls: {
          pip_toggle: false
        },
        plugins: []
      },
      design_tokens: Ym(),
      config_diff: {}
    },
    config: {
      view_type: "GROUP_CALL",
      media: {
        audio: {
          enable_stereo: false,
          enable_high_bitrate: false
        },
        video: {
          quality: "vga",
          frame_rate: 24
        },
        screenshare: {
          quality: "hd",
          frame_rate: 5
        }
      },
      max_video_streams: {
        mobile: 6,
        desktop: 6
      },
      max_screenshare_count: 1
    },
    version: "hybrid"
  };
  function xE() {
    return Wl(LE);
  }
  var $E = {
    permissions: {
      // webinar
      can_accept_production_requests: false,
      can_edit_display_name: true,
      accept_waiting_requests: false,
      disable_participant_audio: false,
      disable_participant_screensharing: false,
      disable_participant_video: false,
      can_spotlight: false,
      kick_participant: false,
      pin_participant: false,
      can_record: false,
      can_livestream: false,
      waiting_room_type: "SKIP",
      plugins: {
        can_close: true,
        can_start: true,
        can_edit_config: false,
        config: {}
      },
      polls: {
        can_create: true,
        can_vote: true,
        can_view: true
      },
      media: {
        video: {
          can_produce: "ALLOWED"
          /* Allowed */
        },
        audio: {
          can_produce: "ALLOWED"
          /* Allowed */
        },
        screenshare: {
          can_produce: "ALLOWED"
          /* Allowed */
        }
      },
      chat: {
        public: {
          can_send: true,
          text: true,
          files: true
        },
        private: {
          can_send: false,
          can_receive: false,
          text: false,
          files: false
        }
      },
      hidden_participant: false,
      is_recorder: false,
      recorder_type: "NONE",
      show_participant_list: true,
      transcription_enabled: false,
      can_change_participant_permissions: false,
      connected_meetings: {
        can_alter_connected_meetings: false,
        can_switch_connected_meetings: false,
        can_switch_to_parent_meeting: false
      },
      stage_enabled: false,
      stage_access: undefined,
      accept_stage_requests: false
    },
    ui: {
      design_tokens: Ym(),
      config_diff: {}
    },
    config: {
      view_type: "GROUP_CALL",
      media: {
        audio: {
          enable_stereo: false,
          enable_high_bitrate: false
        },
        video: {
          quality: "vga",
          frame_rate: 24
        },
        screenshare: {
          quality: "hd",
          frame_rate: 5
        }
      },
      max_video_streams: {
        mobile: 6,
        desktop: 6
      },
      max_screenshare_count: 1
    },
    version: "2.0.0"
  };
  function Kl() {
    return Wl($E);
  }
  var UE = /\s/;
  function FE(s) {
    for (var t = s.length; t-- && UE.test(s.charAt(t)); )
      ;
    return t;
  }
  var VE = /^\s+/;
  function HE(s) {
    return s && s.slice(0, FE(s) + 1).replace(VE, "");
  }
  var wp = 0 / 0, BE = /^[-+]0x[0-9a-f]+$/i, qE = /^0b[01]+$/i, jE = /^0o[0-7]+$/i, GE = parseInt;
  function Pp(s) {
    if (typeof s == "number")
      return s;
    if (TE(s))
      return wp;
    if (nr(s)) {
      var t = typeof s.valueOf == "function" ? s.valueOf() : s;
      s = nr(t) ? t + "" : t;
    }
    if (typeof s != "string")
      return s === 0 ? s : +s;
    s = HE(s);
    var e = qE.test(s);
    return e || jE.test(s) ? GE(s.slice(2), e ? 2 : 8) : BE.test(s) ? wp : +s;
  }
  function Qm(s) {
    return s;
  }
  function JE(s, t, e) {
    switch (e.length) {
      case 0:
        return s.call(t);
      case 1:
        return s.call(t, e[0]);
      case 2:
        return s.call(t, e[0], e[1]);
      case 3:
        return s.call(t, e[0], e[1], e[2]);
    }
    return s.apply(t, e);
  }
  var WE = 800, KE = 16, zE = Date.now;
  function YE(s) {
    var t = 0, e = 0;
    return function() {
      var r = zE(), n = KE - (r - e);
      if (e = r, n > 0) {
        if (++t >= WE)
          return arguments[0];
      } else
        t = 0;
      return s.apply(undefined, arguments);
    };
  }
  function QE(s) {
    return function() {
      return s;
    };
  }
  var XE = ec ? function(s, t) {
    return ec(s, "toString", {
      configurable: true,
      enumerable: false,
      value: QE(t),
      writable: true
    });
  } : Qm;
  const ZE = XE;
  var eC = YE(ZE);
  const tC = eC;
  var Rp = Math.max;
  function rC(s, t, e) {
    return t = Rp(t === undefined ? s.length - 1 : t, 0), function() {
      for (var r = arguments, n = -1, i = Rp(r.length - t, 0), a = Array(i); ++n < i; )
        a[n] = r[t + n];
      n = -1;
      for (var c = Array(t + 1); ++n < t; )
        c[n] = r[n];
      return c[t] = e(a), JE(s, this, c);
    };
  }
  function sC(s, t) {
    return tC(rC(s, t, Qm), s + "");
  }
  function nC(s, t, e) {
    if (!nr(e))
      return false;
    var r = typeof t;
    return (r == "number" ? fo(e) && Im(t, e.length) : r == "string" && t in e) ? ho(e[t], s) : false;
  }
  function iC(s) {
    return sC(function(t, e) {
      var r = -1, n = e.length, i = n > 1 ? e[n - 1] : undefined, a = n > 2 ? e[2] : undefined;
      for (i = s.length > 3 && typeof i == "function" ? (n--, i) : undefined, a && nC(e[0], e[1], a) && (i = n < 3 ? undefined : i, n = 1), t = Object(t); ++r < n; ) {
        var c = e[r];
        c && s(t, c, r, i);
      }
      return t;
    });
  }
  var aC = "[object Object]", oC = Function.prototype, cC = Object.prototype, Xm = oC.toString, dC = cC.hasOwnProperty, lC = Xm.call(Object);
  function uC(s) {
    if (!Pr(s) || Pn(s) != aC)
      return false;
    var t = Gl(s);
    if (t === null)
      return true;
    var e = dC.call(t, "constructor") && t.constructor;
    return typeof e == "function" && e instanceof e && Xm.call(e) == lC;
  }
  var pC = "__lodash_hash_undefined__";
  function hC(s) {
    return this.__data__.set(s, pC), this;
  }
  function mC(s) {
    return this.__data__.has(s);
  }
  function sc(s) {
    var t = -1, e = s == null ? 0 : s.length;
    for (this.__data__ = new kn(); ++t < e; )
      this.add(s[t]);
  }
  sc.prototype.add = sc.prototype.push = hC;
  sc.prototype.has = mC;
  function fC(s, t) {
    for (var e = -1, r = s == null ? 0 : s.length; ++e < r; )
      if (t(s[e], e, s))
        return true;
    return false;
  }
  function gC(s, t) {
    return s.has(t);
  }
  var vC = 1, yC = 2;
  function Zm(s, t, e, r, n, i) {
    var a = e & vC, c = s.length, d = t.length;
    if (c != d && !(a && d > c))
      return false;
    var p = i.get(s), h = i.get(t);
    if (p && h)
      return p == t && h == s;
    var m = -1, g = true, T = e & yC ? new sc() : undefined;
    for (i.set(s, t), i.set(t, s); ++m < c; ) {
      var y = s[m], b = t[m];
      if (r)
        var A = a ? r(b, y, m, t, s, i) : r(y, b, m, s, t, i);
      if (A !== undefined) {
        if (A)
          continue;
        g = false;
        break;
      }
      if (T) {
        if (!fC(t, function(I, $) {
          if (!gC(T, $) && (y === I || n(y, I, e, r, i)))
            return T.push($);
        })) {
          g = false;
          break;
        }
      } else if (!(y === b || n(y, b, e, r, i))) {
        g = false;
        break;
      }
    }
    return i.delete(s), i.delete(t), g;
  }
  function TC(s) {
    var t = -1, e = Array(s.size);
    return s.forEach(function(r, n) {
      e[++t] = [n, r];
    }), e;
  }
  function _C(s) {
    var t = -1, e = Array(s.size);
    return s.forEach(function(r) {
      e[++t] = r;
    }), e;
  }
  var SC = 1, EC = 2, CC = "[object Boolean]", wC = "[object Date]", PC = "[object Error]", RC = "[object Map]", bC = "[object Number]", kC = "[object RegExp]", IC = "[object Set]", AC = "[object String]", DC = "[object Symbol]", MC = "[object ArrayBuffer]", OC = "[object DataView]", bp = Ms ? Ms.prototype : undefined, Nd = bp ? bp.valueOf : undefined;
  function NC(s, t, e, r, n, i, a) {
    switch (e) {
      case OC:
        if (s.byteLength != t.byteLength || s.byteOffset != t.byteOffset)
          return false;
        s = s.buffer, t = t.buffer;
      case MC:
        return !(s.byteLength != t.byteLength || !i(new rc(s), new rc(t)));
      case CC:
      case wC:
      case bC:
        return ho(+s, +t);
      case PC:
        return s.name == t.name && s.message == t.message;
      case kC:
      case AC:
        return s == t + "";
      case RC:
        var c = TC;
      case IC:
        var d = r & SC;
        if (c || (c = _C), s.size != t.size && !d)
          return false;
        var p = a.get(s);
        if (p)
          return p == t;
        r |= EC, a.set(s, t);
        var h = Zm(c(s), c(t), r, n, i, a);
        return a.delete(s), h;
      case DC:
        if (Nd)
          return Nd.call(s) == Nd.call(t);
    }
    return false;
  }
  var LC = 1, xC = Object.prototype, $C = xC.hasOwnProperty;
  function UC(s, t, e, r, n, i) {
    var a = e & LC, c = Zd(s), d = c.length, p = Zd(t), h = p.length;
    if (d != h && !a)
      return false;
    for (var m = d; m--; ) {
      var g = c[m];
      if (!(a ? g in t : $C.call(t, g)))
        return false;
    }
    var T = i.get(s), y = i.get(t);
    if (T && y)
      return T == t && y == s;
    var b = true;
    i.set(s, t), i.set(t, s);
    for (var A = a; ++m < d; ) {
      g = c[m];
      var I = s[g], $ = t[g];
      if (r)
        var V = a ? r($, I, g, t, s, i) : r(I, $, g, s, t, i);
      if (!(V === undefined ? I === $ || n(I, $, e, r, i) : V)) {
        b = false;
        break;
      }
      A || (A = g == "constructor");
    }
    if (b && !A) {
      var O = s.constructor, q = t.constructor;
      O != q && "constructor" in s && "constructor" in t && !(typeof O == "function" && O instanceof O && typeof q == "function" && q instanceof q) && (b = false);
    }
    return i.delete(s), i.delete(t), b;
  }
  var FC = 1, kp = "[object Arguments]", Ip = "[object Array]", Po = "[object Object]", VC = Object.prototype, Ap = VC.hasOwnProperty;
  function HC(s, t, e, r, n, i) {
    var a = Os(s), c = Os(t), d = a ? Ip : Oi(s), p = c ? Ip : Oi(t);
    d = d == kp ? Po : d, p = p == kp ? Po : p;
    var h = d == Po, m = p == Po, g = d == p;
    if (g && Di(s)) {
      if (!Di(t))
        return false;
      a = true, h = false;
    }
    if (g && !h)
      return i || (i = new Cr()), a || Kc(s) ? Zm(s, t, e, r, n, i) : NC(s, t, d, e, r, n, i);
    if (!(e & FC)) {
      var T = h && Ap.call(s, "__wrapped__"), y = m && Ap.call(t, "__wrapped__");
      if (T || y) {
        var b = T ? s.value() : s, A = y ? t.value() : t;
        return i || (i = new Cr()), n(b, A, e, r, i);
      }
    }
    return g ? (i || (i = new Cr()), UC(s, t, e, r, n, i)) : false;
  }
  function ef(s, t, e, r, n) {
    return s === t ? true : s == null || t == null || !Pr(s) && !Pr(t) ? s !== s && t !== t : HC(s, t, e, r, ef, n);
  }
  function BC(s) {
    return function(t, e, r) {
      for (var n = -1, i = Object(t), a = r(t), c = a.length; c--; ) {
        var d = a[++n];
        if (e(i[d], d, i) === false)
          break;
      }
      return t;
    };
  }
  var qC = BC();
  const jC = qC;
  var GC = function() {
    return ir.Date.now();
  };
  const Ld = GC;
  var JC = "Expected a function", WC = Math.max, KC = Math.min;
  function zr(s, t, e) {
    var r, n, i, a, c, d, p = 0, h = false, m = false, g = true;
    if (typeof s != "function")
      throw new TypeError(JC);
    t = Pp(t) || 0, nr(e) && (h = !!e.leading, m = "maxWait" in e, i = m ? WC(Pp(e.maxWait) || 0, t) : i, g = "trailing" in e ? !!e.trailing : g);
    function T(B) {
      var ne = r, Y = n;
      return r = n = undefined, p = B, a = s.apply(Y, ne), a;
    }
    function y(B) {
      return p = B, c = setTimeout(I, t), h ? T(B) : a;
    }
    function b(B) {
      var ne = B - d, Y = B - p, we = t - ne;
      return m ? KC(we, i - Y) : we;
    }
    function A(B) {
      var ne = B - d, Y = B - p;
      return d === undefined || ne >= t || ne < 0 || m && Y >= i;
    }
    function I() {
      var B = Ld();
      if (A(B))
        return $(B);
      c = setTimeout(I, b(B));
    }
    function $(B) {
      return c = undefined, g && r ? T(B) : (r = n = undefined, a);
    }
    function V() {
      c !== undefined && clearTimeout(c), p = 0, r = d = n = c = undefined;
    }
    function O() {
      return c === undefined ? a : $(Ld());
    }
    function q() {
      var B = Ld(), ne = A(B);
      if (r = arguments, n = this, d = B, ne) {
        if (c === undefined)
          return y(d);
        if (m)
          return clearTimeout(c), c = setTimeout(I, t), T(d);
      }
      return c === undefined && (c = setTimeout(I, t)), a;
    }
    return q.cancel = V, q.flush = O, q;
  }
  function nl(s, t, e) {
    (e !== undefined && !ho(s[t], e) || e === undefined && !(t in s)) && Hl(s, t, e);
  }
  function zC(s) {
    return Pr(s) && fo(s);
  }
  function il(s, t) {
    if (!(t === "constructor" && typeof s[t] == "function") && t != "__proto__")
      return s[t];
  }
  function YC(s) {
    return mo(s, go(s));
  }
  function QC(s, t, e, r, n, i, a) {
    var c = il(s, e), d = il(t, e), p = a.get(d);
    if (p) {
      nl(s, e, p);
      return;
    }
    var h = i ? i(c, d, e + "", s, t, a) : undefined, m = h === undefined;
    if (m) {
      var g = Os(d), T = !g && Di(d), y = !g && !T && Kc(d);
      h = d, g || T || y ? Os(c) ? h = c : zC(c) ? h = $m(c) : T ? (m = false, h = xm(d, true)) : y ? (m = false, h = Bm(d, true)) : h = [] : uC(d) || tc(d) ? (h = c, tc(c) ? h = YC(c) : (!nr(c) || Vl(c)) && (h = qm(d))) : m = false;
    }
    m && (a.set(d, h), n(h, d, r, i, a), a.delete(d)), nl(s, e, h);
  }
  function tf(s, t, e, r, n) {
    s !== t && jC(t, function(i, a) {
      if (n || (n = new Cr()), nr(i))
        QC(s, t, a, e, tf, r, n);
      else {
        var c = r ? r(il(s, a), i, a + "", s, t, n) : undefined;
        c === undefined && (c = i), nl(s, a, c);
      }
    }, go);
  }
  var XC = "[object Map]", ZC = "[object Set]", ew = Object.prototype, tw = ew.hasOwnProperty;
  function rw(s) {
    if (s == null)
      return true;
    if (fo(s) && (Os(s) || typeof s == "string" || typeof s.splice == "function" || Di(s) || Kc(s) || tc(s)))
      return !s.length;
    var t = Oi(s);
    if (t == XC || t == ZC)
      return !s.size;
    if (zc(s))
      return !Nm(s).length;
    for (var e in s)
      if (tw.call(s, e))
        return false;
    return true;
  }
  function sw(s, t) {
    return ef(s, t);
  }
  var nw = iC(function(s, t, e) {
    tf(s, t, e);
  });
  const ss = nw;
  var al = /* @__PURE__ */ ((s) => (s.PARTICIPANT = "PARTICIPANT", s.PEER = "PEER", s.CLIENT = "CLIENT", s))(al || {});
  const ie = {
    PROPAGATE_KICK_ALL: "propagate_kick_across_rooms",
    REFRESH_ID_ON_DISCONNECTION: "refresh_id_on_disconnection",
    SIMULCAST: "simulcast",
    CHAT_SOCKET_SERVER: "chat_socket_server",
    POLL_SOCKET_SERVER: "poll_socket_server",
    PLUGIN_SOCKET_SERVER: "plugin_socket_server",
    NR_OTEL_WEB: "nr_otel_web",
    ICE_RESTART_ON_FAILED_STATE: "ice_restart_on_failed_state",
    ICE_RESTART_ON_DISCONNECTED_STATE: "ice_restart_on_disconnected_state",
    ENABLE_ICE_STATE_LOGGING: "enable_ice_state_logging",
    SUPPRESS_PEER_MUTE_UNMUTE_EMITS: "web_core_suppress_peer_mute_unmute_emits",
    SKIP_OTEL_TRACES: "skip_otel_traces",
    USE_USERIDS_IN_CHAT: "use_userids_in_chat",
    CUSTOM_PING_PONG: "custom_ping_pong",
    // NOTE(itzmanish) below flags is added by me
    ENABLE_HIVE_SIMULCAST: "enable_hive_simulcast",
    ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_hive_transport_reconnection_on_ice_failed",
    ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY: "enable_hive_fail_recovery",
    ENABLE_HIVE_INFINITE_RETRIES: "enable_hive_infinite_retries",
    HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "hive_transport_force_relay_on_ice_failed",
    ENABLE_HIVE_CONSUME_OVER_DC: "enable_hive_consume_over_dc",
    // ==========================================
    // NOTE(ravindra-dyte) replicating hive flags for CF, need to remove if not needed
    ENABLE_CF_SIMULCAST: "enable_cf_simulcast",
    ENABLE_CF_TRANSPORT_RECONNECTION_ON_ICE_FAILED: "enable_cf_transport_reconnection_on_ice_failed",
    ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY: "enable_cf_fail_recovery",
    ENABLE_CF_INFINITE_RETRIES: "enable_cf_infinite_retries",
    CF_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED: "cf_transport_force_relay_on_ice_failed",
    // ==========================================
    BYPASS_LOG_EXCLUSION_LIST: "bypass_log_exclusion_list",
    LOG_LEVEL: "log_level",
    V1_PLUGINS: "v1_plugins",
    SCREENSHARE_DTX: "screenshare_dtx",
    SCREENSHARE_PRIORITY: "screenshare_priority",
    SCREENSHARE_MIN_BITRATE: "screenshare_minbitrate",
    SCREENSHARE_SIMULCAST: "screenshare_simulcast",
    DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE: "disable_webcam_layers_on_screenshare",
    SCREENSHARE_FORCE_GOOG_CONFERENCE: "screenshare_force_goog_conference",
    LIVESTREAM: "feat_livestream",
    FETCH_RETRY: "fetch_retry",
    DISABLE_WEBCAM_SIMULCAST: "webcore_disable_webcam_simulcast",
    OVERRIDE_WEBCAM_SIMULCAST: "override_webcam_simulcast",
    SOCKET_POLLING: "socket_polling",
    FEAT_PAGINATED_CHAT: "feat_paginated_chat",
    VAL_MIN_FRAMERATE: "val_min_framerate",
    SCREEENSHARE_ERR_HACK: "screenshare_err_hack",
    SCREEENSHARE_CONSTRAINTS_RETRY: "screenshare_constraints_retry",
    TROUBLESHOOTING: "feat_troubleshooting",
    VIDEO_CONSTRAINTS: "video_constraints",
    SCREENSHARE_CONSTRAINTS: "screenshare_constraints",
    FEAT_CHAT_SDK: "feat_chat_sdk",
    FEAT_CHAT_SDK_SEARCH: "chat_search",
    OBS_QUALITY: "obs_quality",
    ALLOW_SAFARI_MEDIA_MIDDLEWARES: "allow_safari_media_middlewares",
    DYNAMIC_VIDEO_QUALITY: "dynamic_video_quality",
    EXP_RESHARE: "exp_reshare",
    LEAVE_STAGE_ON_END: "leave_stage_on_end",
    SKIP_SETTING_IN_USE_DEVICE: "skip_setting_in_use_device",
    PRECALL_BANDWIDTH_TEST: "precall_bandwidth_test",
    CONSUMER_BIND_NO_RETRY: "consumer_bind_no_retry",
    DEBUG_SOCKET_JOIN: "debug_socket_join"
  };
  function Fo(s) {
    const t = {};
    return typeof (s == null ? undefined : s.code) == "number" && (t.code = s.code), typeof (s == null ? undefined : s.code) == "string" && (t.code = s.code.substring(0, 100)), typeof (s == null ? undefined : s.name) == "string" && (t.name = s.name.substring(0, 500)), typeof (s == null ? undefined : s.message) == "string" && (t.message = s.message.substring(0, 500)), typeof (s == null ? undefined : s.reason) == "string" && (t.reason = s.reason.substring(0, 500)), typeof (s == null ? undefined : s.stack) == "string" && (t.stack = s.stack.substring(0, 500)), t;
  }
  function rf(s) {
    var r, n, i, a;
    const t = typeof navigator != "undefined" && !navigator.isReactNative && typeof window != "undefined" && ((r = window.location.host) == null ? undefined : r.includes("devel")) && ((n = window.location.host) == null ? undefined : n.includes("dyte.io")), e = !!((a = (i = s == null ? undefined : s.getValue("modules")) == null ? undefined : i.devTools) != null && a.logs);
    return t || e;
  }
  function iw(s) {
    if (K.hasFeature(ie.LOG_LEVEL)) {
      let t = K.getValue(ie.LOG_LEVEL) || "all";
      if (t = t.toLowerCase().trim(), t === "off")
        return false;
      if (t !== "all") {
        const e = ["debug", "log", "info", "warn", "error"], r = e.indexOf(
          s
        ), n = e.indexOf(t);
        if (r < n)
          return false;
      }
    }
    return true;
  }
  function sf(s, t, e = {}) {
    return Object.getOwnPropertyNames(s).forEach((r) => {
      var i;
      if ([null, undefined, NaN].includes(s[r]) || t && (((i = t.match(/\./g)) == null ? undefined : i.length) || 0) >= 10)
        return;
      const n = t ? `${t}.${r}` : r;
      typeof s[r] == "object" ? sf(s[r], n, e) : ["number", "string", "boolean"].includes(typeof s[r]) && (e[n] = s[r]);
    }), e;
  }
  function Dp(s, t, e = {}, r = "") {
    const n = {};
    try {
      const i = JSON.stringify(e), a = JSON.parse(i), c = sf(
        a,
        r
      ), d = JSON.stringify(c);
      if (d.length > 5e3) {
        const p = `Log named: "${t}" is trying to log an flattened object of size 
			${d.length} chars that is beyond permitted limit of 5000 chars. Please optimize.`;
        throw rf(s) && console.error(p, {
          log: e,
          flattened: d
        }), new Error(p);
      }
      return JSON.parse(d);
    } catch (i) {
      const a = Fo(i);
      n[`${r}.error.message`] = a.message || "", n[`${r}.error.stack`] = a.stack || "", n[`${r}.error.reason`] = a.reason || "", n[`${r}.error.source`] = "safelyFlattenObjForOpenTelemetry";
    }
    return n;
  }
  const Ea = "chrome", nf = "opera", af = "firefox", of = "iexplorer", cf = "safari", df = "nwjs", lf = "electron", uf = "react-native", zl = "unknown", nc = {
    Chrome: Ea,
    Chromium: Ea,
    Opera: nf,
    Firefox: af,
    "Internet Explorer": of,
    Safari: cf
  };
  function aw() {
    const { userAgent: s } = navigator, t = {
      name: zl,
      version: undefined
    };
    if (s.match(/Chrome/) && !s.match(/Edge/))
      if (s.match(/Edg(A?)/)) {
        const e = s.match(/Chrome\/([\d.]+)/)[1];
        Number.parseInt(e, 10) > 72 && (t.name = Ea, t.version = e);
      } else
        t.name = Ea, t.version = s.match(/Chrome\/([\d.]+)/)[1];
    return t;
  }
  function ow() {
    const { userAgent: s } = navigator;
    if (s.match(/Electron/)) {
      const t = s.match(/Electron\/([\d.]+)/)[1];
      return {
        name: lf,
        version: t
      };
    }
    return null;
  }
  function cw() {
    const { userAgent: s } = navigator;
    if (s.match(/JitsiMeetNW/)) {
      const t = s.match(/JitsiMeetNW\/([\d.]+)/)[1];
      return {
        name: df,
        version: t
      };
    }
  }
  function dw() {
    const s = navigator.userAgent.match(
      /\b(react[ \t_-]*native)(?:\/(\S+))?/i
    );
    let t;
    if (s || navigator.product === "ReactNative")
      return s && s.length > 2 && (s[1], t = s[2]), t || (t = "unknown"), {
        name: uf,
        version: t
      };
  }
  function lw(s) {
    let t;
    const e = [dw, ow, cw];
    for (let n = 0; n < e.length; n += 1)
      if (t = e[n](), t)
        return t;
    const r = s.getBrowserName();
    return r in nc ? {
      name: nc[r],
      version: s.getBrowserVersion()
    } : (t = aw(), t || {
      name: zl,
      version: undefined
    });
  }
  class uw {
    constructor() {
      f(this, "_bowser");
      f(this, "_name");
      f(this, "_version");
      f(this, "getDeviceInfo", () => ({
        isMobile: this.isMobile(),
        browserName: this._bowser.getBrowserName(),
        osName: this._bowser.getOSName(),
        browserVersion: this._bowser.getBrowserVersion(),
        osVersionName: this._bowser.getOSVersion(),
        engineName: this._bowser.getEngineName()
      }));
    }
    /**
     * Creates new BrowserDetection instance.
     *
     * @param {Object} [browserInfo] - Information about the browser.
     * @param {string} browserInfo.name - The name of the browser.
     * @param {string} browserInfo.version - The version of the browser.
     */
    init(t) {
      let e, r;
      if (this._bowser = Bowser.getParser(navigator.userAgent), typeof t == "undefined") {
        const n = lw(this._bowser);
        e = n.name, r = n.version;
      } else
        t.name in nc ? (e = nc[t.name], r = t.version) : (e = zl, r = undefined);
      this._name = e, this._version = r;
    }
    /**
     * Gets current browser name.
     * @returns {string}
     */
    getName() {
      return this._name;
    }
    /**
     * Checks if current browser is Chrome.
     * @returns {boolean}
     */
    isChrome() {
      return this._name === Ea;
    }
    /**
     * Checks if current browser is Opera.
     * @returns {boolean}
     */
    isOpera() {
      return this._name === nf;
    }
    /**
     * Checks if current browser is Firefox.
     * @returns {boolean}
     */
    isFirefox() {
      return this._name === af;
    }
    /**
     * Checks if current browser is Internet Explorer.
     * @returns {boolean}
     */
    isIExplorer() {
      return this._name === of;
    }
    /**
     * Checks if current browser is Safari.
     * @returns {boolean}
     */
    isSafari() {
      return this._name === cf;
    }
    /**
     * Checks if current environment is NWJS.
     * @returns {boolean}
     */
    isNWJS() {
      return this._name === df;
    }
    /**
     * Checks if current environment is Electron.
     * @returns {boolean}
     */
    isElectron() {
      return this._name === lf;
    }
    /**
     * Checks if current environment is React Native.
     * @returns {boolean}
     */
    isReactNative() {
      return this._name === uf || navigator.isReactNative === true;
    }
    /**
     * Returns the version of the current browser.
     * @returns {string}
     */
    getVersion() {
      return this._version;
    }
    isMobile() {
      return this._bowser.getPlatformType() === "mobile";
    }
    /**
     * Check if the parsed browser matches the passed condition.
     *
     * @param {Object} checkTree - It's one or two layered object, which can include a
     * platform or an OS on the first layer and should have browsers specs on the
     * bottom layer.
     * Eg. { chrome: '>71.1.0' }
     *		 { windows: { chrome: '<70.2' } }
     * @returns {boolean | undefined} - Returns true if the browser satisfies the set
     * conditions, false if not and undefined when the browser is not defined in the
     * checktree object or when the current browser's version is unknown.
     * @private
     */
    _checkCondition(t) {
      if (this._version)
        return this._bowser.satisfies(t);
    }
    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * greater than the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     */
    isVersionGreaterThan(t) {
      return this._checkCondition({ [this._name]: `>${t}` });
    }
    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * lower than the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     */
    isVersionLessThan(t) {
      return this._checkCondition({ [this._name]: `<${t}` });
    }
    /**
     * Compares the passed version with the current browser version.
     *
     * @param {*} version - The version to compare with. Anything different
     * than string will be converted to string.
     * @returns {boolean|undefined} - Returns true if the current version is
     * equal to the passed version and false otherwise. Returns undefined if
     * the current browser version is unknown.
     * A loose-equality operator is used here so that it matches the sub-versions as well.
     */
    isVersionEqualTo(t) {
      return this._checkCondition({ [this._name]: `~${t}` });
    }
  }
  class pw extends uw {
    /**
     * Tells whether or not the <tt>MediaStream/tt> is removed from
     * the <tt>PeerConnection</tt> and disposed on video mute (in order to turn
     * off the camera device).
     * @return {boolean} <tt>true</tt> if the current browser supports this
     * strategy or <tt>false</tt> otherwise.
     */
    doesVideoMuteByStreamRemove() {
      return this.isChromiumBased() || this.isWebKitBased();
    }
    /**
     * Check whether or not the current browser support peer to peer connections
     * @return {boolean} <tt>true</tt> if p2p is supported or <tt>false</tt>
     * otherwise.
     */
    supportsP2P() {
      return !this.usesUnifiedPlan();
    }
    /**
     * Checks if the current browser is Chromium based, that is, it's either
     * Chrome / Chromium or uses it as its engine, but doesn't identify as
     * Chrome.
     *
     * This includes the following browsers:
     * - Chrome and Chromium
     * - Other browsers which use the Chrome engine, but are detected as Chrome,
     *	 such as Brave and Vivaldi
     * - Browsers which are NOT Chrome but use it as their engine, and have
     *	 custom detection code: Opera, Electron and NW.JS
     */
    isChromiumBased() {
      return this.isChrome() || this.isElectron() || this.isNWJS() || this.isOpera();
    }
    /**
     * Checks if the current browser is WebKit based. It's either
     * Safari or uses WebKit as its engine.
     *
     * This includes Chrome and Firefox on iOS
     *
     * @returns {boolean}
     */
    isWebKitBased() {
      return this._bowser.isEngine("webkit") && typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getUserMedia != "undefined" && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(RTCRtpTransceiver.prototype).indexOf("currentDirection") > -1;
    }
    /**
     * Checks if the current browser is supported.
     *
     * @returns {boolean} true if the browser is supported, false otherwise.
     */
    isSupported() {
      return typeof RTCPeerConnection != "undefined";
    }
    /**
     * Returns whether or not the current environment needs a user interaction
     * with the page before any unmute can occur.
     *
     * @returns {boolean}
     */
    isUserInteractionRequiredForUnmute() {
      return this.isFirefox() && this.isVersionLessThan("68");
    }
    /**
     * Checks if the current browser triggers 'onmute'/'onunmute' events when
     * user's connection is interrupted and the video stops playback.
     * @returns {*|boolean} 'true' if the event is supported or 'false'
     * otherwise.
     */
    supportsVideoMuteOnConnInterrupted() {
      return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
    }
    /**
     * Checks if the current browser reports upload and download bandwidth
     * statistics.
     * @return {boolean}
     */
    supportsBandwidthStatistics() {
      return !this.isFirefox() && !this.isWebKitBased();
    }
    /**
     * Checks if the current browser supports setting codec preferences on the transceiver.
     * @returns {boolean}
     */
    supportsCodecPreferences() {
      return this.usesUnifiedPlan() && typeof window.RTCRtpTransceiver != "undefined" && Object.keys(window.RTCRtpTransceiver.prototype).indexOf(
        "setCodecPreferences"
      ) > -1 && Object.keys(RTCRtpSender.prototype).indexOf("getCapabilities") > -1 && !this.isWebKitBased();
    }
    /**
     * Checks if the current browser support the device change event.
     * @return {boolean}
     */
    // eslint-disable-next-line class-methods-use-this
    supportsDeviceChangeEvent() {
      return navigator.mediaDevices && typeof navigator.mediaDevices.ondevicechange != "undefined" && typeof navigator.mediaDevices.addEventListener != "undefined";
    }
    /**
     * Checks if the current browser supports RTT statistics for srflx local
     * candidates through the legacy getStats() API.
     */
    supportsLocalCandidateRttStatistics() {
      return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
    }
    /**
     * Checks if the current browser supports the Long Tasks API that lets us observe
     * performance measurement events and be notified of tasks that take longer than
     * 50ms to execute on the main thread.
     */
    supportsPerformanceObserver() {
      return typeof window.PerformanceObserver != "undefined" && PerformanceObserver.supportedEntryTypes.indexOf("longtask") > -1;
    }
    /**
     * Checks if the current browser supports audio level stats on the receivers.
     */
    supportsReceiverStats() {
      return typeof window.RTCRtpReceiver != "undefined" && Object.keys(RTCRtpReceiver.prototype).indexOf(
        "getSynchronizationSources"
      ) > -1;
    }
    /**
     * Checks if the current browser reports round trip time statistics for
     * the ICE candidate pair.
     * @return {boolean}
     */
    supportsRTTStatistics() {
      return !this.isFirefox();
    }
    /**
     * Checks if the browser uses plan B.
     *
     * @returns {boolean}
     */
    usesPlanB() {
      return !this.usesUnifiedPlan();
    }
    /**
     * Checks if the browser uses SDP munging for turning on simulcast.
     *
     * @returns {boolean}
     */
    usesSdpMungingForSimulcast() {
      return this.isChromiumBased() || this.isReactNative() || this.isWebKitBased();
    }
    /**
     * Checks if the browser uses unified plan.
     *
     * @returns {boolean}
     */
    usesUnifiedPlan() {
      return !!(this.isFirefox() || this.isWebKitBased());
    }
    /**
     * Returns whether or not the current browser should be using the new
     * getUserMedia flow, which utilizes the adapter shim. This method should
     * be temporary and used while migrating all browsers to use adapter and
     * the new getUserMedia.
     *
     * @returns {boolean}
     */
    usesNewGumFlow() {
      return !!(this.isChromiumBased() || this.isFirefox() || this.isWebKitBased());
    }
    /**
     * Checks if the browser uses webrtc-adapter. All browsers using the new
     * getUserMedia flow.
     *
     * @returns {boolean}
     */
    usesAdapter() {
      return this.usesNewGumFlow();
    }
    /**
     * Checks if the browser uses RIDs/MIDs for siganling the simulcast streams
     * to the bridge instead of the ssrcs.
     */
    usesRidsForSimulcast() {
      return false;
    }
    /**
     * Checks if the browser supports getDisplayMedia.
     * @returns {boolean} {@code true} if the browser supports getDisplayMedia.
     */
    supportsGetDisplayMedia() {
      return typeof navigator.getDisplayMedia != "undefined" || typeof navigator.mediaDevices != "undefined" && typeof navigator.mediaDevices.getDisplayMedia != "undefined";
    }
    /**
     * Checks if the browser supports insertable streams, needed for E2EE.
     * @returns {boolean} {@code true} if the browser supports insertable streams.
     */
    supportsInsertableStreams() {
      if (!(typeof window.RTCRtpSender != "undefined" && (window.RTCRtpSender.prototype.createEncodedStreams || window.RTCRtpSender.prototype.createEncodedVideoStreams)))
        return false;
      const t = new ReadableStream();
      try {
        return window.postMessage(t, "*", [t]), !0;
      } catch (e) {
        return false;
      }
    }
    /**
     * Whether the browser supports the RED format for audio.
     */
    supportsAudioRed() {
      return Boolean(
        window.RTCRtpSender && window.RTCRtpSender.getCapabilities && window.RTCRtpSender.getCapabilities("audio").codecs.some(
          (t) => t.mimeType === "audio/red"
        ) && window.RTCRtpReceiver && window.RTCRtpReceiver.getCapabilities && window.RTCRtpReceiver.getCapabilities("audio").codecs.some(
          (t) => t.mimeType === "audio/red"
        )
      );
    }
    /**
     * Checks if the browser supports the "sdpSemantics" configuration option.
     * https://webrtc.org/web-apis/chrome/unified-plan/
     *
     * @returns {boolean}
     */
    supportsSdpSemantics() {
      return this.isChromiumBased();
    }
    /**
     * Returns the version of a Chromium based browser.
     *
     * @returns {Number}
     */
    _getChromiumBasedVersion() {
      if (this.isChromiumBased()) {
        if (this.isNWJS())
          return Number.parseInt(process.versions.chromium, 10);
        const t = navigator.userAgent;
        if (t.match(/Chrome/))
          return Number.parseInt(t.match(/Chrome\/([\d.]+)/)[1], 10);
      }
      return -1;
    }
    isIOSMobile() {
      return this.isMobile && this._bowser.getOSName() === "iOS";
    }
  }
  const ve = new pw(), hw = {
    audio: true,
    video: true,
    screenshareAudio: true,
    screenshareVideo: true
  }, oa = {
    baseURL: "http://localhost:5000",
    createdAt: "2021-08-05T10:49:56.602Z",
    description: "Develop plugins locally",
    id: "09259e3b-7be8-46f6-9801-106bf1866e1c",
    name: "Localhost Dev",
    organizationId: "4ad15a19-80e2-4105-bf43-48039fd2963e",
    picture: "https://dyte-uploads.s3.ap-south-1.amazonaws.com/dyte.png",
    private: false,
    published: true,
    staggered: false,
    tags: ["#localhost", "#dev"],
    type: "self_hosted",
    updatedAt: "2021-08-05T10:50:07.681Z"
  }, mw = {
    pip: true,
    poll: true,
    chat: true,
    stage: true,
    theme: true,
    plugin: true,
    tracing: true,
    internals: true,
    recording: true,
    livestream: true,
    participant: true,
    devTools: {
      logs: false
    }
  };
  function ol(s, t) {
    const e = s.getValue("overrides");
    return e && e[t] ? e[t] : false;
  }
  function fw({ baseURI: s }) {
    return s != null && s.includes("preprod.dyte") ? fa.PREPROD : s != null && s.includes("devel.dyte") ? fa.DEVEL : fa.PROD;
  }
  function jn({ servicePrefix: s, baseURI: t }) {
    return `${s}.${t}`;
  }
  function pf(s) {
    const t = s.getValue("baseURI");
    return {
      location: jn({
        servicePrefix: "location",
        baseURI: t
      }),
      locationLegacy: jn({
        servicePrefix: "location-legacy",
        baseURI: t
      }),
      daCollector: jn({
        servicePrefix: "da-collector",
        baseURI: t
      })
    };
  }
  const gw = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>', vw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 12.02c0 1.06.2 2.1.6 3.08l.6 1.42c.22.55.64 1.01 1.17 1.29.27.14.56.21.86.21h2.55c.77 0 1.49-.41 1.87-1.08.5-.87 1.02-1.7 1.72-2.43l1.32-1.39c.44-.46.97-.84 1.49-1.23l.59-.45a.6.6 0 0 0 .23-.47c0-.75-.54-1.57-1.22-1.79a3.34 3.34 0 0 0-2.78.29V4.5a1.5 1.5 0 0 0-2.05-1.4 1.5 1.5 0 0 0-2.9 0A1.5 1.5 0 0 0 6 4.5v.09A1.5 1.5 0 0 0 4 6v6.02ZM8 4.5v4a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0v5a.5.5 0 0 0 1 0v-4a.5.5 0 0 1 1 0v6a.5.5 0 0 0 .85.37h.01c.22-.22.44-.44.72-.58.7-.35 2.22-.57 2.4.5l-.53.4c-.52.4-1.04.78-1.48 1.24l-1.33 1.38c-.75.79-1.31 1.7-1.85 2.63-.21.36-.6.58-1.01.58H7.23a.87.87 0 0 1-.4-.1 1.55 1.55 0 0 1-.71-.78l-.59-1.42a7.09 7.09 0 0 1-.53-2.7V6a.5.5 0 0 1 1 0v3.5a.5.5 0 0 0 1 0v-5a.5.5 0 0 1 1 0Z" fill="currentColor"></path></svg>', Ro = (s) => {
    if (!s)
      return;
    if (!s.startsWith("<svg"))
      return new Promise((i) => {
        i(s);
      });
    const e = new Blob([s], { type: "image/svg+xml" }), r = new Image(), n = window.URL.createObjectURL(e);
    return new Promise((i, a) => {
      r.onload = () => {
        i(r), window.URL.revokeObjectURL(n);
      }, r.onerror = () => {
        a(), window.URL.revokeObjectURL(n);
      }, r.src = n;
    });
  };
  function yw(s) {
    const t = L({}, s), e = /* @__PURE__ */ new Map(), r = (p, h) => (e.has(p) || e.set(p, /* @__PURE__ */ new Set()), e.get(p).add(h), () => {
      var m;
      return (m = e.get(p)) == null ? undefined : m.delete(h);
    }), n = (p, h) => {
      var m;
      (m = e.get(p)) == null || m.delete(h);
    }, i = (p) => {
      var h;
      (h = e.get(p)) == null || h.forEach((m) => {
        try {
          m(t[p]);
        } catch (g) {
          l.error(`Error in notifying for "${p.toString()}"`, g);
        }
      });
    };
    return {
      subscribe: r,
      unsubscribe: n,
      notify: i,
      setValue: (p, h, m = true) => {
        t[p] = h, m && i(p);
      },
      getValue: (p) => t[p],
      getAllValues: () => t
    };
  }
  class Tw {
    constructor() {
      f(this, "contexts", /* @__PURE__ */ new Map());
    }
    createContext(t, e) {
      return this.contexts.has(t) ? this.contexts.get(t) : (this.contexts.set(t, yw(e)), this.contexts.get(t));
    }
    /**
     * NOTE(ishita1805): Used to remap the context
     * when we regnerate a peerId during reconnection.
     */
    remapContext(t, e) {
      const r = e.getValue("peerId");
      r !== t && (e.setValue("peerId", t), this.contexts.set(t, e), this.contexts.delete(r));
    }
    getContext(t) {
      return this.contexts.get(t);
    }
  }
  const va = new Tw(), pe = class {
    static get logsEndpoint() {
      const t = va.getContext(pe.meetingMetadata.peerId);
      return `https://${jn({
      servicePrefix: "api-silos",
      baseURI: t.getValue("baseURI")
    })}/otel/logs`;
    }
    static resetPeerId(t) {
      pe.meetingMetadata.peerId = t;
    }
    static init(t, e) {
      const r = t.getValue("peerId");
      pe.tracingEnabled = e, pe.meetingMetadata.peerId = r, pe.meetingMetadata.sdkVersion = t.getValue("sdkVersion"), pe.meetingMetadata.deviceInfo = ve.getDeviceInfo(), pe.meetingMetadata.visitedUrl = !navigator.isReactNative && typeof window != "undefined" && window.location.href, navigator.isReactNative || document.addEventListener(
        "visibilitychange",
        pe.processCachedLogs
      ), pe.logsProcessorTimer = setInterval(
        pe.processCachedLogs,
        pe.logsProcessingInterval
      ), e && (pe.initialized = true);
    }
    static trace(t) {
      return (e, r, n) => {
        const i = n.value;
        return n.value = function(...c) {
          if (!pe.initialized || navigator.isReactNative || !pe.tracingEnabled || K.hasFeature(ie.SKIP_OTEL_TRACES))
            return i.apply(this, c);
          pe.addLogInCurrentSpan("info", t);
          const d = performance.now(), p = i.apply(this, c);
          return Promise.resolve(p).then(() => {
            const h = performance.now();
            h - d > 10 && pe.addLogInCurrentSpan("info", `${t}_timing`, {
              execTime: h - d,
              country: pe.location.country
            });
          }).catch(() => {
            const h = performance.now();
            pe.addLogInCurrentSpan("info", `${t}_timing`, {
              execTime: h - d
            });
          }), p;
        }, n;
      };
    }
    static injectContext(t) {
      var n;
      const e = v4().replace(/-/g, "").substring(0, 16), r = (n = pe.meetingMetadata.peerId) == null ? undefined : n.replace(/-/g, "");
      t.TRACEPARENT = `00-${r}-${e}-01`;
    }
    /**
     * Adds event into the current span or the main span.
     * Event(or this method) is not a replacement for a log.
     * Tip :: Heavy objects should be logged.
     * Tip :: Light objects with `to the point` info should be added as events.
     * @param eventSeverity severity of the passed event to create better dashboards
     * @param eventName name of event in format
     *	fileName::functionName::eventName or functionName::eventName or whatever seems fit
     * @param metadata pass any information which makes sense for analytics or debugging
     * @param noCache optionally pass if log can be cached in FE or it has to be sent instantly
     * @returns nothing
     */
    static addLogInCurrentSpan(t, e, r = {}, n = false) {
      r != null && r.error && Object.assign(r, { error: Fo(r.error) });
      const i = va.getContext(pe.meetingMetadata.peerId);
      if (rf(i) && (rw(r) ? console[t]("DyteInternalLogs:: ", t, e) : console[t](
        "DyteInternalLogs:: ",
        t,
        e,
        r
      )), !!iw(t))
        try {
          const c = Dp(
            i,
            e,
            r,
            "metadata"
          ), d = new Date(), p = z(L({
            message: e,
            level: t
          }, c), {
            loggedAt: d.toISOString(),
            loggedAtTzOffset: d.getTimezoneOffset()
          });
          n ? pe.sendOtelLogsToNewRelic([p]) : pe.logsCache.push(p);
        } catch (c) {
          pe.addLogInCurrentSpan(
            "error",
            "opentelemetry::addLogInCurrentSpan_failed",
            {
              error: Fo(c)
            }
          );
        }
    }
    static sendOtelLogsToNewRelic(t) {
      const e = va.getContext(pe.meetingMetadata.peerId);
      Zo.post(pe.logsEndpoint, {
        meetingMetadata: Dp(
          e,
          "sendOtelLogsToNewRelic",
          pe.meetingMetadata,
          "meetingMetadata"
        ),
        serviceName: e.getValue("sdkName"),
        logs: t
      }).catch((r) => {
        pe.addLogInCurrentSpan(
          "error",
          "opentelemetry::sendOtelLogToNewRelic_failed",
          {
            error: Fo(r)
          }
        ), pe.logsCache.push(...t);
      });
    }
    static processCachedLogs() {
      const t = pe.logsCache.splice(0, 25);
      t != null && t.length && pe.sendOtelLogsToNewRelic(t);
    }
    static destruct() {
      clearInterval(pe.logsProcessorTimer), pe.processCachedLogs(), navigator.isReactNative || document.removeEventListener(
        "visibilitychange",
        pe.processCachedLogs
      );
    }
  };
  let v = pe;
  f(v, "logsCache", []), f(v, "logsProcessorTimer"), f(v, "location", {
    country: undefined
  }), f(v, "tracingEnabled", true), f(v, "initialized", false), /**
   * NOTE(ravindra-dyte)
   * Periodically send logs to Log Aggregator. Current period: 7 secs
   */
  f(v, "logsProcessingInterval", 7e3), f(v, "logExclusionList", [
    "message",
    "websocket/message",
    "roomMessage",
    "websocket/room-message",
    "websocket/room-legacy-mode",
    "chatMessage",
    "websocket/new-chat-message",
    "websocket/no-active-speaker",
    "websocket/selected-peers",
    "websocket/active-speaker",
    "ping",
    "websocket/new-consumer",
    "websocket/producer-score",
    "websocket/consumer-score",
    "websocket/plugin-event",
    "websocket/plugin-data",
    "websocket/plugin-internal-data"
  ]), f(v, "meetingMetadata", {});
  class l {
    static info(t, e, r) {
      v.addLogInCurrentSpan(
        "info",
        t,
        e,
        r
      );
    }
    static error(t, e, r) {
      v.addLogInCurrentSpan(
        "error",
        t,
        e,
        r
      );
    }
    static debug(t, e, r) {
      v.addLogInCurrentSpan(
        "debug",
        t,
        e,
        r
      );
    }
    static log(t, e, r) {
      v.addLogInCurrentSpan(
        "log",
        t,
        e,
        r
      );
    }
    static warn(t, e, r) {
      v.addLogInCurrentSpan(
        "warn",
        t,
        e,
        r
      );
    }
  }
  const _w = () => {
    !navigator.isReactNative && typeof window != "undefined" && (window.addEventListener("error", (s) => {
      var t;
      !((t = s.filename) != null && t.includes("localhost")) && s.lineno !== 0 && l.error(
        "window::error",
        {
          error: s.error
        },
        true
      );
    }), window.addEventListener(
      "unhandledrejection",
      (s) => {
        var t, e, r, n, i, a, c, d;
        l.error(
          "window::unhandledrejection",
          {
            error: s == null ? undefined : s.reason,
            /**
                               * NOTE(ravindra-dyte):
                               * Network calls fail a lot for clients,
                               *	tracking more info to see where
                               *	*/
            networkCall: {
              url: (e = (t = s == null ? undefined : s.reason) == null ? undefined : t.config) == null ? undefined : e.url,
              baseURL: (n = (r = s == null ? undefined : s.reason) == null ? undefined : r.config) == null ? undefined : n.baseURL,
              method: (a = (i = s == null ? undefined : s.reason) == null ? undefined : i.config) == null ? undefined : a.method,
              status: (c = s == null ? undefined : s.reason) == null ? undefined : c.status,
              statusText: (d = s == null ? undefined : s.reason) == null ? undefined : d.statusText
            }
          },
          true
        );
      }
    ), window.addEventListener("offline", () => {
      l.info("window::offline");
    }), window.addEventListener("online", () => {
      l.info("window::online");
    }));
  }, Sw = {
    "00": "DyteClient",
    "01": "Controller",
    "02": "RoomNodeClient",
    "03": "HiveNodeClient",
    "04": "SocketService",
    "05": "Chat",
    "06": "Plugin",
    "07": "Polls",
    "08": "Meta",
    "09": "Preset",
    10: "Recording",
    11: "Self",
    12: "Participant",
    13: "Spotlight",
    14: "Remote Request",
    15: "Webinar",
    16: "LocalMediaHandler",
    17: "End-End Encryption"
  }, Vo = {
    "0000": "Internal exception.",
    "0001": "Failed to initialize.",
    "0002": "Failed to join room.",
    "0003": "Failed to leave room.",
    "0010": "Browser not supported",
    "0011": "HTTP Network Error",
    "0012": "Websocket Network Error",
    "0100": "Internal exception",
    "0200": "Internal exception.",
    "0300": "Internal exception",
    "0400": "Internal exception",
    "0500": "Internal exception",
    "0501": "Permission denied.",
    "0502": "Invalid message body.",
    "0510": "Invalid channel name.",
    "0600": "Internal exception",
    "0700": "Internal exception",
    "0800": "Internal exception",
    "0900": "Internal exception",
    1e3: "Internal exception",
    1100: "Internal exception",
    1200: "Internal exception",
    1300: "Internal exception",
    1400: "Internal exception",
    1500: "Internal exception",
    1600: "Internal exception",
    1601: "Failed to get audio track",
    1602: "Failed to get video track",
    1603: "Incorrect device",
    1604: "Failed to change device",
    1701: "Crypto error",
    9900: "Internal exception"
  };
  Object.keys(Vo).forEach((s) => {
    Vo[s] = `{${Sw[s.slice(0, 2)]}} ${Vo[s]}`;
  });
  class w extends Error {
    constructor(e, r, n = false) {
      super(e);
      f(this, "code");
      this.code = r, this.name = "DyteError", this.message = `[ERR${this.code}]: ${Vo[this.code]}
${this.message}`;
      try {
        let i = n;
        r && r.endsWith("00") && (i = !0), i && l.error("DyteError", {
          error: { message: this.message, name: this.name, code: r }
        });
      } catch (i) {
      }
    }
  }
  function bo(s, t, e, r) {
    if (r instanceof w)
      throw r;
    if (r instanceof t) {
      const n = new w(r.message, e);
      throw n.stack = r.stack, n;
    } else
      throw r;
  }
  function Mp(s, t, e) {
    if (!s.value) {
      const n = s.get, i = s.set;
      return n && (s.get = function() {
        try {
          return n.apply(this);
        } catch (a) {
          bo(this, t, e, a);
        }
      }), i && (s.set = function(a) {
        try {
          return i.apply(this, [a]);
        } catch (c) {
          bo(this, t, e, c);
        }
      }), s;
    }
    const r = s.value;
    return s.value = function(...n) {
      try {
        const i = r.apply(this, n);
        return i && i instanceof Promise ? i.catch((a) => {
          bo(this, t, e, a);
        }) : i;
      } catch (i) {
        bo(this, t, e, i);
      }
    }, s;
  }
  function Ew(s, t) {
    return (e, r, n) => {
      if (n)
        return Mp(n, s, t);
      for (const i of Reflect.ownKeys(e.prototype).filter(
        (a) => a !== "constructor"
      )) {
        const a = Object.getOwnPropertyDescriptor(
          e.prototype,
          i
        );
        (a.value instanceof Function || a.get instanceof Function || a.set instanceof Function) && Object.defineProperty(
          e.prototype,
          i,
          Mp(a, s, t)
        );
      }
    };
  }
  const vt = (s) => Ew(Error, s);
  function Cw(s) {
    let t = 0, e, r;
    if (!s)
      return t;
    for (e = 0; e < s.length; e += 1)
      r = s.charCodeAt(e), t = (t << 5) - t + r, t |= 0;
    return Math.abs(t) % 100 + 1;
  }
  var Mr, Or;
  const _u = class extends at.EventEmitter {
    constructor() {
      super();
      E(this, Mr, undefined);
      E(this, Or, undefined);
      f(this, "asyncPromiseTimeout");
      _(this, Mr, /* @__PURE__ */ new Map()), _(this, Or, /* @__PURE__ */ new Map()), this.asyncPromiseTimeout = 8e3;
    }
    emitAsync(e, ...r) {
      return u(this, null, function* () {
        o(this, Mr).set(e, []);
        const n = o(this, Or).get(e).map(
          () => new Promise((i) => {
            o(this, Mr).get(e).push(i);
          })
        );
        Pu(_u.prototype, this, "emit").call(this, e, ...r), yield Promise.race([
          Promise.all(n),
          new Promise(
            (i, a) => setTimeout(
              () => a(new Error(`emitAsync failed to resolve for event ${e}.`)),
              this.asyncPromiseTimeout
            )
          )
        ]), o(this, Mr).delete(e);
      });
    }
    onAsync(e, r) {
      const n = o(this, Mr), i = (...a) => u(this, null, function* () {
        var d;
        try {
          yield r(...a);
        } catch (p) {
          l.error("[onAsync]", { error: p });
        }
        const c = (d = n.get(e)) == null ? undefined : d.shift();
        c == null || c();
      });
      return o(this, Or).get(e) || o(this, Or).set(e, []), o(this, Or).get(e).push(i), super.on(e, i);
    }
    /**
     * removes all attached listeners
     */
    reset() {
      _(this, Mr, /* @__PURE__ */ new Map()), _(this, Or, /* @__PURE__ */ new Map()), super.removeAllListeners();
    }
  };
  let cl = _u;
  Mr = new WeakMap(), Or = new WeakMap();
  const R = new cl();
  function ww() {
    ve.isElectron() && window.dyteElectronGetDisplayMediaSource && (navigator.mediaDevices.getDisplayMedia = () => u(this, null, function* () {
      const s = yield window.dyteElectronGetDisplayMediaSource(
        {
          types: ["window", "screen"]
        }
      );
      let t = [];
      if (s && (Array.isArray(s) ? t = s : t = [s]), !(t != null && t.length))
        throw new Error("Couldn't find any media source for screen share.");
      let e = t.find(
        (i) => {
          var a;
          return (a = i.id) == null ? undefined : a.includes("screen");
        }
      );
      e = e != null ? e : t[0];
      const r = {
        audio: false,
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: e.id
          }
        }
      };
      return yield navigator.mediaDevices.getUserMedia(
        r
      );
    }));
  }
  var P = /* @__PURE__ */ ((s) => (s.NEW_PRODUCER = "NEW_PRODUCER", s.PRODUCER_TRACK_ENDED = "PRODUCER_TRACK_ENDED", s.ROOM_NODE_CONNECTION_ERROR = "ROOM_NODE_CONNECTION_ERROR", s.SOCKET_SERVICE_ROOM_JOINED = "SOCKET_SERVICE_ROOM_JOINED", s.SOCKET_SERVICE_RECONNECTED = "SOCKET_SERVICE_RECONNECTED", s.SOCKET_SERVICE_DISCONNECTED = "SOCKET_SERVICE_DISCONNECTED", s.SOCKET_SERVICE_FAILED = "SOCKET_SERVICE_FAILED", s.SOCKET_STATE_UPDATE = "SOCKET_STATE_UPDATE", s.ROOM_NODE_RECONNECTED = "ROOM_NODE_RECONNECTED", s.ROOM_NODE_DISCONNECTED = "ROOM_NODE_DISCONNECTED", s.ROOM_NODE_FAILED = "ROOM_NODE_FAILED", s.TRANSPORT_STATE_UPDATE = "TRANSPORT_STATE_UPDATE", s.PRODUCER_SCORE_UPDATE = "PRODUCER_SCORE_UPDATE", s.CONSUMER_SCORE_UPDATE = "CONSUMER_SCORE_UPDATE", s.PRODUCER_STATUS_UPDATE = "PRODUCER_STATUS_UPDATE", s.CONSUMER_STATUS_UPDATE = "CONSUMER_STATUS_UPDATE", s.LOW_PRODUCER_SCORE = "LOW_PRODUCER_SCORE", s.LOW_CONSUMER_SCORE = "LOW_CONSUMER_SCORE", s.MEDIA_PERMISSION_ERROR = "MEDIA_PERMISSION_ERROR", s.MEDIA_PERMISSION_UPDATE = "MEDIA_PERMISSION_UPDATE", s.WAITLISTED = "WAIT_LISTED", s.MESSAGE = "websocket/message", s.ROOM_MESSAGE = "websocket/room-message", s.PEER_JOINED_INTERNAL = "peer/joined-internal", s.PEER_CLOSED = "websocket/peer-closed", s.CONSUMER_CLOSED = "websocket/consumer-closed", s.CONSUMER_PAUSED = "websocket/consumer-paused", s.CONSUMER_RESUMED = "websocket/consumer-resumed", s.PRODUCER_CLOSED = "websocket/producer-closed", s.NEW_CONSUMER = "websocket/new-consumer", s.PRODUCER_SCORE = "websocket/producer-score", s.CONSUMER_SCORE = "websocket/consumer-score", s.PRODUCER_TOGGLE = "hive/producer-toggle", s.CONSUMER_TOGGLE = "hive/consumer-toggle", s.SELECTED_PEERS_DIFF = "hive/selected-peers-diff", s.UPDATE_ACTIVE = "media/update-active", s.RESET_PRODUCER_STATE = "hive/reset-producer-state", s.CF_TRANSPORT_STATE_CHANGED = "cf/transport-state-changed", s.CF_ROOM_REJOINING = "cf/room-rejoining", s.CF_ROOM_REJOIN_FAILED = "cf/room-rejoining-failed", s.CF_ROOM_REJOINED = "cf/room-rejoined", s.CF_TRANPSORT_RECONNECTING = "cf/transport-reconnecting", s.ROOM_STATE = "sockethub/room-state", s.PEER_DISPLAY_NAME_CHANGED = "hive/display-name-changed", s.GET_STAGE_REQUESTS = "GET_STAGE_REQUESTS", s.UPDATE_STAGE_REQUESTS = "UPDATE_STAGE_REQUESTS", s.KICK_PEER = "KICK_PEER", s.UPDATE_PEER_STAGE_STATUS = "UPDATE_PEER_STAGE_STATUS", s.JOIN_MEDIA_ROOM = "JOIN_MEDIA_ROOM", s.LEAVE_MEDIA_ROOM = "LEAVE_MEDIA_ROOM", s.PIP_HANGUP = "PIP_HANGUP", s.E2EE_ACTIVE_PRODUCER = "E2EE_ACTIVE_PRODUCER", s.E2EE_INACTIVE_PRODUCER = "E2EE_INACTIVE_PRODUCER", s.E2EE_ACTIVE_CONSUMER = "E2EE_ACTIVE_CONSUMER", s.E2EE_INACTIVE_CONSUMER = "E2EE_INACTIVE_CONSUMER", s.SOCKET_PEERS = "SOCKET_PEERS", s.UPDATE_PERMISSIONS = "UPDATE_PERMISSIONS", s.MAX_SPATIAL_LAYER_CHANGE = "MAX_SPATIAL_LAYER_CHANGE", s.MUTE_SELF = "MUTE_SELF", s.MUTE_SELF_VIDEO = "MUTE_SELF_VIDEO", s))(P || {});
  class $i extends at.EventEmitter {
    constructor() {
      super(), super.setMaxListeners(25);
    }
    emit(t, ...e) {
      return super.emit("*", t, ...e), super.emit(t, ...e);
    }
    on(t, e) {
      try {
        const r = this.listenerCount(t);
        r > 25 && r % 25 === 0 && l.warn("DyteEventEmitter::maxListenersExceeded", {
          eventListener: {
            eventName: t.toString(),
            listenerCount: this.listenerCount(t)
          }
        });
      } catch (r) {
      }
      return super.on(t, e);
    }
    addListener(t, e) {
      try {
        const r = this.listenerCount(t);
        r > 25 && r % 25 === 0 && l.warn("DyteEventEmitter::maxListenersExceeded", {
          eventListener: {
            eventName: t.toString(),
            listenerCount: this.listenerCount(t)
          }
        });
      } catch (r) {
      }
      return super.addListener(t, e);
    }
    off(t, e) {
      return super.off(t, e);
    }
    once(t, e) {
      return super.once(t, e);
    }
    prependListener(t, e) {
      return super.prependListener(t, e);
    }
    prependOnceListener(t, e) {
      return super.prependOnceListener(t, e);
    }
    removeListener(t, e) {
      return super.removeListener(t, e);
    }
    removeAllListeners(t) {
      return super.removeAllListeners(t);
    }
    listeners(t) {
      return super.listeners(t);
    }
    listenerCount(t) {
      return super.listenerCount(t);
    }
  }
  class Ft extends at.EventEmitter {
    constructor() {
      super(), super.setMaxListeners(25);
    }
    emit(t, ...e) {
      return super.emit("*", t, ...e), super.emit(t, ...e);
    }
    on(t, e) {
      try {
        const r = this.listenerCount(t);
        r > 25 && r % 25 === 0 && l.warn("DyteEventEmitter::maxListenersExceeded", {
          eventListener: {
            eventName: t.toString(),
            listenerCount: this.listenerCount(t)
          }
        });
      } catch (r) {
      }
      return super.on(t, e);
    }
    addListener(t, e) {
      try {
        const r = this.listenerCount(t);
        r > 25 && r % 25 === 0 && l.warn("DyteEventEmitter::maxListenersExceeded", {
          eventListener: {
            eventName: t.toString(),
            listenerCount: this.listenerCount(t)
          }
        });
      } catch (r) {
      }
      return super.addListener(t, e);
    }
    off(t, e) {
      return super.off(t, e);
    }
    once(t, e) {
      return super.once(t, e);
    }
    prependListener(t, e) {
      return super.prependListener(t, e);
    }
    prependOnceListener(t, e) {
      return super.prependOnceListener(t, e);
    }
    removeListener(t, e) {
      return super.removeListener(t, e);
    }
    removeAllListeners(t) {
      return super.removeAllListeners(t);
    }
    listeners(t) {
      return super.listeners(t);
    }
    listenerCount(t) {
      return super.listenerCount(t);
    }
  }
  function Pw(s, t = 2) {
    return s.replace(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/g, "").trim().split(/\s+/).slice(0, t).map((n) => n.charAt(0)).join("").toUpperCase();
  }
  const Op = 1080, Np = 1920, Rw = (s, t, e, r, n, i) => {
    let a = 0.5, c = 0.5;
    const d = n, p = i, h = Math.min(e / d, r / p);
    let m = d * h, g = p * h, T, y, b, A, I = 1;
    return m < e && (I = e / m), Math.abs(I - 1) < 1e-14 && g < r && (I = r / g), m *= I, g *= I, b = d / (m / e), A = p / (g / r), T = (d - b) * a, y = (p - A) * c, T < 0 && (T = 0), y < 0 && (y = 0), b > d && (b = d), A > p && (A = p), [T, y, b, A, s, t, e, r];
  };
  var jt, Kn, ct, Gt, xe, Xt, Nr, _t, Ge, zn, Yn, Lr, Qn;
  const Su = class extends Ft {
    constructor(e, r, n, i) {
      super();
      E(this, jt, undefined);
      E(this, Kn, undefined);
      E(this, ct, undefined);
      E(this, Gt, undefined);
      E(this, xe, {
        height: Op,
        width: Np
      });
      E(this, Xt, {
        brand: "#2160FD",
        background: "#141414",
        text: "#000000",
        videoBackground: "#191919",
        textOnBrand: "#EEEEEE"
      });
      E(this, Nr, undefined);
      E(this, _t, {});
      E(this, Ge, undefined);
      E(this, zn, undefined);
      E(this, Yn, undefined);
      E(this, Lr, undefined);
      E(this, Qn, false);
      f(this, "cleanupEventListeners", () => {
        o(this, Kn).unsubscribe("stageStatus", this.handlePipMediaControls), o(this, Ge).removeListener("videoUpdate", this.onSelfVideoUpdateListener), o(this, Ge).removeListener("audioUpdate", this.onSelfAudioUpdateListener), o(this, Ge).removeListener("roomLeft", () => this.disable());
      });
      f(this, "enablePipMediaControls", () => {
        this.mountAudioEvents(), this.mountVideoEvents();
      });
      f(this, "onSelfVideoUpdateListener", ({ videoEnabled: e }) => {
        this.updateMediaSession("CAMERA", e);
      });
      f(this, "onSelfAudioUpdateListener", ({ audioEnabled: e }) => {
        this.updateMediaSession("MIC", e);
      });
      f(this, "handlePipMediaControls", (e) => {
        e === "ON_STAGE" ? this.enablePipMediaControls() : this.unmountEvents();
      });
      f(this, "eventCallback", (e) => {
        e === "CAMERA" && (o(this, Ge).videoEnabled ? o(this, Ge).disableVideo() : o(this, Ge).enableVideo(), this.emit("cameraToggled")), e === "MIC" && (o(this, Ge).audioEnabled ? o(this, Ge).disableAudio() : o(this, Ge).enableAudio(), this.emit("micToggled")), e === "END" && (R.emit(P.PIP_HANGUP), this.cleanupEventListeners(), this.emit("hangup"), this.cleanup());
      });
      f(this, "unmountEvents", () => {
        navigator.mediaSession === undefined || navigator.mediaSession.setCameraActive === undefined || (navigator.mediaSession.setActionHandler("togglemicrophone", undefined), navigator.mediaSession.setActionHandler("togglecamera", undefined));
      });
      f(this, "animate", () => {
        if (!this.isActive && o(this, Lr) === "active") {
          this.disable(true);
          return;
        }
        o(this, _t) !== undefined && this.paintCanvas(), o(this, Nr) !== undefined && _(this, Nr, requestAnimationFrame(() => this.animate()));
      });
      /**
          * Disable PiP
          */
      f(this, "disable", (e = false) => {
        _(this, Lr, "idle"), this.cleanupEventListeners(), cancelAnimationFrame(o(this, Nr)), e !== true && document.body.removeChild(o(this, ct)), _(this, Nr, undefined), document.pictureInPictureElement && document.exitPictureInPicture();
      });
      _(this, Kn, e), _(this, Lr, "idle"), _(this, Ge, r), _(this, Xt, {
        brand: r.config.designTokens.colors.brand[500],
        background: r.config.designTokens.colors.background[1e3],
        text: r.config.designTokens.colors.text,
        videoBackground: r.config.designTokens.colors.videoBg,
        textOnBrand: r.config.designTokens.colors.textOnBrand
      }), n && this.setupIcon("pin", n), i && this.setupIcon("handRaise", i);
    }
    static _init(e, r) {
      return u(this, null, function* () {
        let n, i;
        try {
          n = yield Ro(gw), i = yield Ro(vw);
        } catch (a) {
        }
        return new Su(e, r, n, i);
      });
    }
    setupIcon(e, r) {
      return u(this, null, function* () {
        switch (e) {
          case "handRaise":
            _(this, Yn, r);
            break;
          case "pin":
            _(this, zn, r);
            break;
        }
      });
    }
    overrideIcon(e, r) {
      return u(this, null, function* () {
        switch (e) {
          case "handRaise":
            _(this, Yn, yield Ro(r));
            break;
          case "pin":
            _(this, zn, yield Ro(r));
            break;
        }
      });
    }
    constructImage(e) {
      const r = new Image(), n = new Blob([e], { type: "image/svg+xml" }), i = window.URL.createObjectURL(n);
      return new Promise((a) => {
        r.onload = () => {
          a(r), window.URL.revokeObjectURL(i);
        }, r.src = i;
      });
    }
    createVideoContainer() {
      _(this, ct, document.createElement("div")), o(this, ct).style.width = "0.1px", o(this, ct).style.height = "0.1px", o(this, ct).style.overflow = "hidden", o(this, ct).style.position = "absolute", o(this, ct).style.bottom = "0", o(this, ct).style.right = "0", o(this, ct).style.opacity = "0", o(this, ct).appendChild(o(this, Gt));
    }
    setupEventListeners() {
      o(this, Kn).subscribe("stageStatus", this.handlePipMediaControls), o(this, Ge).addListener("videoUpdate", this.onSelfVideoUpdateListener), o(this, Ge).addListener("audioUpdate", this.onSelfAudioUpdateListener), o(this, Ge).addListener("roomLeft", () => this.disable());
    }
    createCanvas() {
      const e = document.createElement("canvas");
      e.height = o(this, xe).height, e.width = o(this, xe).width, _(this, jt, e);
    }
    setupMediaSessionEvents() {
      navigator.mediaSession === undefined || navigator.mediaSession.setCameraActive === undefined || (navigator.mediaSession.setActionHandler("hangup", () => {
        this.eventCallback("END");
      }), this.mountAudioEvents(), this.mountVideoEvents());
    }
    mountAudioEvents() {
      navigator.mediaSession === undefined || navigator.mediaSession.setMicrophoneActive === undefined || o(this, Ge).permissions.canProduceAudio && navigator.mediaSession.setActionHandler("togglemicrophone", () => {
        this.eventCallback("MIC");
      });
    }
    mountVideoEvents() {
      navigator.mediaSession === undefined || navigator.mediaSession.setCameraActive === undefined || o(this, Ge).permissions.canProduceVideo && navigator.mediaSession.setActionHandler("togglecamera", () => {
        this.eventCallback("CAMERA");
      });
    }
    getSources() {
      const r = Object.values(o(this, _t)).reduce(
        (n, i) => (n[i.pinned ? "pinned" : "regular"].push(i), n),
        { pinned: [], regular: [] }
      );
      return [...r.pinned, ...r.regular];
    }
    drawEmptyTile(e, r, n, i) {
      if (o(this, jt) === undefined)
        return;
      const a = o(this, jt).getContext("2d"), c = o(this, jt).width, d = 0, p = 0, h = r - d * 2, m = n - d * 2, g = Math.floor(c / h), T = Math.floor(e / g), b = e % g * (h + d) + d, A = T * (m + d) + d, { displayText: I, image: $ } = i != null ? i : {};
      a.fillStyle = I || $ ? o(this, Xt).videoBackground : o(this, Xt).background, a.strokeStyle = o(this, Xt).brand, a.beginPath(), a.moveTo(b + p, A), a.arcTo(b + h, A, b + h, A + p, p), a.arcTo(
        b + h,
        A + m,
        b + h - p,
        A + m,
        p
      ), a.arcTo(b, A + m, b, A + m - p, p), a.arcTo(b, A, b + p, A, p), a.closePath(), a.fill(), a.stroke();
      const V = h / 6, O = h / 2 + b, q = m / 2 + A;
      a.save(), (I || $) && (a.beginPath(), a.arc(O, q, V, 0, Math.PI * 2), a.fillStyle = o(this, Xt).brand, a.fill(), $ ? (a.clip(), a.drawImage(
        $,
        O - V,
        q - V,
        V * 2,
        V * 2
      ), a.restore()) : I && (a.fillStyle = o(this, Xt).textOnBrand, a.font = `${V / 2}px sans-serif`, a.textAlign = "center", a.textBaseline = "middle", a.fillText(I, O, q)), this.drawIcons(i, b, A, Math.max(h, m)));
    }
    drawIcons(e, r, n, i) {
      const a = Math.min(Math.max(i * 0.15, 100), 200), c = a * 0.2, d = a * 0.2;
      let p = r + c;
      const h = n + c, m = (g) => {
        const T = o(this, jt).getContext("2d");
        T.save(), T.fillStyle = o(this, Xt).background, T.beginPath(), T.moveTo(p + d, h), T.arcTo(p + a, h, p + a, h + d, d), T.arcTo(
          p + a,
          h + a,
          p + a - d,
          h + a,
          d
        ), T.arcTo(p, h + a, p, h + a - d, d), T.arcTo(p, h, p + d, h, d), T.closePath(), T.fill(), typeof g == "string" ? (T.font = `${a / 1.5}px sans-serif`, T.fillStyle = o(this, Xt).text, T.textAlign = "center", T.textBaseline = "top", T.fillText(g, a / 2 + p, h + c)) : T.drawImage(
          g,
          p + c,
          h + c,
          a - c * 2,
          a - c * 2
        ), p += a + c, T.restore();
      };
      e.pinned && m(o(this, zn)), e.handRaised && m(o(this, Yn));
    }
    drawTile(e, r, n) {
      var p, h;
      if (o(this, jt) === undefined)
        return;
      const i = o(this, jt).getContext("2d"), a = this.getSources();
      let c = 0, d = 0;
      for (; c < o(this, xe).height - 5; ) {
        let m = 0;
        for (; m < o(this, xe).width - 5 && d < n; ) {
          if ((p = a[d]) != null && p.enabled) {
            const g = a[d].element, [T, y, b, A, I, $, V, O] = Rw(
              m,
              c,
              e,
              r,
              g.videoWidth,
              g.videoHeight
            );
            ((h = g == null ? undefined : g.classList) == null ? undefined : h.contains("mirror")) ? (i.save(), i.scale(-1, 1), i.drawImage(g, T, y, b, A, -1 * I, $, -1 * V, O), i.restore()) : i.drawImage(g, T, y, b, A, I, $, V, O), this.drawIcons(a[d], I, $, Math.max(V, O));
          } else
            this.drawEmptyTile(d, e, r, a[d]);
          d += 1, m += e;
        }
        c += r;
      }
    }
    calcGridElemSize(e) {
      switch (e) {
        case 0:
        case 1:
          return [o(this, xe).width, o(this, xe).height];
        case 2:
          return [Math.floor(o(this, xe).width / 2), o(this, xe).height];
        case 3:
        case 4:
          return [Math.floor(o(this, xe).width / 2), Math.floor(o(this, xe).height / 2)];
        case 5:
        case 6:
          return [Math.floor(o(this, xe).width / 3), Math.floor(o(this, xe).height / 2)];
        case 7:
        case 8:
        case 9:
          return [Math.floor(o(this, xe).width / 3), Math.floor(o(this, xe).height / 3)];
        default:
          return [Math.floor(o(this, xe).width / 3), Math.floor(o(this, xe).height / 2)];
      }
    }
    paintCanvas() {
      let e = this.getSources().length;
      e !== 1 && (e = e % 2 > 0 ? e + 1 : e);
      const [r, n] = this.calcGridElemSize(e);
      this.drawTile(r, n, e);
    }
    isSupported() {
      return !!window.chrome && document.pictureInPictureEnabled;
    }
    get isActive() {
      return document.pictureInPictureElement !== null;
    }
    cleanup() {
      if (_(this, Qn, false), this.isSupported() && document.exitPictureInPicture !== undefined && document.pictureInPictureElement !== null && document.exitPictureInPicture(), o(this, ct))
        try {
          document.body.removeChild(o(this, ct));
        } catch (e) {
        }
      this.removeAllSources(), _(this, jt, undefined), _(this, Gt, undefined), _(this, Nr, undefined);
    }
    /**
        * Initialize PiP and prepare sources
        */
    init({ height: e, width: r } = {}) {
      if (o(this, Qn))
        return;
      _(this, Qn, true), this.createCanvas(), this.setupMediaSessionEvents();
      const n = document.createElement("video");
      _(this, xe, {
        height: e != null ? e : Op,
        width: r != null ? r : Np
      }), n.height = o(this, xe).height, n.width = o(this, xe).width, n.autoplay = true, n.muted = true, n.srcObject = o(this, jt).captureStream(24), _(this, Gt, n), o(this, Gt).onloadedmetadata = () => {
        try {
          this.emit("pipStarted"), o(this, Gt).onleavepictureinpicture = () => {
            this.emit("pipEnded");
          };
        } catch (i) {
          this.emit("pipEnded");
        }
      }, this.createVideoContainer(), this.paintCanvas();
    }
    updateMediaSession(e, r) {
      navigator.mediaSession !== undefined && (e === "CAMERA" && navigator.mediaSession.setCameraActive !== undefined && navigator.mediaSession.setCameraActive(r), e === "MIC" && navigator.mediaSession.setMicrophoneActive !== undefined && navigator.mediaSession.setMicrophoneActive(r));
    }
    enableSource(e) {
      o(this, _t)[e] !== undefined && (o(this, _t)[e].enabled = true);
    }
    disableSource(e) {
      o(this, _t)[e] !== undefined && (o(this, _t)[e].enabled = false);
    }
    generateAvatar(e, r) {
      return u(this, null, function* () {
        const n = new Image(), i = yield fetch(r).then((c) => c.blob()), a = window.URL.createObjectURL(i);
        n.onload = () => {
          this.updateSource(e, { image: n }), window.URL.revokeObjectURL(a);
        }, n.src = a;
      });
    }
    /**
     * Add a video source from the participant grid
     * @param {string} id id for the source (ex. participant id)
     * @param {HTMLVideoElement} element HTMLVideoElement for the video source
     * @param {boolean} enabled if source is enabled
     * @param {?string} [displayText] two character display text
     */
    addSource(e, r, n, i = false, a = undefined, c = undefined, d = false) {
      l.info("DytePIP::AddSource", {
        pip: {
          id: e,
          handRaised: d
        }
      }), o(this, _t)[e] = {
        id: e,
        element: r,
        enabled: n,
        pinned: i,
        displayText: a ? Pw(a) : undefined,
        imageUrl: c,
        handRaised: d
      }, c && this.generateAvatar(e, c);
    }
    /** Update a video source */
    updateSource(e, r) {
      l.info("DytePIP::UpdateSource", {
        pip: {
          id: e,
          handRaised: r.handRaised
        }
      });
      const n = o(this, _t)[e];
      n && (o(this, _t)[e] = L(L({}, n), r));
    }
    /**
        * Remove the video source for the participant
        * @param id id for the source (ex. participant id)
        */
    removeSource(e) {
      delete o(this, _t)[e];
    }
    /**
        * Remove the pinned source
        * @param id id for the source (ex. participant id)
        */
    removePinnedSource() {
      Object.values(o(this, _t)).forEach((r) => {
        r.pinned && this.removeSource(r.id);
      });
    }
    /**
        * Remove all sources
        */
    removeAllSources() {
      _(this, _t, {});
    }
    /**
        * Enable PiP
        */
    enable() {
      _(this, Lr, "activating"), this.setupEventListeners(), this.updateMediaSession("CAMERA", o(this, Ge).videoEnabled), this.updateMediaSession("MIC", o(this, Ge).audioEnabled), document.body.appendChild(o(this, ct)), _(this, Nr, requestAnimationFrame(() => this.animate())), o(this, Gt).onloadedmetadata = () => {
        o(this, Gt).requestPictureInPicture().then(() => {
          _(this, Lr, "active");
        });
      }, o(this, Gt).readyState === 4 && o(this, Gt).requestPictureInPicture().then(() => {
        _(this, Lr, "active");
      });
    }
  };
  let dl = Su;
  jt = new WeakMap(), Kn = new WeakMap(), ct = new WeakMap(), Gt = new WeakMap(), xe = new WeakMap(), Xt = new WeakMap(), Nr = new WeakMap(), _t = new WeakMap(), Ge = new WeakMap(), zn = new WeakMap(), Yn = new WeakMap(), Lr = new WeakMap(), Qn = new WeakMap();
  var $t;
  (function(s) {
    s[s.PUBLISHER = 0] = "PUBLISHER", s[s.SUBSCRIBER = 1] = "SUBSCRIBER";
  })($t || ($t = {}));
  var kt;
  (function(s) {
    s[s.AUDIO = 0] = "AUDIO", s[s.VIDEO = 1] = "VIDEO";
  })(kt || (kt = {}));
  class bw extends MessageType {
    constructor() {
      super("media.Codec", [
        {
          no: 1,
          name: "channels",
          kind: "scalar",
          opt: true,
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 2,
          name: "clock_rate",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "mime_type",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "sdp_fmtp_line",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const kw = new bw();
  class Iw extends MessageType {
    constructor() {
      super("media.HeaderExtension", [
        {
          no: 1,
          name: "direction",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "uri",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Aw = new Iw();
  class Dw extends MessageType {
    constructor() {
      super("media.Fingerprint", [
        {
          no: 1,
          name: "algorithm",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "value",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new Dw();
  class Mw extends MessageType {
    constructor() {
      super("media.SessionDescription", [
        { no: 1, name: "target", kind: "enum", T: () => ["media.Target", $t] },
        {
          no: 2,
          name: "type",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "sdp",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const ar = new Mw();
  class Ow extends MessageType {
    constructor() {
      super("media.CreateTransportRequest", [
        {
          no: 1,
          name: "consuming",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "force_tcp",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 3, name: "description", kind: "message", T: () => ar },
        {
          no: 4,
          name: "private_ice",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const hf = new Ow();
  class Nw extends MessageType {
    constructor() {
      super("media.CreateTransportResponse", [
        {
          no: 1,
          name: "transport_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "description", kind: "message", T: () => ar },
        {
          no: 3,
          name: "transcription_enabled",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Yl = new Nw();
  class Lw extends MessageType {
    constructor() {
      super("media.RenegotiateRequest", [
        {
          no: 1,
          name: "transport_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const mf = new Lw();
  class xw extends MessageType {
    constructor() {
      super("media.RenegotiateResponse", [
        {
          no: 1,
          name: "transport_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  new xw();
  class $w extends MessageType {
    constructor() {
      super("media.NestedScore", [
        {
          no: 1,
          name: "encoding_idx",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 2,
          name: "rid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "score",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 4,
          name: "ssrc",
          kind: "scalar",
          T: 3,
          L: 0
          /*LongType.BIGINT*/
        }
      ]);
    }
  }
  const Uw = new $w();
  class Fw extends MessageType {
    constructor() {
      super("media.ProducerTrack", [
        {
          no: 1,
          name: "track_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "stream_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Vw = new Fw();
  class Hw extends MessageType {
    constructor() {
      super("media.ProducerEntry", [
        {
          no: 1,
          name: "producing_transport_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new Hw();
  class Bw extends MessageType {
    constructor() {
      super("media.ConsumerEntry", [
        {
          no: 1,
          name: "consuming_transport_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "consumer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new Bw();
  class qw extends MessageType {
    constructor() {
      super("media.ProducerState", [
        {
          no: 1,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "kind", kind: "enum", T: () => ["media.ProducerKind", kt] },
        {
          no: 3,
          name: "pause",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 4,
          name: "screen_share",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "app_data",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "producing_transport_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 7,
          name: "mime_type",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const vo = new qw();
  class jw extends MessageType {
    constructor() {
      super("media.ConsumerState", [
        {
          no: 1,
          name: "consumer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "producer_state", kind: "message", T: () => vo },
        { no: 3, name: "producer_track", kind: "message", T: () => Vw }
      ]);
    }
  }
  const Gw = new jw();
  class Jw extends MessageType {
    constructor() {
      super("media.ProducerIdToConsumerMap", [
        { no: 1, name: "map", kind: "map", K: 9, V: { kind: "message", T: () => Gw } }
      ]);
    }
  }
  const ff = new Jw();
  class Ww extends MessageType {
    constructor() {
      super("media.PeerRtpCapabilitites", [
        { no: 1, name: "sender", kind: "message", T: () => xp },
        { no: 2, name: "receiver", kind: "message", T: () => xp }
      ]);
    }
  }
  const gf = new Ww();
  class Kw extends MessageType {
    constructor() {
      super("media.RtpCapability", [
        { no: 1, name: "codecs", kind: "message", repeat: 1, T: () => kw },
        { no: 2, name: "header_extensions", kind: "message", repeat: 1, T: () => Aw }
      ]);
    }
  }
  const Lp = new Kw();
  class zw extends MessageType {
    constructor() {
      super("media.RtpCapabilitites", [
        { no: 1, name: "audio", kind: "message", T: () => Lp },
        { no: 2, name: "video", kind: "message", T: () => Lp }
      ]);
    }
  }
  const xp = new zw();
  class Yw extends MessageType {
    constructor() {
      super("media.PreferredCodec", [
        {
          no: 1,
          name: "audio",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "video",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Qw = new Yw();
  class Xw extends MessageType {
    constructor() {
      super("media.edge.GeoLocation", [
        {
          no: 1,
          name: "latitude",
          kind: "scalar",
          T: 2
          /*ScalarType.FLOAT*/
        },
        {
          no: 2,
          name: "longitude",
          kind: "scalar",
          T: 2
          /*ScalarType.FLOAT*/
        },
        {
          no: 3,
          name: "region",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Zw = new Xw();
  class eP extends MessageType {
    constructor() {
      super("media.edge.PeerJoinRequest", [
        {
          no: 1,
          name: "display_name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "prejoined",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "room_uuid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "preset",
          kind: "scalar",
          opt: true,
          T: 12
          /*ScalarType.BYTES*/
        },
        {
          no: 6,
          name: "user_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 7,
          name: "organization_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 8, name: "location", kind: "message", T: () => Zw },
        { no: 9, name: "capabilities", kind: "message", T: () => gf }
      ]);
    }
  }
  const vf = new eP();
  class tP extends MessageType {
    constructor() {
      super("media.edge.PeerJoinCompleteRequest", []);
    }
  }
  const yf = new tP();
  class rP extends MessageType {
    constructor() {
      super("media.edge.PeerLeaveRequest", [
        {
          no: 1,
          name: "close_room",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Tf = new rP();
  class sP extends MessageType {
    constructor() {
      super("media.edge.ConsumeMultipleProducerRequest", [
        {
          no: 1,
          name: "producer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "paused",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  new sP();
  class nP extends MessageType {
    constructor() {
      super("media.edge.ConsumePeerRequest", [
        {
          no: 1,
          name: "producing_peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "paused",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "producer_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 4, name: "preferred_codec", kind: "message", T: () => Qw }
      ]);
    }
  }
  const _f = new nP();
  class iP extends MessageType {
    constructor() {
      super("media.edge.ProducerCreateRequest", [
        {
          no: 1,
          name: "kind",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "paused",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "screen_share",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 4, name: "description", kind: "message", T: () => ar },
        {
          no: 5,
          name: "msid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "app_data",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 7,
          name: "mime_type",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Sf = new iP();
  class aP extends MessageType {
    constructor() {
      super("media.edge.SelectedPeersRequest", []);
    }
  }
  new aP();
  class oP extends MessageType {
    constructor() {
      super("media.edge.GlobalPeerPinningRequest", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Ef = new oP();
  class cP extends MessageType {
    constructor() {
      super("media.edge.ProducerToggleRequest", [
        {
          no: 1,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "pause",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const ks = new cP();
  class dP extends MessageType {
    constructor() {
      super("media.edge.ConsumerToggleRequest", [
        {
          no: 1,
          name: "consumer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "pause",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const ic = new dP();
  class lP extends MessageType {
    constructor() {
      super("media.edge.ProducerCloseRequest", [
        {
          no: 1,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const Cf = new lP();
  class uP extends MessageType {
    constructor() {
      super("media.edge.ConsumerCloseRequest", [
        {
          no: 1,
          name: "consumer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const wf = new uP();
  class pP extends MessageType {
    constructor() {
      super("media.edge.KickPeerRequest", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Pf = new pP();
  class hP extends MessageType {
    constructor() {
      super("media.edge.KickAllPeersRequest", [
        {
          no: 1,
          name: "propagate_kick_across_rooms",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Ql = new hP();
  class mP extends MessageType {
    constructor() {
      super("media.edge.PeerDisplayNameEditRequest", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Rf = new mP();
  class fP extends MessageType {
    constructor() {
      super("media.edge.HostMediaControlForPeerRequest", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "audio",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "video",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 4,
          name: "scree_share",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const bf = new fP();
  class gP extends MessageType {
    constructor() {
      super("media.edge.HostMediaControlForAllPeerRequest", [
        {
          no: 1,
          name: "audio",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "video",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "screen_share",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const kf = new gP();
  class vP extends MessageType {
    constructor() {
      super("media.edge.GetRoomStateResponse", [
        {
          no: 1,
          name: "display_title",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "locked_mode",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "room_uuid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "room_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "current_peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "is_recording",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 7,
          name: "recorder_participant_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 8,
          name: "pinned_peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const yP = new vP();
  class TP extends MessageType {
    constructor() {
      super("media.edge.ErrorResponse", [
        {
          no: 1,
          name: "error_message",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "event_id",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
  }
  const _P = new TP();
  class SP extends MessageType {
    constructor() {
      super("media.edge.EmptyResponse", []);
    }
  }
  new SP();
  class EP extends MessageType {
    constructor() {
      super("media.edge.RoomParticipants", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "producer_states", kind: "message", repeat: 1, T: () => vo },
        {
          no: 3,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "user_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 5, name: "capabilities", kind: "message", T: () => gf }
      ]);
    }
  }
  const If = new EP();
  class CP extends MessageType {
    constructor() {
      super("media.edge.SelectedPeersResponse", [
        {
          no: 1,
          name: "audio_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "compulsory_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const ll = new CP();
  class wP extends MessageType {
    constructor() {
      super("media.edge.SelectedPeersDiffEntry", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "priority",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
  }
  const PP = new wP();
  class RP extends MessageType {
    constructor() {
      super("media.edge.SelectedPeersDiffResponse", [
        { no: 1, name: "entries", kind: "message", repeat: 1, T: () => PP }
      ]);
    }
  }
  const $p = new RP();
  class bP extends MessageType {
    constructor() {
      super("media.edge.PeerJoinResponse", []);
    }
  }
  new bP();
  class kP extends MessageType {
    constructor() {
      super("media.edge.PeerJoinCompleteResponse", [
        { no: 1, name: "room_state", kind: "message", T: () => yP },
        { no: 2, name: "participants", kind: "message", repeat: 1, T: () => If },
        { no: 3, name: "selected_peers", kind: "message", T: () => ll },
        {
          no: 4,
          name: "max_preferred_streams",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
  }
  const ac = new kP();
  class IP extends MessageType {
    constructor() {
      super("media.edge.PeerLeaveResponse", [
        {
          no: 1,
          name: "closed",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Af = new IP();
  class AP extends MessageType {
    constructor() {
      super("media.edge.ConsumeMultipleProducerResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 2, name: "consumer_ids_map", kind: "message", T: () => ff }
      ]);
    }
  }
  new AP();
  class DP extends MessageType {
    constructor() {
      super("media.edge.ConsumePeerResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 2, name: "consumer_ids_map", kind: "message", T: () => ff },
        { no: 3, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const Df = new DP();
  class MP extends MessageType {
    constructor() {
      super("media.edge.ProducerCreateResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "producer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 4, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const Mf = new MP();
  class OP extends MessageType {
    constructor() {
      super("media.edge.ProducerScoreResponse", [
        {
          no: 1,
          name: "responseid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "score", kind: "message", T: () => Uw }
      ]);
    }
  }
  new OP();
  class NP extends MessageType {
    constructor() {
      super("media.edge.ActiveSpeakerResponse", [
        {
          no: 1,
          name: "responsepeer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "volume",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
  }
  new NP();
  class LP extends MessageType {
    constructor() {
      super("media.edge.NoActiveSpeakerResponse", []);
    }
  }
  new LP();
  class xP extends MessageType {
    constructor() {
      super("media.edge.ProducerToggleResponse", []);
    }
  }
  new xP();
  class $P extends MessageType {
    constructor() {
      super("media.edge.ConsumerToggleResponse", []);
    }
  }
  new $P();
  class UP extends MessageType {
    constructor() {
      super("media.edge.ProducerClosingResponse", [
        { no: 1, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  const Of = new UP();
  class FP extends MessageType {
    constructor() {
      super("media.edge.ConsumerClosingResponse", [
        { no: 1, name: "description", kind: "message", T: () => ar }
      ]);
    }
  }
  new FP();
  class VP extends MessageType {
    constructor() {
      super("media.edge.GlobalPeerPinningResponse", []);
    }
  }
  new VP();
  class HP extends MessageType {
    constructor() {
      super("media.edge.KickPeerResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Nf = new HP();
  class BP extends MessageType {
    constructor() {
      super("media.edge.KickAllPeersResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Lf = new BP();
  class qP extends MessageType {
    constructor() {
      super("media.edge.HostMediaControlForPeerResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const xf = new qP();
  class jP extends MessageType {
    constructor() {
      super("media.edge.HostMediaControlForAllPeerResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const $f = new jP();
  class GP extends MessageType {
    constructor() {
      super("media.edge.PeerDisplayNameEditResponse", [
        {
          no: 1,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Uf = new GP();
  class JP extends MessageType {
    constructor() {
      super("media.edge.PeerJoinBroadcastResponse", [
        { no: 1, name: "participant", kind: "message", T: () => If }
      ]);
    }
  }
  const Up = new JP();
  class WP extends MessageType {
    constructor() {
      super("media.edge.TrackSubscriptionKind", [
        {
          no: 1,
          name: "audio",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "video",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Fp = new WP();
  class KP extends MessageType {
    constructor() {
      super("media.edge.TrackSubscription", [
        {
          no: 1,
          name: "label",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "webcam", kind: "message", T: () => Fp },
        { no: 3, name: "screenshare", kind: "message", T: () => Fp }
      ]);
    }
  }
  const zP = new KP();
  class YP extends MessageType {
    constructor() {
      super("media.edge.PeerProducingTransportCreateBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "transport_details", kind: "message", T: () => Yl },
        { no: 3, name: "track_subscriptions", kind: "message", repeat: 1, T: () => zP }
      ]);
    }
  }
  new YP();
  class QP extends MessageType {
    constructor() {
      super("media.edge.PeerProducerCreateBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "producer_state", kind: "message", T: () => vo }
      ]);
    }
  }
  const Ff = new QP();
  class XP extends MessageType {
    constructor() {
      super("media.edge.PeerProducerToggleBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "producer_state", kind: "message", T: () => vo }
      ]);
    }
  }
  const Vf = new XP();
  class ZP extends MessageType {
    constructor() {
      super("media.edge.PeerProducerCloseBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "producer_state", kind: "message", T: () => vo }
      ]);
    }
  }
  const Hf = new ZP();
  class eR extends MessageType {
    constructor() {
      super("media.edge.PeerLeaveBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const oc = new eR();
  class tR extends MessageType {
    constructor() {
      super("media.edge.GlobalPeerPinningBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Vp = new tR();
  class rR extends MessageType {
    constructor() {
      super("media.edge.GlobalPeerUnPinningBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new rR();
  class sR extends MessageType {
    constructor() {
      super("media.edge.RecordingStartedBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new sR();
  class nR extends MessageType {
    constructor() {
      super("media.edge.RecordingStoppedBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new nR();
  class iR extends MessageType {
    constructor() {
      super("media.edge.PeerDisplayNameEditBroadcastResponse", [
        {
          no: 1,
          name: "participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new iR();
  class aR extends MessageType {
    constructor() {
      super("media.edge.PeerPingRequestBroadcastResponse", [
        {
          no: 1,
          name: "password",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new aR();
  class oR extends MessageType {
    constructor() {
      super("media.edge.MediaRoomTerminationBroadcastResponse", [
        {
          no: 1,
          name: "reason",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new oR();
  class cR extends MessageType {
    constructor() {
      super("socket.ai.MeetingTranscript", [
        {
          no: 1,
          name: "meeting_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "transcript",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "is_partial",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const xd = new cR();
  class dR extends MessageType {
    constructor() {
      super("socket.api.BaseSocketHubMessage", [
        {
          no: 1,
          name: "event",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 2,
          name: "id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "room_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "payload",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        },
        {
          no: 7,
          name: "error",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 8,
          name: "sid",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new dR();
  class lR extends MessageType {
    constructor() {
      super("socket.api.ErrorMessage", [
        {
          no: 1,
          name: "code",
          kind: "scalar",
          opt: true,
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 2,
          name: "message",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const uR = new lR();
  var vn;
  (function(s) {
    s[s.BROWSER = 0] = "BROWSER", s[s.TRACK = 1] = "TRACK", s[s.COMPOSITE = 2] = "COMPOSITE";
  })(vn || (vn = {}));
  var Gr;
  (function(s) {
    s[s.UNSPECIFIED = 0] = "UNSPECIFIED", s[s.ON_STAGE = 1] = "ON_STAGE", s[s.APPROVED_STAGE = 2] = "APPROVED_STAGE", s[s.REQUESTED_STAGE = 3] = "REQUESTED_STAGE", s[s.OFF_STAGE = 4] = "OFF_STAGE";
  })(Gr || (Gr = {}));
  var ul;
  (function(s) {
    s[s.NONE = 0] = "NONE", s[s.RECORDER = 1] = "RECORDER", s[s.LIVESTREAMER = 2] = "LIVESTREAMER";
  })(ul || (ul = {}));
  var cc;
  (function(s) {
    s[s.HIVE = 0] = "HIVE", s[s.CHAT = 1] = "CHAT", s[s.PING = 2] = "PING";
  })(cc || (cc = {}));
  class pR extends MessageType {
    constructor() {
      super("socket.room.PeerFlags", [
        {
          no: 1,
          name: "preset_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "recorder_type",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "hidden_participant",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const hR = new pR();
  class mR extends MessageType {
    constructor() {
      super("socket.room.Peer", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 4, name: "stage_type", kind: "enum", opt: true, T: () => ["socket.room.StageType", Gr, "STAGE_TYPE_"] },
        {
          no: 5,
          name: "custom_participant_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "preset_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 7,
          name: "display_picture_url",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 8,
          name: "waitlisted",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 9, name: "flags", kind: "message", T: () => hR }
      ]);
    }
  }
  const Yc = new mR();
  class fR extends MessageType {
    constructor() {
      super("socket.room.PeerInfoResponse", [
        { no: 1, name: "peer", kind: "message", T: () => Yc }
      ]);
    }
  }
  const $n = new fR();
  class gR extends MessageType {
    constructor() {
      super("socket.room.PeerStatusUpdate", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "stage_type", kind: "enum", opt: true, T: () => ["socket.room.StageType", Gr, "STAGE_TYPE_"] }
      ]);
    }
  }
  const Hp = new gR();
  class vR extends MessageType {
    constructor() {
      super("socket.room.RoomPeersInfoRequest", [
        {
          no: 1,
          name: "seach_query",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "limit",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "offset",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
  }
  const yR = new vR();
  class TR extends MessageType {
    constructor() {
      super("socket.room.RoomPeersInfoResponse", [
        { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Yc }
      ]);
    }
  }
  const $d = new TR();
  class _R extends MessageType {
    constructor() {
      super("socket.room.RoomPeerCountResponse", [
        {
          no: 1,
          name: "count",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        }
      ]);
    }
  }
  const Bp = new _R();
  class SR extends MessageType {
    constructor() {
      super("socket.room.Room", [
        {
          no: 1,
          name: "room_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "title",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "created_at",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        { no: 5, name: "active_recordings", kind: "message", repeat: 1, T: () => CR },
        {
          no: 6,
          name: "room_uuid",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Bf = new SR();
  class ER extends MessageType {
    constructor() {
      super("socket.room.ActiveRecording", [
        {
          no: 1,
          name: "recording_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", vn] },
        {
          no: 3,
          name: "recording_status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const CR = new ER();
  class wR extends MessageType {
    constructor() {
      super("socket.room.RoomInfoResponse", [
        { no: 1, name: "room", kind: "message", T: () => Bf }
      ]);
    }
  }
  const qp = new wR();
  class PR extends MessageType {
    constructor() {
      super("socket.room.GetPeerInfoRequest", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const qf = new PR();
  class RR extends MessageType {
    constructor() {
      super("socket.room.UpdatePeerInfoRequest", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new RR();
  class bR extends MessageType {
    constructor() {
      super("socket.room.JoinRoomRequest", [
        { no: 1, name: "peer", kind: "message", T: () => Yc },
        {
          no: 3,
          name: "room_uuid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "organization_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "use_hive",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 6,
          name: "preset",
          kind: "scalar",
          opt: true,
          T: 12
          /*ScalarType.BYTES*/
        },
        { no: 7, name: "capabilities", kind: "enum", repeat: 1, T: () => ["socket.room.Capabilities", cc, "CAPABILITIES_"] },
        {
          no: 8,
          name: "timestamp",
          kind: "scalar",
          opt: true,
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        }
      ]);
    }
  }
  const kR = new bR();
  class IR extends MessageType {
    constructor() {
      super("socket.room.LeaveRoomRequest", [
        { no: 1, name: "peer", kind: "message", T: () => Yc },
        {
          no: 2,
          name: "timestamp",
          kind: "scalar",
          opt: true,
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        }
      ]);
    }
  }
  const AR = new IR();
  class DR extends MessageType {
    constructor() {
      super("socket.room.UpdateRoomInfoRequest", [
        { no: 1, name: "room", kind: "message", T: () => Bf }
      ]);
    }
  }
  new DR();
  class MR extends MessageType {
    constructor() {
      super("socket.room.GetConnectedRoomsDumpRequest", []);
    }
  }
  new MR();
  class OR extends MessageType {
    constructor() {
      super("socket.room.ServiceError", [
        {
          no: 1,
          name: "message",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "code",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Xl = new OR();
  class NR extends MessageType {
    constructor() {
      super("socket.room.ConnectedMeetingPeer", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "custom_participant_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "preset_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "display_picture_url",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const LR = new NR();
  class xR extends MessageType {
    constructor() {
      super("socket.room.ConnectedMeetingDump", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "title",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "participants", kind: "message", repeat: 1, T: () => LR }
      ]);
    }
  }
  const jp = new xR();
  class $R extends MessageType {
    constructor() {
      super("socket.room.GetConnectedRoomsDumpResponse", [
        { no: 1, name: "parent_meeting", kind: "message", T: () => jp },
        { no: 2, name: "meetings", kind: "message", repeat: 1, T: () => jp }
      ]);
    }
  }
  const UR = new $R();
  class FR extends MessageType {
    constructor() {
      super("socket.room.CreateRoomRequestPayload", [
        {
          no: 1,
          name: "title",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const VR = new FR();
  class HR extends MessageType {
    constructor() {
      super("socket.room.CreateConnectedRoomsRequest", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => VR }
      ]);
    }
  }
  const BR = new HR();
  class qR extends MessageType {
    constructor() {
      super("socket.room.CreateRoomResponsePayload", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "title",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "error", kind: "message", T: () => Xl }
      ]);
    }
  }
  const jR = new qR();
  class GR extends MessageType {
    constructor() {
      super("socket.room.CreateConnectedRoomsResponse", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => jR }
      ]);
    }
  }
  const Gp = new GR();
  class JR extends MessageType {
    constructor() {
      super("socket.room.UpdateRoomRequestPayload", [
        {
          no: 1,
          name: "meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "title",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const WR = new JR();
  class KR extends MessageType {
    constructor() {
      super("socket.room.UpdateConnectedRoomsRequest", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => WR }
      ]);
    }
  }
  new KR();
  class zR extends MessageType {
    constructor() {
      super("socket.room.DisableRoomPayload", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const YR = new zR();
  class QR extends MessageType {
    constructor() {
      super("socket.room.DisableConnectedRoomsRequest", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => YR }
      ]);
    }
  }
  const XR = new QR();
  class ZR extends MessageType {
    constructor() {
      super("socket.room.DisableConnectedRoomsResponse", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => rb }
      ]);
    }
  }
  const eb = new ZR();
  class tb extends MessageType {
    constructor() {
      super("socket.room.DisableConnectedRoomPayload", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "status",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "title",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 4, name: "error", kind: "message", T: () => Xl }
      ]);
    }
  }
  const rb = new tb();
  class sb extends MessageType {
    constructor() {
      super("socket.room.MovePeerPayload", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "preset_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const nb = new sb();
  class ib extends MessageType {
    constructor() {
      super("socket.room.MovePeersBetweenRoomsRequest", [
        {
          no: 1,
          name: "source_meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "destination_meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "participants", kind: "message", repeat: 1, T: () => nb }
      ]);
    }
  }
  const ab = new ib();
  class ob extends MessageType {
    constructor() {
      super("socket.room.MovedPeer", [
        {
          no: 1,
          name: "meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "custom_participant_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "error", kind: "message", T: () => Xl }
      ]);
    }
  }
  const jf = new ob();
  class cb extends MessageType {
    constructor() {
      super("socket.room.MovePeersBetweenRoomsResponse", [
        { no: 1, name: "payloads", kind: "message", repeat: 1, T: () => jf }
      ]);
    }
  }
  new cb();
  class db extends MessageType {
    constructor() {
      super("socket.room.TransferPeer", [
        {
          no: 1,
          name: "meeting_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "auth_token",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const lb = new db();
  class ub extends MessageType {
    constructor() {
      super("socket.room.GetAllAddedParticipantsResponse", [
        { no: 1, name: "participants", kind: "message", repeat: 1, T: () => mb }
      ]);
    }
  }
  const pb = new ub();
  class hb extends MessageType {
    constructor() {
      super("socket.room.AddedParticipant", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "picture",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "custom_participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const mb = new hb();
  class fb extends MessageType {
    constructor() {
      super("socket.room.RemoveParticipantsRequest", [
        {
          no: 1,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const gb = new fb();
  class vb extends MessageType {
    constructor() {
      super("socket.room.BroadcastMessage", [
        {
          no: 1,
          name: "type",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "payload",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        },
        {
          no: 3,
          name: "timestamp",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        {
          no: 4,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const ko = new vb();
  class yb extends MessageType {
    constructor() {
      super("socket.room.AcceptWaitingRoomRequests", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Tb = new yb();
  class _b extends MessageType {
    constructor() {
      super("socket.room.DenyWaitingRoomRequests", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Sb = new _b();
  class Eb extends MessageType {
    constructor() {
      super("socket.room.WaitingRoomRequest", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "picture",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "custom_participant_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "preset_name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Cb = new Eb();
  class wb extends MessageType {
    constructor() {
      super("socket.room.GetWaitingRoomRequests", [
        { no: 1, name: "requests", kind: "message", repeat: 1, T: () => Cb }
      ]);
    }
  }
  const Jp = new wb();
  class Pb extends MessageType {
    constructor() {
      super("socket.room.GetRoomStageStateResponse", [
        {
          no: 1,
          name: "on_stage_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "approved_stage_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "requested_stage_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Wp = new Pb();
  var pl;
  (function(s) {
    s[s.NONE = 0] = "NONE", s[s.SKIP = 1] = "SKIP", s[s.ON_PRIVILEGED_USER_ENTRY = 2] = "ON_PRIVILEGED_USER_ENTRY", s[s.SKIP_ON_ACCEPT = 3] = "SKIP_ON_ACCEPT";
  })(pl || (pl = {}));
  var Is;
  (function(s) {
    s[s.NONE = 0] = "NONE", s[s.ALLOWED = 1] = "ALLOWED", s[s.NOT_ALLOWED = 2] = "NOT_ALLOWED", s[s.CAN_REQUEST = 3] = "CAN_REQUEST";
  })(Is || (Is = {}));
  class Rb extends MessageType {
    constructor() {
      super("socket.preset.PollsPermissionUpdate", [
        {
          no: 1,
          name: "can_create",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "can_vote",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "can_view",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const bb = new Rb();
  class kb extends MessageType {
    constructor() {
      super("socket.preset.PluginsPermissionsUpdate", [
        {
          no: 1,
          name: "can_close",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "can_start",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Ib = new kb();
  class Ab extends MessageType {
    constructor() {
      super("socket.preset.PublicChatPermission", [
        {
          no: 1,
          name: "can_send",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "text",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "files",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Db = new Ab();
  class Mb extends MessageType {
    constructor() {
      super("socket.preset.PrivateChatPermission", [
        {
          no: 1,
          name: "can_send",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "can_receive",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "text",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 4,
          name: "files",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Ob = new Mb();
  class Nb extends MessageType {
    constructor() {
      super("socket.preset.ChatPermissionUpdate", [
        { no: 1, name: "public", kind: "message", T: () => Db },
        { no: 2, name: "private", kind: "message", T: () => Ob }
      ]);
    }
  }
  const Lb = new Nb();
  class xb extends MessageType {
    constructor() {
      super("socket.preset.ConnectedMeetingPermissionUpdate", [
        {
          no: 1,
          name: "can_alter_connected_meetings",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 2,
          name: "can_switch_to_parent_meeting",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "can_switch_connected_meetings",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const $b = new xb();
  class Ub extends MessageType {
    constructor() {
      super("socket.preset.StreamPermission", [
        { no: 1, name: "can_produce", kind: "enum", opt: true, T: () => ["socket.preset.StreamPermissionType", Is, "STREAM_PERMISSION_TYPE_"] },
        { no: 2, name: "can_consume", kind: "enum", opt: true, T: () => ["socket.preset.StreamPermissionType", Is, "STREAM_PERMISSION_TYPE_"] }
      ]);
    }
  }
  const Ud = new Ub();
  class Fb extends MessageType {
    constructor() {
      super("socket.preset.MediaPermissionUpdate", [
        { no: 1, name: "video", kind: "message", T: () => Ud },
        { no: 2, name: "audio", kind: "message", T: () => Ud },
        { no: 3, name: "screenshare", kind: "message", T: () => Ud }
      ]);
    }
  }
  const Vb = new Fb();
  class Hb extends MessageType {
    constructor() {
      super("socket.preset.PresetUpdates", [
        { no: 1, name: "polls", kind: "message", T: () => bb },
        { no: 2, name: "plugins", kind: "message", T: () => Ib },
        { no: 3, name: "chat", kind: "message", T: () => Lb },
        {
          no: 4,
          name: "accept_waiting_requests",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "can_accept_production_requests",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 6,
          name: "can_edit_display_name",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 7,
          name: "can_record",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 8,
          name: "can_livestream",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 9,
          name: "can_spotlight",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 10,
          name: "disable_participant_audio",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 11,
          name: "disable_participant_screensharing",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 12,
          name: "disable_participant_video",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 13,
          name: "kick_participant",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 14,
          name: "pin_participant",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 15,
          name: "transcription_enabled",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 16, name: "waiting_room_type", kind: "enum", opt: true, T: () => ["socket.preset.WaitingRoomType", pl, "WAITING_ROOM_TYPE_"] },
        {
          no: 17,
          name: "is_recorder",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 18, name: "recorder_type", kind: "enum", opt: true, T: () => ["socket.room.RecorderType", ul, "RECORDER_TYPE_"] },
        {
          no: 19,
          name: "hidden_participant",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 20,
          name: "show_participant_list",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 21,
          name: "can_change_participant_permissions",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 22, name: "connected_meetings", kind: "message", T: () => $b },
        { no: 23, name: "media", kind: "message", T: () => Vb }
      ]);
    }
  }
  const Zl = new Hb();
  class Bb extends MessageType {
    constructor() {
      super("socket.preset.ReadPeersPresetRequest", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const qb = new Bb();
  class jb extends MessageType {
    constructor() {
      super("socket.preset.PeerPreset", [
        {
          no: 1,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "preset",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const Gb = new jb();
  class Jb extends MessageType {
    constructor() {
      super("socket.preset.ReadPeersPresetResponse", [
        { no: 1, name: "peer_presets", kind: "message", repeat: 1, T: () => Gb }
      ]);
    }
  }
  const Wb = new Jb();
  class Kb extends MessageType {
    constructor() {
      super("socket.preset.UpdatePeerPreset", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 2, name: "patch", kind: "message", T: () => Zl }
      ]);
    }
  }
  const Gf = new Kb();
  class zb extends MessageType {
    constructor() {
      super("socket.preset.UpdatePeersPresetRequest", [
        { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Gf }
      ]);
    }
  }
  const Yb = new zb();
  class Qb extends MessageType {
    constructor() {
      super("socket.preset.UpdatePeersPresetResponse", [
        { no: 1, name: "update_peers_presets", kind: "message", repeat: 1, T: () => Gf }
      ]);
    }
  }
  const Kp = new Qb();
  class Xb extends MessageType {
    constructor() {
      super("socket.preset.PeerUserIDMap", [
        {
          no: 1,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Zb = new Xb();
  class ek extends MessageType {
    constructor() {
      super("socket.preset.BulkUpdatePeerPresetRequest", [
        { no: 1, name: "peers", kind: "message", repeat: 1, T: () => Zb },
        { no: 2, name: "patch", kind: "message", T: () => Zl }
      ]);
    }
  }
  new ek();
  class tk extends MessageType {
    constructor() {
      super("socket.preset.BulkUpdatePeerPresetResponse", [
        { no: 2, name: "patch", kind: "message", T: () => Zl }
      ]);
    }
  }
  new tk();
  class rk extends MessageType {
    constructor() {
      super("socket.chat.ChatMessage", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "pinned",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 6,
          name: "is_edited",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 7,
          name: "payload_type",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 8,
          name: "payload",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 10,
          name: "target_user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 11,
          name: "created_at",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        {
          no: 12,
          name: "created_at_ms",
          kind: "scalar",
          opt: true,
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        {
          no: 13,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 14,
          name: "channel_index",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const In = new rk();
  class sk extends MessageType {
    constructor() {
      super("socket.chat.GetPaginatedChatMessageRoomRequest", [
        {
          no: 1,
          name: "time_stamp",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        {
          no: 2,
          name: "size",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "from",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 4,
          name: "reversed",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const nk = new sk();
  class ik extends MessageType {
    constructor() {
      super("socket.chat.GetPaginatedChatMessageRoomResponse", [
        { no: 1, name: "messages", kind: "message", repeat: 1, T: () => In },
        {
          no: 2,
          name: "next",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const ak = new ik();
  class ok extends MessageType {
    constructor() {
      super("socket.chat.GetChatMessagesResponse", [
        { no: 1, name: "messages", kind: "message", repeat: 1, T: () => In }
      ]);
    }
  }
  const Jf = new ok();
  class ck extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToRoomRequest", [
        {
          no: 1,
          name: "payload_type",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 2,
          name: "payload",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const dk = new ck();
  class lk extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToRoomResponse", [
        { no: 1, name: "message", kind: "message", T: () => In }
      ]);
    }
  }
  const Fd = new lk();
  class uk extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToPeersRequest", [
        {
          no: 1,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "payload_type",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "payload",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const pk = new uk();
  class hk extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToPeersResponse", [
        { no: 1, name: "message", kind: "message", T: () => In }
      ]);
    }
  }
  const Vd = new hk();
  class mk extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToChannelRequest", [
        {
          no: 1,
          name: "channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "payload_type",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "payload",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const fk = new mk();
  class gk extends MessageType {
    constructor() {
      super("socket.chat.SendChatMessageToChannelResponse", [
        { no: 1, name: "message", kind: "message", T: () => In }
      ]);
    }
  }
  new gk();
  class vk extends MessageType {
    constructor() {
      super("socket.chat.EditChatMessageRequest", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "payload_type",
          kind: "scalar",
          opt: true,
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "payload",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "pinned",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const yk = new vk();
  class Tk extends MessageType {
    constructor() {
      super("socket.chat.PinChatMessageRequest", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "pinned",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const _k = new Tk();
  class Sk extends MessageType {
    constructor() {
      super("socket.chat.PinChatMessageResponse", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "pinned",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 3,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Io = new Sk();
  class Ek extends MessageType {
    constructor() {
      super("socket.chat.EditChatMessageResponse", [
        { no: 1, name: "message", kind: "message", T: () => In }
      ]);
    }
  }
  const Ao = new Ek();
  class Ck extends MessageType {
    constructor() {
      super("socket.chat.DeleteChatMessageRequest", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const wk = new Ck();
  class Pk extends MessageType {
    constructor() {
      super("socket.chat.DeleteChatMessageResponse", [
        {
          no: 1,
          name: "chat_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Do = new Pk();
  class Rk extends MessageType {
    constructor() {
      super("socket.chat.SearchChatMessagesRequest", [
        {
          no: 1,
          name: "time_stamp",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        {
          no: 2,
          name: "size",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 3,
          name: "from",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        },
        {
          no: 4,
          name: "reversed",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "channel_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "search_term",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const bk = new Rk();
  class kk extends MessageType {
    constructor() {
      super("socket.chat.MarkChannelIndexAsReadRequest", [
        {
          no: 1,
          name: "channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "channel_index",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Ik = new kk();
  class Ak extends MessageType {
    constructor() {
      super("socket.chat.MarkChannelIndexAsReadResponse", [
        {
          no: 1,
          name: "channel_index",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Dk = new Ak();
  class Mk extends MessageType {
    constructor() {
      super("socket.chat.CreateChatChannelRequest", [
        {
          no: 1,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "target_user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "display_picture_url",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "visibility",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "is_direct_message",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Ok = new Mk();
  class Nk extends MessageType {
    constructor() {
      super("socket.chat.UpdateChatChannelRequest", [
        {
          no: 1,
          name: "chat_channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "target_user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "display_picture_url",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "visibility",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "is_direct_message",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Lk = new Nk();
  class xk extends MessageType {
    constructor() {
      super("socket.chat.CreateChatChannelResponse", [
        {
          no: 1,
          name: "chat_channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  new xk();
  class $k extends MessageType {
    constructor() {
      super("socket.chat.GetChatChannelRequest", [
        {
          no: 1,
          name: "chat_channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Uk = new $k();
  class Fk extends MessageType {
    constructor() {
      super("socket.chat.LatestMessageAndUnreadCount", [
        { no: 1, name: "message", kind: "message", T: () => In },
        {
          no: 2,
          name: "unread_count",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        }
      ]);
    }
  }
  const Vk = new Fk();
  class Hk extends MessageType {
    constructor() {
      super("socket.chat.ChatChannel", [
        {
          no: 1,
          name: "chat_channel_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "display_picture_url",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "visibility",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "is_direct_message",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        { no: 6, name: "latest_message_and_unread_count", kind: "message", T: () => Vk },
        {
          no: 7,
          name: "target_user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Bk = new Hk();
  class qk extends MessageType {
    constructor() {
      super("socket.chat.GetChatChannelResponse", [
        { no: 1, name: "chat_channels", kind: "message", repeat: 1, T: () => Bk }
      ]);
    }
  }
  const Ir = new qk();
  class jk extends MessageType {
    constructor() {
      super("socket.chat.ChannelMember", [
        {
          no: 1,
          name: "id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "name",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "picture",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "custom_participant_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Gk = new jk();
  class Jk extends MessageType {
    constructor() {
      super("socket.chat.GetChatChannelMembersResponse", [
        { no: 1, name: "channel_members", kind: "message", repeat: 1, T: () => Gk }
      ]);
    }
  }
  const Wk = new Jk();
  class Kk extends MessageType {
    constructor() {
      super("socket.plugin.AddPluginRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "staggered",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const zk = new Kk();
  class Yk extends MessageType {
    constructor() {
      super("socket.plugin.RemovePluginRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "staggered",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Qk = new Yk();
  class Xk extends MessageType {
    constructor() {
      super("socket.plugin.EnablePluginForRoomRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Zk = new Xk();
  class eI extends MessageType {
    constructor() {
      super("socket.plugin.DisablePluginForRoomRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const tI = new eI();
  class rI extends MessageType {
    constructor() {
      super("socket.plugin.EnablePluginForPeersRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const sI = new rI();
  class nI extends MessageType {
    constructor() {
      super("socket.plugin.DisablePluginForPeersRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const iI = new nI();
  class aI extends MessageType {
    constructor() {
      super("socket.plugin.PluginEventToRoomRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "plugin_data",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const oI = new aI();
  class cI extends MessageType {
    constructor() {
      super("socket.plugin.PluginEventToPeersRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "plugin_data",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const dI = new cI();
  class lI extends MessageType {
    constructor() {
      super("socket.plugin.StoreKeys", [
        {
          no: 1,
          name: "store_key",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "payload",
          kind: "scalar",
          opt: true,
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const eu = new lI();
  class uI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreInsertKeysRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "store_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "insert_keys", kind: "message", repeat: 1, T: () => eu }
      ]);
    }
  }
  const zp = new uI();
  class pI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreGetKeysRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "store_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "get_keys", kind: "message", repeat: 1, T: () => eu }
      ]);
    }
  }
  const hI = new pI();
  class mI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreDeleteKeysRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "store_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "delete_keys", kind: "message", repeat: 1, T: () => eu }
      ]);
    }
  }
  const fI = new mI();
  class gI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreDeleteRequest", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "store_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const vI = new gI();
  class yI extends MessageType {
    constructor() {
      super("socket.plugin.EnablePluginResponse", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "enabled_by",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const hl = new yI();
  class TI extends MessageType {
    constructor() {
      super("socket.plugin.EnablePluginsResponse", [
        { no: 1, name: "plugins", kind: "message", repeat: 1, T: () => hl }
      ]);
    }
  }
  const _I = new TI();
  class SI extends MessageType {
    constructor() {
      super("socket.plugin.DisablePluginResponse", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "disabled_by",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Yp = new SI();
  class EI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreItem", [
        {
          no: 1,
          name: "timestamp",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "store_key",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "payload",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const CI = new EI();
  class wI extends MessageType {
    constructor() {
      super("socket.plugin.PluginStoreResponse", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "store_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "store_items", kind: "message", repeat: 1, T: () => CI }
      ]);
    }
  }
  const Qp = new wI();
  class PI extends MessageType {
    constructor() {
      super("socket.plugin.PluginEventResponse", [
        {
          no: 1,
          name: "plugin_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "plugin_data",
          kind: "scalar",
          T: 12
          /*ScalarType.BYTES*/
        }
      ]);
    }
  }
  const Xp = new PI();
  class RI extends MessageType {
    constructor() {
      super("socket.livestreaming.LiveStreamingEvent", [
        {
          no: 1,
          name: "livestream_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "err_message",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "meeting_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 5,
          name: "playback_url",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "org_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 7,
          name: "room_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 8,
          name: "room_uuid",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 9,
          name: "status",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 10,
          name: "manual_ingest",
          kind: "scalar",
          opt: true,
          T: 8
          /*ScalarType.BOOL*/
        }
      ]);
    }
  }
  const Zp = new RI();
  class bI extends MessageType {
    constructor() {
      super("socket.livestreaming.GetStagePeersResponse", [
        {
          no: 1,
          name: "stage_peers",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const eh = new bI();
  class kI extends MessageType {
    constructor() {
      super("socket.livestreaming.StageRequest", [
        {
          no: 1,
          name: "display_name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "peer_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const II = new kI();
  class AI extends MessageType {
    constructor() {
      super("socket.livestreaming.GetStageRequestsResponse", [
        { no: 1, name: "stage_requests", kind: "message", repeat: 1, T: () => II }
      ]);
    }
  }
  const Hd = new AI();
  class DI extends MessageType {
    constructor() {
      super("socket.livestreaming.GrantStageAccessRequest", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const MI = new DI();
  class OI extends MessageType {
    constructor() {
      super("socket.livestreaming.DenyStageAccessRequest", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const NI = new OI();
  class LI extends MessageType {
    constructor() {
      super("socket.livestreaming.LeaveStageRequest", [
        {
          no: 1,
          name: "user_ids",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const th = new LI();
  class xI extends MessageType {
    constructor() {
      super("socket.polls.Poll", [
        {
          no: 1,
          name: "poll_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "created_by",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "created_by_user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 4,
          name: "question",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 5, name: "options", kind: "message", repeat: 1, T: () => UI },
        {
          no: 6,
          name: "hide_votes",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 7,
          name: "anonymous",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 8,
          name: "votes",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const Wf = new xI();
  class $I extends MessageType {
    constructor() {
      super("socket.polls.PollOption", [
        {
          no: 1,
          name: "text",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "count",
          kind: "scalar",
          opt: true,
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        },
        { no: 3, name: "votes", kind: "message", repeat: 1, T: () => VI }
      ]);
    }
  }
  const UI = new $I();
  class FI extends MessageType {
    constructor() {
      super("socket.polls.PollVote", [
        {
          no: 1,
          name: "user_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const VI = new FI();
  class HI extends MessageType {
    constructor() {
      super("socket.polls.NewPollRequest", [
        {
          no: 1,
          name: "question",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "options",
          kind: "scalar",
          repeat: 2,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 3,
          name: "anonymous",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 4,
          name: "hide_votes",
          kind: "scalar",
          T: 8
          /*ScalarType.BOOL*/
        },
        {
          no: 5,
          name: "created_by",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 6,
          name: "created_by_user_id",
          kind: "scalar",
          opt: true,
          T: 9
          /*ScalarType.STRING*/
        }
      ]);
    }
  }
  const BI = new HI();
  class qI extends MessageType {
    constructor() {
      super("socket.polls.VotePollRequest", [
        {
          no: 1,
          name: "poll_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "index",
          kind: "scalar",
          T: 4,
          L: 2
          /*LongType.NUMBER*/
        }
      ]);
    }
  }
  const jI = new qI();
  class GI extends MessageType {
    constructor() {
      super("socket.polls.UpdatePollResponse", [
        { no: 1, name: "poll", kind: "message", T: () => Wf }
      ]);
    }
  }
  const Bd = new GI();
  class JI extends MessageType {
    constructor() {
      super("socket.polls.GetPollsResponse", [
        { no: 1, name: "polls", kind: "message", repeat: 1, T: () => Wf }
      ]);
    }
  }
  const WI = new JI();
  class KI extends MessageType {
    constructor() {
      super("socket.recording.RecordingEvent", [
        {
          no: 1,
          name: "recording_id",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        {
          no: 2,
          name: "err_message",
          kind: "scalar",
          T: 9
          /*ScalarType.STRING*/
        },
        { no: 3, name: "recording_type", kind: "enum", T: () => ["common.RecordingType", vn] }
      ]);
    }
  }
  const rh = new KI();
  class zI extends MessageType {
    constructor() {
      super("google.protobuf.Timestamp", [
        {
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3,
          L: 0
          /*LongType.BIGINT*/
        },
        {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
          /*ScalarType.INT32*/
        }
      ]);
    }
    /**
     * Creates a new `Timestamp` for the current time.
     */
    now() {
      const t = this.create(), e = Date.now();
      return t.seconds = PbLong.from(Math.floor(e / 1e3)).toBigInt(), t.nanos = e % 1e3 * 1e6, t;
    }
    /**
     * Converts a `Timestamp` to a JavaScript Date.
     */
    toDate(t) {
      return new Date(PbLong.from(t.seconds).toNumber() * 1e3 + Math.ceil(t.nanos / 1e6));
    }
    /**
     * Converts a JavaScript Date to a `Timestamp`.
     */
    fromDate(t) {
      const e = this.create(), r = t.getTime();
      return e.seconds = PbLong.from(Math.floor(r / 1e3)).toBigInt(), e.nanos = r % 1e3 * 1e6, e;
    }
    /**
     * In JSON format, the `Timestamp` type is encoded as a string
     * in the RFC 3339 format.
     */
    internalJsonWrite(t, e) {
      let r = PbLong.from(t.seconds).toNumber() * 1e3;
      if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z"))
        throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (t.nanos < 0)
        throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
      let n = "Z";
      if (t.nanos > 0) {
        let i = (t.nanos + 1e9).toString().substring(1);
        i.substring(3) === "000000" ? n = "." + i.substring(0, 3) + "Z" : i.substring(6) === "000" ? n = "." + i.substring(0, 6) + "Z" : n = "." + i + "Z";
      }
      return new Date(r).toISOString().replace(".000Z", n);
    }
    /**
     * In JSON format, the `Timestamp` type is encoded as a string
     * in the RFC 3339 format.
     */
    internalJsonRead(t, e, r) {
      if (typeof t != "string")
        throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(t) + ".");
      let n = t.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!n)
        throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
      let i = Date.parse(n[1] + "-" + n[2] + "-" + n[3] + "T" + n[4] + ":" + n[5] + ":" + n[6] + (n[8] ? n[8] : "Z"));
      if (Number.isNaN(i))
        throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
      if (i < Date.parse("0001-01-01T00:00:00Z") || i > Date.parse("9999-12-31T23:59:59Z"))
        throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      return r || (r = this.create()), r.seconds = PbLong.from(i / 1e3).toBigInt(), r.nanos = 0, n[7] && (r.nanos = parseInt("1" + n[7] + "0".repeat(9 - n[7].length)) - 1e9), r;
    }
  }
  new zI();
  const YI = 0, QI = 1, XI = 2, ZI = 3, eA = 4, tA = 5, rA = {
    getPeerInfo: 0,
    updatePeerInfo: 1,
    getRoomPeersInfo: 2,
    joinRoom: 3,
    leaveRoom: 4,
    getRoomInfo: 5,
    updateRoomInfo: 6,
    closeRoom: 7,
    startedLivestream: 8,
    stoppedLivestream: 9,
    erroredLivestream: 10,
    getStagePeers: 11,
    getStageRequests: 12,
    requestStageAccess: 13,
    cancelStageRequest: 14,
    grantStageAccess: 15,
    denyStageAccess: 16,
    roomPeerCount: 17,
    joinStage: 18,
    leaveStage: 19,
    // getConnectedRoomsDump returns entire dump for a breakout rooms meeting
    // This details which peer is in which meeting currently, and which is the parent meeting
    getConnectedRoomsDump: 20,
    // createConnectedRooms to create breakout rooms
    createConnectedRooms: 21,
    // deleteConnectedRooms to delete breakout rooms
    deleteConnectedRooms: 22,
    // move peers between breakout rooms
    movePeers: 23,
    // transfer peer to new room
    transferPeer: 24,
    // message sent by socket service to inform client of a participant joining a breakout room
    movedPeer: 25,
    // message sent by socket service to inform client of updates in connected rooms
    connectedRoomsUpdated: 26,
    // message sent by socket service to inform client of deletion in connected rooms
    connectedRoomsDeleted: 27,
    // get all participants that have been added to the meeting irrespective of their live status
    getAllAddedParticipants: 28,
    // broadcast api
    broadcastMessage: 29,
    kick: 30,
    kickAll: 31,
    transcript: 32,
    // waitlist events
    getWaitingRoomRequests: 33,
    acceptWaitingRoomRequests: 34,
    waitingRoomRequestAccepted: 35,
    denyWaitingRoomRequests: 36,
    waitingRoomRequestDenied: 37,
    peerStageStatusUpdate: 38,
    broadcastToPeers: 39,
    recordingStarted: 40,
    recordingStopped: 41,
    recordingPaused: 42,
    getRoomStageState: 43,
    livestreamingInvoked: 44
  }, sA = {
    getMessages: 0,
    sendMessageToRoom: 1,
    sendMessageToPeers: 2,
    editMessage: 3,
    deleteMessage: 4,
    getPaginatedMessages: 5,
    sendMessageToChannel: 6,
    searchChannelMessages: 7,
    getAllChatChannels: 8,
    markChannelIndexAsRead: 9,
    pinMessage: 10
  }, nA = {
    getPlugins: 0,
    addPlugin: 1,
    enablePluginForRoom: 2,
    disablePluginForPeers: 3,
    enablePluginForPeers: 4,
    disablePluginForRoom: 5,
    removePlugin: 6,
    customPluginEventToRoom: 7,
    customPluginEventToPeers: 8,
    storeInsertKeys: 9,
    storeGetKeys: 10,
    storeDeleteKeys: 11,
    storeDelete: 12
  }, iA = {
    createPoll: 0,
    getPolls: 1,
    votePoll: 2,
    updatePoll: 3
  }, Kf = {
    unknown: 0,
    createWebRTCTransport: 1,
    produce: 2,
    consume: 3,
    toggleProducer: 4,
    toggleConsumer: 5,
    closeProducer: 6,
    closeConsumer: 7,
    // adding some buffers for new media events.
    joinRoom: 16,
    leaveRoom: 17,
    selectedPeer: 18,
    globalPinPeer: 19,
    selfJoinComplete: 20,
    // some additional buffer for broadcast events.
    peerJoinedBroadcast: 25,
    peerLeaveBroadcast: 26,
    peerProducerCreateBroadcast: 27,
    peerProducerToggleBroadcast: 28,
    peerProducerCloseBroadcast: 29,
    globalPeerPinBroadcast: 30,
    recordingStartedBroadcast: 31,
    recordingStoppedBroadcast: 32,
    peerDisplayNameEditBroadcast: 33,
    mediaRoomTerminationBroadcastResponse: 36,
    selectedPeerDiff: 40,
    renegotiateSessionDescription: 50,
    errorResponse: 60,
    kickPeer: 90,
    kickAll: 91,
    changeDisplayName: 92,
    hostControlPeer: 93,
    hostControlAllPeers: 94
  }, aA = {
    createChatChannel: 0,
    getChatChannel: 1,
    deprecatedGetAllChatChannels: 2,
    getChannelMembers: 3,
    updateChatChannel: 4
  }, oA = {
    getUserPresets: 0,
    updateUserPreset: 1
  };
  function Ui(s, t) {
    return Object.keys(t).reduce((e, r) => (e[r] = (s << 16) + t[r], e), {});
  }
  function zf(s, t) {
    return Object.keys(s).reduce((e, r) => (e[r] = t | s[r], e), {});
  }
  const F = Ui(YI, rA), Ne = Ui(QI, sA), J = Ui(
    XI,
    nA
  ), Ar = Ui(ZI, iA), Ws = Ui(
    eA,
    aA
  ), ae = zf(Kf, 16777216), oe = zf(Kf, 50331648), Ho = Ui(
    tA,
    oA
  );
  var cA = Object.defineProperty, dA = Object.getOwnPropertyDescriptor, tu = (s, t, e, r) => {
    for (var n = dA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && cA(t, e, n), n;
  }, us, _h;
  const ml = (_h = class {
    constructor(s) {
      E(this, us, undefined);
      _(this, us, s);
    }
    createChannel(s, t, e, r = "public", n = false) {
      return u(this, null, function* () {
        const i = {
          displayName: s,
          targetUserIds: t,
          displayPictureUrl: e,
          visibility: r,
          isDirectMessage: n
        };
        n && (i.visibility = "private");
        const a = yield o(this, us).sendMessagePromise(
          Ws.createChatChannel,
          Ok.toBinary(i)
        ), c = Ir.fromBinary(
          a.payload
        ).chatChannels;
        return ml.formatChannel(c[0]);
      });
    }
    updateChannel(s, t) {
      return u(this, null, function* () {
        const e = yield o(this, us).sendMessagePromise(
          Ws.updateChatChannel,
          Lk.toBinary({
            chatChannelId: s,
            targetUserIds: t.memberIds,
            displayName: t.displayName,
            displayPictureUrl: t.displayPictureUrl,
            visibility: t.visibility
          })
        ), r = Ir.fromBinary(
          e.payload
        ).chatChannels;
        return ml.formatChannel(r[0]);
      });
    }
    static formatChannel(s) {
      var r;
      const { latestMessageAndUnreadCount: t } = s, e = z(L({}, s), {
        id: s.chatChannelId,
        memberIds: s.targetUserIds,
        unreadCount: (r = t == null ? undefined : t.unreadCount) != null ? r : 0
      });
      return t != null && t.message && (e.latestMessage = tr.formatSocketServiceMessage(
        t.message
      )), delete e.chatChannelId, delete e.targetUserIds, delete e.latestMessageAndUnreadCount, e;
    }
    getChannelMembers(s) {
      return u(this, null, function* () {
        try {
          const t = yield o(this, us).sendMessagePromise(
            Ws.getChannelMembers,
            Uk.toBinary({ chatChannelId: s })
          );
          return Wk.fromBinary(t.payload).channelMembers.map((n) => {
            var i = n, { id: e } = i, r = na(i, ["id"]);
            return z(L({}, r), { userId: e });
          });
        } catch (t) {
          return [];
        }
      });
    }
    on(s, t) {
      let e, r;
      switch (s) {
        case Ws.createChatChannel: {
          e = Ir.fromBinary.bind(
            Ir
          ), r = Ir.create();
          break;
        }
        case Ws.updateChatChannel: {
          e = Ir.fromBinary.bind(
            Ir
          ), r = Ir.create();
          break;
        }
      }
      if (!e) {
        l.warn(
          `ChatChannelSocketHandler::Event ${s} is not recognized`
        );
        return;
      }
      o(this, us).on(s, ({ payload: n }) => {
        let i = r;
        try {
          i = e(n);
        } catch (a) {
          l.error("ChatChannelSocketHandler::on::binary_decode_error", {
            error: a
          });
        }
        return t(i);
      });
    }
  }, us = new WeakMap(), _h);
  let _n = ml;
  tu([
    v.trace("ChatChannelHandler.createChannel")
  ], _n.prototype, "createChannel");
  tu([
    v.trace("ChatChannelHandler.updateChannel")
  ], _n.prototype, "updateChannel");
  tu([
    v.trace("ChatChannelHandler.getChannelMembers")
  ], _n.prototype, "getChannelMembers");
  var lA = Object.defineProperty, uA = Object.getOwnPropertyDescriptor, or = (s, t, e, r) => {
    for (var n = uA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && lA(t, e, n), n;
  }, Et = /* @__PURE__ */ ((s) => (s[s.TEXT = 0] = "TEXT", s[s.IMAGE = 1] = "IMAGE", s[s.FILE = 2] = "FILE", s[s.CUSTOM = 3] = "CUSTOM", s))(Et || {}), dt;
  class Qt {
    constructor(t) {
      E(this, dt, undefined);
      _(this, dt, t);
    }
    getChatMessages() {
      return o(this, dt).sendMessagePromise(Ne.getMessages);
    }
    getChatMessagesPaginated(t, e, r, n = 0, i = "") {
      return u(this, null, function* () {
        const a = {
          timeStamp: t,
          size: e,
          from: n,
          reversed: r,
          channelId: i
        }, c = yield o(this, dt).sendMessagePromise(
          Ne.getPaginatedMessages,
          nk.toBinary(a)
        );
        return c.payload ? ak.fromBinary(
          c.payload
        ) : {
          messages: [],
          next: false
        };
      });
    }
    sendMessageToRoom(t, e) {
      const r = {
        payloadType: e,
        payload: t
      };
      o(this, dt).sendMessage(
        Ne.sendMessageToRoom,
        dk.toBinary(r)
      );
    }
    sendMessageToPeers(t, e, r) {
      const n = {
        payloadType: e,
        peerIds: r,
        payload: t
      };
      o(this, dt).sendMessage(
        Ne.sendMessageToPeers,
        pk.toBinary(n)
      );
    }
    sendMessageToChannel(t, e, r) {
      const n = {
        payloadType: e,
        channelId: r,
        payload: t
      };
      o(this, dt).sendMessage(
        Ne.sendMessageToChannel,
        fk.toBinary(n)
      );
    }
    sendMessage(t, e, r, n) {
      if (n && this.sendMessageToChannel(t, e, n), r && r.length > 0) {
        this.sendMessageToPeers(t, e, r);
        return;
      }
      this.sendMessageToRoom(t, e);
    }
    editMessage(t, e, r, n, i) {
      return u(this, null, function* () {
        const a = {
          chatId: t,
          payloadType: r,
          payload: e
        };
        n && (a.channelId = n), i !== undefined && (a.pinned = i);
        const c = yield o(this, dt).sendMessagePromise(
          Ne.editMessage,
          yk.toBinary(a)
        );
        return Ao.fromBinary(c.payload).message;
      });
    }
    deleteMessage(t, e) {
      return u(this, null, function* () {
        const r = {
          chatId: t
        };
        e && (r.channelId = e);
        const n = yield o(this, dt).sendMessagePromise(
          Ne.deleteMessage,
          wk.toBinary(r)
        ), i = Do.fromBinary(n.payload);
        return L({
          id: i.chatId
        }, i.channelId ? { channelId: i.channelId } : {});
      });
    }
    searchMessages(t, e) {
      return u(this, null, function* () {
        var n, i, a;
        const r = {
          searchTerm: t,
          timeStamp: (n = e.timestamp) != null ? n : Date.now(),
          size: (i = e.size) != null ? i : 75,
          from: 0,
          reversed: (a = e.reversed) != null ? a : true
        };
        e.channelId && (r.channelId = e.channelId);
        try {
          const c = yield o(this, dt).sendMessagePromise(
            Ne.searchChannelMessages,
            bk.toBinary(r)
          );
          return Jf.fromBinary(c.payload).messages;
        } catch (c) {
          return [];
        }
      });
    }
    getAllChannels() {
      return u(this, null, function* () {
        try {
          const t = yield o(this, dt).sendMessagePromise(
            Ne.getAllChatChannels
          );
          return Ir.fromBinary(t.payload).chatChannels.map(_n.formatChannel);
        } catch (t) {
          return [];
        }
      });
    }
    markLastReadMessage(t, e) {
      return u(this, null, function* () {
        const r = yield o(this, dt).sendMessagePromise(
          Ne.markChannelIndexAsRead,
          Ik.toBinary({
            channelId: t,
            userId: e.userId,
            channelIndex: e.channelIndex
          })
        );
        return Dk.fromBinary(r.payload).channelIndex;
      });
    }
    setPinState(t, e) {
      return u(this, null, function* () {
        const r = {
          chatId: t.id,
          pinned: e,
          channelId: t.channelId
        }, n = yield o(this, dt).sendMessagePromise(
          Ne.pinMessage,
          _k.toBinary(r)
        );
        return Io.fromBinary(n.payload);
      });
    }
    on(t, e) {
      let r, n;
      switch (t) {
        case Ne.sendMessageToRoom: {
          r = Fd.fromBinary.bind(
            Fd
          ), n = Fd.create();
          break;
        }
        case Ne.sendMessageToPeers: {
          r = Vd.fromBinary.bind(
            Vd
          ), n = Vd.create();
          break;
        }
        case Ne.editMessage: {
          r = Ao.fromBinary.bind(
            Ao
          ), n = Ao.create();
          break;
        }
        case Ne.pinMessage: {
          r = Io.fromBinary.bind(
            Io
          ), n = Io.create();
          break;
        }
        case Ne.deleteMessage: {
          r = Do.fromBinary.bind(
            Do
          ), n = Do.create();
          break;
        }
      }
      if (!r) {
        l.warn(`ChatSocketHandler::Event ${t} is not recognized`);
        return;
      }
      o(this, dt).on(t, ({ payload: i }) => {
        let a = n;
        try {
          a = r(i);
        } catch (c) {
          l.error("chatSocketHandler::on::binary_decode_error", {
            error: c
          });
        }
        return e(a);
      });
    }
  }
  dt = new WeakMap();
  or([
    v.trace("SocketService.getChatMessages")
  ], Qt.prototype, "getChatMessages");
  or([
    v.trace("SocketService.getChatMessagesPaginated")
  ], Qt.prototype, "getChatMessagesPaginated");
  or([
    v.trace("SocketService.sendMessageToRoom")
  ], Qt.prototype, "sendMessageToRoom");
  or([
    v.trace("SocketService.sendMessageToPeers")
  ], Qt.prototype, "sendMessageToPeers");
  or([
    v.trace("SocketService.sendMessageToChannel")
  ], Qt.prototype, "sendMessageToChannel");
  or([
    v.trace("SocketService.sendMessage")
  ], Qt.prototype, "sendMessage");
  or([
    v.trace("SocketService.editMessage")
  ], Qt.prototype, "editMessage");
  or([
    v.trace("SocketService.deleteMessage")
  ], Qt.prototype, "deleteMessage");
  or([
    v.trace("SocketService.searchMessages")
  ], Qt.prototype, "searchMessages");
  or([
    v.trace("SocketService.getAllChannels")
  ], Qt.prototype, "getAllChannels");
  or([
    v.trace("SocketService.markLastReadMessage")
  ], Qt.prototype, "markLastReadMessage");
  function pA(s) {
    return s.replace(
      /([-_]\w)/g,
      (t) => t[1].toUpperCase()
    );
  }
  function sr(s) {
    if (!s || typeof s != "object")
      return s;
    if (Array.isArray(s))
      return s.map(
        (e) => sr(e)
      );
    const t = {};
    return Object.keys(s).forEach((e) => {
      const r = validate(e) ? e : pA(e);
      t[r] = sr(s[e]);
    }), t;
  }
  function hA(s) {
    return s.replace(
      /[A-Z]/g,
      (t) => `_${t.toLowerCase()}`
    );
  }
  function Yf(s) {
    if (!s || typeof s != "object")
      return s;
    if (Array.isArray(s))
      return s.map(
        (e) => Yf(e)
      );
    const t = {};
    return Object.keys(s).forEach((e) => {
      const r = validate(e) ? e : hA(e);
      t[r] = s[e];
    }), t;
  }
  function dc(s, t = {}) {
    return s == null ? {} : (Object.getOwnPropertyNames(s).forEach((e) => {
      if (typeof s[e] != "function") {
        if (typeof s[e] == "object") {
          dc(s[e], t[e] = {});
          return;
        }
        t[e] = s[e];
      }
    }), t);
  }
  const mA = 3, fA = 30, gA = 8e3;
  class vA {
    constructor(t, e) {
      f(this, "ipInfo");
      f(this, "axios");
      f(this, "requests");
      f(this, "roomName");
      f(this, "roomUUID");
      f(this, "authToken");
      f(this, "organizationId");
      f(this, "iceServers");
      f(this, "pluginInformation");
      f(this, "userDetails");
      f(this, "roomDetails");
      f(this, "context");
      this.context = t;
      const {
        timeout: r = gA,
        retry: n = mA,
        retryDelay: i = fA,
        baseURL: a = "https://api.cluster.dyte.in",
        authToken: c,
        cachedUserDetails: d
      } = e || {};
      this.iceServers = d == null ? undefined : d.iceServers, this.pluginInformation = d == null ? undefined : d.pluginInformation, this.userDetails = d == null ? undefined : d.userDetails, this.roomDetails = d == null ? undefined : d.roomDetails, this.requests = Zo.create({
        baseURL: a,
        responseType: "json",
        timeout: r,
        retry: n,
        retryDelay: i
      }), this.axios = Zo, this.setAuthToken(c, { bearer: true }), this.requests.interceptors.request.use(
        (p) => (v.injectContext(this.requests.defaults.headers.common), p),
        (p) => u(this, null, function* () {
          l.error("xhr::axios", {
            debuggingHint: "otelRequestInterceptor failed.",
            error: p
          });
        })
      ), this.requests.interceptors.response.use(
        (p) => {
          try {
            p.config.url !== v.logsEndpoint && l.debug("xhr::axios", {
              // Note(ravindra-dyte): Do not Log entire data, log what is needed
              networkCall: {
                status: p.status,
                statusText: p.statusText,
                baseURL: p.config.baseURL,
                url: p.config.url,
                method: p.config.method
              }
            });
          } catch (h) {
            console.error("xhr::dyte", {
              error: "responseInterceptorFailed",
              err: h,
              response: p
            });
          }
          return p;
        },
        (p) => u(this, null, function* () {
          var h;
          try {
            if (!p)
              return Promise.reject(new w("Unknown network error occurred", "0011"));
            p && p.config && ((h = p.config) == null ? void 0 : h.url) !== v.logsEndpoint && l.error("xhr::axios", {
              error: p,
              networkCall: {
                status: p.status,
                statusText: p.statusText,
                baseURL: p.config.baseURL,
                url: p.config.url,
                retries: p.config.retry,
                method: p.config.method,
                isOnline: navigator.onLine ? "online" : "offline"
              }
            });
            const {
              config: m,
              message: g
            } = p;
            return m && g && m.retry !== void 0 && m.retry > 0 && (g.includes("timeout") || g.includes("Network Error")) ? (m.retry -= 1, this.requests(m)) : Promise.reject(new w(g, "0011"));
          } catch (m) {
            return console.error("xhr::dyte", {
              error: "responseInterceptorFailed",
              err: m,
              responseError: p
            }), Promise.reject(new w(m.message, "0011"));
          }
        })
      );
    }
    get peerId() {
      return this.context.getValue("peerId");
    }
    setAuthToken(t, e) {
      const { bearer: r } = e || {};
      this.authToken = t, this.requests.defaults.headers.common.Authorization = r ? `Bearer ${t}` : t;
    }
    setHeader(t, e) {
      this.requests.defaults.headers.common[t] = e;
    }
    setRoomName(t) {
      this.roomName = t;
    }
    setRoomUUID(t) {
      this.roomUUID = t;
    }
    setOrganizationId(t) {
      this.organizationId = t;
    }
  }
  var yA = Object.defineProperty, TA = Object.getOwnPropertyDescriptor, ru = (s, t, e, r) => {
    for (var n = TA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && yA(t, e, n), n;
  };
  class Qc extends vA {
    constructor(t, e) {
      super(t, e), this.setHeader("x-dyte-web-core-version", t.getValue("sdkVersion"));
    }
    getIPDetails() {
      return u(this, null, function* () {
        var e;
        const { peerId: t } = this;
        try {
          const r = yield xl$1.getIPDetails({
            peerId: t,
            apiHostnames: pf(this.context),
            logger: l
          });
          if (l.log("ipInfo", { ipInfo: r }), ((e = r == null ? void 0 : r.loc) == null ? void 0 : e.length) > 5)
            return r;
          throw Error("Insufficient data");
        } catch (r) {
          l.warn(
            "ApiClient.getRoomNodeLinkAndTitleV1 Failed to get ip details",
            { error: { name: r.name, message: r.message } }
          );
          return;
        }
      });
    }
    getICEServers() {
      return u(this, null, function* () {
        if (this.iceServers)
          return this.iceServers;
        const { success: t, iceServers: e } = (yield this.requests.get("/iceservers")).data;
        if (t)
          return (e == null ? undefined : e.length) > 0 && (this.iceServers = e), e;
      });
    }
    getPlugins() {
      return u(this, null, function* () {
        var n, i, a, c, d, p, h;
        if (this.pluginInformation)
          return this.pluginInformation;
        let { plugins: t } = (yield this.requests.get("/v2/plugins/user")).data.data;
        const e = ((i = (n = K.getValue(ie.V1_PLUGINS)) == null ? undefined : n.toString()) == null ? undefined : i.split(",")) || [];
        return t = t.reduce(
          (m, g) => (m[e.includes(g.id) ? "v1" : "v2"].push(g), m),
          { v1: [], v2: [] }
        ).v2, (d = (c = (a = this.context.getValue("modules")) == null ? undefined : a.devTools) == null ? undefined : c.plugins) != null && d.length && ((h = (p = this.context.getValue("modules")) == null ? undefined : p.devTools) == null || h.plugins.forEach((m) => {
          var T, y, b;
          const g = z(L({}, oa), {
            tags: [...oa.tags]
          });
          g.baseURL = `http://localhost:${m.port}`, g.name = m.name, g.picture = (T = m.picture) != null ? T : oa.picture, g.description = (y = m.description) != null ? y : oa.description, g.staggered = (b = m.staggered) != null ? b : oa.staggered, g.createdAt = new Date().toISOString(), g.updatedAt = new Date().toISOString(), g.id = m.id, g.organizationId = this.organizationId, t.push(g);
        })), t;
      });
    }
    getPluginDetails(t) {
      return u(this, null, function* () {
        const { plugin: e } = (yield this.requests.get(`/v2/plugins/view/${t}`)).data.data;
        return e;
      });
    }
    getPluginConfig(t) {
      return u(this, null, function* () {
        return (yield this.axios.get(`${t}/dyte-config.json`)).data;
      });
    }
    authorizePlugin(t) {
      return u(this, null, function* () {
        const e = {
          peerId: this.peerId
        }, { token: r } = (yield this.requests.post(`/v2/plugins/authorize/${t}`, e)).data.data;
        return r;
      });
    }
    getPresignedUrls(t, e) {
      return u(this, null, function* () {
        const r = ol(this.context, "chat_upload_expiry"), n = {
          roomUUID: this.roomUUID,
          filename: t,
          expiry: typeof r == "number" ? r : undefined
        };
        K.hasFeature(ie.FEAT_CHAT_SDK) && (n.viewType = e);
        const { getLocation: i, putLocation: a } = (yield this.requests.post("/v1/meetings/genPreSignedUploadUrl", n)).data.data;
        return {
          getLocation: i,
          putLocation: a
        };
      });
    }
    uploadFile(t, e) {
      return u(this, null, function* () {
        if (navigator.isReactNative && "uri" in t)
          try {
            yield fetch(e, {
              method: "PUT",
              headers: {
                "Content-Type": "application/octet-stream"
              },
              body: {
                uri: t.uri,
                name: t.name
              }
            });
          } catch (r) {
            l.error(`sendFileMessage::${r}`);
          }
        else
          yield this.axios.put(e, t, {
            headers: {
              "Content-Type": t.type
            }
          });
      });
    }
  }
  ru([
    v.trace("APIClient.getIPDetails")
  ], Qc.prototype, "getIPDetails");
  ru([
    v.trace("APIClient.getICEServers")
  ], Qc.prototype, "getICEServers");
  ru([
    v.trace("APIClient.getPlugins")
  ], Qc.prototype, "getPlugins");
  var _A = Object.defineProperty, SA = Object.getOwnPropertyDescriptor, Zr = (s, t, e, r) => {
    for (var n = SA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && _A(t, e, n), n;
  };
  class br extends Qc {
    // eslint-disable-next-line class-methods-use-this
    startLivestreaming(e) {
      return u(this, arguments, function* ({
        manualIngestion: t
      }) {
        const r = sr(
          yield this.requests.post(
            `/v2/meetings/${this.context.getValue("meetingId")}/livestreams`,
            {
              manual_ingest: !!t
            }
          )
        ).data.data;
        return {
          playbackUrl: r.playbackUrl,
          status: r.status,
          manualIngest: r.manualIngest,
          ingestionCredentials: r.streamKey ? {
            ingestionServer: r.ingestServer,
            streamKey: r.streamKey
          } : null
        };
      });
    }
    // eslint-disable-next-line class-methods-use-this
    stopLivestreaming() {
      return u(this, null, function* () {
        return this.requests.post(
          `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream/stop`
        );
      });
    }
    getActiveLivestream() {
      return u(this, null, function* () {
        const t = sr(
          (yield this.requests.get(
            `/v2/meetings/${this.context.getValue("meetingId")}/active-livestream`
          )).data.data
        );
        return {
          playbackUrl: t.playbackUrl,
          status: t.status,
          manualIngest: t.manualIngest,
          ingestionCredentials: t.streamKey ? {
            ingestionServer: t.ingestServer,
            streamKey: t.streamKey
          } : null
        };
      });
    }
    getUserDetails() {
      return u(this, null, function* () {
        if (this.userDetails)
          return this.userDetails;
        const t = (yield this.requests.get("v2/internals/participant-details")).data.data;
        return sr(t);
      });
    }
    startRecording(t, e) {
      return u(this, null, function* () {
        return (yield this.requests.post("/v2/recordings", z(L({}, Yf(t)), {
          meeting_id: this.context.getValue("meetingId"),
          allow_multiple_recordings: !!e
        }))).data.data.id;
      });
    }
    updateRecording(t, e) {
      return u(this, null, function* () {
        return this.requests.put(`v2/recordings/${t}`, {
          action: e
        });
      });
    }
    getActiveRecording() {
      return u(this, null, function* () {
        const { status: t, id: e } = (yield this.requests.get(
          `v2/recordings/active-recording/${this.context.getValue("meetingId")}`
        )).data.data;
        return { status: t, id: e };
      });
    }
    getActiveTranscript() {
      return u(this, null, function* () {
        const { transcript_download_url: t } = (yield this.requests.get(
          `v2/meetings/${this.context.getValue("meetingId")}/active-transcript`
        )).data.data;
        try {
          return { transcript: (yield this.axios.get(t)).data };
        } catch (e) {
          throw new w("Cant fetch transcript s3 url");
        }
      });
    }
    getRoomNodeData() {
      return u(this, null, function* () {
        const t = yield this.getIPDetails();
        if (this.ipInfo = t, this.roomDetails)
          return this.roomDetails;
        const {
          roomNodeLink: e,
          title: r,
          useHiveMedia: n,
          sfu: i
        } = sr(
          (yield this.requests.post("v2/internals/rooms", {
            ip_information: t
          })).data.data
        );
        return {
          roomNodeUrl: e,
          meetingTitle: r,
          useHiveMedia: n != null ? n : false,
          sfu: i
        };
      });
    }
  }
  Zr([
    v.trace("APIClient.startLivestreaming")
  ], br.prototype, "startLivestreaming");
  Zr([
    v.trace("APIClient.stopLivestreaming")
  ], br.prototype, "stopLivestreaming");
  Zr([
    v.trace("APIClient.getActiveLivestream")
  ], br.prototype, "getActiveLivestream");
  Zr([
    v.trace("APIClient.getUserDetails")
  ], br.prototype, "getUserDetails");
  Zr([
    v.trace("APIClient.startRecording")
  ], br.prototype, "startRecording");
  Zr([
    v.trace("APIClient.stopRecording")
  ], br.prototype, "updateRecording");
  Zr([
    v.trace("APIClient.getActiveRecording")
  ], br.prototype, "getActiveRecording");
  Zr([
    v.trace("APIClient.getActiveTranscript")
  ], br.prototype, "getActiveTranscript");
  Zr([
    v.trace("APIClient.getRoomNodeData")
  ], br.prototype, "getRoomNodeData");
  let fl;
  function EA(s, t) {
    return fl = new br(s, t), fl;
  }
  function qe() {
    return fl;
  }
  function CA(s, t) {
    return `<blockquote>${t.replace(/<blockquote>[.\s\S]*<\/blockquote>\n\n/m, "")}</blockquote>

${s}`;
  }
  const Fi = {
    maxInvocations: 5,
    period: 1
  };
  function At(s, t) {
    return function(e, r, n) {
      const i = n.value;
      let a = 0, c = Date.now();
      return n.value = function(...d) {
        const p = Date.now(), h = t ? this[t] : s;
        if (p - c > h.period * 1e3 && (c = p, a = 0), a >= h.maxInvocations)
          throw new w(`Method rate limit ${h.maxInvocations} invocations/${h.period}sec exceeded`);
        return a += 1, i.apply(this, d);
      }, n;
    };
  }
  var wA = Object.defineProperty, PA = Object.getOwnPropertyDescriptor, yt = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? PA(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && wA(t, e, n), n;
  };
  const RA = ["text", "image", "file", "custom", "poll"], Bo = { maxInvocations: 180, period: 60 };
  var re, zs, Je, Ys, Pa, _c, Qf, Sh;
  let rt = (Sh = class extends Ft {
    constructor(t, e, r, n, i) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, _c);
      /**
       * An array of chat messages.
       */
      f(this, "messages");
      /**
       * An Array of all available channels.
       */
      f(this, "channels", []);
      E(this, re, undefined);
      E(this, zs, undefined);
      E(this, Je, undefined);
      E(this, Ys, undefined);
      E(this, Pa, undefined);
      f(this, "maxTextLimit", 2e3);
      _(this, Pa, t), _(this, Je, e), _(this, Ys, r), _(this, re, n), _(this, zs, i), this.messages = [];
    }
    /**
    	Set the max character limit of a text message
    */
    setMaxTextLimit(t) {
      this.maxTextLimit = t;
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get socketJoined() {
      return o(this, _c, Qf).socketJoined === true;
    }
    sendMessageInternal(i, a, c) {
      return u(this, arguments, function* (t, e, r, n = {}) {
        switch (t.type) {
          case "text": {
            const d = n.replyTo && n.replyTo.type === "text" ? CA(t.message, n.replyTo.message) : t.message;
            yield this.sendTextMessageInternal(d, e, r);
            break;
          }
          case "image":
            yield this.sendImageMessageInternal(t.image, e, r);
            break;
          case "file":
            yield this.sendFileMessageInternal(t.file, e, r);
            break;
          default:
            l.error("sendMessage::message_type_not_supported", {
              dyteChat: { messageType: t.type }
            });
            break;
        }
      });
    }
    sendTextMessageInternal(t, e, r) {
      return u(this, null, function* () {
        var i, a, c, d, p, h;
        if (t.length > this.maxTextLimit)
          throw new w("Max character limit breached");
        if (e && e.length > 0) {
          if (!((i = o(this, re).permissions) != null && i.chatPrivate.canSend) || !((a = o(this, re).permissions) != null && a.chatPrivate.text))
            throw l.error("sendTextMessage::private_chat_permission_denied"), new w("Could not send message to private chat.", "0501");
        } else if (!((d = (c = o(this, re).permissions) == null ? undefined : c.chatPublic) != null && d.canSend) || !((h = (p = o(this, re).permissions) == null ? undefined : p.chatPublic) != null && h.text))
          throw l.error("sendTextMessage::public_chat_permission_denied"), new w("Could not send message to public chat.", "0501");
        if (!t)
          throw l.error("sendTextMessage::message_can_not_be_empty"), new w("Message can not be empty.", "0502");
        if (r) {
          o(this, Je).sendMessageToChannel(t, Et.TEXT, r);
          return;
        }
        let n = [];
        e && e.length > 0 && (e.push(o(this, re).id), n = o(this, zs).joined.toArray().filter((m) => e.includes(m.id)).map((m) => m.userId), n.push(o(this, re).userId)), o(this, Je).sendMessage(
          t,
          Et.TEXT,
          e
        );
      });
    }
    sendImageMessageInternal(t, e, r) {
      return u(this, null, function* () {
        var i, a, c, d, p, h;
        if (e && e.length > 0) {
          if (!((i = o(this, re).permissions) != null && i.chatPrivate.canSend) || !((a = o(this, re).permissions) != null && a.chatPrivate.files)) {
            l.error("sendImageMessage::private_chat_permission_denied");
            return;
          }
        } else if (!((d = (c = o(this, re).permissions) == null ? undefined : c.chatPublic) != null && d.canSend) || !((h = (p = o(this, re).permissions) == null ? undefined : p.chatPublic) != null && h.files)) {
          l.error("sendImageMessage::permission_denied");
          return;
        }
        if (!t) {
          l.error("sendImageMessage::required_argument_image_can_not_be_empty");
          return;
        }
        if (!["image/gif", "image/jpeg", "image/png"].includes(t.type)) {
          l.error("sendImageMessage::image_type_not_supported", { dyteChat: { imageType: t.type } });
          return;
        }
        try {
          const m = qe(), { getLocation: g, putLocation: T } = yield m.getPresignedUrls(
            t.name,
            o(this, re).config.viewType
          );
          if (yield m.uploadFile(t, T), r) {
            o(this, Je).sendMessageToChannel(
              g,
              Et.IMAGE,
              r
            );
            return;
          }
          let y = [];
          e && e.length > 0 && (e.push(o(this, re).id), y = o(this, zs).joined.toArray().filter((b) => e.includes(b.id)).map((b) => b.userId), y.push(o(this, re).userId)), o(this, Je).sendMessage(
            g,
            Et.IMAGE,
            e
          );
        } catch (m) {
          throw new w("Error sending image message.");
        }
      });
    }
    sendFileMessageInternal(t, e, r) {
      return u(this, null, function* () {
        var n, i, a, c, d, p;
        if (e && e.length > 0) {
          if (!((n = o(this, re).permissions) != null && n.chatPrivate.canSend) || !((i = o(this, re).permissions) != null && i.chatPrivate.files)) {
            l.error("sendFileMessage::private_chat_permission_denied");
            return;
          }
        } else if (!((c = (a = o(this, re).permissions) == null ? undefined : a.chatPublic) != null && c.canSend) || !((p = (d = o(this, re).permissions) == null ? undefined : d.chatPublic) != null && p.files)) {
          l.error("sendFileMessage::permission_denied");
          return;
        }
        if (!t) {
          l.error("sendFileMessage::required_argument_file_can_not_be_empty");
          return;
        }
        try {
          const h = qe(), { getLocation: m, putLocation: g } = yield h.getPresignedUrls(
            t.name,
            o(this, re).config.viewType
          );
          if (yield h.uploadFile(t, g), r) {
            o(this, Je).sendMessageToChannel(
              JSON.stringify({
                link: m,
                name: t.name,
                size: "size" in t ? t.size : 0
              }),
              Et.FILE,
              r
            );
            return;
          }
          let T = [];
          e && e.length > 0 && (e.push(o(this, re).id), T = o(this, zs).joined.toArray().filter((b) => e.includes(b.id)).map((b) => b.userId), T.push(o(this, re).userId));
          const y = JSON.stringify({
            link: m,
            name: t.name,
            size: "size" in t ? t.size : 0
          });
          o(this, Je).sendMessage(
            y,
            Et.FILE,
            e
          );
        } catch (h) {
          throw new w("Error sending file message.");
        }
      });
    }
    // eslint-disable-next-line class-methods-use-this
    get rateLimits() {
      return Bo;
    }
    // eslint-disable-next-line class-methods-use-this
    updateRateLimits(t, e) {
      Bo.maxInvocations = t, Bo.period = e;
    }
    sendTextMessage(t, e) {
      return u(this, null, function* () {
        return this.sendTextMessageInternal(t, e);
      });
    }
    sendCustomMessage(t, e) {
      return u(this, null, function* () {
        var i, a, c, d, p, h, m, g, T, y, b, A, I, $, V;
        if (e && e.length > 0) {
          if (!((i = o(this, re).permissions) != null && i.chatPrivate.canSend) || !((a = o(this, re).permissions) != null && a.chatPrivate.files) || !((c = o(this, re).permissions) != null && c.chatPrivate.text)) {
            l.error("sendCustomMessage::private_chat_permission_denied");
            return;
          }
        } else if (!((p = (d = o(this, re).permissions) == null ? undefined : d.chatPublic) != null && p.canSend) || !((m = (h = o(this, re).permissions) == null ? undefined : h.chatPublic) != null && m.files) || !((T = (g = o(this, re).permissions) == null ? undefined : g.chatPublic) != null && T.text)) {
          l.error("sendCustomMessage::permission_denied");
          return;
        }
        const r = (O) => u(this, null, function* () {
          try {
            if (typeof O == "string")
              return { link: O };
            const q = qe(), { getLocation: B, putLocation: ne } = yield q.getPresignedUrls(
              O.name,
              o(this, re).config.viewType
            );
            return yield q.uploadFile(O, ne), {
              link: B,
              type: O.type,
              name: O.name,
              size: O.size
            };
          } catch (q) {
            throw new w("Error sending image message.");
          }
        }), n = z(L({}, t), {
          files: yield Promise.all((b = (y = t.files) != null ? y : []) == null ? undefined : b.map((O) => u(this, null, function* () {
            return r(O);
          }))),
          images: yield Promise.all((I = (A = t.images) != null ? A : []) == null ? undefined : I.map((O) => u(this, null, function* () {
            return r(O);
          }))),
          videos: yield Promise.all((V = ($ = t.videos) != null ? $ : []) == null ? undefined : V.map((O) => u(this, null, function* () {
            return r(O);
          })))
        });
        o(this, Je).sendMessage(
          JSON.stringify(n),
          Et.CUSTOM,
          e
        );
      });
    }
    sendImageMessage(t, e) {
      return u(this, null, function* () {
        return this.sendImageMessageInternal(t, e);
      });
    }
    sendFileMessage(t, e) {
      return u(this, null, function* () {
        return this.sendFileMessageInternal(t, e);
      });
    }
    sendMessage(t, e) {
      return u(this, null, function* () {
        return this.sendMessageInternal(t, e);
      });
    }
    editTextMessage(t, e, r) {
      return u(this, null, function* () {
        var n, i, a, c, d, p;
        if (((i = (n = o(this, re).permissions) == null ? undefined : n.chatMessage) == null ? undefined : i.canEdit) === "NONE")
          throw new w("Not permitted to edit messages", "0501");
        if (!((c = (a = o(this, re).permissions) == null ? undefined : a.chatPublic) != null && c.canSend) || !((p = (d = o(this, re).permissions) == null ? undefined : d.chatPublic) != null && p.text)) {
          l.error("editTextMessage::permission_denied");
          return;
        }
        if (!e) {
          l.error("editTextMessage::message_can_not_be_empty");
          return;
        }
        o(this, Je).editMessage(
          t,
          e,
          Et.TEXT,
          r
        );
      });
    }
    editImageMessage(t, e, r) {
      return u(this, null, function* () {
        var i, a, c, d;
        if (!((a = (i = o(this, re).permissions) == null ? undefined : i.chatPublic) != null && a.canSend) || !((d = (c = o(this, re).permissions) == null ? undefined : c.chatPublic) != null && d.files)) {
          l.error("editImageMessage::permission_denied");
          return;
        }
        if (!e) {
          l.error("editImageMessage::required_argument_image_can_not_be_empty");
          return;
        }
        if (!["image/gif", "image/jpeg", "image/png"].includes(e.type)) {
          l.error("sendImageMessage::image_type_not_supported", {
            dyteChat: { imageType: e.type }
          });
          return;
        }
        try {
          const p = qe(), { getLocation: h, putLocation: m } = yield p.getPresignedUrls(e.name, o(this, re).config.viewType);
          yield p.uploadFile(e, m), o(this, Je).editMessage(
            t,
            h,
            Et.IMAGE,
            r
          );
        } catch (p) {
          throw new w("Error editing image message.");
        }
      });
    }
    editFileMessage(t, e, r) {
      return u(this, null, function* () {
        var n, i, a, c;
        if (!((i = (n = o(this, re).permissions) == null ? undefined : n.chatPublic) != null && i.canSend) || !((c = (a = o(this, re).permissions) == null ? undefined : a.chatPublic) != null && c.files)) {
          l.error("sendFileMessage::permission_denied");
          return;
        }
        if (!e) {
          l.error("sendFileMessage::required_argument_file_can_not_be_empty");
          return;
        }
        try {
          const d = qe(), { getLocation: p, putLocation: h } = yield d.getPresignedUrls(
            e.name,
            o(this, re).config.viewType
          );
          yield d.uploadFile(e, h), o(this, Je).editMessage(
            t,
            JSON.stringify({
              link: p,
              name: e.name,
              size: "size" in e ? e.size : 0
            }),
            Et.FILE,
            r
          );
        } catch (d) {
          throw new w("Error editing file message.");
        }
      });
    }
    editMessage(t, e, r) {
      return u(this, null, function* () {
        switch (e.type) {
          case "text": {
            this.editTextMessage(t, e.message, r);
            break;
          }
          case "image": {
            this.editImageMessage(t, e.image, r);
            break;
          }
          case "file": {
            this.editFileMessage(t, e.file, r);
            break;
          }
          default: {
            l.error("editMessage::message_type_not_supported", {
              dyteChat: { messageType: e.type }
            });
            break;
          }
        }
      });
    }
    deleteMessage(t, e) {
      return u(this, null, function* () {
        var r, n;
        if (((n = (r = o(this, re).permissions) == null ? undefined : r.chatMessage) == null ? undefined : n.canDelete) === "NONE")
          throw new w("Not permitted to delete messages", "0501");
        o(this, Je).deleteMessage(t, e);
      });
    }
    /**
     * Returns an array of messages sent by a specific userId.
     * @param userId The user id of the user that sent the message.
     */
    getMessagesByUser(t) {
      return this.messages.filter((e) => e.userId === t);
    }
    /**
     * Returns an array of 'text', 'image' or 'file' messages.
     * @param type 'text', 'image', or 'file'.
     */
    getMessagesByType(t) {
      return this.messages.filter((e) => e.type === t);
    }
    /**
     * Pins a chat message
     * @param id ID of the message to be pinned
     */
    pin(t) {
      return u(this, null, function* () {
        if (!this.socketJoined)
          throw new w("Can`t pin message without joining room");
        if (!o(this, re).permissions.pinParticipant)
          throw new w("You do not have permission to pin messages.");
        const e = this.messages.find((r) => r.id === t);
        if (e) {
          o(this, Je).setPinState(e, true);
          return;
        }
        throw new w(`No message found with id: ${t}`);
      });
    }
    /**
     * Unpins a chat message
     * @param id ID of the message to be unpinned
     */
    unpin(t) {
      return u(this, null, function* () {
        if (!this.socketJoined)
          throw new w("Can`t unpin message without joining room");
        if (!o(this, re).permissions.pinParticipant)
          throw new w("You do not have permission to unpin messages.");
        const e = this.messages.find((r) => r.id === t);
        if (e) {
          o(this, Je).setPinState(e, false);
          return;
        }
        throw new w(`No message found with id: ${t}`);
      });
    }
    /**
     * Gets chat messages in a paginated manner
     */
    getMessages(t, e, r, n = 0, i = undefined) {
      return u(this, null, function* () {
        const a = yield o(this, Je).getChatMessagesPaginated(t, e, r, n, i);
        return {
          messages: a.messages.map(
            (c) => tr.formatSocketServiceMessage(c)
          ),
          next: a.next
        };
      });
    }
    createChannel(n, i) {
      return u(this, arguments, function* (t, e, r = {}) {
        var p;
        const a = (p = o(this, re).permissions) == null ? undefined : p.chatChannel;
        if (a) {
          if (a.canCreate === "NONE")
            throw new w("Not permitted to create channels", "0501");
          if (r.visibility === "public" && !(a.canCreate === "PUBLIC" || a.canCreate === "ALL"))
            throw new w("Not permitted to create public channels", "0501");
          if (r.visibility === "private" && !(a.canCreate === "PRIVATE" || a.canCreate === "ALL"))
            throw new w("Not permitted to create private channels", "0501");
        }
        if (!t || t.trim().length === 0)
          throw new w("channel name cannot be empty.", "0510");
        const c = [.../* @__PURE__ */ new Set([...e, o(this, re).userId])];
        return yield o(this, Ys).createChannel(
          t.trim(),
          c,
          r.displayPictureUrl,
          r.visibility,
          r.isDirectMessage
        );
      });
    }
    updateChannel(t, e) {
      var a, c, d, p, h;
      const r = this.channels.find((m) => m.id === t), n = (a = o(this, re).permissions) == null ? undefined : a.chatChannel;
      if (n) {
        if (n.canUpdate === "NONE")
          throw new w("Not permitted to update channels", "0501");
        if (r.visibility === "public" && !(n.canUpdate === "PUBLIC" || n.canUpdate === "ALL"))
          throw new w("Not permitted to update public channels", "0501");
        if (r.visibility === "private" && !(n.canUpdate === "PRIVATE" || n.canUpdate === "ALL"))
          throw new w("Not permitted to update private channels", "0501");
      }
      const i = {
        memberIds: (c = e.memberIds) != null ? c : r.memberIds,
        displayName: (d = e.displayName) != null ? d : r.displayName,
        displayPictureUrl: (p = e.displayPictureUrl) != null ? p : r.displayPictureUrl,
        visibility: (h = e.visibility) != null ? h : r.visibility
      };
      return o(this, Ys).updateChannel(t, i);
    }
    sendMessageToChannel(n, i) {
      return u(this, arguments, function* (t, e, r = {}) {
        return this.sendMessageInternal(t, null, e, r);
      });
    }
    getChannelMembers(t) {
      return u(this, null, function* () {
        return o(this, Ys).getChannelMembers(t);
      });
    }
    searchMessages(r) {
      return u(this, arguments, function* (t, e = {}) {
        if (!K.hasFeature(ie.FEAT_CHAT_SDK_SEARCH))
          throw new w("searchMessages is temporarily disabled!");
        return (yield o(this, Je).searchMessages(t, e)).map(tr.formatSocketServiceMessage);
      });
    }
    markLastReadMessage(t, e) {
      return u(this, null, function* () {
        yield o(this, Je).markLastReadMessage(t, e);
        const r = this.channels.find((n) => n.id === t);
        if (r) {
          const n = z(L({}, r), { unreadCount: 0 });
          this.channels = this.channels.map((i) => i.id === t ? n : i), this.emit("channelMessageUpdate", n);
        }
      });
    }
    /**
     * Returns an array of pinned messages.
     */
    get pinned() {
      return this.messages.filter((t) => t.pinned);
    }
  }, re = new WeakMap(), zs = new WeakMap(), Je = new WeakMap(), Ys = new WeakMap(), Pa = new WeakMap(), _c = new WeakSet(), Qf = function() {
    return o(this, Pa).getValue("connectionHandler");
  }, Sh);
  yt([
    v.trace("DyteChat.sendTextMessage"),
    At(Bo)
  ], rt.prototype, "sendTextMessage", 1);
  yt([
    v.trace("DyteChat.sendImageMessage"),
    At({ maxInvocations: 20, period: 60 })
  ], rt.prototype, "sendImageMessage", 1);
  yt([
    v.trace("DyteChat.sendFileMessage"),
    At({ maxInvocations: 20, period: 60 })
  ], rt.prototype, "sendFileMessage", 1);
  yt([
    v.trace("DyteChat.sendMessage"),
    At({ maxInvocations: 180, period: 60 })
  ], rt.prototype, "sendMessage", 1);
  yt([
    v.trace("DyteChat.editTextMessage")
  ], rt.prototype, "editTextMessage", 1);
  yt([
    v.trace("DyteChat.editImageMessage")
  ], rt.prototype, "editImageMessage", 1);
  yt([
    v.trace("DyteChat.editFileMessage")
  ], rt.prototype, "editFileMessage", 1);
  yt([
    v.trace("DyteChat.editMessage")
  ], rt.prototype, "editMessage", 1);
  yt([
    v.trace("DyteChat.deleteMessage")
  ], rt.prototype, "deleteMessage", 1);
  yt([
    v.trace("DyteChat.createChannel")
  ], rt.prototype, "createChannel", 1);
  yt([
    v.trace("DyteChat.updateChannel")
  ], rt.prototype, "updateChannel", 1);
  yt([
    v.trace("DyteChat.sendMessageToChannel")
  ], rt.prototype, "sendMessageToChannel", 1);
  yt([
    v.trace("DyteChat.getChannelMembers")
  ], rt.prototype, "getChannelMembers", 1);
  yt([
    v.trace("DyteChat.searchMessages")
  ], rt.prototype, "searchMessages", 1);
  yt([
    v.trace("DyteChat.markLastReadMessage")
  ], rt.prototype, "markLastReadMessage", 1);
  rt = yt([
    vt("0500")
  ], rt);
  var bA = Object.defineProperty, kA = Object.getOwnPropertyDescriptor, IA = (s, t, e, r) => {
    for (var n = kA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && bA(t, e, n), n;
  }, Sc, Eh;
  const Hs = (Eh = class {
    constructor(s, t, e, r, n) {
      f(this, "chat");
      f(this, "chatSocketHandler");
      f(this, "chatChannelSocketHandler");
      f(this, "self");
      E(this, Sc, undefined);
      _(this, Sc, s), this.chatSocketHandler = t, this.chatChannelSocketHandler = e, this.chat = new rt(
        s,
        t,
        e,
        r,
        n
      ), this.self = r, this.setupEvents();
    }
    static init(s, t, e, r, n) {
      return u(this, null, function* () {
        return new Hs(
          s,
          t,
          e,
          r,
          n
        );
      });
    }
    static formatMessage(s) {
      return z(L({}, s), {
        time: new Date(s.time),
        type: RA[s.type]
      });
    }
    /**
     * @access private
     * This function formates the chat message coming from
     * socket service. This is not meant for external use.
     */
    static formatSocketServiceMessage(s) {
      const t = s.createdAt * 1e3, e = {
        displayName: s.displayName,
        id: s.chatId,
        time: t,
        timeMs: s.createdAtMs,
        type: s.payloadType,
        isEdited: s.isEdited,
        userId: s.userId,
        targetUserIds: s.targetUserIds,
        channelId: s.channelId,
        channelIndex: s.channelIndex,
        message: "",
        link: "",
        name: "",
        html: "",
        images: [],
        videos: [],
        files: [],
        size: 0,
        pinned: s.pinned
      };
      switch (e.type) {
        case Et.TEXT: {
          e.message = s.payload;
          break;
        }
        case Et.IMAGE: {
          e.link = s.payload;
          break;
        }
        case Et.FILE: {
          const { link: r, name: n, size: i } = JSON.parse(s.payload);
          e.link = r, e.name = n, e.size = i;
          break;
        }
        case Et.CUSTOM: {
          const {
            html: r,
            images: n,
            message: i,
            videos: a,
            files: c
          } = JSON.parse(s.payload);
          e.message = i, e.html = r, e.images = n, e.videos = a, e.files = c;
          break;
        }
      }
      return Hs.formatMessage(e);
    }
    getChatMessages() {
      return u(this, null, function* () {
        if (this.self.config.viewType === "LIVESTREAM" || this.self.config.viewType === "CHAT" || K.hasFeature(ie.FEAT_PAGINATED_CHAT))
          return;
        const s = yield this.chatSocketHandler.getChatMessages();
        if (!(s != null && s.payload))
          return;
        const t = Jf.fromBinary(
          s.payload
        ).messages;
        this.chat.messages = t.map(
          (e) => Hs.formatSocketServiceMessage(e)
        );
      });
    }
    setupEvents() {
      R.on(
        P.SOCKET_SERVICE_ROOM_JOINED,
        () => u(this, null, function* () {
          this.getChatMessages();
        })
      ), this.chatSocketHandler.on(
        Ne.sendMessageToRoom,
        (s) => {
          const t = Hs.formatSocketServiceMessage(
            s.message
          );
          if (!t.channelId)
            this.chat.messages = [...this.chat.messages, t];
          else {
            const e = this.chat.channels.find((r) => r.id === t.channelId);
            e && (e.latestMessage = t, e.unreadCount += 1, this.chat.emit("channelMessageUpdate", e));
          }
          this.chat.emit("chatUpdate", {
            action: "add",
            message: t,
            messages: this.chat.messages
          });
        }
      ), this.chatSocketHandler.on(
        Ne.sendMessageToPeers,
        (s) => {
          const t = Hs.formatSocketServiceMessage(
            s.message
          );
          this.chat.messages = [...this.chat.messages, t], this.chat.emit("chatUpdate", {
            action: "add",
            message: t,
            messages: this.chat.messages
          });
        }
      ), this.chatSocketHandler.on(
        Ne.editMessage,
        (s) => {
          const t = Hs.formatSocketServiceMessage(
            s.message
          );
          if (t.channelId) {
            this.chat.emit("chatUpdate", {
              action: "edit",
              message: t,
              messages: this.chat.messages
            });
            return;
          }
          const e = this.chat.messages.findIndex((r) => r.id === t.id);
          e !== -1 && (this.chat.messages[e] = t, this.chat.emit("chatUpdate", {
            action: "edit",
            message: t,
            messages: this.chat.messages
          }));
        }
      ), this.chatSocketHandler.on(
        Ne.deleteMessage,
        (s) => {
          if (s.channelId) {
            this.chat.emit("chatUpdate", {
              action: "delete",
              message: { id: s.chatId, channelId: s.channelId },
              messages: this.chat.messages
            });
            return;
          }
          const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
          if (t === -1)
            return;
          const [e] = this.chat.messages.splice(t, 1);
          this.chat.emit("chatUpdate", {
            action: "delete",
            message: e,
            messages: this.chat.messages
          });
        }
      ), this.chatChannelSocketHandler.on(
        Ws.createChatChannel,
        (s) => {
          const [t] = s.chatChannels, e = _n.formatChannel(t);
          this.chat.channels.push(e), this.chat.emit("channelCreate", e);
        }
      ), this.chatSocketHandler.on(
        Ne.pinMessage,
        (s) => {
          const t = this.chat.messages.findIndex((r) => r.id === s.chatId);
          if (t === -1)
            return;
          const e = this.chat.messages[t];
          e.pinned = s.pinned, this.chat.messages[t] = e, this.chat.emit("chatUpdate", {
            action: "edit",
            message: e,
            messages: this.chat.messages
          });
        }
      ), this.chatChannelSocketHandler.on(
        Ws.updateChatChannel,
        (s) => {
          const [t] = s.chatChannels, e = _n.formatChannel(t);
          this.chat.channels = this.chat.channels.map((r) => r.id === e.id ? e : r), this.chat.emit("channelUpdate", e);
        }
      );
    }
  }, Sc = new WeakMap(), Eh);
  let tr = Hs;
  IA([
    v.trace("ChatController.setupEvents")
  ], tr.prototype, "setupEvents");
  var MA = (s, t, e, r) => {
    for (var n = t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(n)) || n);
    return n;
  }, Ec, Xf, Xn, Zn, Ra, Ch;
  let gl = (Ch = class extends Ft {
    constructor(t, e, r) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, Ec);
      /**
       * An array of poll items.
       */
      f(this, "items");
      E(this, Xn, undefined);
      E(this, Zn, undefined);
      E(this, Ra, undefined);
      _(this, Ra, t), _(this, Xn, e), _(this, Zn, r), this.items = [];
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get socketJoined() {
      var t;
      return ((t = o(this, Ec, Xf)) == null ? undefined : t.socketJoined) === true;
    }
    /**
     * Creates a poll in the meeting.
     * @param question The question that is to be voted for.
     * @param options The options of the poll.
     * @param anonymous If true, the poll votes are anonymous.
     * @param hideVotes If true, the votes on the poll are hidden.
     */
    create(t, e, r = false, n = false) {
      return u(this, null, function* () {
        if (!this.socketJoined)
          throw new w("Can't create polls without joining room");
        if (!o(this, Xn).permissions.polls.canCreate) {
          l.error("DytePolls::create::permission_denied");
          return;
        }
        if (!t || !e) {
          l.error("DytePolls::question_and_options_can_not_be_empty", {
            dytePolls: {
              hasQuestion: !!t,
              optionsLength: e == null ? undefined : e.length
            }
          });
          return;
        }
        if (e.length < 2) {
          l.error("DytePolls::there_must_be_at_least_two_options", {
            dytePolls: { hasQuestion: !!t, optionsLength: e.length }
          });
          return;
        }
        yield o(this, Zn).createPoll(
          t,
          e,
          r,
          n
        );
      });
    }
    /**
     * Casts a vote on an existing poll.
     * @param pollId The ID of the poll that is to be voted on.
     * @param index The index of the option.
     */
    vote(t, e) {
      return u(this, null, function* () {
        if (!o(this, Xn).permissions.polls.canVote) {
          l.error("DytePolls::vote::permission_denied");
          return;
        }
        yield o(this, Zn).votePoll(t, e);
      });
    }
  }, Ec = new WeakSet(), Xf = function() {
    return o(this, Ra).getValue("connectionHandler");
  }, Xn = new WeakMap(), Zn = new WeakMap(), Ra = new WeakMap(), Ch);
  gl = MA([
    vt("0700")
  ], gl);
  var OA = Object.defineProperty, NA = Object.getOwnPropertyDescriptor, LA = (s, t, e, r) => {
    for (var n = NA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && OA(t, e, n), n;
  }, ei, Qs, wh;
  const Un = (wh = class {
    constructor(s, t, e) {
      f(this, "polls");
      E(this, ei, undefined);
      E(this, Qs, undefined);
      this.polls = new gl(s, t, e), _(this, ei, t), _(this, Qs, e), this.setupEvents();
    }
    static init(s, t, e) {
      return u(this, null, function* () {
        return new Un(s, t, e);
      });
    }
    canViewPolls() {
      return o(this, ei).permissions.polls.canView;
    }
    setupEvents() {
      const s = {
        [Ar.createPoll]: (r) => {
          r.poll && this.updatePoll(Un.formatSocketServicePoll(r.poll));
        },
        [Ar.updatePoll]: (r) => {
          r.poll && this.updatePoll(Un.formatSocketServicePoll(r.poll));
        },
        [Ar.votePoll]: (r) => {
          r.poll && this.updatePoll(Un.formatSocketServicePoll(r.poll));
        }
      }, t = () => {
        R.on(P.SOCKET_SERVICE_ROOM_JOINED, () => {
          this.getPolls();
        }), Object.keys(s).map(Number).forEach((r) => {
          o(this, Qs).on(r, s[r]);
        });
      }, e = () => {
        R.on(P.SOCKET_SERVICE_ROOM_JOINED, () => {
          this.getPolls();
        }), Object.keys(s).map(Number).forEach((r) => {
          o(this, Qs).removeListeners(r);
        });
      };
      o(this, ei).permissions.on("permissionsUpdate", (r) => u(this, null, function* () {
        var n;
        (n = r == null ? undefined : r.polls) != null && n.canView ? (yield this.getPolls(), t()) : (this.polls.items = [], e());
      })), this.canViewPolls() && t();
    }
    updatePoll(s) {
      if (!this.canViewPolls())
        return;
      const t = this.polls.items.findIndex((e) => e.id === s.id);
      if (t > -1) {
        const e = JSON.stringify(this.polls.items[t]);
        this.polls.items[t] = s, e !== JSON.stringify(s) && this.polls.emit("pollsUpdate", {
          polls: this.polls.items,
          newPoll: false
        });
        return;
      }
      this.polls.items = [...this.polls.items, s], this.polls.emit("pollsUpdate", { polls: this.polls.items, newPoll: true });
    }
    getPolls() {
      return u(this, null, function* () {
        const s = yield o(this, Qs).getPolls();
        if (!(s != null && s.payload))
          return;
        const { polls: t } = WI.fromBinary(s.payload);
        this.polls.items = t.map(
          (e) => Un.formatSocketServicePoll(e)
        );
      });
    }
    static formatSocketServicePoll(s) {
      const t = s.options.map((e) => ({
        count: e.count,
        text: e.text,
        votes: e.votes.map((r) => ({
          id: r.userId,
          name: r.name
        }))
      }));
      return {
        anonymous: s.anonymous,
        createdBy: s.createdBy,
        createdByUserId: s.createdByUserId,
        hideVotes: s.hideVotes,
        id: s.pollId,
        options: t,
        question: s.question,
        voted: s.votes
      };
    }
  }, ei = new WeakMap(), Qs = new WeakMap(), wh);
  let Zf = Un;
  LA([
    v.trace("PollController.setupEvents")
  ], Zf.prototype, "setupEvents");
  var UA = (s, t, e, r) => {
    for (var n = t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(n)) || n);
    return n;
  }, eg = /* @__PURE__ */ ((s) => (s[s.User = 0] = "User", s[s.Meeting = 1] = "Meeting", s))(eg || {}), ti, Cc, tg, ba, yl, Xs, ka, Ph;
  let vl = (Ph = class extends Ft {
    constructor(t, e, r, n, i) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, Cc);
      E(this, ba);
      /**
       *	Represents the current active tab
      */
      f(this, "selfActiveTab");
      /**
       * Represents whether current user is spotlighted
      */
      f(this, "broadcastTabChanges");
      E(this, ti, undefined);
      E(this, Xs, undefined);
      E(this, ka, undefined);
      /**
       * The `viewType` tells the type of the meeting
       * possible values are: GROUP_CALL| LIVESTREAM | CHAT | AUDIO_ROOM
       */
      f(this, "viewType");
      /**
       * The timestamp of the time when the meeting started.
       */
      f(this, "meetingStartedTimestamp");
      /**
       * The title of the meeting.
       */
      f(this, "meetingTitle");
      /**
       * (Experimental) The sessionId this meeting object is part of.
       */
      f(this, "sessionId");
      _(this, ti, t), _(this, Xs, e), this.viewType = r, _(this, ka, n), this.meetingTitle = i, this.broadcastTabChanges = e.permissions.canSpotlight;
    }
    get socketState() {
      return o(this, ba, yl).socketState;
    }
    get mediaState() {
      return o(this, ba, yl).mediaState;
    }
    /**
     * The room name of the meeting.
     */
    get meetingId() {
      var t;
      return (t = o(this, Cc, tg)) == null ? undefined : t.roomName;
    }
    /**
     * Sets current user as broadcasting tab changes
     * @param broadcastTabChanges
     */
    setBroadcastTabChanges(t) {
      if (!o(this, Xs).permissions.canSpotlight)
        throw l.error("DyteSpotlight::setSpotlighted::permission_denied"), new w("User does not have permission to toggle spotlight");
      this.broadcastTabChanges = t, this.emit("broadcastTabChangesUpdate", this.broadcastTabChanges), this.broadcastTabChanges && this.assertActiveTabToRoom();
    }
    /**
     * Sets current active tab for user
     * @param spotlightTab
     */
    setSelfActiveTab(t, e) {
      var r;
      l.info("DyteSpotlight::setActiveTab", {
        spotlight: {
          currentTab: {
            id: t.id,
            type: t.type
          }
        }
      }), this.selfActiveTab = t, e === 0 && this.emit("selfTabUpdate", t), (r = o(this, Xs).permissions) != null && r.canSpotlight && this.broadcastTabChanges && e === 0 && this.assertActiveTabToRoom();
    }
    assertActiveTabToRoom() {
      o(this, ka).broadcastMessage("spotlight", {
        userId: o(this, Xs).userId,
        currentTab: this.selfActiveTab
      });
    }
  }, ti = new WeakMap(), Cc = new WeakSet(), tg = function() {
    return o(this, ti).getValue("roomNodeClient");
  }, ba = new WeakSet(), yl = function() {
    return o(this, ti).getValue("connectionHandler");
  }, Xs = new WeakMap(), ka = new WeakMap(), Ph);
  vl = UA([
    vt("0800")
  ], vl);
  function FA(s) {
    let t = "", e = [""];
    const r = [e];
    let n = 0, i = 0, a = true, c;
    for (c of s)
      c === '"' ? (a && c === t && (e[n] += c), a = !a) : c === "," && a ? c = e[++n] = "" : c === `
` && a ? (t === "\r" && (e[n] = e[n].slice(0, -1)), e = r[++i] = [c = ""], n = 0) : e[n] += c, t = c;
    return r;
  }
  var VA = Object.defineProperty, HA = Object.getOwnPropertyDescriptor, rg = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? HA(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && VA(t, e, n), n;
  };
  let Ds = class extends Ft {
    constructor() {
      super();
      f(this, "transcripts");
      this.transcripts = [];
    }
    static init(t) {
      return u(this, null, function* () {
        const e = new Ds();
        try {
          t && e.getActiveTranscript();
        } catch (r) {
          l.error("Error fetching active transcriptions ", r);
        }
        return e;
      });
    }
    /**
    * Parse a single line transcript
    */
    static parseTranscript(t, e = false) {
      try {
        if (!t)
          return;
        const [[
          r,
          n,
          i,
          a,
          c,
          d
        ]] = FA(t);
        return {
          id: v4(),
          name: c,
          peerId: n,
          userId: i,
          customParticipantId: a,
          transcript: d,
          isPartialTranscript: e,
          date: new Date(parseInt(r, 10) * 1e3)
        };
      } catch (r) {
        l.error(`Failed to parse transcript: ${t}`, r);
        return;
      }
    }
    /**
    * Parse a multi-line transcript
    */
    static parseTranscripts(t) {
      return t ? t.split(`
`).map((e) => Ds.parseTranscript(e, false)).filter(Boolean) : [];
    }
    getActiveTranscript() {
      return u(this, null, function* () {
        try {
          const t = qe(), { transcript: e } = yield t.getActiveTranscript();
          this.transcripts = Ds.parseTranscripts(e);
        } catch (t) {
        }
      });
    }
    onTranscript(t) {
      return u(this, null, function* () {
        var r;
        const e = this.transcripts.filter(({ peerId: n }) => n === t.peerId);
        if ((r = e == null ? undefined : e.at(-1)) != null && r.isPartialTranscript) {
          const n = e.at(-1);
          n.transcript = t.transcript, n.isPartialTranscript = t.isPartialTranscript, this.emit("transcript", n);
          return;
        }
        this.transcripts = [...this.transcripts, t], this.emit("transcript", t);
      });
    }
  };
  rg([
    v.trace("DyteAi.getActiveTranscript")
  ], Ds.prototype, "getActiveTranscript", 1);
  Ds = rg([
    vt("0000")
  ], Ds);
  var BA = Object.defineProperty, qA = Object.getOwnPropertyDescriptor, jA = (s, t, e, r) => {
    for (var n = qA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && BA(t, e, n), n;
  }, ps, ri, wc, Rh;
  const sg = (Rh = class {
    constructor(s, t, e, r, n, i) {
      f(this, "meta");
      f(this, "ai");
      E(this, ps, undefined);
      E(this, ri, undefined);
      f(this, "aiSocketHandler");
      E(this, wc, undefined);
      _(this, wc, s), this.meta = new vl(
        s,
        t,
        t.config.viewType,
        e,
        i
      ), this.ai = r, _(this, ps, t), _(this, ri, e), this.aiSocketHandler = n, t.config.viewType !== gt.Chat && this.setupEvents();
    }
    /**
     *
     */
    static init(s, t, e, r, n) {
      return u(this, null, function* () {
        const i = yield Ds.init(t.permissions.transcriptionEnabled);
        return new sg(
          s,
          t,
          e,
          i,
          r,
          n
        );
      });
    }
    conditionallySetActiveTab(s) {
      var t;
      s != null && s.currentTab && ((t = this.meta.selfActiveTab) == null ? undefined : t.id) !== s.currentTab.id && (this.meta.setSelfActiveTab(
        s.currentTab,
        eg.Meeting
      ), this.meta.emit(
        "activeTabUpdate",
        s.currentTab
      ));
    }
    setupEvents() {
      R.on(
        P.TRANSPORT_STATE_UPDATE,
        (s) => {
          this.meta.emit("mediaConnectionUpdate", s);
        }
      ), R.on(
        P.SOCKET_STATE_UPDATE,
        (s) => {
          this.meta.emit("socketConnectionUpdate", s);
        }
      ), R.on(P.ROOM_STATE, ({ createdAt: s, roomUuid: t }) => {
        const e = this.meta.meetingStartedTimestamp;
        if (t && (this.meta.sessionId = t), s && !e) {
          const r = new Date(s * 1e3);
          this.meta.meetingStartedTimestamp = r, this.meta.emit("meetingStartTimeUpdate", {
            meetingStartedTimestamp: this.meta.meetingStartedTimestamp
          });
        }
      }), R.on(
        P.PRODUCER_SCORE_UPDATE,
        ({ score: s }) => {
          s < 5 && this.meta.emit("poorConnection", { score: s });
        }
      ), o(this, ps).permissions.canSpotlight && (l.info("DyteMetaController::Asserting Spotlight"), this.meta.selfActiveTab && o(this, ri).broadcastMessage("spotlight", {
        userId: o(this, ps).userId,
        currentTab: this.meta.selfActiveTab
      })), R.on(
        P.PEER_JOINED_INTERNAL,
        (s) => u(this, null, function* () {
          o(this, ps).permissions.canSpotlight && this.meta.selfActiveTab && o(this, ri).broadcastToPeers("spotlight", [s.id], {
            userId: o(this, ps).userId,
            currentTab: this.meta.selfActiveTab
          });
        })
      ), R.on(
        P.ROOM_MESSAGE,
        (s) => {
          var e, r;
          let t;
          if ("type" in s) {
            if (s.type !== "spotlight")
              return;
            t = L(L({}, s), s.payload);
          } else if ("roomMessageType" in s) {
            if (s.roomMessageType !== "spotlight")
              return;
            t = s;
          } else
            return;
          l.info("Spotlight Assertion Received", {
            spotlight: {
              spotlighter: { id: t.userId },
              currentTab: {
                id: (e = t.currentTab) == null ? undefined : e.id,
                type: (r = t.currentTab) == null ? undefined : r.type
              }
            }
          }), this.conditionallySetActiveTab(t);
        }
      ), R.on(
        P.MESSAGE,
        (s) => {
          var e, r;
          let t;
          if ("type" in s) {
            if (s.type !== "spotlight")
              return;
            t = L(L({}, s), s.payload);
          } else if ("roomMessageType" in s) {
            if (s.roomMessageType !== "spotlight")
              return;
            t = s;
          } else
            return;
          l.info("Spotlight Assertion Received", {
            spotlight: {
              spotlighter: { id: t.userId },
              currentTab: {
                id: (e = t.currentTab) == null ? undefined : e.id,
                type: (r = t.currentTab) == null ? undefined : r.type
              }
            }
          }), this.conditionallySetActiveTab(t);
        }
      ), this.aiSocketHandler.on(F.transcript, (s) => {
        const {
          meetingId: t,
          transcript: e,
          isPartial: r
        } = s, n = Ds.parseTranscript(e, r);
        if (!n) {
          l.warn("Received empty transcript data");
          return;
        }
        this.ai.onTranscript(n), this.meta.emit("transcript", n);
        const { peerId: i, name: a, transcript: c } = n;
        l.debug(`${t} Received transcript for peer ${i} - ${a}: ${c}`);
      });
    }
  }, ps = new WeakMap(), ri = new WeakMap(), wc = new WeakMap(), Rh);
  let ng = sg;
  jA([
    v.trace("MetaController.setupEvents")
  ], ng.prototype, "setupEvents");
  var GA = Object.defineProperty, JA = Object.getOwnPropertyDescriptor, An = (s, t, e, r) => {
    for (var n = JA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && GA(t, e, n), n;
  }, Jt, si, Ee, Ia, dr, lr, ni, qo;
  class xs extends Ft {
    constructor(e, r, n, i, a) {
      super();
      E(this, ni);
      E(this, Jt, undefined);
      E(this, si, undefined);
      E(this, Ee, undefined);
      E(this, Ia, undefined);
      E(this, dr, undefined);
      E(this, lr, undefined);
      _(this, lr, e), _(this, Jt, i), _(this, si, a), _(this, Ee, r), _(this, Ia, n), _(this, dr, []), this.setupEvents();
    }
    get status() {
      return o(this, lr).getValue("stageStatus");
    }
    setupEvents() {
      const e = {
        /**
         * NOTE(ishita1805): Update stageRequests when socket sends them.
         */
        [P.GET_STAGE_REQUESTS]: (i) => u(this, null, function* () {
          _(this, dr, i);
        }),
        /**
         * NOTE(ishita1805): Update stageRequests when a peer
         * who has requested leaves/joins the meeting
         */
        [P.UPDATE_STAGE_REQUESTS]: (a) => u(this, [a], function* ({ add: i }) {
          const c = o(this, dr).length, { stageRequests: d } = this.getAccessRequests();
          (i || d.length > c) && this.emit("newStageRequest", { count: d.length }), this.emit("stageAccessRequestUpdate", d);
        })
      }, r = () => {
        Object.entries(e).forEach(([i, a]) => {
          R.onAsync(
            i,
            a
          );
        });
      }, n = () => {
        Object.entries(e).forEach(([i, a]) => {
          R.removeListener(
            i,
            a
          );
        });
      };
      o(this, Ee).permissions.on("permissionsUpdate", (i) => {
        const { canAcceptProductionRequests: a } = i;
        a !== undefined && (o(this, Ee).permissions.acceptStageRequests ? (r(), o(this, Jt).getStageRequests()) : (n(), _(this, dr, []), this.emit("stageAccessRequestUpdate", o(this, dr))));
      }), o(this, Ee).permissions.acceptStageRequests && r();
    }
    getAccessRequests() {
      if (!o(this, Ee).permissions.stageEnabled)
        throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
      if (!o(this, Ee).permissions.acceptStageRequests)
        throw l.error("DyteStage::get_access_request::permission_denied"), new w("You do not have permission to perform this action/");
      const e = o(this, Ia).joined.toArray().filter(
        (r) => r.stageStatus === "REQUESTED_TO_JOIN_STAGE"
      ).map((r) => ({
        displayName: r.name,
        userId: r.userId,
        peerId: r.id
      }));
      return _(this, dr, e), { stageRequests: o(this, dr) };
    }
    requestAccess() {
      return u(this, null, function* () {
        if (!o(this, Ee).permissions.stageEnabled)
          throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
        if (this.status !== "OFF_STAGE")
          throw new w(
            `Unable to request access you are currently ${this.status}`
          );
        if (o(this, Ee).permissions.stageAccess === W.Allowed) {
          Le(this, ni, qo).call(this, "ACCEPTED_TO_JOIN_STAGE");
          return;
        }
        o(this, Jt).requestAccess(), Le(this, ni, qo).call(this, "REQUESTED_TO_JOIN_STAGE");
      });
    }
    cancelRequestAccess() {
      return u(this, null, function* () {
        if (!o(this, Ee).permissions.stageEnabled)
          throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
        o(this, Jt).cancelRequestAccess(), Le(this, ni, qo).call(this, "OFF_STAGE");
      });
    }
    grantAccess(e) {
      if (!o(this, Ee).roomJoined)
        throw new w(
          "Can`t grant for participant without joining room"
        );
      if (!o(this, Ee).permissions.stageEnabled)
        throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
      if (!o(this, Ee).permissions.acceptStageRequests)
        throw l.error("DyteStage::grant_access::permission_denied"), new w("You do not have permission to perform this action");
      return o(this, Jt).grantAccess(e);
    }
    denyAccess(e) {
      if (!o(this, Ee).roomJoined)
        throw new w(
          "Can`t rejectRequestToJoinStage for participant without joining room"
        );
      if (!o(this, Ee).permissions.stageEnabled)
        throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
      if (!o(this, Ee).permissions.acceptStageRequests)
        throw l.error("DyteStage::deny_access::permission_denied"), new w("You do not have permission to perform this action/");
      return o(this, Jt).denyAccess(e);
    }
    join() {
      return u(this, null, function* () {
        const e = o(this, lr).getValue("viewType");
        if (this.status === "ON_STAGE")
          throw new w("You are already on stage.");
        if (this.status !== "ACCEPTED_TO_JOIN_STAGE" || o(this, Ee).permissions.stageAccess === W.NotAllowed)
          throw new w(`Unable to join stage you are currently ${this.status}`);
        if (yield o(this, Jt).joinStage(), e === gt.Livestream && (yield o(this, si).joinRoom(o(this, Ee), e)), o(this, lr).setValue("stageStatus", "ON_STAGE"), e === gt.Livestream) {
          const { peers: r } = yield o(this, si).getStagePeers();
          R.emit(P.SOCKET_PEERS, r);
        }
      });
    }
    leave() {
      return u(this, null, function* () {
        if (!o(this, Ee).permissions.stageEnabled)
          throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
        if (!(this.status === "ON_STAGE" || this.status === "ACCEPTED_TO_JOIN_STAGE"))
          throw new w(`Unable to leave stage you are currently ${this.status}`);
        o(this, Ee).setIsPinned(false), yield o(this, Jt).leaveStage(o(this, Ee).userId), o(this, lr).setValue("stageStatus", "OFF_STAGE", false), yield R.emitAsync(P.LEAVE_MEDIA_ROOM, "stageLeft"), o(this, lr).notify("stageStatus");
      });
    }
    /**
     * Method to kick a user off the stage
     *
     * `permissions.acceptStageRequests` privilege required
     */
    kick(e) {
      return u(this, null, function* () {
        if (!o(this, Ee).roomJoined)
          throw new w(
            "Can`t kick participant without joining room"
          );
        if (!o(this, Ee).permissions.stageEnabled)
          throw l.error("DyteStage::stage_disabled"), new w("Stage is disabled");
        if (!o(this, Ee).permissions.acceptStageRequests)
          throw l.error("DyteStage::kick::permission_denied"), new w("You do not have permissions for kick");
        return o(this, Jt).kick(e);
      });
    }
  }
  Jt = new WeakMap(), si = new WeakMap(), Ee = new WeakMap(), Ia = new WeakMap(), dr = new WeakMap(), lr = new WeakMap(), ni = new WeakSet(), qo = function(e) {
    return u(this, null, function* () {
      this.status !== e && o(this, lr).setValue("stageStatus", e);
    });
  };
  An([
    v.trace("DyteStage.getStageRequests")
  ], xs.prototype, "getAccessRequests");
  An([
    v.trace("DyteStage.requestAccess")
  ], xs.prototype, "requestAccess");
  An([
    v.trace("DyteStage.cancelRequestAccess")
  ], xs.prototype, "cancelRequestAccess");
  An([
    v.trace("DyteStage.grantAccess")
  ], xs.prototype, "grantAccess");
  An([
    v.trace("DyteStage.denyAccess")
  ], xs.prototype, "denyAccess");
  An([
    v.trace("DyteStage.joinStage")
  ], xs.prototype, "join");
  An([
    v.trace("DyteStage.leaveStage")
  ], xs.prototype, "leave");
  function WA(s) {
    return !(s.viewType === "LIVESTREAM" || s.viewType === "CHAT");
  }
  function su(s) {
    switch (s) {
      case Gr.UNSPECIFIED:
        return "OFF_STAGE";
      case Gr.REQUESTED_STAGE:
        return "REQUESTED_TO_JOIN_STAGE";
      case Gr.APPROVED_STAGE:
        return "ACCEPTED_TO_JOIN_STAGE";
      case Gr.OFF_STAGE:
        return "OFF_STAGE";
      case Gr.ON_STAGE:
        return "ON_STAGE";
      default:
        return "OFF_STAGE";
    }
  }
  var KA = Object.defineProperty, zA = Object.getOwnPropertyDescriptor, YA = (s, t, e, r) => {
    for (var n = zA(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && KA(t, e, n), n;
  }, hs, Zs, ms, Aa, xr;
  class ig {
    constructor(t, e, r, n, i) {
      f(this, "stage");
      E(this, hs, undefined);
      E(this, Zs, undefined);
      E(this, ms, undefined);
      E(this, Aa, 0);
      E(this, xr, undefined);
      _(this, xr, t), this.stage = new xs(
        t,
        n,
        i,
        e,
        r
      ), _(this, ms, e), _(this, hs, n), _(this, Zs, i), this.setupEvents();
    }
    setupEvents() {
      o(this, xr).subscribe("stageStatus", (t) => {
        this.stage.emit("stageStatusUpdate", t);
      }), o(this, ms).on(F.grantStageAccess, () => {
        o(this, hs).permissions.stageAccess !== W.Allowed && (this.stage.emit("stageRequestApproved"), this.setStageStatus("ACCEPTED_TO_JOIN_STAGE"));
      }), o(this, ms).on(F.peerStageStatusUpdate, (t) => {
        t !== undefined && (t.peerId === o(this, hs).id ? this.selfStageStatusHandler(t) : this.peerStageStatusHandler(t));
      }), o(this, ms).on(F.denyStageAccess, () => {
        o(this, hs).permissions.stageAccess !== W.Allowed && (this.stage.emit("stageRequestRejected"), this.setStageStatus("OFF_STAGE"));
      }), o(this, ms).on(
        F.getStageRequests,
        (t) => u(this, null, function* () {
          var r;
          if (o(this, hs).permissions.stageAccess !== W.Allowed)
            return;
          const e = (r = t == null ? undefined : t.stageRequests) != null ? r : [];
          yield R.emitAsync(P.GET_STAGE_REQUESTS, e), o(this, Aa) < e.length && e.length > 0 && this.stage.emit("newStageRequest", { count: e.length }), _(this, Aa, e.length), this.stage.emit("stageAccessRequestUpdate", e);
        })
      );
    }
    getCurrentStageRequests() {
      return o(this, Zs).joined.toArray().filter(
        (e) => e.stageStatus === "REQUESTED_TO_JOIN_STAGE"
      ).map((e) => ({
        displayName: e.name,
        userId: e.userId,
        peerId: e.id
      }));
    }
    setStageStatus(t) {
      return u(this, null, function* () {
        this.stage.status !== t && o(this, xr).setValue("stageStatus", t);
      });
    }
    /**
     * NOTE(ishita1805): Runs for cases like:
     * - Being kicked from stage
     * - Socket-Client inconsistency
     */
    selfStageStatusHandler(t) {
      const e = su(t.stageType), r = o(this, xr).getValue("stageStatus");
      if (r !== e)
        switch (t.stageType) {
          case 1:
            o(this, xr).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.join();
            break;
          case 2:
          case 3:
            this.setStageStatus(r);
            break;
          case 0:
          case 4:
          default:
            o(this, xr).setValue("stageStatus", "ACCEPTED_TO_JOIN_STAGE", false), this.stage.leave();
            break;
        }
    }
    /**
     * NOTE(ishita1805): Source of truth for updating peer stage status
     */
    peerStageStatusHandler(t) {
      return u(this, null, function* () {
        const e = o(this, Zs).joined.get(t.peerId), r = o(this, Zs).viewMode === "ACTIVE_GRID";
        if (!e) {
          l.warn("err::peerStageStatusUpdate: participant not found");
          return;
        }
        switch (t.stageType) {
          case 1:
            e.setStageStatus("ON_STAGE"), r && R.emit(P.UPDATE_ACTIVE);
            break;
          case 2:
            e.setStageStatus("ACCEPTED_TO_JOIN_STAGE");
            break;
          case 3:
            e.setStageStatus("REQUESTED_TO_JOIN_STAGE");
            break;
          case 0:
          case 4:
          default:
            e.setStageStatus("OFF_STAGE"), r && R.emit(P.UPDATE_ACTIVE);
            break;
        }
        R.emit(P.UPDATE_PEER_STAGE_STATUS, {
          id: e.id,
          status: e.stageStatus
        });
      });
    }
  }
  hs = new WeakMap(), Zs = new WeakMap(), ms = new WeakMap(), Aa = new WeakMap(), xr = new WeakMap();
  YA([
    v.trace("DyteStage.setupEvents")
  ], ig.prototype, "setupEvents");
  var QA = Object.defineProperty, XA = Object.getOwnPropertyDescriptor, Xc = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? XA(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && QA(t, e, n), n;
  };
  const $e = {
    getPeer: 14,
    getPeers: 15,
    chatMessage: 16,
    getRoomName: 17,
    getDisplayTitle: 18,
    getPluginInitiator: 19,
    customPluginEventToParent: 20,
    peerJoined: 22,
    peerLeft: 23,
    sendData: 24,
    stageStatusUpdate: 25,
    peerStageStatusUpdate: 26
  };
  var lt, Lt, ii, ai, $r, oi, ci, en, la, bh;
  let Ni = (bh = class extends $i {
    constructor(t, {
      baseURL: e,
      createdAt: r,
      description: n,
      id: i,
      name: a,
      organizationId: c,
      picture: d,
      private: p,
      published: h,
      staggered: m,
      tags: g,
      type: T,
      updatedAt: y
    }, b, A, I, $) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, en);
      E(this, lt, undefined);
      f(this, "baseURL");
      f(this, "createdAt");
      f(this, "description");
      f(this, "id");
      f(this, "name");
      E(this, Lt, undefined);
      E(this, ii, undefined);
      E(this, ai, undefined);
      f(this, "organizationId");
      f(this, "picture");
      f(this, "private");
      f(this, "published");
      f(this, "staggered");
      f(this, "tags");
      f(this, "type");
      f(this, "updatedAt");
      E(this, $r, undefined);
      f(this, "config");
      E(this, oi, undefined);
      f(this, "active");
      f(this, "iframes");
      f(this, "enabledBy");
      E(this, ci, undefined);
      _(this, ci, t), this.baseURL = e, this.createdAt = new Date(r), this.description = n, this.id = i, this.name = a, _(this, Lt, A), this.organizationId = c, this.picture = d, this.private = p, this.published = h, this.staggered = m, this.tags = g, this.type = T, this.updatedAt = new Date(y), this.active = false, this.iframes = /* @__PURE__ */ new Map(), _(this, lt, b), _(this, ii, I), _(this, ai, $), this.enabledBy = "";
    }
    /**
     * @access private
     * This function forwards events to plugin. This is not meant for external use.
     * @param message Socket message forwarded to this plugin.
     */
    sendIframeEvent(t) {
      this.iframes.size && this.iframes.forEach((e) => {
        const { iframe: r } = e;
        r && (navigator.isReactNative ? r.postMessage(JSON.stringify(t)) : r.contentWindow.postMessage(t, "*"));
      });
    }
    handleIframeMessage(t) {
      return u(this, null, function* () {
        var a;
        if (!this.active)
          return;
        const e = t, { payload: r, uuid: n, type: i } = e;
        switch (i) {
          case J.customPluginEventToRoom: {
            o(this, lt).customPluginEventToRoom(
              this.id,
              r,
              n
            );
            break;
          }
          case J.customPluginEventToPeers: {
            o(this, lt).customPluginEventToPeers(
              this.id,
              r.peerIds,
              r,
              n
            );
            break;
          }
          case J.enablePluginForRoom: {
            o(this, lt).enablePluginForRoom(this.id, n);
            break;
          }
          case J.enablePluginForPeers: {
            o(this, lt).enablePluginForPeers(
              this.id,
              r.peerIds,
              n
            );
            break;
          }
          case J.disablePluginForRoom: {
            o(this, lt).disablePluginForRoom(this.id, n);
            break;
          }
          case J.disablePluginForPeers: {
            o(this, lt).disablePluginForPeers(
              this.id,
              r.peerIds,
              n
            );
            break;
          }
          case J.storeInsertKeys: {
            o(this, lt).storeInsertKeys(
              this.id,
              r.store,
              r.insertKeys,
              n
            );
            break;
          }
          case J.storeGetKeys: {
            o(this, lt).storeGetKeys(
              this.id,
              r.store,
              r.getKeys,
              n
            );
            break;
          }
          case J.storeDeleteKeys: {
            o(this, lt).storeDeleteKeys(
              this.id,
              r.store,
              r.deleteKeys,
              n
            );
            break;
          }
          case J.storeDelete: {
            o(this, lt).storeDelete(this.id, r.store, n);
            break;
          }
          case $e.chatMessage: {
            const {
              messagePayload: c,
              peerIds: d
            } = r;
            if (!o(this, ai)) {
              this.sendIframeEvent({
                type: $e.chatMessage,
                uuid: e.uuid,
                payload: { error: "Chat is disabled for this room." }
              });
              return;
            }
            try {
              yield o(this, ai).sendMessage(c, d), this.sendIframeEvent({
                type: $e.chatMessage,
                uuid: e.uuid,
                payload: { success: !0 }
              });
            } catch (p) {
              this.sendIframeEvent({
                type: $e.chatMessage,
                uuid: e.uuid,
                payload: {
                  error: p
                }
              });
            }
            break;
          }
          case $e.getPeer: {
            let c;
            const { peerId: d } = r, p = z(L({}, o(this, Lt)), {
              id: o(this, Lt).id,
              isRecorder: (a = o(this, Lt).permissions) == null ? undefined : a.isRecorder,
              isHidden: o(this, Lt).permissions.hiddenParticipant,
              stageStatus: o(this, Lt).stageStatus
            });
            d ? (c = o(this, ii).joined.get(r.peerId), o(this, Lt).id === d && (c = p)) : c = p, this.sendIframeEvent({
              type: $e.getPeer,
              payload: { peer: c && dc(c) },
              uuid: e.uuid
            });
            break;
          }
          case $e.getPeers: {
            const c = o(this, ii).joined.toArray().map((d) => dc(d));
            this.sendIframeEvent({
              type: $e.getPeers,
              payload: { peers: c },
              uuid: e.uuid
            });
            break;
          }
          case $e.getPluginInitiator: {
            this.sendIframeEvent({
              type: $e.getPluginInitiator,
              payload: { enabledBy: this.enabledBy },
              uuid: e.uuid
            });
            break;
          }
          case $e.getDisplayTitle: {
            this.sendIframeEvent({
              type: $e.getDisplayTitle,
              payload: { displayTitle: o(this, en, la).meetingTitle },
              uuid: e.uuid
            });
            break;
          }
          case $e.getRoomName: {
            this.sendIframeEvent({
              type: $e.getRoomName,
              payload: { roomName: o(this, en, la).roomName },
              uuid: e.uuid
            });
            break;
          }
          case $e.customPluginEventToParent: {
            this.emit(e.payload.eventName, e.payload.data);
            break;
          }
        }
      });
    }
    sendData(t) {
      this.active && (l.info("DytePlugin::SendData", {
        plugin: {
          id: this.id,
          name: this.name,
          data: {
            eventName: t.eventName
          }
        }
      }), this.sendIframeEvent({
        type: $e.sendData,
        uuid: "",
        payload: t
      }));
    }
    /**
     * This method is used for cleaning up event listeners attached to an iframe. It must
     * be used before the iframe is removed from the DOM.
     * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
     */
    removePluginView(t = "default") {
      var n;
      const { iframe: e, listener: r } = (n = this.iframes.get(t)) != null ? n : {};
      (e || r) && (navigator.isReactNative ? e.props.onMessage = undefined : window.removeEventListener("message", r), this.iframes.delete(t));
    }
    /**
     * This method adds the communcation layer between the plugin inside the iframe
     * and the core application (meeting object) in the main window.
     * @param iframe Iframe element to display this plugin.
     * @param viewId ID of the view corresponding to this iframe. Default is 'default'.
     */
    addPluginView(t, e = "default") {
      var a;
      if (!o(this, oi))
        throw l.error(
          "DytePlugin::addPluginView::no_auth_token_set_for_plugin"
        ), new w("No auth token set for plugin.");
      if (!t)
        throw l.error("DytePlugin::addPluginView::iframe_was_not_provided"), new w("Iframe was not provided.");
      this.removePluginView(e);
      const r = t, n = new URL(this.baseURL), i = {
        auth: o(this, oi),
        parent: navigator.isReactNative ? this.baseURL : window.location.origin,
        backend: o(this, ci).getValue("apiBase"),
        pluginId: this.id,
        roomName: (a = o(this, en, la).roomName) != null ? a : "",
        displayTitle: o(this, en, la).meetingTitle
      };
      if (Object.keys(i).forEach((c) => {
        n.searchParams.set(c, i[c]);
      }), r.src = n.href, r.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", r.title = e, navigator.isReactNative)
        r.props.onMessage = (c) => {
          this.handleIframeMessage(JSON.parse(c.nativeEvent.data));
        }, this.iframes.set(e, { iframe: r });
      else {
        const c = (d) => u(this, null, function* () {
          d.source === t.contentWindow && (yield this.handleIframeMessage(d.data));
        });
        window.addEventListener("message", c), this.iframes.set(e, { iframe: r, listener: c });
      }
    }
    setActive(t) {
      var e, r;
      if (this.active = t, t) {
        this.emit("stateUpdate", {
          active: this.active,
          pluginId: this.id,
          bind: this.addPluginView.bind(this),
          views: (e = this.config) == null ? undefined : e.views
        });
        return;
      }
      this.active = false, this.emit("stateUpdate", {
        active: this.active,
        pluginId: this.id,
        views: (r = this.config) == null ? undefined : r.views
      });
    }
    /**
     * @access private
     * Not for external use
     */
    // NOTE(roerohan): Enable this plugin for the current user.
    activateForSelf() {
      return u(this, null, function* () {
        const t = qe(), e = yield t.authorizePlugin(this.id);
        _(this, oi, e), _(this, $r, new Date());
        try {
          const r = yield t.getPluginConfig(this.baseURL);
          this.config = r;
        } catch (r) {
          l.error("DytePlugin::activateForSelf", { error: r });
        }
        this.setActive(true), this.emit("enabled");
      });
    }
    /**
     * @access private
     * Not for external use
     */
    // NOTE(roerohan): Disable this plugin for the current user.
    deactivateForSelf() {
      Array.from(this.iframes.keys()).forEach((t) => {
        this.removePluginView(t);
      }), _(this, $r, undefined), this.iframes.clear(), this.setActive(false), this.emit("closed");
    }
    /**
     * @deprecated
     */
    enable() {
      return u(this, null, function* () {
        return this.activateForSelf();
      });
    }
    /**
     * @deprecated
     */
    disable() {
      return this.deactivateForSelf();
    }
    activate() {
      return u(this, null, function* () {
        var t, e;
        this.active || (e = (t = o(this, Lt).permissions) == null ? undefined : t.plugins) != null && e.canStart && (o(this, lt).addPlugin(this.id, this.staggered), _(this, $r, new Date()), l.info("plugin::activated", {
          plugin: {
            id: this.id,
            enabledBy: this.enabledBy,
            name: this.name
          }
        }));
      });
    }
    deactivate() {
      return u(this, null, function* () {
        var t, e;
        this.active && (!((e = (t = o(this, Lt).permissions) == null ? undefined : t.plugins) != null && e.canClose) && this.enabledBy !== o(this, Lt).id || (o(this, lt).removePlugin(this.id), l.info("plugin::deactivated", {
          plugin: {
            id: this.id,
            name: this.name,
            duration: o(this, $r) ? new Date().getTime() - o(this, $r).getTime() : 0
          }
        }), _(this, $r, undefined)));
      });
    }
  }, lt = new WeakMap(), Lt = new WeakMap(), ii = new WeakMap(), ai = new WeakMap(), $r = new WeakMap(), oi = new WeakMap(), ci = new WeakMap(), en = new WeakSet(), la = function() {
    return o(this, ci).getValue("roomNodeClient");
  }, bh);
  Xc([
    At({ maxInvocations: 5, period: 1 })
  ], Ni.prototype, "sendData", 1);
  Xc([
    v.trace("DytePlugin.activatePlugin")
  ], Ni.prototype, "activate", 1);
  Xc([
    v.trace("DytePlugin.deactivatePlugin")
  ], Ni.prototype, "deactivate", 1);
  Ni = Xc([
    vt("0600")
  ], Ni);
  var He, tn;
  class ag extends Map {
    constructor(e) {
      const {
        onAddEvent: r,
        onDeleteEvent: n,
        onClearEvent: i
      } = e;
      super();
      E(this, He, undefined);
      E(this, tn, undefined);
      f(this, "onAddEvent");
      f(this, "onDeleteEvent");
      f(this, "onClearEvent");
      _(this, He, new $i()), this.onAddEvent = r, this.onDeleteEvent = n, this.onClearEvent = i, _(this, tn, /* @__PURE__ */ new Map());
    }
    emit(e, ...r) {
      return o(this, He).emit(e, ...r);
    }
    on(e, r) {
      return o(this, He).on(e, r);
    }
    addListener(e, r) {
      return o(this, He).addListener(e, r);
    }
    off(e, r) {
      return o(this, He).off(e, r);
    }
    once(e, r) {
      return o(this, He).once(e, r);
    }
    prependListener(e, r) {
      return o(this, He).prependListener(e, r);
    }
    prependOnceListener(e, r) {
      return o(this, He).prependOnceListener(e, r);
    }
    removeListener(e, r) {
      return o(this, He).removeListener(e, r);
    }
    removeAllListeners(e) {
      return o(this, He).removeAllListeners(e);
    }
    listeners(e) {
      return o(this, He).listeners(e);
    }
    listenerCount(e) {
      return o(this, He).listenerCount(e);
    }
    getMaxListeners() {
      return o(this, He).getMaxListeners();
    }
    setMaxListeners(e) {
      return o(this, He).setMaxListeners(e);
    }
    eventNames() {
      return o(this, He).eventNames();
    }
    add(e, r = true) {
      return this.set(e.id, e, r);
    }
    set(e, r, n = true) {
      const i = super.set(e, r), a = (c, ...d) => {
        this.emit(c, r, ...d);
      };
      return o(this, tn).set(e, a), r.on("*", a), n && o(this, He).emit(this.onAddEvent, r), i;
    }
    delete(e, r = true, n = false) {
      const i = this.get(e);
      if (!i)
        return false;
      i.removeListener("*", o(this, tn).get(e));
      const a = super.delete(e);
      return n && i.removeAllListeners(), r && o(this, He).emit(this.onDeleteEvent, i), a;
    }
    clear(e = true, r = false) {
      this.forEach((i) => {
        i.removeListener("*", o(this, tn).get(i.id)), r && i.removeAllListeners();
      });
      const n = super.clear();
      return e && o(this, He).emit(this.onClearEvent), n;
    }
    toArray() {
      return Array.from(this.values());
    }
  }
  He = new WeakMap(), tn = new WeakMap();
  class sh extends ag {
    constructor() {
      super({
        onAddEvent: "pluginAdded",
        onDeleteEvent: "pluginDeleted"
      });
    }
    add(t, e = true) {
      return super.add(t, e);
    }
    delete(t, e = true, r = false) {
      return super.delete(t, e, r);
    }
  }
  var tD = (s, t, e, r) => {
    for (var n = t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(n)) || n);
    return n;
  };
  let Tl = class {
    constructor() {
      /**
       * All plugins accessible by the current user.
       */
      f(this, "all");
      /**
       * All plugins that are currently enabled in the room.
       */
      f(this, "active");
      this.all = new sh(), this.active = new sh();
    }
  };
  Tl = tD([
    vt("0600")
  ], Tl);
  var rD = Object.defineProperty, sD = Object.getOwnPropertyDescriptor, Zc = (s, t, e, r) => {
    for (var n = sD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && rD(t, e, n), n;
  }, Wt, di, Da, kh;
  const og = (kh = class {
    constructor(s, t, e, r) {
      f(this, "plugins");
      E(this, Wt, undefined);
      E(this, di, undefined);
      E(this, Da, undefined);
      _(this, Wt, t), _(this, di, e), _(this, Da, s), this.plugins = r, this.setupEvents();
    }
    static init(s, t, e, r, n, i, a) {
      return u(this, null, function* () {
        const c = new Tl();
        return t.forEach((d) => {
          const p = new Ni(
            s,
            d,
            e,
            i,
            a,
            n
          );
          c.all.add(p);
        }), new og(
          s,
          e,
          r,
          c
        );
      });
    }
    getRoomPlugins() {
      return u(this, null, function* () {
        var t;
        const { plugins: s } = yield o(this, Wt).getActivePlugins();
        (t = this.plugins.active) == null || t.toArray().forEach((e) => {
          this.disablePlugin({ id: e.id });
        }), yield Promise.all(
          s.map(
            (e) => this.enablePlugin({
              id: e.pluginId,
              enabledBy: e.enabledBy
            })
          )
        );
      });
    }
    enablePlugin(e) {
      return u(this, arguments, function* ({
        id: s,
        enabledBy: t
      }) {
        const r = this.plugins.all.get(s);
        r && (yield r.activateForSelf(), r.enabledBy = t);
      });
    }
    disablePlugin(t) {
      return u(this, arguments, function* ({ id: s }) {
        const e = this.plugins.all.get(s);
        e && e.deactivateForSelf();
      });
    }
    sendIframeEvent(s, t, e, r) {
      const n = this.plugins.all.get(t);
      n && n.sendIframeEvent({ type: s, uuid: e, payload: r });
    }
    broadcastIframeEvent(s, t) {
      this.plugins.active.forEach((e) => {
        this.sendIframeEvent(s, e.id, "", t);
      });
    }
    setupEvents() {
      this.plugins.all.on(
        "stateUpdate",
        ({ active: s, id: t }) => {
          if (s) {
            this.plugins.active.add(this.plugins.all.get(t));
            return;
          }
          this.plugins.active.delete(t);
        }
      ), R.onAsync(P.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
        yield this.getRoomPlugins(), l.debug("[SOCKET_SERVICE_ROOM_JOINED] resolved request to fetch plugins.");
      })), o(this, Wt).on(
        J.addPlugin,
        (s) => u(this, null, function* () {
          var e;
          const t = s.pluginId;
          (e = this.plugins.all.get(t)) != null && e.active || (yield this.enablePlugin({ id: t, enabledBy: s.enabledBy }));
        })
      ), o(this, Wt).on(
        J.removePlugin,
        (s) => u(this, null, function* () {
          var e;
          const t = s.pluginId;
          (e = this.plugins.all.get(t)) != null && e.active && (yield this.disablePlugin({ id: t }));
        })
      ), [
        J.enablePluginForPeers,
        J.enablePluginForRoom
      ].forEach((s) => {
        o(this, Wt).on(
          s,
          (t, e) => u(this, null, function* () {
            this.sendIframeEvent(s, t.pluginId, e, {
              enabledBy: t.enabledBy
            });
          })
        );
      }), [
        J.disablePluginForPeers,
        J.disablePluginForRoom
      ].forEach((s) => {
        o(this, Wt).on(
          s,
          (t, e) => u(this, null, function* () {
            this.sendIframeEvent(s, t.pluginId, e, {
              disabledBy: t.disabledBy
            });
          })
        );
      }), [
        J.customPluginEventToPeers,
        J.customPluginEventToRoom
      ].forEach((s) => {
        o(this, Wt).on(
          s,
          (t, e) => u(this, null, function* () {
            this.sendIframeEvent(s, t.pluginId, e, {
              data: JSON.parse(
                new TextDecoder().decode(t.pluginData)
              )
            });
          })
        );
      }), [
        J.storeInsertKeys,
        J.storeGetKeys,
        J.storeDeleteKeys
      ].forEach((s) => {
        o(this, Wt).on(
          s,
          (t, e) => u(this, null, function* () {
            var n;
            const r = (n = t.storeItems) == null ? undefined : n.map((i) => {
              var a;
              return {
                timestamp: i.timestamp,
                peerId: i.peerId,
                payload: JSON.parse(
                  (a = i.payload) != null && a.length ? new TextDecoder().decode(i.payload) : "{}"
                ),
                key: i.storeKey
              };
            });
            this.sendIframeEvent(s, t.pluginId, e, {
              storeName: t.storeName,
              storeItems: r
            });
          })
        );
      }), o(this, Wt).on(
        J.storeDelete,
        (s, t) => u(this, null, function* () {
          this.sendIframeEvent(J.storeDelete, s.pluginId, t, {
            storeName: s.storeName
          });
        })
      ), o(this, di).on(
        Ne.sendMessageToPeers,
        (s) => {
          const t = tr == null ? undefined : tr.formatSocketServiceMessage(
            s.message
          );
          this.broadcastIframeEvent($e.chatMessage, { message: t });
        }
      ), o(this, di).on(
        Ne.sendMessageToRoom,
        (s) => {
          const t = tr == null ? undefined : tr.formatSocketServiceMessage(
            s.message
          );
          this.broadcastIframeEvent($e.chatMessage, { message: t });
        }
      ), R.on(P.PEER_JOINED_INTERNAL, (s) => {
        const t = dc(s);
        this.broadcastIframeEvent($e.peerJoined, t);
      }), R.on(P.PEER_CLOSED, (s) => {
        this.broadcastIframeEvent($e.peerLeft, s);
      }), R.on(P.UPDATE_PEER_STAGE_STATUS, (s) => {
        this.broadcastIframeEvent($e.peerStageStatusUpdate, s);
      }), o(this, Da).subscribe("stageStatus", (s) => {
        this.broadcastIframeEvent($e.stageStatusUpdate, s);
      });
    }
  }, Wt = new WeakMap(), di = new WeakMap(), Da = new WeakMap(), kh);
  let yo = og;
  Zc([
    v.trace("PluginController.getRoomPlugins")
  ], yo.prototype, "getRoomPlugins");
  Zc([
    v.trace("PluginController.enableForSelf")
  ], yo.prototype, "enablePlugin");
  Zc([
    v.trace("PluginController.disableForSelf")
  ], yo.prototype, "disablePlugin");
  Zc([
    v.trace("PluginController.setupEvents")
  ], yo.prototype, "setupEvents");
  class nD {
    constructor() {
      f(this, "mediaJoined");
      f(this, "socketJoined");
      f(this, "socketJoinAttempted");
      f(this, "mediaJoinAttempted");
      f(this, "socketState");
      f(this, "mediaState");
      this.mediaJoined = false, this.socketJoined = false, this.socketJoinAttempted = false, this.mediaJoinAttempted = false, this.socketState = {
        state: undefined,
        reconnected: false,
        reconnectionAttempt: undefined
      }, this.mediaState = {
        recv: undefined,
        send: undefined
      };
    }
    get joinAttempted() {
      return this.mediaJoinAttempted || this.socketJoinAttempted;
    }
    get roomJoined() {
      return this.mediaJoined && this.socketJoined;
    }
    updateSocketConnectionState(t, e) {
      let r;
      const { reconnected: n } = this.socketState;
      switch (t) {
        case "connected":
          r = {
            state: "connected",
            reconnected: n,
            reconnectionAttempt: undefined
          };
          break;
        case "disconnected":
          r = {
            state: "disconnected",
            reconnected: false,
            reconnectionAttempt: 0
          }, this.socketJoined = false;
          break;
        case "reconnected":
          r = {
            state: "connected",
            reconnected: true,
            reconnectionAttempt: undefined
          };
          break;
        case "reconnecting":
          r = {
            state: "reconnecting",
            reconnected: n,
            reconnectionAttempt: 0
          };
          break;
        case "reconnectAttempt":
          r = {
            state: "reconnecting",
            reconnected: n,
            reconnectionAttempt: e
          };
          break;
        case "failed":
          r = {
            state: "failed",
            reconnected: n,
            reconnectionAttempt: undefined
          }, this.socketJoined = false;
          break;
      }
      r && (R.emit(P.SOCKET_STATE_UPDATE, r), this.socketState = r);
    }
  }
  var iD = Object.defineProperty, aD = Object.getOwnPropertyDescriptor, To = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? aD(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && iD(t, e, n), n;
  }, li, Ma, ui, jo, Ih;
  let Sn = (Ih = class extends Ft {
    constructor(t, e) {
      super();
      E(this, ui);
      E(this, li, undefined);
      E(this, Ma, undefined);
      f(this, "recordingPeerIds", []);
      f(this, "recordings", []);
      _(this, Ma, t), _(this, li, e);
    }
    get recordingState() {
      return this.recordings.some((t) => t.state === "RECORDING") ? "RECORDING" : this.recordings.some((t) => t.state === "PAUSED") ? "PAUSED" : this.recordings.some((t) => t.state === "STARTING") ? "STARTING" : this.recordings.some((t) => t.state === "STOPPING") ? "STOPPING" : "IDLE";
    }
    updateRecordings(t) {
      this.recordings = t, this.emit("recordingUpdate", this.recordingState);
    }
    start(t) {
      return u(this, null, function* () {
        if (!o(this, li).permissions.canRecord)
          throw l.error("DyteRecording::start::permission_denied"), new w("User does not have permission to start recording");
        if ((t == null ? undefined : t.allowMultiple) !== true && (this.recordingState === "STARTING" || this.recordingState === "RECORDING" || this.recordingState === "STOPPING"))
          throw l.error("DyteRecording::start::recording_in_progress", {
            recording: {
              state: this.recordingState
            }
          }), new w(
            `Cant start recording, recordingState irregular: ${this.recordingState}`
          );
        try {
          const e = qe(), { recording: r = {} } = o(this, Ma).getValue("defaults"), n = yield e.startRecording(r, t == null ? void 0 : t.allowMultiple);
          this.updateRecordings([...this.recordings, {
            id: n,
            state: "STARTING",
            type: "BROWSER"
          }]);
        } catch (e) {
          throw l.error("DyteRecording::stop::recording_failed_to_start", {
            error: e
          }), new w("Error while starting recording");
        }
      });
    }
    stop(t) {
      return u(this, null, function* () {
        yield Le(this, ui, jo).call(this, "stop", ["RECORDING", "PAUSED"], t);
      });
    }
    pause(t) {
      return u(this, null, function* () {
        yield Le(this, ui, jo).call(this, "pause", ["RECORDING"], t);
      });
    }
    resume(t) {
      return u(this, null, function* () {
        yield Le(this, ui, jo).call(this, "resume", ["PAUSED"], t);
      });
    }
  }, li = new WeakMap(), Ma = new WeakMap(), ui = new WeakSet(), jo = function(t, e, r) {
    return u(this, null, function* () {
      if (!o(this, li).permissions.canRecord)
        throw l.error("DyteRecording::stop::permission_denied"), new w("User does not have permission to stop recording");
      let n = [];
      if (r !== undefined) {
        const i = this.recordings.find((a) => a.id === r);
        if (i === undefined)
          throw new w("Could not find the specified recording");
        if (e.includes(i.state)) {
          l.error("DyteRecording::stop::recording_not_in_expected_state", {
            recording: {
              state: i.state
            }
          });
          return;
        }
        n.push(i);
      } else
        n = this.recordings.filter((i) => e.includes(i.state));
      n.forEach((i) => u(this, null, function* () {
        const a = i.state;
        t === "stop" && (i.state = "STOPPING", this.emit("recordingUpdate", "STOPPING"));
        try {
          yield qe().updateRecording(i.id, t);
        } catch (c) {
          throw l.error("DyteRecording::stop::recording_failed_to_stop", {
            error: c
          }), i.state !== a && (i.state = a, this.emit("recordingUpdate", a)), new w("Error while stopping recording");
        }
      }));
    });
  }, Ih);
  To([
    v.trace("DyteRecording.start")
  ], Sn.prototype, "start", 1);
  To([
    v.trace("DyteRecording.stop")
  ], Sn.prototype, "stop", 1);
  To([
    v.trace("DyteRecording.stop")
  ], Sn.prototype, "pause", 1);
  To([
    v.trace("DyteRecording.stop")
  ], Sn.prototype, "resume", 1);
  Sn = To([
    vt("1000")
  ], Sn);
  var oD = Object.defineProperty, cD = Object.getOwnPropertyDescriptor, dD = (s, t, e, r) => {
    for (var n = cD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && oD(t, e, n), n;
  }, Pc;
  class cg {
    constructor(t, e, r) {
      f(this, "recording");
      f(this, "room");
      E(this, Pc, undefined);
      _(this, Pc, t), this.recording = new Sn(t, e), this.room = r, this.setupEvents();
    }
    // eslint-disable-next-line class-methods-use-this
    getRecordingTypeFromProtoType(t) {
      let e;
      switch (t) {
        case vn.BROWSER:
          e = "BROWSER";
          break;
        case vn.COMPOSITE:
          e = "COMPOSITE";
          break;
        case vn.TRACK:
          e = "TRACK";
          break;
        default:
          e = "BROWSER";
      }
      return e;
    }
    setupEvents() {
      R.on(P.ROOM_STATE, (t) => {
        t.activeRecordings.length !== 0 ? this.recording.updateRecordings(
          t.activeRecordings.map((e) => {
            const r = this.getRecordingTypeFromProtoType(e.recordingType);
            return { id: e.recordingId, state: e.recordingStatus, type: r };
          })
        ) : this.recording.recordings.length && this.recording.updateRecordings([]);
      }), this.room.on(F.recordingStarted, (t) => {
        let e = false;
        const r = [...this.recording.recordings];
        if (r.forEach((n) => {
          n.id === t.recordingId && (e = true, n.state = "RECORDING");
        }), e === false) {
          const n = this.getRecordingTypeFromProtoType(t.recordingType);
          r.push({
            id: t.recordingId,
            state: "RECORDING",
            type: n
          });
        }
        this.recording.updateRecordings(r);
      }), this.room.on(F.recordingPaused, (t) => {
        const e = [...this.recording.recordings];
        e.forEach((r) => {
          r.id === t.recordingId && (r.state = "PAUSED");
        }), this.recording.updateRecordings(e);
      }), this.room.on(F.recordingStopped, (t) => {
        const e = [...this.recording.recordings.filter((r) => r.id !== t.recordingId)];
        this.recording.updateRecordings(e);
      });
    }
  }
  Pc = new WeakMap();
  dD([
    v.trace("RecordingController.setupEvents")
  ], cg.prototype, "setupEvents");
  class lD {
    static hasFeature(t) {
      var e;
      return (e = K.hasFeature(t)) != null ? e : false;
    }
    static getFeatureValue(t) {
      return K.getValue(t);
    }
    static getAllFeatures() {
      return K.getAllFlags();
    }
  }
  class nu {
    constructor(t, e, r) {
      f(this, "logger");
      f(this, "features");
      f(this, "browserSpecs");
      f(this, "callStats");
      this.logger = t, this.features = e, this.browserSpecs = ve, this.callStats = r;
    }
    static init(t) {
      return new nu(l, lD, t);
    }
  }
  class iu {
    constructor(t) {
      f(this, "internals");
      this.internals = t;
    }
    static init() {
      return u(this, null, function* () {
        const t = nu.init(U);
        return new iu(t);
      });
    }
  }
  var uD = Object.defineProperty, pD = Object.getOwnPropertyDescriptor, Vt = (s, t, e, r) => {
    for (var n = pD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && uD(t, e, n), n;
  }, ze, nt, We, ur, Kt, Oa, Rc;
  class Dt extends $i {
    constructor(e, r, n = _l, i = true) {
      super();
      E(this, ze, undefined);
      E(this, nt, undefined);
      E(this, We, undefined);
      E(this, ur, undefined);
      E(this, Kt, undefined);
      E(this, Oa, undefined);
      E(this, Rc, undefined);
      f(this, "audioUpdateInProgress");
      f(this, "videoUpdateInProgress");
      _(this, Rc, e), this.audioUpdateInProgress = false, this.videoUpdateInProgress = false, _(this, ze, new dg(e, r)), _(this, nt, new ND(
        o(this, ze),
        undefined,
        n
      )), _(this, We, new HD(
        o(this, ze),
        undefined,
        n
      )), _(this, Kt, new UD(
        o(this, ze)
      )), _(this, ur, new xD(
        o(this, ze)
      )), _(this, Oa, i), o(this, nt).on("trackMuted", this.onAudioTrackMuted.bind(this)), o(this, nt).on(
        "trackChanged",
        this.onAudioTrackChanged.bind(this)
      ), o(this, We).on(
        "trackChanged",
        this.onVideoTrackChanged.bind(this)
      ), o(this, We).on("trackEnded", this.onVideoTrackEnded.bind(this)), o(this, Kt).on(
        "trackEnded",
        this.onScreenShareEnded.bind(this)
      ), this.onVisibilityChange = this.onVisibilityChange.bind(this), document.addEventListener("visibilitychange", this.onVisibilityChange);
    }
    // eslint-disable-next-line class-methods-use-this
    onVisibilityChange() {
      return u(this, null, function* () {
        U.tabChanged(document.visibilityState === "visible"), document.visibilityState !== "visible" ? U.browserBackgrounded() : (U.browserForegrounded(), yield this.setupSpeaker());
      });
    }
    // eslint-disable-next-line class-methods-use-this
    repopulateAvailableDevices() {
      return u(this, null, function* () {
        return true;
      });
    }
    setupStreams(n) {
      return u(this, arguments, function* ({
        audio: e,
        video: r
      }) {
        var c;
        let i, a;
        if (e && r)
          try {
            const d = yield o(this, ze).getAudioAndVideoTrack();
            i = d.audioTrack, a = d.videoTrack;
          } catch (d) {
            l.error(
              "LocalMediaHandler::init::Failed to get audio video tracks",
              {
                error: d
              }
            );
          }
        if (!i && e)
          try {
            i = yield o(this, ze).getAudioTrack(!1);
          } catch (d) {
            l.error("LocalMediaHandler::init::Failed to get audio track", {
              error: d
            });
          }
        if (!a && r)
          try {
            a = yield o(this, ze).getVideoTrack();
          } catch (d) {
            l.error("LocalMediaHandler::init::Failed to get video track", {
              error: d
            });
          }
        yield o(this, nt).setMediaTrack(i), yield o(this, We).setMediaTrack(a);
        try {
          yield o(this, ur).setupSpeaker();
        } catch (d) {
        }
        if (a) {
          const d = yield this.getDeviceById(a.getSettings().deviceId);
          U.onSafeInitialization(() => {
            U.selectedDevice("VIDEO", d);
          });
        }
        if (i) {
          const d = yield this.getDeviceById(i.getSettings().deviceId);
          U.onSafeInitialization(() => {
            U.selectedDevice("AUDIO", d);
          });
        }
        (c = o(this, ur).currentDevice) != null && c.deviceId && U.onSafeInitialization(() => {
          U.selectedDevice("SPEAKER", o(this, ur).currentDevice);
        }), o(this, ze).onDeviceChange((d, p, h) => {
          this.onDeviceChange(p, h);
        });
      });
    }
    getCurrentDevices() {
      return {
        audio: o(this, nt).currentDevice,
        video: o(this, We).currentDevice,
        speaker: o(this, ur).currentDevice
      };
    }
    get permissions() {
      return o(this, ze).permissions;
    }
    getAllDevices() {
      return o(this, ze).getAvailableDevices();
    }
    getDeviceById(e, r) {
      return o(this, ze).getDevice(e);
    }
    /**
     * Audio Input Handler
     */
    onAudioTrackMuted() {
      this.emit("AUDIO_TRACK_SILENT");
    }
    onAudioTrackChanged() {
      this.emit("AUDIO_TRACK_CHANGE");
    }
    get rawAudioTrack() {
      return o(this, nt).mediaTrack;
    }
    get audioTrack() {
      return o(this, nt).transformedMediaTrack;
    }
    get audioEnabled() {
      return o(this, nt).trackEnabled;
    }
    enableAudio() {
      return u(this, null, function* () {
        if (!this.audioUpdateInProgress) {
          this.audioUpdateInProgress = true;
          try {
            yield o(this, nt).unmuteTrack();
          } catch (e) {
          } finally {
            this.audioUpdateInProgress = false;
          }
        }
      });
    }
    disableAudio() {
      o(this, nt).muteTrack();
    }
    getAudioDevices(e) {
      return o(this, ze).getAudioInputDevices(e);
    }
    setAudioDevice(e) {
      return u(this, null, function* () {
        yield o(this, nt).setDevice(e), e != null && e.deviceId && U.onSafeInitialization(() => {
          U.selectedDevice("AUDIO", e);
        }), this.emit("AUDIO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
      });
    }
    /**
     * Audio Output Handler
     */
    setupSpeaker() {
      return o(this, ur).setupSpeaker();
    }
    setSpeakerDevice(e) {
      return u(this, null, function* () {
        yield o(this, ur).setupSpeaker(e), e != null && e.deviceId && U.onSafeInitialization(() => {
          U.selectedDevice("SPEAKER", e);
        }), this.emit("DEVICE_CHANGE", { device: e });
      });
    }
    /**
     * Video Handler
     */
    onVideoTrackChanged() {
      this.emit("VIDEO_TRACK_CHANGE");
    }
    onVideoTrackEnded() {
      this.emit("VIDEO_TRACK_CHANGE");
    }
    get rawVideoTrack() {
      return o(this, We).mediaTrack;
    }
    get videoTrack() {
      return o(this, We).transformedMediaTrack;
    }
    get videoEnabled() {
      return o(this, We).trackEnabled;
    }
    enableVideo() {
      return u(this, null, function* () {
        if (!this.videoUpdateInProgress) {
          this.videoUpdateInProgress = true;
          try {
            yield o(this, We).unmuteTrack();
          } catch (e) {
          } finally {
            this.videoUpdateInProgress = false;
          }
        }
      });
    }
    disableVideo() {
      o(this, We).disableTrack();
    }
    getVideoDevices(e) {
      return o(this, ze).getVideoInputDevices(e);
    }
    setVideoDevice(e) {
      return u(this, null, function* () {
        yield o(this, We).setDevice(e), e != null && e.deviceId && U.onSafeInitialization(() => {
          U.selectedDevice("VIDEO", e);
        }), this.emit("VIDEO_TRACK_CHANGE"), this.emit("DEVICE_CHANGE", { device: e });
      });
    }
    updateVideoConstraints(e) {
      return u(this, null, function* () {
        yield o(this, We).updateConstraints(e);
      });
    }
    /**
     * Screen Share Handler
     */
    onScreenShareEnded() {
      this.emit("SCREENSHARE_ENDED");
    }
    get screenShareTracks() {
      return {
        audio: o(this, Kt).audioMediaTrack,
        video: o(this, Kt).videoMediaTrack
      };
    }
    get screenShareEnabled() {
      return o(this, Kt).trackEnabled;
    }
    enableScreenShare() {
      return u(this, null, function* () {
        yield o(this, Kt).enableScreenShare();
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        o(this, Kt).disableScreenShare();
      });
    }
    updateScreenshareConstraints(e) {
      return u(this, null, function* () {
        yield o(this, Kt).updateConstraints(e);
      });
    }
    getSpeakerDevices(e) {
      return o(this, ze).getAudioOutputDevices(e);
    }
    /**
     * Middleware Utility
     */
    addAudioMiddleware(e) {
      return o(this, nt).addMiddleware(e);
    }
    removeAudioMiddleware(e) {
      return o(this, nt).removeMiddleware(e);
    }
    addVideoMiddleware(e) {
      return o(this, We).addMiddleware(e);
    }
    removeVideoMiddleware(e) {
      return o(this, We).removeMiddleware(e);
    }
    setVideoMiddlewareGlobalConfig(e) {
      return o(this, We).setVideoMiddlewareGlobalConfig(e);
    }
    destruct() {
      o(this, nt).disableTrack(), o(this, We).disableTrack(), o(this, We).terminateMiddlewareWebWorker(), o(this, Kt).disableScreenShare(), o(this, ze).destruct();
    }
    onDeviceChange(e, r) {
      return u(this, null, function* () {
        var n, i;
        this.emit("DEVICE_LIST_UPDATED", e), !(r || !o(this, Oa)) && ((n = e == null ? undefined : e.added) == null || n.forEach((a) => u(this, null, function* () {
          var c;
          a && !_l(a) && (a.kind === "audioinput" && ((c = this.audioTrack) == null ? undefined : c.enabled) === true ? yield this.setAudioDevice(a) : a.kind === "audiooutput" && (yield this.setSpeakerDevice(a)));
        })), (i = e == null ? undefined : e.removed) == null || i.forEach((a) => u(this, null, function* () {
          var c;
          if (a.kind === "audiooutput" && ((c = this.getCurrentDevices().speaker) == null ? undefined : c.deviceId) === a.deviceId) {
            const d = (yield this.getSpeakerDevices()).find((p) => p.deviceId !== a.deviceId);
            d && (yield this.setSpeakerDevice(d));
          }
        })));
      });
    }
    /**
     * Backward Compatibility
     */
    removeAllTracks() {
      this.destruct();
    }
    removeDocumentEventListeners() {
      return u(this, null, function* () {
        document.removeEventListener("visibilitychange", this.onVisibilityChange);
      });
    }
  }
  ze = new WeakMap(), nt = new WeakMap(), We = new WeakMap(), ur = new WeakMap(), Kt = new WeakMap(), Oa = new WeakMap(), Rc = new WeakMap();
  Vt([
    v.trace("MediaHandler.setupStreams")
  ], Dt.prototype, "setupStreams");
  Vt([
    v.trace("MediaHandler.enableAudio")
  ], Dt.prototype, "enableAudio");
  Vt([
    v.trace("MediaHandler.disableAudio")
  ], Dt.prototype, "disableAudio");
  Vt([
    v.trace("MediaHandler.setAudioDevice")
  ], Dt.prototype, "setAudioDevice");
  Vt([
    v.trace("MediaHandler.enableVideo")
  ], Dt.prototype, "enableVideo");
  Vt([
    v.trace("MediaHandler.disableVideo")
  ], Dt.prototype, "disableVideo");
  Vt([
    v.trace("MediaHandler.setVideoDevice")
  ], Dt.prototype, "setVideoDevice");
  Vt([
    v.trace("MediaHandler.updateVideoConstraints")
  ], Dt.prototype, "updateVideoConstraints");
  Vt([
    v.trace("MediaHandler.enableScreenShare")
  ], Dt.prototype, "enableScreenShare");
  Vt([
    v.trace("MediaHandler.disableScreenShare")
  ], Dt.prototype, "disableScreenShare");
  Vt([
    v.trace("MediaHandler.updateScreenshareConstraints")
  ], Dt.prototype, "updateScreenshareConstraints");
  Vt([
    v.trace("MediaHandler.destruct")
  ], Dt.prototype, "destruct");
  Vt([
    v.trace("MediaHandler.onDeviceChange")
  ], Dt.prototype, "onDeviceChange");
  function Mo(s, t, e) {
    switch (true) {
      case ve.isChromiumBased():
        switch (t) {
          case "NotAllowedError":
            return e.includes("by system") ? "SYSTEM_DENIED" : s === "screenshare" ? "CANCELED" : "DENIED";
          case "NotReadableError":
          default:
            return "COULD_NOT_START";
        }
      case ve.isSafari():
        switch (t) {
          case "NotAllowedError":
            return "DENIED";
          default:
            return "COULD_NOT_START";
        }
      case ve.isFirefox():
        switch (t) {
          case "NotFoundError":
          case "NotReadableError":
            return "SYSTEM_DENIED";
          case "NotAllowedError":
            return "DENIED";
          case "AbortError":
          default:
            return "COULD_NOT_START";
        }
      default:
        return "COULD_NOT_START";
    }
  }
  const hD = [
    "virtual",
    "emulator",
    "krisp",
    "solstice conference",
    "teams",
    "loom",
    "zoom",
    "manycam",
    "blackhole",
    "displayport",
    "xsplit",
    // XSplit virtual camera
    "wirecast",
    // Wirecast virtual camera
    "vMix",
    // vMix virtual camera
    "elgato",
    // Elgato virtual camera
    "epiphan",
    // Epiphan virtual camera
    "voice changer",
    // Some voice changer software
    "voicemod",
    // Voicemod virtual audio device
    "morphvoxx"
    // MorphVOXX virtual audio device
  ];
  function _l(s) {
    const t = s.label.toLowerCase();
    return ve._bowser.getOSName() === "macOS" && t.includes("iphone") ? (l.log("isVirtualDevice::ignore_macos_continuity"), true) : hD.some(
      (e) => t.includes(e)
    );
  }
  function mD(s, t) {
    return u(this, null, function* () {
      if (!(s != null && s.length))
        return t;
      const e = new AudioContext(), r = yield Promise.all(
        s == null ? undefined : s.map((a) => a(e))
      ), n = e.createMediaStreamSource(
        new MediaStream([t])
      ), i = e.createMediaStreamDestination();
      try {
        let a = n;
        for (let c = 0; c < r.length; c += 1)
          a.connect(r[c]), a = r[c];
        a.connect(i);
      } catch (a) {
        return l.error("getTransformedAudioTrack::middleware_execution_failed", {
          error: a
        }), t;
      }
      return i.stream.getAudioTracks()[0];
    });
  }
  var rn;
  class fD {
    constructor() {
      E(this, rn, undefined);
    }
    terminateMiddlewareWebWorker() {
      if (o(this, rn))
        try {
          clearInterval$1(o(this, rn)), _(this, rn, void 0);
        } catch (t) {
          l.debug("WorkerTimers::terminateMiddlewareWebWorker::failed");
        }
    }
    getTransformedVideoTrack(t, e, r) {
      return u(this, null, function* () {
        if (!(t != null && t.length))
          return e;
        const n = document.createElement("canvas"), i = yield Promise.all(
          t == null ? undefined : t.map((m) => m({
            canvas: n,
            WorkerTimers: hd
          }))
        );
        if (r.disablePerFrameCanvasRendering)
          return n.captureStream().getVideoTracks()[0];
        const a = document.createElement("video"), c = new MediaStream();
        c.addTrack(e);
        const d = n.getContext("2d");
        a.srcObject = c, a.autoplay = true, this.terminateMiddlewareWebWorker();
        const p = () => u(this, null, function* () {
          if (e.enabled === false || e.readyState === "ended") {
            this.terminateMiddlewareWebWorker(), a.remove(), n.remove();
            return;
          }
          try {
            d.drawImage(a, 0, 0);
            for (let m = 0; m < i.length; m += 1)
              typeof i[m] == "function" && (yield i[m](
                n,
                d
              ));
          } catch (m) {
            l.error(
              "getTransformedVideoTrack::middleware_execution_failed",
              { error: m }
            );
          }
        });
        try {
          a.play();
        } catch (m) {
        }
        return a.addEventListener(
          "play",
          () => {
            n.width = a.width || e.getSettings().width, n.height = a.width || e.getSettings().height, _(this, rn, setInterval$1(
              p,
              50
            ));
          },
          false
        ), n.captureStream().getVideoTracks()[0];
      });
    }
  }
  rn = new WeakMap();
  const nh = {
    gross: { width: { ideal: 192 }, height: { ideal: 144 } },
    qvga: { width: { ideal: 384 }, height: { ideal: 288 } },
    pvga: { width: { ideal: 480 }, height: { ideal: 360 } },
    vga: { width: { ideal: 640 }, height: { ideal: 480 } },
    hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
    hd_cropped: { width: { ideal: 900 }, height: { ideal: 720 } },
    fhd: { width: { ideal: 1920 }, height: { ideal: 1080 } }
  }, ih = {
    320: [
      // For QVGA, we can only send the lowest layer.
      {
        rid: "q",
        maxBitrate: 25e4,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      }
    ],
    640: [
      // For VGA, we can send the lowest and middle layer.
      {
        rid: "q",
        scaleResolutionDownBy: 2,
        maxBitrate: 25e4,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      },
      {
        rid: "h",
        maxBitrate: 7e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ],
    1280: [
      // For HD, we can send all the layers but it takes too much bandwidth, so
      // we are sending only the half and quarter layers for now
      {
        rid: "q",
        scaleResolutionDownBy: 2,
        maxBitrate: 5e5,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      },
      {
        rid: "h",
        maxBitrate: 13e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ]
  }, gD = {
    320: [
      // For QVGA, we can only send the lowest layer.
      {
        rid: "q",
        maxBitrate: 25e4,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      }
    ],
    640: [
      {
        rid: "h",
        maxBitrate: 7e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ],
    1280: [
      {
        rid: "h",
        maxBitrate: 14e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ]
  }, ah = {
    320: [
      // For QVGA, we can only send the lowest layer.
      {
        rid: "q",
        maxBitrate: 25e4,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      }
    ],
    640: [
      // For VGA, we can send the lowest and middle layer.
      {
        rid: "q",
        scaleResolutionDownBy: 2,
        maxBitrate: 25e4,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      },
      {
        rid: "h",
        maxBitrate: 7e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ],
    1280: [
      // For HD, we can send all the layers but it takes too much bandwidth, so
      // we are sending only the half and quarter layers for now
      {
        rid: "q",
        scaleResolutionDownBy: 2,
        maxBitrate: 5e5,
        maxFramerate: 24,
        scalabilityMode: "L1T1"
      },
      {
        rid: "h",
        maxBitrate: 13e5,
        maxFramerate: 30,
        scalabilityMode: "L1T1"
      }
    ]
  };
  var X = /* @__PURE__ */ ((s) => (s.WEBCAM = "webcam", s.MIC = "mic", s.SCREENSHARE_VIDEO = "screenshare_video", s.SCREENSHARE_AUDIO = "screenshare_audio", s))(X || {});
  const vD = xE(), Nn = sr(
    vD.config.media
  );
  function yD(s) {
    var e, r;
    const t = {};
    return s.audio && (t.audio = {
      enableStereo: (e = s.audio.enableStereo) != null ? e : false,
      enableHighBitrate: (r = s.audio.enableHighBitrate) != null ? r : false
    }), t.video = s.video.quality, t;
  }
  var sn, bc;
  class TD {
    constructor(t, e) {
      E(this, sn, undefined);
      E(this, bc, undefined);
      // eslint-disable-next-line class-methods-use-this
      f(this, "getScreenShareConstraints", () => {
        var p, h, m, g, T, y, b, A, I;
        const t = (p = o(this, sn)) == null ? undefined : p.screenshare, e = (m = (h = t == null ? undefined : t.width) == null ? undefined : h.max) != null ? m : 1920, r = (T = (g = t == null ? undefined : t.height) == null ? undefined : g.max) != null ? T : 1080, n = (b = (y = t == null ? undefined : t.frameRate) == null ? undefined : y.max) != null ? b : 5;
        let i = (I = (A = t == null ? undefined : t.frameRate) == null ? undefined : A.ideal) != null ? I : 5;
        const a = t == null ? undefined : t.displaySurface, c = t == null ? undefined : t.selfBrowserSurface;
        K.getValue(ie.VAL_MIN_FRAMERATE) && (i = parseInt(K.getValue(ie.VAL_MIN_FRAMERATE), 10));
        let d = {
          width: { max: e },
          height: { max: r },
          frameRate: {
            ideal: i,
            max: n
          }
        };
        if (K.hasFeature(ie.SCREENSHARE_CONSTRAINTS)) {
          const $ = K.getValue(
            ie.SCREENSHARE_CONSTRAINTS
          );
          d = JSON.parse($);
        }
        return a !== undefined && ["monitor", "browser", "window"].includes(a) && (d = z(L({}, d), { displaySurface: a })), c !== undefined && (d = z(L({}, d), { selfBrowserSurface: c })), {
          audio: true,
          video: d
        };
      });
      // eslint-disable-next-line class-methods-use-this
      f(this, "getAudioConstraints", (t) => {
        var i, a, c, d, p, h, m, g;
        const e = {}, r = (i = o(this, sn)) == null ? undefined : i.audio, n = r != null && r.enableStereo ? 2 : 1;
        return ve.isFirefox() || ve.isWebKitBased() ? (e.audio = {
          deviceId: t,
          autoGainControl: (a = r == null ? undefined : r.autoGainControl) != null ? a : true,
          echoCancellation: (c = r == null ? undefined : r.echoCancellation) != null ? c : true,
          noiseSuppression: (d = r == null ? undefined : r.noiseSupression) != null ? d : true,
          channelCount: n
        }, e) : (e.audio = {}, e.audio.optional = [
          t ? { sourceId: t } : { sourceId: "default" },
          { channelCount: n },
          { echoCancellation: (p = r == null ? undefined : r.echoCancellation) != null ? p : true },
          { googEchoCancellation: (h = r == null ? undefined : r.echoCancellation) != null ? h : true },
          { googAutoGainControl: (m = r == null ? undefined : r.autoGainControl) != null ? m : true },
          { googNoiseSuppression: (g = r == null ? undefined : r.noiseSupression) != null ? g : true },
          { googHighpassFilter: true }
        ], e);
      });
      f(this, "getVideoConstraints", (t) => {
        var i, a, c;
        const e = {}, r = (i = o(this, sn)) == null ? undefined : i.video;
        let n = nh.vga;
        if (typeof r == "string" ? n = nh[r] : r !== undefined && (n.height.ideal = r.height.ideal, n.width.ideal = r.width.ideal), n.frameRate = {
          ideal: (c = (a = n.frameRate) == null ? undefined : a.ideal) != null ? c : 24
        }, ve.isChromiumBased() && (n.frameRate.max = 30), K.hasFeature(ie.VIDEO_CONSTRAINTS)) {
          const d = K.getValue(
            ie.VIDEO_CONSTRAINTS
          );
          n = JSON.parse(d);
        }
        return e.video = n, typeof e.video == "boolean" || (t ? e.video.deviceId = { exact: t } : e.video.facingMode = "user"), e;
      });
      _(this, bc, t), _(this, sn, e);
    }
    // eslint-disable-next-line class-methods-use-this
    getUpdatedVideoConstraints(t) {
      return t;
    }
  }
  sn = new WeakMap(), bc = new WeakMap();
  class qd extends Error {
    constructor(e, r, n) {
      super(r);
      f(this, "constraints");
      f(this, "name");
      this.name = e, this.constraints = n;
    }
  }
  class _D {
    constructor() {
      f(this, "permissions");
      this.permissions = {
        audio: "NOT_REQUESTED",
        video: "NOT_REQUESTED",
        screenshare: "NOT_REQUESTED"
      };
    }
    getAudioInputDevices(t) {
      return u(this, null, function* () {
        let e = t;
        return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audioinput");
      });
    }
    getVideoInputDevices(t) {
      return u(this, null, function* () {
        let e = t;
        return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "videoinput");
      });
    }
    getAudioOutputDevices(t) {
      return u(this, null, function* () {
        let e = t;
        return t || (e = yield this.getAvailableDevices()), e.filter((r) => r.kind === "audiooutput");
      });
    }
  }
  var SD = Object.defineProperty, ED = Object.getOwnPropertyDescriptor, cr = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? ED(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && SD(t, e, n), n;
  }, pi, pr, kc, Ah;
  let Ut = (Ah = class extends _D {
    constructor(t, e) {
      super();
      /**
      	 * Only used for recognising device change
      	 */
      f(this, "availableDevices");
      E(this, pi, undefined);
      E(this, pr, undefined);
      E(this, kc, undefined);
      _(this, kc, t), _(this, pr, new TD(t, e)), _(this, pi, new AbortController()), this.availableDevices = [], this.getAvailableDevices();
    }
    get constraintsBuilder() {
      return o(this, pr);
    }
    destruct() {
      return u(this, null, function* () {
        var t;
        (t = o(this, pi)) == null || t.abort();
      });
    }
    handlePermissionErrors(t, e) {
      const r = Mo(t, e.name, e.message);
      return this.permissions[t] = r, R.emit(P.MEDIA_PERMISSION_ERROR, {
        message: r,
        constraints: e.constraints,
        kind: t
      }), r;
    }
    getAudioAndVideoTrack() {
      return u(this, null, function* () {
        const t = {
          audio: o(this, pr).getAudioConstraints().audio,
          video: o(this, pr).getVideoConstraints().video
        };
        try {
          l.info("getUserMediaWithoutTimeout::requesting_user_media", {
            constraints: JSON.stringify(t)
          });
          const e = yield navigator.mediaDevices.getUserMedia(
            t
          );
          l.info("getUserMediaWithoutTimeout::received_user_media", {
            constraints: JSON.stringify(t)
          });
          const r = e.getAudioTracks()[0];
          let n = e.getVideoTracks()[0];
          if (this.permissions.audio = "ACCEPTED", this.permissions.video = "ACCEPTED", K.hasFeature(ie.OBS_QUALITY) && n.label.includes("OBS Virtual")) {
            const c = (yield this.getVideoInputDevices()).find((d) => d.label.includes("OBS Virtual"));
            n = yield this.getVideoTrack(c.deviceId);
          }
          return R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.audio,
            kind: "audio"
          }), R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.video,
            kind: "video"
          }), { audioTrack: r, videoTrack: n };
        } catch (e) {
          throw l.error("WebMediaInterface.getAudioAndVideoTrack", { error: e }), new w("Couldnt fetch audio and video track");
        }
      });
    }
    getAudioTrack(t, e) {
      return u(this, null, function* () {
        let r = yield this.getAudioInputDevices();
        if (r.length === 0)
          throw this.permissions.audio = "NO_DEVICES_AVAILABLE", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.audio,
            kind: "audio"
          }), new w("No audio devices available");
        const n = (i) => u(this, null, function* () {
          let a;
          try {
            r = r.filter((d) => d.deviceId !== i), a = o(this, pr).getAudioConstraints(i), l.info("getUserMediaWithoutTimeout::requesting_user_media", {
              constraints: JSON.stringify(a)
            });
            const [c] = (yield navigator.mediaDevices.getUserMedia(a)).getAudioTracks();
            return l.info("getUserMediaWithoutTimeout::received_user_media", {
              constraints: JSON.stringify(a)
            }), c;
          } catch (c) {
            const d = Mo(
              "audio",
              c.name,
              c.message
            ), p = new qd(c.name, c.message, a);
            if (d === "COULD_NOT_START") {
              const h = r.shift();
              if (!h)
                throw p;
              return n(h.deviceId);
            }
            throw p;
          }
        });
        try {
          const i = yield n(e);
          return i.enabled = !t, this.permissions.audio !== "ACCEPTED" && (this.permissions.audio = "ACCEPTED", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.audio,
            kind: "audio"
          })), i;
        } catch (i) {
          throw i.constraints && this.handlePermissionErrors("audio", i), new w(i.message, "1601");
        }
      });
    }
    getVideoTrack(t) {
      return u(this, null, function* () {
        var c;
        const e = K.hasFeature(ie.OBS_QUALITY), r = (c = yield this.getCurrentDeviceLabel(t)) == null ? undefined : c.includes("OBS Virtual"), n = e && r, i = yield this.getVideoInputDevices();
        if (i.length === 0)
          throw this.permissions.video = "NO_DEVICES_AVAILABLE", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.video,
            kind: "video"
          }), new w("No video devices available");
        const a = (d) => u(this, null, function* () {
          try {
            let p = d;
            const { video: h } = p;
            n && typeof h != "boolean" && (p = {
              video: { deviceId: h.deviceId }
            }), l.info("getUserMediaWithoutTimeout::requesting_user_media", {
              constraints: JSON.stringify(p)
            });
            const [m] = (yield navigator.mediaDevices.getUserMedia(p)).getVideoTracks();
            if (n && typeof h != "boolean" && typeof h.width == "object") {
              const { width: g, height: T } = m.getSettings(), { ideal: y } = h.width;
              m.applyConstraints({
                width: { ideal: y },
                height: { ideal: Math.floor(T * y / g) },
                frameRate: h.frameRate
              });
            }
            return l.info("getUserMediaWithoutTimeout::received_user_media", {
              constraints: JSON.stringify(p)
            }), m;
          } catch (p) {
            const h = Mo(
              "video",
              p.name,
              p.message
            ), m = new qd(p.name, p.message, d);
            if (h === "COULD_NOT_START") {
              if (!i.shift())
                throw m;
              return a({ video: d.video });
            }
            throw m;
          }
        });
        try {
          const d = o(this, pr).getVideoConstraints(t), p = yield a(d);
          return this.permissions.video !== "ACCEPTED" && (this.permissions.video = "ACCEPTED", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.video,
            kind: "video"
          })), p;
        } catch (d) {
          throw d.constraints && this.handlePermissionErrors("video", d), new w(d.message, "1601");
        }
      });
    }
    getScreenShareTracks() {
      return u(this, null, function* () {
        const t = (e) => u(this, null, function* () {
          try {
            l.info("getDisplayMediaWithoutTimeout::requesting_display_media", {
              constraints: JSON.stringify(e)
            }), U.screenShareRequested();
            const r = yield navigator.mediaDevices.getDisplayMedia(
              e
            );
            return l.info("getDisplayMediaWithoutTimeout::received_display_media", {
              constraints: JSON.stringify(e)
            }), r;
          } catch (r) {
            const n = Mo(
              "video",
              r.name,
              r.message
            ), i = new qd(r.name, r.message, e), a = { video: true };
            if (sw(e, a) || !K.hasFeature(ie.SCREEENSHARE_CONSTRAINTS_RETRY))
              throw i;
            if (n === "COULD_NOT_START")
              return t(a);
            throw i;
          }
        });
        try {
          const e = o(this, pr).getScreenShareConstraints(), r = yield t(e);
          return this.permissions.screenshare !== "ACCEPTED" && (this.permissions.screenshare = "ACCEPTED", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.permissions.screenshare,
            kind: "screenshare"
          })), {
            audioTrack: r.getAudioTracks()[0],
            videoTrack: r.getVideoTracks()[0]
          };
        } catch (e) {
          throw e.constraints && this.handlePermissionErrors("screenshare", e), new w(e.message, "1601");
        }
      });
    }
    getCurrentDeviceLabel(t) {
      return u(this, null, function* () {
        const e = yield this.getDevice(t || "default");
        return e == null ? undefined : e.label;
      });
    }
    getAvailableDevices() {
      return u(this, null, function* () {
        try {
          const t = yield navigator.mediaDevices.enumerateDevices();
          return this.availableDevices = t, t;
        } catch (t) {
          throw l.error("enumerate_devices_failed", {
            error: t
          }), new w("Failed to get available devices");
        }
      });
    }
    getAvailableDevicesByKind(t) {
      return u(this, null, function* () {
        try {
          return (yield navigator.mediaDevices.enumerateDevices()).filter(
            ({ kind: e }) => t === e
          );
        } catch (e) {
          throw l.error("enumerate_devices_failed", {
            error: e
          }), new w("Failed to get available devices by kind");
        }
      });
    }
    getDevice(t) {
      return u(this, null, function* () {
        try {
          return (yield navigator.mediaDevices.enumerateDevices()).filter((r) => r.deviceId === t)[0];
        } catch (e) {
          throw l.error("enumerate_devices_failed", {
            error: e
          }), new w("Failed to get device");
        }
      });
    }
    onDeviceChange(t) {
      return u(this, null, function* () {
        ve.supportsDeviceChangeEvent() && navigator.mediaDevices.addEventListener(
          "devicechange",
          (e) => u(this, null, function* () {
            var p, h;
            const r = (m) => `${m.kind}-${m.deviceId}`, n = this.availableDevices, i = new Set(
              n.map((m) => r(m))
            ), a = yield this.getAvailableDevices(), c = new Set(
              a.map((m) => r(m))
            ), d = {
              added: a.filter(
                (m) => !i.has(r(m))
              ),
              removed: n.filter(
                (m) => !c.has(r(m))
              ),
              devices: a
            };
            if ((p = d.added) != null && p.length || (h = d.removed) != null && h.length) {
              l.info("repopulated_full_device_list", {
                devices: JSON.stringify(a)
              });
              const m = [...d.added, ...d.removed];
              U.onSafeInitialization(() => u(this, null, function* () {
                m.some((g) => g.kind === "audioinput") && U.devices("AUDIO", a == null ? undefined : a.filter((g) => g.kind === "audioinput")), m.some((g) => g.kind === "videoinput") && U.devices("VIDEO", a == null ? undefined : a.filter((g) => g.kind === "videoinput")), m.some((g) => g.kind === "audiooutput") && U.devices("SPEAKER", a == null ? undefined : a.filter((g) => g.kind === "audiooutput"));
              })), t(e, d, false);
            }
          }),
          { signal: o(this, pi).signal }
        );
      });
    }
  }, pi = new WeakMap(), pr = new WeakMap(), kc = new WeakMap(), Ah);
  cr([
    v.trace("WebMediaInterface.destruct")
  ], Ut.prototype, "destruct", 1);
  cr([
    v.trace("WebMediaInterface.handlePermissionErrors")
  ], Ut.prototype, "handlePermissionErrors", 1);
  cr([
    v.trace("WebMediaInterface.getAudioAndVideoTrack")
  ], Ut.prototype, "getAudioAndVideoTrack", 1);
  cr([
    v.trace("WebMediaInterface.getAudioTrack")
  ], Ut.prototype, "getAudioTrack", 1);
  cr([
    v.trace("WebMediaInterface.getVideoTrack")
  ], Ut.prototype, "getVideoTrack", 1);
  cr([
    v.trace("WebMediaInterface.getScreenShareTracks")
  ], Ut.prototype, "getScreenShareTracks", 1);
  cr([
    v.trace("WebMediaInterface.getAvailableDevices")
  ], Ut.prototype, "getAvailableDevices", 1);
  cr([
    v.trace("WebMediaInterface.getAvailableDevicesByKind")
  ], Ut.prototype, "getAvailableDevicesByKind", 1);
  cr([
    v.trace("WebMediaInterface.getDevice")
  ], Ut.prototype, "getDevice", 1);
  cr([
    v.trace("WebMediaInterface.onDeviceChange")
  ], Ut.prototype, "onDeviceChange", 1);
  Ut = cr([
    vt("1600")
  ], Ut);
  const dg = Ut, jd = {
    setItem: (s, t) => {
      try {
        localStorage.setItem(s, t);
      } catch (e) {
        l.error("LocalStorage::setItem::crashed", {
          error: e,
          localStorage: { key: s, value: t }
        });
      }
    },
    getItem: (s) => {
      try {
        return localStorage.getItem(s);
      } catch (t) {
        l.error("LocalStorage::getItem::crashed", {
          error: t,
          localStorage: { key: s }
        });
      }
      return null;
    }
  }, CD = (s = 0) => new Promise((t) => setTimeout(t, s)), wD = (s, t, e) => {
    const r = e , n = s.createMediaStreamSource(t), i = s.createAnalyser();
    i.fftSize = 2048, n.connect(i);
    const a = new Uint8Array(i.fftSize);
    let c = false;
    setTimeout(() => {
      c = true;
    }, r);
    function d() {
      return c ? Promise.resolve(true) : (i.getByteTimeDomainData(a), a.some((p) => p !== 128 && p !== 0) ? Promise.resolve(false) : CD().then(d));
    }
    return d().then(
      (p) => (n.disconnect(), p),
      (p) => {
        throw n.disconnect(), p;
      }
    );
  }, PD = typeof AudioContext != "undefined" ? AudioContext : null;
  class au {
    constructor(t) {
      f(this, "_AudioContext");
      f(this, "audioContext");
      f(this, "_audioContextRefContainers");
      const e = L({ AudioContext: PD }, t);
      Object.defineProperties(this, {
        _AudioContext: {
          value: e.AudioContext
        },
        audioContext: {
          value: null,
          writable: true
        },
        _audioContextRefContainers: {
          value: /* @__PURE__ */ new Set()
        },
        AudioContextProvider: {
          enumerable: true,
          value: au
        }
      });
    }
    getOrCreate(t) {
      if (!this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.add(t), this._AudioContext && !this.audioContext))
        try {
          this.audioContext = new this._AudioContext();
        } catch (e) {
        }
      return this.audioContext;
    }
    release(t) {
      this._audioContextRefContainers.has(t) && (this._audioContextRefContainers.delete(t), !this._audioContextRefContainers.size && this.audioContext && (this.audioContext.close(), this.audioContext = null));
    }
  }
  const oh = new au(), RD = 3, bD = 250;
  function kD(s) {
    const t = {}, e = oh.getOrCreate(
      t
    );
    let r = RD;
    function n() {
      return r -= 1, wD(e, s.srcObject, bD).then((i) => i ? r > 0 ? n() : true : false).catch(() => true);
    }
    return n().finally(() => {
      oh.release(t);
    });
  }
  function ch(s) {
    return u(this, null, function* () {
      const t = new Audio(), e = new MediaStream();
      e.addTrack(s), t.srcObject = e;
      let r = false;
      try {
        const n = t.play();
        n && (yield n), r = yield kD(t), r && l.info("checkIfAudioTrackIsSilent::silence_detected");
      } catch (n) {
        l.error("checkIfAudioTrackIsSilent::failed_to_detect_silence", {
          error: n
        });
      } finally {
        t.pause(), t.remove();
      }
      return r;
    });
  }
  var DD = (s, t, e, r) => {
    for (var n = t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(n)) || n);
    return n;
  };
  let Sl = class extends $i {
    /**
     * Allows creation of an instance of BaseMediaHandler with a track.
     * We initialize it with a track when we want to enable streams on init.
     * @param mediaInterface
     * @param mediaTrack
     */
    constructor(t, e, r) {
      super();
      f(this, "constructorName", this.constructor.name);
      // Will be set in case user has explicity used Self.setDevice
      // to set the device.
      f(this, "userSelectedDevice");
      f(this, "mediaInterface");
      f(this, "isNonPreferredDevice");
      f(this, "_mediaTrack");
      f(this, "transformedMediaTrack");
      f(this, "middlewares", []);
      f(this, "currentDevice");
      this.mediaInterface = t, e && this.setMediaTrack(e), this.userSelectedDevice = undefined, this.isNonPreferredDevice = r, this.onTrackEnded = this.onTrackEnded.bind(this), this.onTrackMuted = this.onTrackMuted.bind(this);
    }
    /**
     * NOTE(roerohan): DO NOT use this.#mediaTrack anywhere else,
     * except for these 3 functions below.
     */
    /**
     * Cleans up all acquired tracks.
     */
    disableTrack() {
      var t, e;
      this.removeMediaTrackListeners(), (t = this._mediaTrack) == null || t.stop(), this._mediaTrack = undefined, (e = this.transformedMediaTrack) == null || e.stop(), this.transformedMediaTrack = undefined;
    }
    get mediaTrack() {
      return this._mediaTrack;
    }
    setMediaTrack(t) {
      return u(this, null, function* () {
        const e = (r) => {
          l.error(`${this.constructorName}.setMediaTrack.error`, {
            error: r
          });
        };
        try {
          this.disableTrack();
        } catch (r) {
          e(r);
        }
        this._mediaTrack = yield this.conditionallyChangeTrack(t), yield this.setTransformedTrack();
        try {
          this.addMediaTrackListeners(), yield this.setCurrentDevice();
        } catch (r) {
          e(r);
        }
      });
    }
    /**
     * Represents current audio/video state according to track status
     */
    get trackEnabled() {
      return !!this.mediaTrack && this.mediaTrack.readyState === "live" && this.mediaTrack.enabled;
    }
    /**
     * Mutes track if it's present, DOES NOT STOP IT!
     * Only used for audio streams
     */
    muteTrack() {
      if (!this.mediaTrack) {
        l.warn(
          "BaseMediaHandler.muteTrack Tried muting with no track present"
        );
        return;
      }
      this.transformedMediaTrack && (this.transformedMediaTrack.enabled = false), this.mediaTrack.enabled = false;
    }
    /**
     * If track is present and not enabled, we enable it.
     * If no track is present we set one up.
     */
    unmuteTrack() {
      return u(this, null, function* () {
        try {
          this.mediaTrack ? this.mediaTrack.enabled = !0 : yield this.enableTrack(!1);
        } catch (t) {
          throw l.error(`${this.constructorName}.unmuteTrack.error`, {
            error: t
          }), this.disableTrack(), new w("Failed to unmute track");
        }
      });
    }
    /**
     * Called after every track switch, maintains local state of current
     * selected device for this particular stream.
     */
    setCurrentDevice() {
      return u(this, null, function* () {
        var t;
        if (!this.mediaTrack) {
          this.currentDevice = undefined;
          return;
        }
        ((t = this.currentDevice) == null ? undefined : t.deviceId) !== this.mediaTrack.getSettings().deviceId && (this.currentDevice = yield this.mediaInterface.getDevice(
          this.mediaTrack.getSettings().deviceId
        ));
      });
    }
    /**
     * Middleware Utility
     */
    addMiddleware(t) {
      return u(this, null, function* () {
        if (ve.isWebKitBased() && !K.hasFeature(ie.ALLOW_SAFARI_MEDIA_MIDDLEWARES))
          return {
            success: false,
            message: "Middlewares are not supported in this WebKit engine based browser."
          };
        if (this.middlewares.includes(t))
          return {
            success: false,
            message: "This middleware has been applied, already. Skipping."
          };
        try {
          return this.middlewares.push(t), this.trackEnabled && (yield this.setTransformedTrack()), { success: !0, message: "Successfully added the middleware." };
        } catch (e) {
          return l.error("While adding middleware", { error: e }), this.removeMiddleware(t), { success: false, message: e == null ? undefined : e.message };
        }
      });
    }
    removeMiddleware(t) {
      return u(this, null, function* () {
        const e = this.middlewares.indexOf(t, 0);
        if (e > -1)
          try {
            return this.middlewares.splice(e, 1), yield this.setTransformedTrack(!0), {
              success: !0,
              message: "Successfully removed the middleware."
            };
          } catch (r) {
            return l.error("While removing middleware", { error: r }), { success: false, message: r == null ? undefined : r.message };
          }
        return {
          success: false,
          message: "No such middleware was found. Skipping."
        };
      });
    }
    addMediaTrackListeners() {
      var t, e, r;
      this.mediaTrack && (l.info(
        `${this.constructorName}.addMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? undefined : t.getSettings()) == null ? undefined : e.deviceId} of type ${(r = this.mediaTrack) == null ? undefined : r.kind}`
      ), this.mediaTrack.addEventListener("ended", this.onTrackEnded), this.mediaTrack.addEventListener("mute", this.onTrackMuted));
    }
    removeMediaTrackListeners() {
      var t, e, r;
      this.mediaTrack && (l.info(
        `${this.constructorName}.removeMediaTrackListeners for deviceId ${(e = (t = this.mediaTrack) == null ? undefined : t.getSettings()) == null ? undefined : e.deviceId} of type ${(r = this.mediaTrack) == null ? undefined : r.kind}`
      ), l.info(`${this.constructorName}.removeMediaTrackListeners`), this.mediaTrack.removeEventListener("ended", this.onTrackEnded), this.mediaTrack.removeEventListener("mute", this.onTrackMuted));
    }
  };
  Sl = DD([
    vt("1600")
  ], Sl);
  const lg$1 = Sl;
  var MD = Object.defineProperty, OD = Object.getOwnPropertyDescriptor, ou = (s, t, e, r) => {
    for (var n = OD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && MD(t, e, n), n;
  };
  const Gd = "[Dyte]nonSilentDeviceLabels";
  class ed extends lg$1 {
    setDevice(t) {
      return u(this, null, function* () {
        if (!t)
          throw l.warn("AudioMediaHandler.setDevice No device received"), new w("No device received!", "1603");
        if (t.kind !== "audioinput")
          throw l.warn("AudioMediaHandler.setDevice Received non audio device"), new w(
            "Non audio device received while setting device!",
            "1603"
          );
        try {
          const e = this.trackEnabled;
          this.userSelectedDevice = t.deviceId, yield this.setMediaTrack(
            yield this.mediaInterface.getAudioTrack(
              !e,
              t.deviceId
            )
          );
        } catch (e) {
          throw l.error("AudioMediaHandler.setDevice.error", {
            error: e
          }), this.disableTrack(), new w(e.message, "1604");
        }
      });
    }
    enableTrack(t) {
      return u(this, null, function* () {
        if (this.trackEnabled) {
          l.warn("AudioMediaHandler.enableTrack Track already enabled!");
          return;
        }
        const e = yield this.mediaInterface.getAudioTrack(
          t,
          this.userSelectedDevice
        );
        yield this.setMediaTrack(e);
      });
    }
    setTransformedTrack(t) {
      return u(this, null, function* () {
        var e;
        if (!t && !((e = this.middlewares) != null && e.length)) {
          this.transformedMediaTrack = this.mediaTrack;
          return;
        }
        try {
          this.transformedMediaTrack = yield mD(
            this.middlewares,
            this.mediaTrack
          ), this.emit("trackChanged");
        } catch (r) {
          l.error("AudioMediaHandler.setTransformedTrack", {
            error: r
          }), this.transformedMediaTrack = this.mediaTrack;
        }
      });
    }
    onTrackEnded() {
      return u(this, null, function* () {
        l.info("AudioMediaHandler.TrackEnded"), this.emit("trackEnded");
        const t = this.mediaTrack.enabled;
        this.disableTrack(), yield this.enableTrack(!t), yield this.setTransformedTrack(), this.emit("trackChanged");
      });
    }
    onTrackMuted() {
      l.info("AudioMediaHandler.TrackMuted"), this.emit("trackMuted");
    }
    conditionallyChangeTrack(t) {
      return u(this, null, function* () {
        var c;
        if (!t || this.userSelectedDevice)
          return t;
        let e = t;
        const r = yield this.mediaInterface.getAudioInputDevices(), n = this.isNonPreferredDevice ? r.filter((d) => d && !this.isNonPreferredDevice(d)) : r;
        if (!(n != null && n.length))
          return e;
        n.find(
          (d) => d.deviceId === t.getSettings().deviceId
        ) || (e.stop(), l.info("localmediahandler::setupstreams::found_audio_non_preferred"), e = yield this.mediaInterface.getAudioTrack(
          false,
          n[0].deviceId
        ));
        const i = JSON.parse(
          jd.getItem(Gd)
        );
        if (i != null && i.devices.some(
          (d) => d.label === e.label
        ))
          return e;
        if (!(yield ch(e))) {
          const d = (c = i == null ? undefined : i.devices.concat({
            label: e.label
          })) != null ? c : [{ label: e.label }];
          return jd.setItem(Gd, JSON.stringify({
            devices: d
          })), e;
        }
        l.info("AudioMediaHandler.conditionallyChangeTrack.DetectedSilentTrack");
        const a = e.getSettings().deviceId;
        return n.filter((d) => d.deviceId !== a).some((d) => u(this, null, function* () {
          if (e = yield this.mediaInterface.getAudioTrack(
            false,
            d.deviceId
          ), !(yield ch(e))) {
            const p = i.devices.concat({
              label: e.label
            });
            return jd.setItem(Gd, JSON.stringify({
              devices: p
            })), l.info("AudioMediaHandler.conditionallyChangeTrack.SuccesfullyChangedTrack"), true;
          }
          return l.info("AudioMediaHandler.conditionallyChangeTrack.AnotherSilentTrackFound"), false;
        })), e;
      });
    }
  }
  ou([
    v.trace("AudioMediaHandler.setTransformedTrack")
  ], ed.prototype, "setTransformedTrack");
  ou([
    v.trace("AudioMediaHandler.onTrackEnded")
  ], ed.prototype, "onTrackEnded");
  ou([
    v.trace("AudioMediaHandler.conditionallyChangeTrack")
  ], ed.prototype, "conditionallyChangeTrack");
  const ND = ed;
  var hi;
  class LD {
    constructor(t) {
      E(this, hi, undefined);
      f(this, "currentDevice");
      _(this, hi, t);
    }
    setupSpeaker(t) {
      return u(this, null, function* () {
        var r;
        if (!(o(this, hi) instanceof dg))
          return;
        let e = t;
        if (t || ([e] = (yield o(this, hi).getAvailableDevicesByKind(
          "audiooutput"
        )).filter((i) => !_l(i))), !e)
          throw new w("No speaker found");
        ((r = this.currentDevice) == null ? undefined : r.deviceId) !== e.deviceId && (this.currentDevice = e, document.querySelectorAll("audio").forEach((n) => u(this, null, function* () {
          if (typeof n.sinkId != "undefined" && this.currentDevice.deviceId && n.sinkId !== this.currentDevice.deviceId)
            try {
              yield n.setSinkId(this.currentDevice.deviceId);
            } catch (i) {
            }
        })));
      });
    }
  }
  hi = new WeakMap();
  const xD = LD;
  class $D extends $i {
    constructor(e) {
      super();
      f(this, "mediaInterface");
      f(this, "audioMediaTrack");
      f(this, "videoMediaTrack");
      this.mediaInterface = e;
    }
    get trackEnabled() {
      return !!this.videoMediaTrack;
    }
    enableScreenShare() {
      return u(this, null, function* () {
        var e, r;
        try {
          const { audioTrack: n, videoTrack: i } = yield this.mediaInterface.getScreenShareTracks();
          if (this.audioMediaTrack = n, this.videoMediaTrack = i, this.addMediaTrackListeners(), ((r = (e = this.mediaInterface) == null ? void 0 : e.permissions) == null ? void 0 : r.screenshare) === "ACCEPTED")
            return;
          this.mediaInterface.permissions && (this.mediaInterface.permissions.screenshare = "ACCEPTED", R.emit(P.MEDIA_PERMISSION_UPDATE, {
            message: this.mediaInterface.permissions.screenshare,
            kind: "screenshare"
          }));
        } catch (n) {
        }
      });
    }
    disableScreenShare() {
      var e, r;
      this.removeMediaTrackListeners(), (e = this.audioMediaTrack) == null || e.stop(), (r = this.videoMediaTrack) == null || r.stop(), this.videoMediaTrack = undefined, this.audioMediaTrack = undefined;
    }
    updateConstraints(e) {
      return u(this, null, function* () {
        if (!this.videoMediaTrack)
          throw new w("No media track enabled!");
        const r = this.mediaInterface;
        if (!r.constraintsBuilder)
          throw new w("update constraints not supported for non web clients", "1100");
        try {
          this.videoMediaTrack.applyConstraints(
            r.constraintsBuilder.getUpdatedVideoConstraints(e)
          ), this.addMediaTrackListeners();
        } catch (n) {
          l.error("ScreenShareHandler.updateConstraints.error", {
            error: n
          });
        }
      });
    }
    addMediaTrackListeners() {
      var e, r;
      (e = this.videoMediaTrack) == null || e.addEventListener(
        "ended",
        this.onTrackEnded.bind(this)
      ), ve.isWebKitBased() && ((r = this.videoMediaTrack) == null || r.addEventListener(
        "mute",
        this.onTrackEnded.bind(this)
      ));
    }
    removeMediaTrackListeners() {
      var e, r;
      (e = this.videoMediaTrack) == null || e.removeEventListener("ended", this.onTrackEnded), (r = this.videoMediaTrack) == null || r.removeEventListener("mute", this.onTrackEnded);
    }
    onTrackEnded() {
      this.emit("trackEnded");
    }
  }
  const UD = $D;
  var FD = Object.defineProperty, VD = Object.getOwnPropertyDescriptor, td = (s, t, e, r) => {
    for (var n = VD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && FD(t, e, n), n;
  }, mi, Na;
  class _o extends lg$1 {
    constructor(e, r, n) {
      super(e, r, n);
      E(this, mi, undefined);
      E(this, Na, {
        disablePerFrameCanvasRendering: false
      });
      _(this, mi, new fD());
    }
    setDevice(e) {
      return u(this, null, function* () {
        if (!e)
          throw l.warn("VideoMediaHandler.setDevice No device received"), new w("No device received!");
        if (e.kind !== "videoinput")
          throw l.warn("VideoMediaHandler.setDevice Received non video device", {
            devices: [e]
          }), new w(
            "Non video device received while setting video device!"
          );
        if (this.userSelectedDevice = e.deviceId, !(this.mediaTrack && this.mediaTrack.enabled)) {
          l.warn(
            "VideoMediaHandler.setDevice Tried switching device with video disabled",
            {
              devices: [e]
            }
          ), this.currentDevice = e;
          return;
        }
        try {
          yield this.setMediaTrack(
            yield this.mediaInterface.getVideoTrack(this.userSelectedDevice)
          );
        } catch (r) {
          throw l.error("VideoMediaHandler.setDevice.error", {
            error: r
          }), this.disableTrack(), new w("Failed to change device");
        }
      });
    }
    enableTrack() {
      return u(this, null, function* () {
        if (this.trackEnabled) {
          l.warn("VideoMediaHandler.enableTrack Track already enabled!");
          return;
        }
        yield this.setMediaTrack(
          yield this.mediaInterface.getVideoTrack(this.userSelectedDevice)
        );
      });
    }
    setTransformedTrack(e) {
      return u(this, null, function* () {
        var r;
        if (!e && !((r = this.middlewares) != null && r.length)) {
          this.transformedMediaTrack = this.mediaTrack;
          return;
        }
        try {
          this.transformedMediaTrack = yield o(this, mi).getTransformedVideoTrack(
            this.middlewares,
            this.mediaTrack,
            o(this, Na)
          ), this.emit("trackChanged");
        } catch (n) {
          l.error("VideoMediaHandler.setTransformedTrack", {
            error: n
          }), this.transformedMediaTrack = this.mediaTrack;
        }
      });
    }
    setVideoMiddlewareGlobalConfig(e) {
      return u(this, null, function* () {
        _(this, Na, e);
      });
    }
    updateConstraints(e) {
      return u(this, null, function* () {
        if (!this._mediaTrack)
          throw new w("No media track enabled!");
        const r = this.mediaInterface;
        if (!r.constraintsBuilder)
          throw new w("update constraints not supported for non web clients", "1100");
        try {
          this._mediaTrack.applyConstraints(
            r.constraintsBuilder.getUpdatedVideoConstraints(e)
          ), yield this.setTransformedTrack(), this.addMediaTrackListeners(), yield this.setCurrentDevice();
        } catch (n) {
          l.error("VideoMediaHandler.updateConstraints.error", {
            error: n
          });
        }
      });
    }
    terminateMiddlewareWebWorker() {
      o(this, mi).terminateMiddlewareWebWorker();
    }
    onTrackEnded() {
      return u(this, null, function* () {
        l.info("VideoMediaHandler.TrackEnded"), this.disableTrack(), this.emit("trackEnded");
      });
    }
    onTrackMuted() {
      l.info("VideoMediaHandler.TrackMuted"), this.emit("trackMuted");
    }
    conditionallyChangeTrack(e) {
      return u(this, null, function* () {
        if (!e || this.userSelectedDevice)
          return e;
        let r = e;
        const n = yield this.mediaInterface.getVideoInputDevices(), i = this.isNonPreferredDevice ? n.filter((a) => !this.isNonPreferredDevice(a)) : n;
        return !(i != null && i.length) || window.FAST_DYTE || i.find(
          (a) => a.deviceId === e.getSettings().deviceId
        ) || (r.stop(), l.info("localmediahandler::setupstreams::found_video_non_preferred"), r = yield this.mediaInterface.getVideoTrack(
          i[0].deviceId
        )), r;
      });
    }
  }
  mi = new WeakMap(), Na = new WeakMap();
  td([
    v.trace("VideoMediaHandler.setTransformedTrack")
  ], _o.prototype, "setTransformedTrack");
  td([
    v.trace("VideoMediaHandler.setVideoMiddlewareGlobalConfig")
  ], _o.prototype, "setVideoMiddlewareGlobalConfig");
  td([
    v.trace("VideoMediaHandler.onTrackEnded")
  ], _o.prototype, "onTrackEnded");
  td([
    v.trace("VideoMediaHandler.conditionallyChangeTrack")
  ], _o.prototype, "conditionallyChangeTrack");
  const HD = _o, dh = sr(
    Kl()
  );
  var wt, nn, La, fi;
  const Vn = class {
    constructor(t) {
      E(this, wt, undefined);
      E(this, nn, undefined);
      E(this, La, undefined);
      E(this, fi, undefined);
      if (!t)
        throw new w("Could not load preset.");
      _(this, wt, t.config), _(this, La, t.name), _(this, nn, t.ui || sr(Kl().ui)), _(this, fi, t.permissions.plugins.config);
    }
    /** @deprecated. Use init() */
    static fromResponse(t) {
      return new Vn(t);
    }
    /** @deprecated. Use init() */
    static default() {
      return new Vn(dh);
    }
    static init(t, e = true) {
      return !t || e ? new Vn(dh) : new Vn(t);
    }
    /**
     * @deprecated
     * The `setupScreen` represents the setup screen for the meeting.
     */
    get setupScreen() {
      return {
        isEnabled: true
      };
    }
    /**
     * @deprecated
     * The `waitingRoom` contains the properties to show a layout when
     * the participant is in waiting to join the meeting.
     */
    get waitingRoom() {
      return {
        isEnabled: true
      };
    }
    /**
     * @deprecated
     * The `controlBar` contains the properties to show the meeting control bar with
     * various action buttons for the meeting.
     * The `elements` key contains the various action buttons.
     */
    get controlBar() {
      return {
        isEnabled: true,
        elements: {
          chat: true,
          fullscreen: true,
          invite: false,
          layout: false,
          participants: true,
          plugins: true,
          polls: true,
          reactions: false,
          screenshare: true
        }
      };
    }
    /**
     * @deprecated
     * The `header` contains the properties to show the meeting header with various elements.
     * The `elements` key contains the following properties
     * `logo` - string value representing the public URL for the logo
     * `timer` - boolean value suggesting if the timer should be shown
     * `title` - boolean value suggesting if the meeting title should be shown
     * `participantCount` - boolean value suggesting if the participant count shuld be shown
     * `changeLayout` - boolean value suggesting if the participant can change layout
     */
    get header() {
      return {
        isEnabled: true,
        elements: {
          logo: o(this, nn).designTokens.logo,
          timer: true,
          title: true,
          participantCount: true,
          changeLayout: false
        }
      };
    }
    /**
     * @deprecated
     * The `pipMode` property returns a boolean value
     * If true, picture-in-picture mode is enabled for the participant.
     */
    get pipMode() {
      return true;
    }
    /**
     * The `viewType` tells the type of the meeting
     * possible values are: GROUP_CALL| LIVESTREAM | CHAT | AUDIO_ROOM
     */
    get viewType() {
      return o(this, wt).viewType;
    }
    /**
     * The `livestreamViewerQualities` specifies the allowed qualities of a stream,
     * that can be viewed by a livestream viewer
     * */
    get livestreamViewerQualities() {
      return o(this, wt).livestreamViewerQualities || [];
    }
    /**
     * The `maxVideoStreams` contains the maximum video
     * streams for mobile and desktop
     */
    get maxVideoStreams() {
      return o(this, wt).maxVideoStreams;
    }
    /**
     * The `maxScreenShareCount` contains the maximum
     * possible concurrent screen shares
     */
    get maxScreenShareCount() {
      return o(this, wt).maxScreenshareCount;
    }
    /**
     * @deprecated in favour of permissions.plugins.config
     */
    get plugins() {
      return [];
    }
    /**
     * The `disabledPlugins` property returns id of all disabled plugins
     */
    get disabledPlugins() {
      return Object.keys(o(this, fi)).filter((t) => o(this, fi)[t].disabled);
    }
    get designTokens() {
      return o(this, nn).designTokens;
    }
    get configDiff() {
      return o(this, nn).configDiff;
    }
    get mediaConstraints() {
      var t, e, r, n, i, a, c, d, p, h, m, g, T, y, b, A, I, $, V, O, q, B, ne, Y;
      return {
        audio: {
          enableStereo: (n = (r = (e = (t = o(this, wt)) == null ? undefined : t.media) == null ? undefined : e.audio) == null ? undefined : r.enableStereo) != null ? n : Nn.audio.enableStereo,
          enableHighBitrate: (d = (c = (a = (i = o(this, wt)) == null ? undefined : i.media) == null ? undefined : a.audio) == null ? undefined : c.enableHighBitrate) != null ? d : Nn.audio.enableHighBitrate
        },
        video: {
          quality: (g = (m = (h = (p = o(this, wt)) == null ? undefined : p.media) == null ? undefined : h.video) == null ? undefined : m.quality) != null ? g : Nn.video.quality,
          frameRate: (A = (b = (y = (T = o(this, wt)) == null ? undefined : T.media) == null ? undefined : y.video) == null ? undefined : b.frameRate) != null ? A : Nn.video.frameRate
        },
        screenshare: {
          quality: (O = (V = ($ = (I = o(this, wt)) == null ? undefined : I.media) == null ? undefined : $.screenshare) == null ? undefined : V.quality) != null ? O : Nn.screenshare.quality,
          frameRate: (Y = (ne = (B = (q = o(this, wt)) == null ? undefined : q.media) == null ? undefined : B.screenshare) == null ? undefined : ne.frameRate) != null ? Y : Nn.screenshare.frameRate
        }
      };
    }
    get name() {
      return o(this, La);
    }
  };
  let El = Vn;
  wt = new WeakMap(), nn = new WeakMap(), La = new WeakMap(), fi = new WeakMap();
  var BD = Object.defineProperty, qD = Object.getOwnPropertyDescriptor, ug = (s, t, e, r) => {
    for (var n = qD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && BD(t, e, n), n;
  }, gi;
  class cu extends Ft {
    constructor(e) {
      super();
      E(this, gi, undefined);
      f(this, "state", "IDLE");
      f(this, "playbackUrl");
      f(this, "ingestionCredentials");
      f(this, "viewerCount");
      _(this, gi, e), this.viewerCount = 0;
    }
    setLivestreamState(e) {
      const r = this.state;
      this.state = e, r !== e && this.emitCurrentLivestreamState();
    }
    emitCurrentLivestreamState() {
      this.emit("livestreamUpdate", this.state);
    }
    start() {
      return u(this, arguments, function* (e = {
        manualIngestion: false
      }) {
        if (!o(this, gi).permissions.canLivestream)
          throw l.error("DyteLivestream::start::permission_denied"), new w(
            "User does not have permission to start livestreaming"
          );
        this.setLivestreamState("STARTING");
        try {
          const r = qe(), {
            playbackUrl: n,
            ingestionCredentials: i
          } = yield r.startLivestreaming(e);
          this.playbackUrl = n, this.ingestionCredentials = i, e != null && e.manualIngestion && this.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
        } catch (r) {
          throw l.error("DyteRecording::stop::livestream_failed_to_start", {
            error: r
          }), this.setLivestreamState("IDLE"), new w("Error while starting livestream");
        }
      });
    }
    stop() {
      return u(this, null, function* () {
        if (!o(this, gi).permissions.canLivestream)
          throw l.error("DyteLivestream::stop::permission_denied"), new w(
            "User does not have permission to stop livestreaming"
          );
        if (this.state !== "LIVESTREAMING" && this.state !== "WAITING_ON_MANUAL_INGESTION")
          throw l.error("DyteLivestream::stop::inconsistent_state"), new w("Livestream not started yet");
        try {
          this.setLivestreamState("STOPPING"), yield qe().stopLivestreaming();
        } catch (e) {
          throw l.error("DyteLivestream::stop::livestream_failed_to_stop", {
            error: e
          }), this.setLivestreamState("STOPPING"), new w("Error while stopping livestream");
        }
      });
    }
  }
  gi = new WeakMap();
  ug([
    v.trace("livestream.start")
  ], cu.prototype, "start");
  ug([
    v.trace("livestream.stop")
  ], cu.prototype, "stop");
  var jD = Object.defineProperty, GD = Object.getOwnPropertyDescriptor, JD = (s, t, e, r) => {
    for (var n = GD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && jD(t, e, n), n;
  }, vi, yi, Ur;
  class pg {
    constructor(t, e) {
      f(this, "livestream");
      E(this, vi, undefined);
      E(this, yi, undefined);
      E(this, Ur, undefined);
      _(this, yi, t), this.livestream = new cu(t), _(this, Ur, e), this.setupEvents();
    }
    fetchInitialLivestreamingState() {
      return u(this, null, function* () {
        const t = qe(), {
          status: e,
          playbackUrl: r,
          manualIngest: n,
          ingestionCredentials: i
        } = yield t.getActiveLivestream();
        this.livestream.playbackUrl = r, this.livestream.ingestionCredentials = i, e === "LIVE" && this.livestream.setLivestreamState("LIVESTREAMING"), e === "INVOKED" && n && this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
      });
    }
    setupEvents() {
      o(this, Ur).on(
        F.startedLivestream,
        (t) => u(this, null, function* () {
          this.livestream.playbackUrl = t.playbackUrl, this.livestream.setLivestreamState("LIVESTREAMING");
          try {
            o(this, yi).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
          } catch (e) {
            l.error("Error: LivestreamController.fetchLivestream during startedLivestream re-fetch");
          }
        })
      ), o(this, Ur).on(
        F.livestreamingInvoked,
        (t) => u(this, null, function* () {
          if (t.manualIngest) {
            this.livestream.setLivestreamState("WAITING_ON_MANUAL_INGESTION");
            try {
              o(this, yi).permissions.canLivestream && (yield this.fetchInitialLivestreamingState());
            } catch (e) {
              l.error("Error: LivestreamController.fetchLivestream during livestreamingInvoked re-fetch");
            }
          }
        })
      ), o(this, Ur).on(F.stoppedLivestream, () => {
        this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = undefined, this.livestream.ingestionCredentials = undefined;
      }), o(this, Ur).on(F.erroredLivestream, () => {
        this.livestream.setLivestreamState("IDLE"), this.livestream.playbackUrl = undefined;
      }), o(this, Ur).on(
        F.roomPeerCount,
        (t) => {
          this.livestream.viewerCount = t.count, this.livestream.emit("viewerCountUpdate", t.count);
        }
      ), R.on(
        P.PEER_JOINED_INTERNAL,
        (t) => u(this, null, function* () {
          var e;
          ((e = t.flags) == null ? undefined : e.hiddenParticipant) === true && t.recorderType === "LIVESTREAMER" && (_(this, vi, t.id), this.livestream.setLivestreamState("LIVESTREAMING"));
        })
      ), R.on(P.PEER_CLOSED, (t) => {
        t.id === o(this, vi) && (_(this, vi, undefined), this.livestream.setLivestreamState("IDLE"));
      }), R.onAsync(P.LEAVE_MEDIA_ROOM, () => u(this, null, function* () {
        this.livestream.playbackUrl || (l.info("Fetching livestreaming state on leave stage"), yield this.fetchInitialLivestreamingState());
      })), R.on(P.SOCKET_SERVICE_ROOM_JOINED, () => u(this, null, function* () {
        try {
          yield this.fetchInitialLivestreamingState();
        } catch (t) {
          l.error("Error: LivestreamController.fetchLivestream");
        }
      }));
    }
  }
  vi = new WeakMap(), yi = new WeakMap(), Ur = new WeakMap();
  JD([
    v.trace("LivestreamController.setupEvents")
  ], pg.prototype, "setupEvents");
  var WD = Object.defineProperty, KD = Object.getOwnPropertyDescriptor, So = (s, t, e, r) => {
    for (var n = KD(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && WD(t, e, n), n;
  }, ut, fs, gs, Ic, hg;
  class Vi {
    constructor({ name: t, socketHandler: e, meetingId: r }) {
      E(this, Ic);
      f(this, "name", "");
      E(this, ut, {});
      E(this, fs, "");
      E(this, gs, undefined);
      f(this, "rateLimitConfig", {
        maxInvocations: 5,
        period: 1
      });
      f(this, "bulkRateLimitConfig", {
        maxInvocations: 5,
        period: 1
      });
      f(this, "listeners", {});
      this.name = t, _(this, gs, e), _(this, fs, r);
    }
    /**
       * @description Sets a value in the store.
       * @param {string} key - Unique identifier used to store value.
       * @param {any} value - Data to be set.
       * @returns {Promise<void>} A promise.
       */
    set(t, e, r = true, n = false) {
      return u(this, null, function* () {
        o(this, ut)[t] = e, r && this.remoteSet(t, e), n && (this.listeners[t] && this.listeners[t].forEach(
          (i) => i({ [t]: o(this, ut)[t] })
        ), this.listeners["*"] && this.listeners["*"].forEach(
          (i) => i({ [t]: o(this, ut)[t] })
        ));
      });
    }
    remoteSet(t, e) {
      o(this, gs).storeInsertKeys(o(this, fs), this.name, [{ key: t, payload: e }]);
    }
    bulkSet(t) {
      return u(this, null, function* () {
        t.forEach(({ key: e, payload: r }) => {
          o(this, ut)[e] = r;
        }), o(this, gs).storeInsertKeys(o(this, fs), this.name, t);
      });
    }
    update(t, e, r = true) {
      return u(this, null, function* () {
        Le(this, Ic, hg).call(this, t, e, r);
      });
    }
    // eslint-disable-next-line consistent-return
    delete(t, e = true, r = false) {
      return u(this, null, function* () {
        if (o(this, ut)[t] && delete o(this, ut)[t], e)
          return o(this, gs).storeDeleteKeys(
            o(this, fs),
            this.name,
            [{ key: t }]
          );
        r && (this.listeners[t] && (this.listeners[t].forEach((n) => n({ [t]: undefined })), delete this.listeners[t]), this.listeners["*"] && this.listeners["*"].forEach((n) => n({ [t]: undefined })));
      });
    }
    bulkDelete(t) {
      return u(this, null, function* () {
        return t.forEach(({ key: e }) => {
          o(this, ut)[e] && delete o(this, ut)[e];
        }), o(this, gs).storeDeleteKeys(
          o(this, fs),
          this.name,
          t
        );
      });
    }
    /**
     * @description Returns value for the given key.
     * @param {string} key - Unique identifier used to store value.
     * @returns {any} Value for the given key.
     */
    get(t) {
      if (o(this, ut)[t])
        return o(this, ut)[t];
    }
    /**
     * @description Returns the entire store.
     * @returns {StoreData} An instance of StoreData.
     */
    getAll() {
      return o(this, ut);
    }
    get rateLimits() {
      return this.rateLimitConfig;
    }
    updateRateLimits(t, e) {
      this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
    }
    get bulkRateLimits() {
      return this.bulkRateLimitConfig;
    }
    // eslint-disable-next-line class-methods-use-this
    updateBulkRateLimits(t, e) {
      this.bulkRateLimitConfig.maxInvocations = t, this.bulkRateLimitConfig.period = e;
    }
    /**
     * @description Listens for data change on a store key.
     * @param {string} key - Unique identifier used to store value.
     * @param {Function} cb - The callback function that gets executed
     * when data is modified.
     * @returns {void} void
     */
    subscribe(t, e) {
      if (this.listeners[t]) {
        this.listeners[t].push(e);
        return;
      }
      this.listeners[t] = [e];
    }
    /**
       * @description Removes all listeners for a key on the store.
       * @param {string} key - Unique identifier used to store value.
    * * @param {Function} cb - Callback to be removed.
       * @returns {void} void
       */
    unsubscribe(t, e) {
      var r;
      if (e) {
        this.listeners[t] = ((r = this.listeners[t]) == null ? undefined : r.filter((n) => n !== e)) || [];
        return;
      }
      this.listeners[t] && delete this.listeners[t];
    }
    populate(t) {
      _(this, ut, t);
    }
  }
  ut = new WeakMap(), fs = new WeakMap(), gs = new WeakMap(), Ic = new WeakSet(), hg = function(t, e, r = true) {
    let n;
    const i = o(this, ut)[t], a = Object.prototype.toString.call(e), c = Object.prototype.toString.call(i);
    if (a !== c) {
      this.set(t, e);
      return;
    }
    switch (c) {
      case "[object Array]":
        n = [...i, ...e];
        break;
      case "[object Object]":
        n = L(L({}, i), e);
        break;
      case "[object Map]":
        n = new Map([...i, ...e]);
        break;
      case "[object Set]":
        n = /* @__PURE__ */ new Set([...i, ...e]);
        break;
      default:
        n = e;
        break;
    }
    this.set(t, n, r);
  };
  So([
    At(Fi, "rateLimitConfig")
  ], Vi.prototype, "remoteSet");
  So([
    At(Fi, "bulkRateLimitConfig")
  ], Vi.prototype, "bulkSet");
  So([
    At(Fi, "rateLimitConfig")
  ], Vi.prototype, "update");
  So([
    At(Fi, "rateLimitConfig")
  ], Vi.prototype, "delete");
  So([
    At(Fi, "bulkRateLimitConfig")
  ], Vi.prototype, "bulkDelete");
  var an, on, xa, Cl, $a, vs, Ac, mg;
  class zD {
    constructor(t, e) {
      E(this, xa);
      E(this, Ac);
      f(this, "stores", /* @__PURE__ */ new Map());
      E(this, an, undefined);
      E(this, on, "");
      E(this, $a, undefined);
      E(this, vs, /* @__PURE__ */ new Map());
      _(this, an, e), _(this, on, t.getValue("meetingId")), _(this, $a, t), Le(this, Ac, mg).call(this);
    }
    create(t) {
      const e = new Vi(
        { name: t, socketHandler: o(this, an), meetingId: o(this, on) }
      );
      return o(this, an).storeGetKeys(o(this, on), t, []), new Promise((n, i) => {
        const a = setTimeout(() => i(Error("Failed")), 3e3);
        o(this, vs).set(t, { rejectTimeout: a, resolve: n, store: e });
      });
    }
  }
  an = new WeakMap(), on = new WeakMap(), xa = new WeakSet(), Cl = function() {
    return o(this, $a).getValue("peerId");
  }, $a = new WeakMap(), vs = new WeakMap(), Ac = new WeakSet(), mg = function() {
    [
      J.storeInsertKeys,
      J.storeGetKeys,
      J.storeDeleteKeys
    ].forEach((t) => {
      o(this, an).on(
        t,
        (e) => u(this, null, function* () {
          var i, a;
          if (e.pluginId !== o(this, on))
            return;
          const r = (i = e.storeItems) == null ? undefined : i.map((c) => {
            var d;
            return {
              timestamp: c.timestamp,
              peerId: c.peerId,
              payload: JSON.parse(
                (d = c.payload) != null && d.length ? new TextDecoder().decode(c.payload) : "{}"
              ),
              key: c.storeKey
            };
          });
          if (t === J.storeGetKeys) {
            const c = o(this, vs).get(e.storeName), d = this.stores.get(e.storeName) || (c == null ? undefined : c.store);
            o(this, vs).get(e.storeName) && (this.stores.set(e.storeName, c.store), c.resolve(d), clearTimeout(c.rejectTimeout), o(this, vs).delete(e.storeName)), r.forEach((p) => {
              d.set(p.key, p.payload, false, false);
            });
            return;
          }
          const n = this.stores.get(e.storeName) || ((a = o(this, vs).get(e.storeName)) == null ? undefined : a.store);
          n !== undefined && (t === J.storeInsertKeys && r.forEach(({ key: c, peerId: d, payload: p }) => {
            d === o(this, xa, Cl) && t !== J.storeGetKeys || n.set(c, p, false, true);
          }), t === J.storeDeleteKeys && r.forEach(({ key: c, peerId: d }) => {
            d !== o(this, xa, Cl) && n.delete(c, false, true);
          }));
        })
      );
    });
  };
  function Ks(s) {
    var t, e, r, n, i, a, c, d, p, h, m, g, T;
    return s ? {
      media: {
        audio: {
          enabled: s.audioEnabled,
          trackId: (t = s.audioTrack) == null ? undefined : t.id,
          permission: "mediaPermissions" in s ? (e = s.mediaPermissions) == null ? undefined : e.audio : null
        },
        video: {
          enabled: s.videoEnabled,
          trackId: (r = s.videoTrack) == null ? undefined : r.id,
          permission: "mediaPermissions" in s ? (n = s.mediaPermissions) == null ? undefined : n.video : null
        },
        screenshare: {
          enabled: s.screenShareEnabled,
          permission: "mediaPermissions" in s ? (i = s.mediaPermissions) == null ? undefined : i.screenshare : null,
          audio: {
            enabled: (c = (a = s.screenShareTracks) == null ? undefined : a.audio) == null ? undefined : c.enabled,
            trackId: (p = (d = s.screenShareTracks) == null ? undefined : d.audio) == null ? undefined : p.id
          },
          video: {
            enabled: (m = (h = s.screenShareTracks) == null ? undefined : h.video) == null ? undefined : m.enabled,
            trackId: (T = (g = s.screenShareTracks) == null ? undefined : g.video) == null ? undefined : T.id
          }
        }
      }
    } : {};
  }
  var YD = Object.defineProperty, QD = Object.getOwnPropertyDescriptor, Hi = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? QD(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && YD(t, e, n), n;
  };
  const XD = 0.8, ZD = 1.2;
  var Ti, _i, ys, cn, ua, Fr, Ua, Ts, Si, Go, Vr, Dc, Fa, wl, Dh;
  let Qr = (Dh = class extends Ft {
    constructor(t, e, r, n) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, cn);
      E(this, Si);
      E(this, Fa);
      /**
       * The peer ID of the participant.
       * The participants are indexed by this ID in the participant map.
       */
      f(this, "id");
      /**
       * The user ID of the participant.
       */
      f(this, "userId");
      /**
       * The name of the participant.
       */
      f(this, "name");
      /**
       * The picture of the participant.
       */
      f(this, "picture");
      f(this, "isHost");
      /**
       * The custom id of the participant set during Add Participant REST API
       */
      f(this, "customParticipantId");
      f(this, "flags");
      /**
       * The device configuration of the participant.
       */
      f(this, "device");
      /**
       * The participant's video track.
       */
      f(this, "videoTrack");
      /**
       * The participant's audio track.
       */
      f(this, "audioTrack");
      /**
       * The participant's screenshare video and audio track.
       */
      f(this, "screenShareTracks");
      /**
       * This is true if the participant's video is enabled.
       */
      f(this, "videoEnabled");
      /**
       * This is true if the participant's audio is enabled.
       */
      f(this, "audioEnabled");
      /**
       * This is true if the participant is screensharing.
       */
      f(this, "screenShareEnabled");
      /**
       * producers created by participant
       */
      f(this, "producers");
      /**
       * producer config passed during manual subscription
       */
      f(this, "manualProducerConfig");
      /**
       * This is true if the participant is pinned.
       */
      E(this, Ti, undefined);
      /**
       * This is true if the dyte participant supports remote control.
       */
      f(this, "supportsRemoteControl", false);
      /**
       * Represents the participants current stage status
       */
      E(this, _i, undefined);
      /**
       * The preset of the participant.
       */
      f(this, "presetName");
      E(this, ys, undefined);
      E(this, Fr, undefined);
      E(this, Ua, undefined);
      E(this, Ts, /* @__PURE__ */ new Map());
      /*
      * Specifies the currently set max spatial layer
      * Assuming a two layer simulcast, 0 being the lower layer
      * default = 1
      */
      E(this, Vr, 1);
      E(this, Dc, zr((t) => {
        if (!this.videoTrack)
          return;
        const { clientWidth: e, clientHeight: r } = t, { width: n, height: i } = this.videoTrack.getSettings();
        if (!n || !i)
          return;
        const a = i / r, c = n / e, d = Math.max(a, c);
        d > ZD && o(this, Vr) === 1 ? (_(this, Vr, 0), R.emit(P.MAX_SPATIAL_LAYER_CHANGE, {
          peerId: this.id,
          maxSpatialLayer: o(this, Vr)
        })) : d < XD && o(this, Vr) === 0 && (_(this, Vr, 1), R.emit(P.MAX_SPATIAL_LAYER_CHANGE, {
          peerId: this.id,
          maxSpatialLayer: o(this, Vr)
        }));
      }, 2e3));
      _(this, ys, t);
      const {
        id: i,
        userId: a,
        displayName: c,
        device: d,
        picture: p,
        isHost: h,
        flags: m,
        clientSpecificId: g,
        stageStatus: T,
        customParticipantId: y,
        audioMuted: b,
        audioTrack: A,
        videoEnabled: I = false,
        videoTrack: $,
        producers: V,
        metadata: O
      } = e;
      this.id = i, this.userId = a, this.name = c, this.device = d, this.picture = p, this.isHost = h, this.flags = m, this.manualProducerConfig = hw, _(this, _i, T != null ? T : "ON_STAGE"), this.customParticipantId = y != null ? y : g, this.audioEnabled = !b, this.audioTrack = A, this.videoEnabled = I, this.videoTrack = $, this.screenShareTracks = {
        audio: undefined,
        video: undefined
      }, this.producers = V != null ? V : [], this.presetName = O == null ? undefined : O.preset_name, _(this, Ti, false), _(this, Fr, r), _(this, Ua, n), this.setupEvents(), this.updateVideo = this.updateVideo.bind(this), Le(this, Fa, wl).call(this);
    }
    /**
     * @deprecated
     * Use `customParticipantId`
     */
    get clientSpecificId() {
      return this.customParticipantId;
    }
    /** Denotes the participants's current stage status. */
    get stageStatus() {
      return o(this, _i);
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get mediaJoined() {
      return o(this, ys).getValue("connectionHandler").mediaJoined;
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get socketJoined() {
      return o(this, ys).getValue("connectionHandler").socketJoined;
    }
    setVideoEnabled(t, e = true) {
      this.videoEnabled = t, e && (l.info("DyteParticipant::setVideoEnabled::videoUpdate", L({}, Ks(this))), this.emit("videoUpdate", {
        videoEnabled: this.videoEnabled,
        videoTrack: this.videoTrack
      }));
    }
    setAudioEnabled(t, e = true) {
      this.audioEnabled = t, e && (l.info("DyteParticipant::setAudioEnabled::audioUpdate", L({}, Ks(this))), this.emit("audioUpdate", {
        audioEnabled: this.audioEnabled,
        audioTrack: this.audioTrack
      }));
    }
    setScreenShareEnabled(t, e = true) {
      this.screenShareEnabled = t, e && this.emit("screenShareUpdate", {
        screenShareEnabled: this.screenShareEnabled,
        screenShareTracks: this.screenShareTracks
      });
    }
    setupEvents() {
      this.on("videoUpdate", Le(this, Fa, wl));
    }
    /**
     * Returns `participant.id` if user has permission
     * to pin participants.
     */
    pin() {
      return u(this, null, function* () {
        if (!this.mediaJoined)
          throw new w("Can`t pin participant without joining room");
        if (!o(this, Fr).permissions.pinParticipant)
          throw new w("You do not have permission to pin participants.");
        return o(this, cn, ua).pinPeer(this.id);
      });
    }
    /**
     * Returns `participant.id` if user has permission
     * to unpin participants.
     */
    unpin() {
      return u(this, null, function* () {
        if (!this.mediaJoined)
          throw new w("Can`t unpin participant without joining room");
        if (!o(this, Fr).permissions.pinParticipant)
          throw new w("You do not have permission to unpin participants.");
        return o(this, cn, ua).pinPeer(null);
      });
    }
    /**
     * @access private
     * Not for external use
     */
    setIsPinned(t, e = true) {
      var n;
      _(this, Ti, t);
      const r = t ? "pinned" : "unpinned";
      (n = o(this, Si, Go)) == null || n.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
    }
    disableAudio() {
      return u(this, null, function* () {
        const t = this.id;
        if (l.info("DyteParticipant::disable_audio", {
          dyteParticipant: { id: t }
        }), !this.mediaJoined)
          throw new w(
            "Can`t disable participant audio without joining room"
          );
        if (o(this, Fr).permissions.canDisableParticipantAudio)
          return o(this, cn, ua).disableAudio(t);
        throw l.error("DyteParticipant::unauthorized_disable_audio", {
          dyteParticipant: { id: t }
        }), new w(
          "Unauthorized: User does not have permission to disable participant audio."
        );
      });
    }
    kick() {
      return u(this, null, function* () {
        const t = this.id;
        if (l.info("DyteParticipant::kick", {
          dyteParticipant: { id: t }
        }), !this.socketJoined)
          throw new w("Can`t kick participant without joining room");
        if (o(this, Fr).permissions.kickParticipant) {
          yield R.emitAsync(P.KICK_PEER, {
            peerId: t
          });
          return;
        }
        throw l.error("DyteParticipant::unauthorized_kick", {
          dyteParticipant: { id: t }
        }), new w(
          "Unauthorized: User does not have permission to kick participants."
        );
      });
    }
    disableVideo() {
      return u(this, null, function* () {
        const t = this.id;
        if (l.info("DyteParticipant::disable_video", {
          dyteParticipant: { id: t }
        }), !this.mediaJoined)
          throw new w(
            "Can`t disable participant video without joining room"
          );
        if (o(this, Fr).permissions.canDisableParticipantVideo)
          return o(this, cn, ua).disableVideo(t);
        throw l.error("DyteParticipant::unauthorized_disable_video", {
          dyteParticipant: { id: t }
        }), new w(
          "Unauthorized: User does not have permission to disable participant video."
        );
      });
    }
    getPermissions() {
      return u(this, null, function* () {
        return o(this, Ua).getUserPermissions(this.userId);
      });
    }
    setStageStatus(t) {
      _(this, _i, t), this.emit("stageStatusUpdate", this);
    }
    /**
     * Returns true if the participant is pinned.
     */
    get isPinned() {
      return o(this, Ti);
    }
    registerVideoElement(t) {
      var r, n, i, a;
      let e;
      (n = (r = o(this, Ts).get(t)) == null ? undefined : r.observer) == null || n.disconnect(), "ResizeObserver" in window && (e = new ResizeObserver(() => o(this, Dc).call(this, t)), e.observe(t)), o(this, Ts).set(t, { observer: e }), this.updateVideo(t), (a = o(this, Si, Go)) == null || a.addSource(
        this.id,
        t,
        this.videoEnabled,
        this.isPinned,
        this.name,
        this.picture,
        (i = this.raised) != null ? i : false
      );
    }
    deregisterVideoElement(t) {
      var e, r, n;
      t.srcObject = undefined, (r = (e = o(this, Ts).get(t)) == null ? undefined : e.observer) == null || r.disconnect(), o(this, Ts).delete(t), (n = o(this, Si, Go)) == null || n.removeSource(this.id);
    }
    /**
     * Internal method, do not use
     */
    updateVideo(t) {
      var e;
      if (this.videoEnabled) {
        if (this.videoTrack == null)
          return;
        const r = (e = t.srcObject) == null ? undefined : e.getTracks()[0];
        if ((r == null ? undefined : r.id) === this.videoTrack.id)
          return;
        const n = new MediaStream();
        n.addTrack(this.videoTrack), t.srcObject = n;
      } else
        t.srcObject = undefined;
      t.style.display = this.videoEnabled ? "block" : "none";
    }
  }, Ti = new WeakMap(), _i = new WeakMap(), ys = new WeakMap(), cn = new WeakSet(), ua = function() {
    return o(this, ys).getValue("roomNodeClient");
  }, Fr = new WeakMap(), Ua = new WeakMap(), Ts = new WeakMap(), Si = new WeakSet(), Go = function() {
    return o(this, ys).getValue("pip");
  }, Vr = new WeakMap(), Dc = new WeakMap(), Fa = new WeakSet(), wl = function() {
    Array.from(o(this, Ts).keys()).forEach(this.updateVideo);
  }, Dh);
  Hi([
    v.trace("DyteParticipant.disableAudio")
  ], Qr.prototype, "disableAudio", 1);
  Hi([
    v.trace("DyteParticipant.kick")
  ], Qr.prototype, "kick", 1);
  Hi([
    v.trace("DyteParticipant.disableVideo")
  ], Qr.prototype, "disableVideo", 1);
  Hi([
    v.trace("DyteParticipant.getPermissions")
  ], Qr.prototype, "getPermissions", 1);
  Hi([
    v.trace("DyteParticipant.setStageStatus")
  ], Qr.prototype, "setStageStatus", 1);
  Qr = Hi([
    vt("1200")
  ], Qr);
  class ca extends ag {
    constructor(t) {
      const {
        onAddEvent: e = "participantJoined",
        onDeleteEvent: r = "participantLeft",
        onClearEvent: n = "participantsCleared"
      } = t != null ? t : {};
      super({
        onAddEvent: e,
        onDeleteEvent: r,
        onClearEvent: n
      });
    }
    add(t, e = true) {
      return this.has(t.id) && Object.is(this.get(t.id), t) === false && this.delete(t.id), super.add(t, e);
    }
    clear(t = true, e = false) {
      return super.clear(t, e);
    }
    delete(t, e = true, r = false) {
      return super.delete(t, e, r);
    }
  }
  var _s;
  class eM extends $i {
    constructor() {
      super();
      E(this, _s, undefined);
      _(this, _s, /* @__PURE__ */ new Map());
    }
    /**
     * @private
     */
    __set(e, r) {
      return o(this, _s).set(e, r);
    }
    /**
     * @private
     */
    __clear() {
      return o(this, _s).clear();
    }
    get(e) {
      return o(this, _s).get(e);
    }
    toArray() {
      return Array.from(o(this, _s).values());
    }
  }
  _s = new WeakMap();
  var yn = {}, rd = {}, lc = {}, tM = {
    get exports() {
      return lc;
    },
    set exports(s) {
      lc = s;
    }
  }, Jd, lh;
  function rM() {
    if (lh)
      return Jd;
    lh = 1;
    var s = 1e3, t = s * 60, e = t * 60, r = e * 24, n = r * 7, i = r * 365.25;
    Jd = function(h, m) {
      m = m || {};
      var g = typeof h;
      if (g === "string" && h.length > 0)
        return a(h);
      if (g === "number" && isFinite(h))
        return m.long ? d(h) : c(h);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(h)
      );
    };
    function a(h) {
      if (h = String(h), !(h.length > 100)) {
        var m = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          h
        );
        if (m) {
          var g = parseFloat(m[1]), T = (m[2] || "ms").toLowerCase();
          switch (T) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return g * i;
            case "weeks":
            case "week":
            case "w":
              return g * n;
            case "days":
            case "day":
            case "d":
              return g * r;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return g * e;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return g * t;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return g * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return g;
            default:
              return;
          }
        }
      }
    }
    function c(h) {
      var m = Math.abs(h);
      return m >= r ? Math.round(h / r) + "d" : m >= e ? Math.round(h / e) + "h" : m >= t ? Math.round(h / t) + "m" : m >= s ? Math.round(h / s) + "s" : h + "ms";
    }
    function d(h) {
      var m = Math.abs(h);
      return m >= r ? p(h, m, r, "day") : m >= e ? p(h, m, e, "hour") : m >= t ? p(h, m, t, "minute") : m >= s ? p(h, m, s, "second") : h + " ms";
    }
    function p(h, m, g, T) {
      var y = m >= g * 1.5;
      return Math.round(h / g) + " " + T + (y ? "s" : "");
    }
    return Jd;
  }
  function sM(s) {
    e.debug = e, e.default = e, e.coerce = d, e.disable = i, e.enable = n, e.enabled = a, e.humanize = rM(), e.destroy = p, Object.keys(s).forEach((h) => {
      e[h] = s[h];
    }), e.names = [], e.skips = [], e.formatters = {};
    function t(h) {
      let m = 0;
      for (let g = 0; g < h.length; g++)
        m = (m << 5) - m + h.charCodeAt(g), m |= 0;
      return e.colors[Math.abs(m) % e.colors.length];
    }
    e.selectColor = t;
    function e(h) {
      let m, g = null, T, y;
      function b(...A) {
        if (!b.enabled)
          return;
        const I = b, $ = Number(new Date()), V = $ - (m || $);
        I.diff = V, I.prev = m, I.curr = $, m = $, A[0] = e.coerce(A[0]), typeof A[0] != "string" && A.unshift("%O");
        let O = 0;
        A[0] = A[0].replace(/%([a-zA-Z%])/g, (B, ne) => {
          if (B === "%%")
            return "%";
          O++;
          const Y = e.formatters[ne];
          if (typeof Y == "function") {
            const we = A[O];
            B = Y.call(I, we), A.splice(O, 1), O--;
          }
          return B;
        }), e.formatArgs.call(I, A), (I.log || e.log).apply(I, A);
      }
      return b.namespace = h, b.useColors = e.useColors(), b.color = e.selectColor(h), b.extend = r, b.destroy = e.destroy, Object.defineProperty(b, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => g !== null ? g : (T !== e.namespaces && (T = e.namespaces, y = e.enabled(h)), y),
        set: (A) => {
          g = A;
        }
      }), typeof e.init == "function" && e.init(b), b;
    }
    function r(h, m) {
      const g = e(this.namespace + (typeof m == "undefined" ? ":" : m) + h);
      return g.log = this.log, g;
    }
    function n(h) {
      e.save(h), e.namespaces = h, e.names = [], e.skips = [];
      let m;
      const g = (typeof h == "string" ? h : "").split(/[\s,]+/), T = g.length;
      for (m = 0; m < T; m++)
        g[m] && (h = g[m].replace(/\*/g, ".*?"), h[0] === "-" ? e.skips.push(new RegExp("^" + h.slice(1) + "$")) : e.names.push(new RegExp("^" + h + "$")));
    }
    function i() {
      const h = [
        ...e.names.map(c),
        ...e.skips.map(c).map((m) => "-" + m)
      ].join(",");
      return e.enable(""), h;
    }
    function a(h) {
      if (h[h.length - 1] === "*")
        return true;
      let m, g;
      for (m = 0, g = e.skips.length; m < g; m++)
        if (e.skips[m].test(h))
          return false;
      for (m = 0, g = e.names.length; m < g; m++)
        if (e.names[m].test(h))
          return true;
      return false;
    }
    function c(h) {
      return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function d(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }
    function p() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return e.enable(e.load()), e;
  }
  var nM = sM;
  (function(s, t) {
    t.formatArgs = r, t.save = n, t.load = i, t.useColors = e, t.storage = a(), t.destroy = (() => {
      let d = false;
      return () => {
        d || (d = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), t.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function e() {
      return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function r(d) {
      if (d[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + d[0] + (this.useColors ? "%c " : " ") + "+" + s.exports.humanize(this.diff), !this.useColors)
        return;
      const p = "color: " + this.color;
      d.splice(1, 0, p, "color: inherit");
      let h = 0, m = 0;
      d[0].replace(/%[a-zA-Z%]/g, (g) => {
        g !== "%%" && (h++, g === "%c" && (m = h));
      }), d.splice(m, 0, p);
    }
    t.log = console.debug || console.log || (() => {
    });
    function n(d) {
      try {
        d ? t.storage.setItem("debug", d) : t.storage.removeItem("debug");
      } catch (p) {
      }
    }
    function i() {
      let d;
      try {
        d = t.storage.getItem("debug");
      } catch (p) {
      }
      return !d && typeof process != "undefined" && "env" in process && (d = process.env.DEBUG), d;
    }
    function a() {
      try {
        return localStorage;
      } catch (d) {
      }
    }
    s.exports = nM(t);
    const { formatters: c } = s.exports;
    c.j = function(d) {
      try {
        return JSON.stringify(d);
      } catch (p) {
        return "[UnexpectedJSONParseError]: " + p.message;
      }
    };
  })(tM, lc);
  var iM = Ru && Ru.__importDefault || function(s) {
    return s && s.__esModule ? s : { default: s };
  };
  Object.defineProperty(rd, "__esModule", { value: true });
  rd.Logger = undefined;
  const Ln = iM(lc), xn = "awaitqueue";
  class aM {
    constructor(t) {
      t ? (this._debug = (0, Ln.default)(`${xn}:${t}`), this._warn = (0, Ln.default)(`${xn}:WARN:${t}`), this._error = (0, Ln.default)(`${xn}:ERROR:${t}`)) : (this._debug = (0, Ln.default)(xn), this._warn = (0, Ln.default)(`${xn}:WARN`), this._error = (0, Ln.default)(`${xn}:ERROR`)), this._debug.log = console.info.bind(console), this._warn.log = console.warn.bind(console), this._error.log = console.error.bind(console);
    }
    get debug() {
      return this._debug;
    }
    get warn() {
      return this._warn;
    }
    get error() {
      return this._error;
    }
  }
  rd.Logger = aM;
  Object.defineProperty(yn, "__esModule", { value: true });
  var Li = yn.AwaitQueue = yn.AwaitQueueRemovedTaskError = yn.AwaitQueueStoppedError = undefined;
  const oM = rd, ts = new oM.Logger();
  class du extends Error {
    constructor(t) {
      super(t != null ? t : "AwaitQueue stopped"), this.name = "AwaitQueueStoppedError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, du);
    }
  }
  yn.AwaitQueueStoppedError = du;
  class sd extends Error {
    constructor(t) {
      super(t != null ? t : "AwaitQueue task removed"), this.name = "AwaitQueueRemovedTaskError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, sd);
    }
  }
  yn.AwaitQueueRemovedTaskError = sd;
  class cM {
    constructor() {
      this.pendingTasks = /* @__PURE__ */ new Map(), this.nextTaskId = 0, this.stopping = false;
    }
    get size() {
      return this.pendingTasks.size;
    }
    push(t, e) {
      return u(this, null, function* () {
        if (e = e != null ? e : t.name, ts.debug(`push() [name:${e}]`), typeof t != "function")
          throw new TypeError("given task is not a function");
        if (e)
          try {
            Object.defineProperty(t, "name", { value: e });
          } catch (r) {
          }
        return new Promise((r, n) => {
          const i = {
            id: this.nextTaskId++,
            task: t,
            name: e,
            enqueuedAt: Date.now(),
            executedAt: undefined,
            completed: false,
            resolve: (a) => {
              if (i.completed)
                return;
              i.completed = true, this.pendingTasks.delete(i.id), ts.debug(`resolving task [name:${i.name}]`), r(a);
              const [c] = this.pendingTasks.values();
              c && !c.executedAt && this.execute(c);
            },
            reject: (a) => {
              if (!i.completed && (i.completed = true, this.pendingTasks.delete(i.id), ts.debug(`rejecting task [name:${i.name}]: %s`, String(a)), n(a), !this.stopping)) {
                const [c] = this.pendingTasks.values();
                c && !c.executedAt && this.execute(c);
              }
            }
          };
          this.pendingTasks.set(i.id, i), this.pendingTasks.size === 1 && this.execute(i);
        });
      });
    }
    stop() {
      ts.debug("stop()"), this.stopping = true;
      for (const t of this.pendingTasks.values())
        ts.debug(`stop() | stopping task [name:${t.name}]`);
      this.stopping = false;
    }
    remove(t) {
      ts.debug(`remove() [taskIdx:${t}]`);
      const e = Array.from(this.pendingTasks.values())[t];
      if (!e) {
        ts.debug(`stop() | no task with given idx [taskIdx:${t}]`);
        return;
      }
      e.reject(new sd());
    }
    dump() {
      const t = Date.now();
      let e = 0;
      return Array.from(this.pendingTasks.values()).map((r) => ({
        idx: e++,
        task: r.task,
        name: r.name,
        enqueuedTime: r.executedAt ? r.executedAt - r.enqueuedAt : t - r.enqueuedAt,
        executionTime: r.executedAt ? t - r.executedAt : 0
      }));
    }
    execute(t) {
      return u(this, null, function* () {
        if (ts.debug(`execute() [name:${t.name}]`), t.executedAt)
          throw new Error("task already being executed");
        t.executedAt = Date.now();
        try {
          const e = yield t.task();
          t.resolve(e);
        } catch (e) {
          t.reject(e);
        }
      });
    }
  }
  Li = yn.AwaitQueue = cM;
  var Va;
  class fg {
    constructor() {
      f(this, "meetingTitle");
      f(this, "roomName");
      f(this, "roomUUID");
      // sfuHandler: any;
      E(this, Va, undefined);
      f(this, "context");
      f(this, "authToken");
      f(this, "maxPreferredStreams");
    }
    get peerId() {
      return this.context.getValue("peerId");
    }
    get mediaJoined() {
      return false;
    }
    set mediaJoined(t) {
      throw new w("Method not implemented.");
    }
    get sfuHandler() {
      return o(this, Va);
    }
    get mediaState() {
      return o(this, Va).transportState;
    }
    reconnect() {
      throw new w("Method not implemented.");
    }
    partialJoinRoom(t, e, r = false, n = undefined) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    joinRoom(a, c) {
      return u(this, arguments, function* (t, e, r = {}, n = false, i = false) {
        throw new w("Method not implemented.");
      });
    }
    leaveRoom() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    reset(t = true) {
      throw new w("Method not implemented");
    }
    handleSocketCallbacks(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    handleSockets(t, e) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    shareMic(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    shareWebcam(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    shareScreen(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    unmuteSelf() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    muteSelf() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    pauseWebcam() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    acceptWaitingRequest(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    rejectWaitingRequest(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    muteAll(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    muteAllVideo() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    disableAudio(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    disableVideo(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    kickAll() {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    kick(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    pinPeer(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    getConsumers() {
      throw new w("Method not implemented.");
    }
    stopAllProducers() {
      throw new w("Method not implemented.");
    }
    activatePeers(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    deactivatePeers(t, e = "default") {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    createConsumers(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    closeConsumers(t) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
    switchConsumersToLayer(t, e) {
      return u(this, null, function* () {
        throw new w("Method not implemented.");
      });
    }
  }
  Va = new WeakMap();
  var Wr = /* @__PURE__ */ ((s) => (s.INITIALIZING = "INITIALIZING", s.INITIALIZED = "INITIALIZED", s.NOT_INITIALIZED = "NOT_INITIALIZED", s))(Wr || {});
  class gg extends at.EventEmitter {
  }
  class En extends at.EventEmitter {
    constructor() {
      super(), this.setMaxListeners(1 / 0);
    }
    safeEmit(t, ...e) {
      const r = this.listenerCount(t);
      try {
        return this.emit(t, ...e);
      } catch (n) {
        return l.error(
          `EnhancedEventEmitter:: safeEmit() | event listener ${t} threw an error`,
          {
            error: n
          }
        ), Boolean(r);
      }
    }
    safeEmitAsPromise(t, ...e) {
      return u(this, null, function* () {
        const r = {}.EVENT_PROMISE_TIMEOUT ? parseInt({}.EVENT_PROMISE_TIMEOUT, 10) : 1e4;
        return this.safeEmitAsPromiseWithTimeout(t, r, ...e);
      });
    }
    safeEmitAsPromiseWithTimeout(t, e, ...r) {
      return u(this, null, function* () {
        return new Promise((n, i) => {
          setTimeout(i, e, "event request timeout");
          try {
            this.emit(t.toString(), ...r, n, i);
          } catch (a) {
            l.error(
              `EnhancedEventEmitter:: safeEmitAsPromise() | event listener for event ${t.toString()} threw an error [event:%s]:%o`,
              {
                error: a
              }
            ), i(a);
          }
        });
      });
    }
  }
  function dM(s, t) {
    const e = new Error(t);
    return e.name = s, e;
  }
  class Cn extends w {
    constructor(t) {
      super(t), this.name = "UnsupportedError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, Cn) : this.stack = new Error(t).stack;
    }
  }
  class Xe extends w {
    constructor(t) {
      super(t), this.name = "InvalidStateError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, Xe) : this.stack = new Error(t).stack;
    }
  }
  class vg extends w {
    constructor(t) {
      super(t), this.name = "TransportConnectionError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, Xe) : this.stack = new Error(t).stack;
    }
  }
  class yg extends w {
    constructor(t) {
      super(t), this.name = "DataChannelRequestError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, Xe) : this.stack = new Error(t).stack;
    }
  }
  var Ha, Ba, qa, ja, hr, Ga, Ja, Zt, dn, Wa, Ka, za, Pl, Mc, _g, Oc, Sg;
  class Tg extends En {
    constructor({
      id: e,
      localId: r,
      producerId: n,
      producingPeerId: i,
      producingTransportId: a,
      handler: c,
      track: d,
      appData: p,
      paused: h,
      reuseTrack: m,
      rtpReceiver: g
    }) {
      super();
      E(this, za);
      E(this, Mc);
      E(this, Oc);
      // Associated transciever RTCRtpSender object
      f(this, "rtpReceiver");
      // Observer is for external libs to listen for some of the events
      f(this, "observer");
      // Consumer ID
      E(this, Ha, undefined);
      // Consumer's local ID
      E(this, Ba, undefined);
      // Producer ID associated with this consumer
      E(this, qa, undefined);
      E(this, ja, undefined);
      // Indicates whether the consumer is closed or not
      E(this, hr, undefined);
      // Destroy track on close flag
      E(this, Ga, undefined);
      // RTCRtpReceiver associated with the consumer
      E(this, Ja, undefined);
      // Remote track
      E(this, Zt, undefined);
      // Paused flag
      E(this, dn, undefined);
      // Peer ID corresponding to the consumer
      E(this, Wa, undefined);
      // Custom data corresponding to this consumer
      E(this, Ka, undefined);
      _(this, Ha, e), _(this, Ba, r), _(this, Ja, c), _(this, Ka, p), _(this, Wa, i), _(this, ja, a), _(this, hr, false), _(this, qa, n), _(this, Zt, d), _(this, dn, h != null ? h : false), _(this, Ga, m), this.observer = new En(), this.rtpReceiver = g, Le(this, Mc, _g).call(this);
    }
    /**
     * Consumer ID
     */
    get id() {
      return o(this, Ha);
    }
    /**
     * Producing peer id corresponding to this consumer
     */
    get peerId() {
      return o(this, Wa);
    }
    /**
     * Local ID for the consumer
     */
    get localId() {
      return o(this, Ba);
    }
    /**
     * Producer ID associated with this consumer
     */
    get producerId() {
      return o(this, qa);
    }
    get producingTransportId() {
      return o(this, ja);
    }
    /**
     * Indicates whether this consumer is closed
     */
    get closed() {
      return o(this, hr);
    }
    /**
     * Kind of media corresponding to this consumer
     */
    get kind() {
      return o(this, Zt).kind;
    }
    /**
     * The track associated with this consumer
     */
    get track() {
      return o(this, Zt);
    }
    /**
     * Indicates whether the consumer is paused
     */
    get paused() {
      return o(this, dn);
    }
    get remotelyPaused() {
      return this.paused;
    }
    /**
     *	Custom data corresponding to this consumer
     */
    get appData() {
      return o(this, Ka);
    }
    /**
     * Closes the Consumer.
     */
    close(e) {
      o(this, hr) || (l.debug("Consumer::close() with reason:", {
        consumer: {
          id: this.id,
          appData: this.appData,
          peerId: this.peerId,
          closureReason: e,
          kind: this.kind
        }
      }), _(this, hr, true), o(this, Ga) || Le(this, Oc, Sg).call(this), this.emit("close", e), this.observer.safeEmit("close", e));
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    getStats() {
      return u(this, null, function* () {
        if (o(this, hr))
          throw new Xe("closed");
        return o(this, Ja).getReceiverStats(this.localId);
      });
    }
    /**
     * Pauses receiving media.
     */
    pause() {
      if (l.debug("consumer::pause()", {
        consumer: {
          id: this.id,
          appData: this.appData,
          peerId: this.peerId,
          kind: this.kind
        }
      }), o(this, hr)) {
        l.error("consumer::pause() | Consumer closed", {
          consumer: {
            id: this.id,
            appData: this.appData,
            peerId: this.peerId,
            kind: this.kind
          }
        });
        return;
      }
      _(this, dn, true), o(this, Zt).enabled = false, this.observer.safeEmit("pause");
    }
    /**
     * Resumes receiving media.
     */
    resume() {
      if (l.debug("consumer::resume()", {
        consumer: {
          id: this.id,
          appData: this.appData,
          peerId: this.peerId,
          kind: this.kind
        }
      }), o(this, hr)) {
        l.error("Consumer::resume() | Consumer closed", {
          consumer: {
            id: this.id,
            appData: this.appData,
            peerId: this.peerId,
            kind: this.kind
          }
        });
        return;
      }
      _(this, dn, false), o(this, Zt).enabled = true, this.observer.safeEmit("resume");
    }
  }
  Ha = new WeakMap(), Ba = new WeakMap(), qa = new WeakMap(), ja = new WeakMap(), hr = new WeakMap(), Ga = new WeakMap(), Ja = new WeakMap(), Zt = new WeakMap(), dn = new WeakMap(), Wa = new WeakMap(), Ka = new WeakMap(), za = new WeakSet(), Pl = function() {
    l.debug('Consumer::track "ended" event', {
      consumer: {
        id: this.id,
        appData: this.appData,
        peerId: this.peerId,
        kind: this.kind
      }
    }), this.safeEmit("trackended"), this.observer.safeEmit("trackended");
  }, Mc = new WeakSet(), _g = function() {
    o(this, Zt).addEventListener("ended", Le(this, za, Pl).bind(this));
  }, Oc = new WeakSet(), Sg = function() {
    try {
      o(this, Zt).removeEventListener("ended", Le(this, za, Pl)), o(this, Zt).stop();
    } catch (e) {
      l.error("Consumer::destroyTrack()", {
        consumer: {
          id: this.id,
          appData: this.appData,
          peerId: this.peerId,
          kind: this.kind
        },
        error: e
      });
    }
  };
  let lM = class extends Tg {
  };
  const uh = (s) => new Promise((t) => setTimeout(t, s));
  function wr(s, t) {
    return u(this, null, function* () {
      return new Promise((e, r) => u(this, null, function* () {
        const { strategy: n, maxRetryCount: i, delayTime: a } = L({
          strategy: "linear",
          maxRetryCount: 3,
          delayTime: 10
        }, t);
        let c = 0, d, p = false;
        const h = (m) => {
          p = true, r(m);
        };
        for (; c < i; ) {
          try {
            const m = yield s(c, h);
            return e(m);
          } catch (m) {
            if (d = m, p)
              break;
            if (c < i)
              n === "linear" ? yield uh(a * (c + 1)) : n === "exponential" && (yield uh(a * (c + Math.max(0, c - 1))));
            else
              break;
          }
          c += 1;
        }
        return r(d);
      }));
    });
  }
  function uc(s) {
    if (Promise.allSettled)
      return Promise.allSettled(s);
    const t = s.map((e) => e.then((r) => ({
      status: "fulfilled",
      value: r
    })).catch((r) => ({
      status: "rejected",
      reason: r
    })));
    return Promise.all(t);
  }
  function uM(s, t) {
    return typeof s == "undefined" ? t : typeof window != "undefined" && Object.getOwnPropertyDescriptor(window, "structuredClone") ? structuredClone(s) : JSON.parse(JSON.stringify(s));
  }
  function Eg(s) {
    return typeof s == "object" && !Array.isArray(s) && s !== null;
  }
  function Wd(s) {
    return Math.random().toString(36).substring(2, 2 + s);
  }
  const Oo = 1;
  function ph(s) {
    const t = s;
    return delete t.payload._bolt, t;
  }
  function pM(s) {
    return s.payload && Eg(s.payload);
  }
  function pc(s) {
    var t, e;
    return pM(s) && (e = (t = s.payload._bolt) == null ? undefined : t.id) != null ? e : "";
  }
  var Ss;
  const Hn = class extends at.EventEmitter {
    constructor(e, r, n) {
      super();
      f(this, "channel");
      f(this, "queue");
      f(this, "serverProtocolVersion");
      E(this, Ss, /* @__PURE__ */ new Map());
      f(this, "respond", (e, r, n = false) => {
        let i;
        n ? i = Hn.createErrorResponse(e, r) : i = Hn.createResponse(e, r), this.channel.send(JSON.stringify(i));
      });
      f(this, "notify", (e) => {
        const r = Hn.createNotification(e);
        this.channel.send(JSON.stringify(r));
      });
      f(this, "request", (e) => u(this, null, function* () {
        const r = Hn.createRequest(e), n = new Promise((i, a) => {
          const c = 1e3 * (5 + 0.1 * this.queue.size), { id: d } = r.payload._bolt, p = {
            id: d,
            method: r.type,
            resolve: (h) => {
              this.queue.delete(d) && (clearTimeout(p.timer), i(h));
            },
            timer: setTimeout(() => {
              this.queue.delete(d) && a(new Error(`request timeout for message id: ${d}`));
            }, c),
            cancel: (h) => {
              this.queue.delete(d) && (clearTimeout(p.timer), a(h));
            }
          };
          this.queue.set(d, p);
        });
        return this.channel.send(JSON.stringify(r)), n;
      }));
      f(this, "send", (e) => {
        const r = JSON.stringify(e), n = 16384;
        if (r.length > n) {
          const i = n - 200, a = Math.ceil(r.length / i), c = [];
          for (let p = 0; p < a; p += 1) {
            const h = p * i, m = (p + 1) * i;
            c.push(r.slice(h, m));
          }
          const d = v4();
          for (let p = 0; p < a; p += 1) {
            const h = c[p], g = JSON.stringify({
              id: d,
              count: a,
              chunkIndex: p,
              chunk: h
            });
            l.debug(`Sending message chunk over dc: ${g}`), this.channel.send(g);
          }
        } else
          l.debug(`Sending message over dc: ${r}`), this.channel.send(r);
      });
      f(this, "processMessage", (e) => {
        var n;
        o(this, Ss).has(e.id) || o(this, Ss).set(e.id, []);
        const r = o(this, Ss).get(e.id);
        if (r[e.chunkIndex] = e, (r == null ? undefined : r.length) === e.count && !r.some((i) => i === undefined)) {
          const i = o(this, Ss).get(e.id), a = i == null ? undefined : i.reduce((d, p) => d + p.chunk, "");
          o(this, Ss).delete(e.id);
          const c = JSON.parse(a);
          if (!c.payload || !Eg(c.payload))
            throw new Error("corrupted incoming message over dc", {
              cause: { code: "CORRUPT_DC_MESSAGE", values: c }
            });
          if (this.processBoltHandshake(c))
            return;
          if (this.serverProtocolVersion = (n = c.payload._bolt) == null ? undefined : n.version, !this.processResponseMsg(c))
            return c;
        }
      });
      f(this, "processResponseMsg", (e) => {
        const { id: r } = e.payload._bolt, n = this.queue.get(r);
        return n ? (l.debug(`resolving pending request with id: ${r}, complete response: ${JSON.stringify(e)}`), e.type === "error" ? n.cancel(ph(e)) : n.resolve(ph(e)), true) : false;
      });
      f(this, "processBoltHandshake", (e) => {
        var r, n;
        return e.type === "_bolt" || e.type === "handshake" ? (this.respond((n = (r = e.payload._bolt) == null ? undefined : r.id) != null ? n : Wd(8), { type: "_bolt", payload: { message: "pong" } }), true) : false;
      });
      this.label = r, this.transportId = n, this.channel = e, this.queue = /* @__PURE__ */ new Map();
    }
  };
  let Bs = Hn;
  Ss = new WeakMap(), f(Bs, "createRequest", (e) => {
    var r;
    if ((r = e.payload) != null && r._bolt)
      throw new Error("rpc fields are internal values");
    return {
      type: e.type,
      payload: z(L({}, e.payload), {
        _bolt: {
          id: Wd(8),
          type: "REQUEST",
          version: Oo
        }
      })
    };
  }), f(Bs, "createResponse", (e, r) => {
    var n;
    if ((n = r.payload) != null && n._bolt)
      throw new Error("rpc fields are internal values");
    return {
      type: r.type,
      payload: z(L({}, r.payload), {
        _bolt: {
          id: e,
          type: "RESPONSE",
          version: Oo
        }
      })
    };
  }), f(Bs, "createNotification", (e) => {
    var r;
    if ((r = e.payload) != null && r._bolt)
      throw new Error("rpc fields are internal values");
    return {
      type: e.type,
      payload: z(L({}, e.payload), {
        bolt: {
          id: Wd(8),
          type: "NOTIFY",
          version: Oo
        }
      })
    };
  }), f(Bs, "createErrorResponse", (e, r) => ({
    type: "error",
    payload: {
      error: r.message,
      _bolt: {
        id: e,
        type: "RESPONSE",
        version: Oo
      }
    }
  }));
  const Rl = "transport closed";
  class Cg extends En {
    constructor({
      id: e,
      direction: r,
      handlerFactory: n,
      iceServers: i,
      iceTransportPolicy: a,
      proprietaryConstraints: c,
      additionalSettings: d,
      appData: p,
      config: h
    }) {
      var g, T;
      super();
      f(this, "awaitQueue");
      f(this, "observer");
      // Id.
      f(this, "id");
      f(this, "serverId");
      // Closed flag.
      f(this, "closed", false);
      // Direction.
      f(this, "direction");
      // SCTP max message size if enabled, null otherwise.
      f(this, "maxSctpMessageSize");
      // RTC handler isntance.
      f(this, "handler");
      // Transport connection state.
      f(this, "connectionState", "new");
      // Producers map
      f(this, "producers");
      // Consumers map
      f(this, "consumers");
      // Datachannels map
      f(this, "datachannels");
      f(this, "connected", false);
      f(this, "eventsDCReadyPromise");
      f(this, "eventsDCReadyPromiseResolver");
      f(this, "eventsDCFailureTimer");
      f(this, "transportConnectionPromise");
      f(this, "consumerTrackEvents");
      f(this, "unknownTracksMap");
      f(this, "consumerTrackPool");
      // App custom data.
      f(this, "appData");
      l.debug(`constructor() [id: ${e}, direction: ${r}]`), this.id = e, this.direction = r;
      const m = uM(d, {});
      delete m.iceServers, delete m.iceTransportPolicy, delete m.bundlePolicy, delete m.rtcpMuxPolicy, delete m.sdpSemantics, this.producers = /* @__PURE__ */ new Map(), this.consumers = /* @__PURE__ */ new Map(), this.datachannels = /* @__PURE__ */ new Map(), this.consumerTrackEvents = /* @__PURE__ */ new Map(), this.consumerTrackPool = /* @__PURE__ */ new Map(), this.unknownTracksMap = /* @__PURE__ */ new Map(), this.awaitQueue = new Li(), this.observer = new En(), this.handler = n(), this.handler._enableHighBitrate = (g = h == null ? undefined : h.enableHighBitrate) != null ? g : false, this.handler._enableStereo = (T = h == null ? undefined : h.enableStereo) != null ? T : false, this.handler.init({
        onTrackHandler: this._ontrack.bind(this),
        direction: r,
        iceServers: i,
        iceTransportPolicy: a,
        additionalSettings: d,
        proprietaryConstraints: c
      }), this.appData = p || {}, this.transportConnectionPromise = new Promise((y) => {
        this.observer.once("connected", () => {
          y(true);
        }), this.observer.once("disconnect", () => {
          y(false);
        }), this.observer.once("close", () => {
          y(false);
        });
      }), this.eventsDCReadyPromise = new Promise((y) => {
        this.eventsDCReadyPromiseResolver = y;
      }), this.handler.on(
        "@connectionstatechange",
        (y) => {
          y !== this.connectionState && (l.debug(`connection state changed to ${y}`), this.connectionState = y, y === "connected" && (this.connected = true, this.observer.emit("connected")), y === "disconnected" && (this.connected = false, this.observer.emit("disconnect")), (y === "failed" || y === "closed") && (this.connected = false, this.observer.emit("close")), this.closed || this.safeEmit("connectionstatechange", y));
        }
      ), this.handler.on(
        "@icecandidate",
        ({ candidate: y }) => {
          this.closed || this.safeEmit("icecandidate", y);
        }
      ), this.handler.on("dc_open", (y) => {
        let b = this.datachannels.get(y.label);
        b || (b || (b = new Bs(y, y.label, this.serverId), this.datachannels.set(y.label, b)), this.eventsDCFailureTimer = setTimeout(() => {
          y.label === "events" && (this.eventsDCReadyPromiseResolver(false), this.safeEmit("dc_error", y.label));
        }, 5e3));
      }), this.handler.on("datachannel", (y, b) => {
        y.label === "events" && (this.eventsDCReadyPromiseResolver(true), this.eventsDCFailureTimer && clearTimeout(this.eventsDCFailureTimer));
        const A = this.datachannels.get(y.label);
        if (!A) {
          l.error("unregistered datachannel for message", {
            rtcChannel: {
              label: y.label,
              message: b
            }
          });
          return;
        }
        try {
          const I = JSON.parse(b);
          l.debug("datachannel message chunk recieved", {
            dataChannelMessageChunk: {
              id: I.id,
              count: I.count,
              chunkIndex: I.chunkIndex,
              chunk: I.chunk,
              transprtId: this.serverId
            }
          });
          const $ = A.processMessage(I);
          if (!$)
            return;
          l.debug(
            `datachannel message with id:${I.id} on transport:${this.serverId}complete - ${JSON.stringify($)}`
          ), this.emit(`datachannel:${y.label}`, A.label, $);
        } catch (I) {
          l.error("error parsing message", {
            error: I
          });
        }
      });
    }
    get isConnected() {
      return this.transportConnectionPromise;
    }
    setServerId(e) {
      this.serverId = e;
    }
    getDatachannel(e) {
      return this.datachannels.get(e);
    }
    get isEventsDCReady() {
      return this.eventsDCReadyPromise;
    }
    /**
     * Close the Transport.
     */
    close() {
      this.closed || (l.debug("Transport close called"), this.connected = false, this.closed = true, this.handler.close(), Array.from(this.producers.values()).forEach(
        (e) => {
          e.close(Rl).catch(() => {
          });
        }
      ), this.producers.clear(), Array.from(this.consumers.values()).forEach((e) => {
        e.close(Rl);
      }), this.consumers.clear(), this.consumerTrackPool.clear(), this.consumerTrackEvents.clear(), this.emit("close"), this.observer.emit("close"));
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    getStats() {
      return u(this, null, function* () {
        if (this.closed)
          throw new Xe("closed");
        return this.handler.getTransportStats();
      });
    }
    /**
     * Restart ICE connection.
     */
    restartIce() {
      return u(this, null, function* () {
        if (l.debug("restartIce()"), this.closed)
          throw new Xe("closed");
        return this.handler.restartIce();
      });
    }
    /**
     * Update ICE servers.
     */
    updateIceServers() {
      return u(this, arguments, function* ({
        iceServers: e
      } = {}) {
        if (l.debug("updateIceServers()"), this.closed)
          throw new Xe("closed");
        return this.handler.updateIceServers(e);
      });
    }
    setRemoteOffer(e) {
      return u(this, null, function* () {
        yield this.setRemoteDescription(e);
        const r = yield this.handler.pc.createAnswer(), n = libExports.parse(r.sdp);
        return n.media = n.media.map((i) => {
          if (i.type === "audio") {
            const a = L({}, i), c = a.fmtp.find(
              (p) => p.payload === 111
            );
            return c && (c.config += ";stereo=1;sprop-stereo=1"), a.rtcpFb || (a.rtcpFb = []), a.rtcpFb.some(
              (p) => p.type === "nack"
            ) || a.rtcpFb.push({
              payload: parseInt(a.payloads, 10),
              type: "nack"
            }), a;
          }
          return i;
        }), r.sdp = libExports.write(n), yield this.setLocalDescription(r), r;
      });
    }
    sendErrorOverDC(e, r, n) {
      const i = this.getDatachannel(e);
      if (!i)
        throw new Error("datachannel not found", {
          cause: { code: "DC_NOT_FOUND", values: { label: e } }
        });
      i.respond(r, n, true);
    }
    sendResponseOverDC(e, r, n) {
      const i = this.getDatachannel(e);
      if (!i)
        throw new Error("datachannel not found", {
          cause: { code: "DC_NOT_FOUND", values: { label: e } }
        });
      i.respond(r, n);
    }
    setRemoteDescription(e) {
      return u(this, null, function* () {
        yield this.handler.pc.setRemoteDescription(e);
      });
    }
    setLocalDescription(e) {
      return u(this, null, function* () {
        l.debug(`${this.direction}() {transportId: ${this.serverId}} | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), yield this.handler.pc.setLocalDescription(e);
      });
    }
    createConsumersOverDataChannel(e) {
      return u(this, null, function* () {
        const r = this.getDatachannel("events");
        if (!r)
          throw dM("DC_NOT_READY", "events datachannel not ready");
        if (!e || e && e.length === 0)
          throw new Error("list of producers is required");
        const n = {
          type: "create_consumer",
          payload: {
            producers: e.map(({ producerId: d, producingTransportId: p }) => ({
              producerId: d,
              producingTransportId: p
            }))
          }
        }, i = /* @__PURE__ */ new Map();
        e.forEach((d) => i.set(d.producerId, d));
        const a = (yield r.request(n)).payload;
        l.info(`createConsumersOverDataChannel::response ${JSON.stringify(a)}`);
        const c = /* @__PURE__ */ new Map();
        return Object.entries(a).forEach(([d, p]) => {
          const h = i.get(p.producerId);
          if (!h) {
            l.error(`unknown entry in create consumer response, producerId: ${p.producerId}`, {
              consumerState: p
            });
            return;
          }
          c.set(p.producerId, {
            consumerId: d,
            producingTransportId: h.producingTransportId,
            producingPeerId: h.producingPeerId,
            kind: h.kind,
            paused: h.pause,
            streamId: p.streamId,
            trackId: p.trackId,
            screenShare: h.screenShare,
            appData: {}
          });
        }), c;
      });
    }
  }
  class wg extends En {
    /**
     * @emits transportclose
     * @emits trackended
     * @emits @replacetrack - (track: MediaStreamTrack | null)
     * @emits @setmaxspatiallayer - (spatialLayer: string)
     * @emits @setrtpencodingparameters - (params: any)
     * @emits @getstats
     */
    constructor({
      id: e,
      localId: r,
      track: n,
      stopTracks: i,
      disableTrackOnPause: a,
      zeroRtpOnPause: c,
      handler: d,
      appData: p,
      rtpSender: h
    }) {
      super();
      // Id.
      f(this, "_id");
      // Local id.
      f(this, "_localId");
      // Closed flag.
      f(this, "_closed", false);
      // Associated RTCRtpSender.
      f(this, "_handler");
      // Local track.
      f(this, "_track");
      // Producer kind.
      f(this, "_kind");
      // Paused flag.
      f(this, "_paused");
      // Video max spatial layer.
      f(this, "_maxSpatialLayer");
      // Whether the Producer should call stop() in given tracks.
      f(this, "_stopTracks");
      // Whether the Producer should set track.enabled = false when paused.
      f(this, "_disableTrackOnPause");
      // Whether we should replace the RTCRtpSender.track with null when paused.
      f(this, "_zeroRtpOnPause");
      // custom data.
      f(this, "_appData");
      // Observer for external libs listen for few events
      f(this, "observer");
      // Associated transciever RTCRtpSender object
      f(this, "rtpSender");
      this._id = e, this._localId = r, this._track = n, this._kind = n.kind, this._paused = a ? !n.enabled : false, this._maxSpatialLayer = undefined, this._stopTracks = i, this._disableTrackOnPause = a, this._zeroRtpOnPause = c, this._appData = p || {}, this._onTrackEnded = this._onTrackEnded.bind(this), this._handler = d, this.rtpSender = h, this.observer = new En(), this._handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
      return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
      return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
      return this._kind;
    }
    /**
     * The associated track.
     */
    get track() {
      return this._track;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
      return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
      return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * Invalid setter.
     */
    // eslint-disable-next-line class-methods-use-this
    set appData(e) {
      throw new Error("cannot override appData object");
    }
    /**
     * Closes the Producer.
     */
    close(e) {
      return u(this, null, function* () {
        if (this._closed)
          return;
        if (l.debug("Producer::close() with reason:"), this._closed = true, this._destroyTrack(), e === Rl) {
          this.observer.emit("close");
          return;
        }
        const { offerSdp: r, callback: n } = yield this._handler.stopSending(this.localId);
        this.observer.emit("close");
        const { answer: i } = yield this.safeEmitAsPromise("close", { offer: r, reason: e });
        n(i);
      });
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    getStats() {
      return u(this, null, function* () {
        if (this._closed)
          throw new Xe("closed");
        return this._handler.getSenderStats(this.localId);
      });
    }
    /**
     * Pauses sending media.
     */
    pause() {
      l.debug("Producer::pause()", {
        producer: {
          id: this.id,
          appData: this.appData,
          kind: this.kind
        }
      }), this._closed && l.error("Producer::pause() | Producer closed", {
        producer: {
          id: this.id,
          appData: this.appData,
          kind: this.kind
        }
      }), this._paused = true, this._track && this._disableTrackOnPause && (this._track.enabled = false), this._zeroRtpOnPause && this._handler.replaceTrack(this.localId, null), this.observer.emit("pause");
    }
    /**
     * Resumes sending media.
     */
    resume() {
      if (l.debug("Producer::resume()", {
        producer: {
          id: this.id,
          appData: this.appData,
          kind: this.kind
        }
      }), this._closed) {
        l.error("Producer::resume() | Producer closed", {
          producer: {
            id: this.id,
            appData: this.appData,
            kind: this.kind
          }
        });
        return;
      }
      this._paused = false, this._track && this._disableTrackOnPause && (this._track.enabled = true), this._zeroRtpOnPause && this._handler.replaceTrack(this.localId, this._track), this.observer.emit("resume");
    }
    /**
     * Replaces the current track with a new one or null.
     */
    replaceTrack(r) {
      return u(this, arguments, function* ({
        track: e
      }) {
        if (l.debug("Producer::replaceTrack()", {
          producer: {
            id: this.id,
            appData: this.appData,
            kind: this.kind,
            trackId: e == null ? undefined : e.id
          }
        }), this._closed) {
          if (e && this._stopTracks)
            try {
              e.stop();
            } catch (n) {
              l.error("Producer::replaceTrack", {
                producer: {
                  id: this.id,
                  appData: this.appData,
                  kind: this.kind,
                  trackId: e == null ? undefined : e.id
                },
                error: n
              });
            }
          throw new Xe("closed");
        } else if (e && e.readyState === "ended")
          throw new Xe("track ended");
        if (e === this._track) {
          l.debug("replaceTrack() | same track, ignored", {
            producer: {
              id: this.id,
              appData: this.appData,
              kind: this.kind,
              trackId: e == null ? undefined : e.id
            }
          });
          return;
        }
        (!this._zeroRtpOnPause || !this._paused) && (yield this._handler.replaceTrack(this.localId, e)), this._destroyTrack(), this._track = e, this._handleTrack();
      });
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    setMaxSpatialLayer(e) {
      return u(this, null, function* () {
        if (this._closed)
          throw new Xe("closed");
        if (this._kind !== "video")
          throw new Cn("not a video Producer");
        if (typeof e != "number")
          throw new TypeError("invalid spatialLayer");
        yield this._handler.setMaxSpatialLayer(this.localId, e), this._maxSpatialLayer = e;
      });
    }
    /**
     * Sets the DSCP value.
     */
    setRtpEncodingParameters(e) {
      return u(this, null, function* () {
        if (this._closed)
          throw new Xe("closed");
        if (typeof e != "object")
          throw new TypeError("invalid params");
        yield this._handler.setRtpEncodingParameters(this.localId, e);
      });
    }
    _onTrackEnded() {
      l.debug('Producer::track "ended" event', {
        producer: {
          id: this.id,
          appData: this.appData,
          kind: this.kind,
          trackId: this.track.id
        }
      }), this.observer.emit("trackended"), this.safeEmit("trackended", this.track.id);
    }
    _handleTrack() {
      this._track && this._track.addEventListener("ended", this._onTrackEnded);
    }
    _destroyTrack() {
      var e;
      if (this._track)
        try {
          this._track.removeEventListener("ended", this._onTrackEnded), this._stopTracks && this._track.stop();
        } catch (r) {
          l.error("Producer::_destroyTrack", {
            producer: {
              id: this.id,
              appData: this.appData,
              kind: this.kind,
              trackId: (e = this._track) == null ? undefined : e.id
            },
            error: r
          });
        }
    }
  }
  let hM = class extends wg {
  }, mM = class extends Cg {
    consume(t) {
      return u(this, null, function* () {
        if (l.debug(`consume() producers: ${JSON.stringify(t)}`), this.closed)
          throw new Xe("closed");
        if (this.direction !== "recv")
          throw new Cn("not a receiving transport");
        if (this.listenerCount("connect") === 0 && this.connectionState === "new")
          throw new TypeError('no "connect" listener set into this transport');
        if (!(yield this.isConnected))
          throw new vg("transport not connected");
        let e;
        try {
          e = yield this.createConsumersOverDataChannel(t);
        } catch (n) {
          throw new yg(n.message);
        }
        const r = [];
        return e.forEach((n, i) => {
          const {
            consumerId: a,
            trackId: c,
            screenShare: d,
            paused: p,
            streamId: h,
            kind: m,
            appData: g,
            producingTransportId: T,
            producingPeerId: y
          } = n;
          r.push(
            this.consumerCreationTask({
              consumerId: a,
              trackId: c,
              streamId: h,
              kind: m,
              producerId: i,
              producingPeerId: y,
              producingTransportId: T,
              paused: p,
              screenShare: d,
              appData: g
            })
          );
        }), uc(r);
      });
    }
    connect() {
      return u(this, null, function* () {
        try {
          const { offerSdp: t, callback: e } = yield this.handler.connect(), { answer: r } = yield this.safeEmitAsPromise("connect", {
            offer: t
          });
          if (yield e(r), !(yield this.isConnected))
            throw new Error("ice connection failed");
          if (!(yield this.isEventsDCReady))
            throw new Error("events datachannel not open");
        } catch (t) {
          throw l.error("transport failed to connect:", t), t;
        }
      });
    }
    _ontrack(t) {
      const { track: e, transceiver: r, streams: n } = t;
      l.info(`track event received [trackId: ${e.id}]`);
      const i = `${n[0].id}:${e.kind}`;
      e.addEventListener("ended", () => {
        l.info(`rtc consumer track ended [trackId: ${e.id}]`), this.consumerTrackPool.delete(e.id), this.unknownTracksMap.delete(i);
      }), this.consumerTrackPool.set(e.id, [e, r]);
      const a = this.consumerTrackEvents.get(i);
      a ? (a(e, r), this.consumerTrackEvents.delete(i)) : (l.warn(`track event handler not found ${i}`), this.unknownTracksMap.set(i, t));
    }
    consumerCreationTask(m) {
      return u(this, arguments, function* ({
        consumerId: t,
        producerId: e,
        producingPeerId: r,
        producingTransportId: n,
        streamId: i,
        trackId: a,
        paused: c,
        screenShare: d,
        appData: p,
        kind: h
      }) {
        const g = `${i}:${h}`, T = {
          consumerId: t,
          producerId: e,
          producingPeerId: r,
          producingTransportId: n,
          streamId: i,
          trackId: a,
          appData: p,
          kind: h,
          paused: c,
          screenShare: d,
          name: "consumer creation task error",
          message: "consumer creation failed"
        };
        return new Promise((b, A) => {
          const I = setTimeout(() => {
            this.consumerTrackEvents.delete(g), T.isTimedout = true, A(T);
          }, 5e3), $ = (q, B) => {
            try {
              if (q.readyState === "ended")
                clearTimeout(I), A(T);
              else {
                const ne = q;
                ne.enabled = !0, this.handler.midTransceiverMap.set(B.mid, B);
                const Y = new lM({
                  id: t,
                  localId: B.mid,
                  track: ne,
                  paused: c,
                  producerId: e,
                  producingPeerId: r,
                  producingTransportId: n,
                  handler: this.handler,
                  appData: z(L({}, p), { screenShare: d, peerId: r }),
                  reuseTrack: !0,
                  rtpReceiver: B.receiver
                });
                this.consumers.set(t, Y), Y.once("close", () => {
                  this.consumers.delete(Y.id), this.handler.midTransceiverMap.delete(B.mid);
                }), l.info("consumer created for ", {
                  consumer: {
                    id: t,
                    kind: h,
                    appData: {
                      screenShare: d
                    },
                    peerId: r,
                    producerId: e
                  }
                }), this.observer.emit("newconsumer", Y), clearTimeout(I), b(Y);
              }
            } catch (ne) {
              l.warn("error while creating consumer:", ne), clearTimeout(I), A(T);
            }
          }, V = this.consumerTrackPool.get(t);
          if ((V == null ? undefined : V.length) === 2) {
            $(V[0], V[1]);
            return;
          }
          const O = this.unknownTracksMap.get(g);
          O ? (this.unknownTracksMap.delete(g), $(O.track, O.transceiver)) : this.consumerTrackEvents.set(g, $);
        });
      });
    }
    retryFailedConsumerCreationTasks(t) {
      return u(this, null, function* () {
        return uc(
          t.map(
            (e) => u(this, null, function* () {
              return wr((r) => u(this, null, function* () {
                return r > 0 && l.warn(`retrying failed consumer creation task: ${JSON.stringify(e)}`), this.consumerCreationTask(L({}, e));
              }));
            })
          )
        );
      });
    }
    /**
     * Create a Producer.
     */
    produce() {
      return u(this, arguments, function* ({
        track: t,
        encodings: e,
        codecOptions: r,
        stopTracks: n = true,
        disableTrackOnPause: i = true,
        zeroRtpOnPause: a = false,
        appData: c = {}
      } = {}) {
        if (l.debug(`produce() [track:${t.id}]`), t) {
          if (this.direction !== "send")
            throw new Cn("not a sending Transport");
          if (t.readyState === "ended")
            throw new Xe("track ended");
          if (this.listenerCount("connect") === 0 && this.connectionState === "new")
            throw new TypeError('no "connect" listener set into this transport');
          if (this.listenerCount("produce") === 0)
            throw new TypeError('no "produce" listener set into this transport');
          if (c && typeof c != "object")
            throw new TypeError("if given, appData must be an object");
        } else
          throw new TypeError("missing track");
        if (!(yield this.isConnected))
          return Promise.reject(new Error("Transport not connected"));
        const { producerId: d, localId: p, rtpSender: h } = yield this.awaitQueue.push(() => u(this, null, function* () {
          const {
            offerSdp: g,
            callback: T,
            sender: y,
            mid: b
          } = yield this.handler.send({
            track: t,
            encodings: e,
            codecOption: r,
            screenShare: c == null ? undefined : c.screenShare
          }), { answer: A, producerId: I } = yield this.safeEmitAsPromise(
            "produce",
            {
              offer: g,
              kind: t.kind,
              paused: i ? !t.enabled : false,
              appData: z(L({}, c || {}), { mid: b })
            }
          ), $ = yield T(A);
          return { producerId: I, localId: $, rtpSender: y };
        }), "producer"), m = new hM({
          id: d,
          localId: p,
          track: t,
          stopTracks: n,
          disableTrackOnPause: i,
          zeroRtpOnPause: a,
          appData: c,
          handler: this.handler,
          rtpSender: h
        });
        return this.producers.set(d, m), m.observer.on("close", () => {
          this.producers.delete(m.id);
        }), this.emit("newproducer", m), this.observer.emit("newproducer", m), m;
      });
    }
  };
  class lu extends En {
    // eslint-disable-next-line no-useless-constructor
    constructor() {
      super();
      // Map of RTCTransceivers indexed by MID.
      f(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      f(this, "_enableHighBitrate", false);
      f(this, "_enableStereo", false);
      this._mapMidTransceiver = /* @__PURE__ */ new Map(), this._enableHighBitrate = false;
    }
    get midTransceiverMap() {
      return this._mapMidTransceiver;
    }
  }
  class uu extends lu {
    // eslint-disable-next-line no-useless-constructor
    constructor() {
      super();
      // Handler direction.
      f(this, "_direction");
      // RTCPeerConnection instance.
      f(this, "_pc");
      // Local stream for sending general media tracks.
      f(this, "_sendWebStream", new MediaStream());
      // Local stream for sending screenshare tracks.
      f(this, "_sendScreenShareStream", new MediaStream());
      // Got transport local and remote parameters.
      f(this, "_transportReady", false);
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return () => new uu();
    }
    // eslint-disable-next-line class-methods-use-this
    get name() {
      return "Chrome74";
    }
    get pc() {
      return this._pc;
    }
    close() {
      if (l.debug("close()"), this._pc)
        try {
          this._pc.close();
        } catch (e) {
          l.error("pc.close()", e);
        }
    }
    init({
      direction: e,
      iceServers: r,
      iceTransportPolicy: n,
      additionalSettings: i,
      proprietaryConstraints: a,
      onTrackHandler: c
    }) {
      this._direction = e, this._pc = new RTCPeerConnection(
        L({
          iceServers: r || [],
          iceTransportPolicy: n || "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          sdpSemantics: "unified-plan"
        }, i),
        a
      ), c && this._pc.addEventListener("track", (d) => {
        c(d);
      }), this._addEventListeners();
    }
    connect() {
      return u(this, null, function* () {
        const e = this._pc.createDataChannel("dyte"), r = yield this._pc.createOffer();
        return l.info(`connect offer: ${JSON.stringify(r)}`), yield this._pc.setLocalDescription(r), {
          offerSdp: r,
          callback: (i) => u(this, null, function* () {
            l.debug(`Chrome74::connect() | calling pc.setRemoteDescription() [answer:${JSON.stringify(i)}]`), yield this._pc.setRemoteDescription(i), e.close();
          })
        };
      });
    }
    updateIceServers(e) {
      return u(this, null, function* () {
        l.debug("updateIceServers()");
        const r = this._pc.getConfiguration();
        r.iceServers = e, this._pc.setConfiguration(r);
      });
    }
    restartIce() {
      return u(this, null, function* () {
        l.debug("restartIce()");
        const e = yield this.pc.createOffer({
          iceRestart: true
        });
        return l.debug(`restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), {
          offerSdp: e,
          callback: (n) => u(this, null, function* () {
            l.info(`restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`), yield this._pc.setRemoteDescription(n);
          })
        };
      });
    }
    getTransportStats() {
      return u(this, null, function* () {
        return this._pc.getStats();
      });
    }
    send(a) {
      return u(this, arguments, function* ({
        track: e,
        encodings: r,
        codecOption: n,
        screenShare: i
      }) {
        var h;
        this._assertSendDirection(), l.debug(`send() [kind:${e.kind}, track.id:${e.id}]`);
        const c = this._pc.addTransceiver(e, {
          direction: "sendonly",
          streams: [
            i ? this._sendScreenShareStream : this._sendWebStream
          ],
          sendEncodings: r
        });
        if (!navigator.isReactNative) {
          l.debug("creating new transceiver");
          const m = RTCRtpSender.getCapabilities(e.kind);
          l.info(`senders available params: ${JSON.stringify(m)}`);
          const g = [];
          if (n) {
            const T = m.codecs.find(
              (y) => y.mimeType.includes(n.name)
            );
            if (n.parameters) {
              l.info(`codecOption.parameters:${JSON.stringify(n.parameters)}`);
              const y = ((h = T.sdpFmtpLine) == null ? undefined : h.split(";")) || [];
              y.push(...n.parameters);
              const b = Array.from(new Set(y).values());
              T.sdpFmtpLine = b.join(";");
            }
            g.push(T);
          }
          l.info(`selected codecs: ${JSON.stringify(g)}`), c.setCodecPreferences(g);
        }
        const d = yield this._pc.createOffer();
        if (!this._transportReady)
          throw new Error("webrtc transport not connected");
        if (yield this._pc.setLocalDescription(d), n && n.name === "opus") {
          const m = this._enableStereo, g = this._enableHighBitrate ? m ? 128e3 : 64e3 : m ? 64e3 : 32e3;
          d.sdp = d.sdp.replace(
            "minptime=10;useinbandfec=1",
            `minptime=10;useinbandfec=1;usedtx=1${m ? "" : ";stereo=1;sprop-stereo=1"};maxaveragebitrate=${g}`
          ), d.sdp += `a=rtcp-fb:111 nack\r
`;
        }
        return {
          offerSdp: d,
          callback: (m) => u(this, null, function* () {
            return l.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(m)}]`), yield this._pc.setRemoteDescription(m), this.midTransceiverMap.set(c.mid, c), c.mid;
          }),
          sender: c.sender,
          mid: c.mid
        };
      });
    }
    stopSending(e) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`stopSending() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.sender.replaceTrack(null), this._pc.removeTrack(r.sender), r.direction = "inactive";
        const n = yield this._pc.createOffer();
        return l.debug(`stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a), this.midTransceiverMap.delete(e);
          })
        };
      });
    }
    replaceTrack(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), r ? l.debug(`replaceTrack() [localId:${e}, track.id:${r.id}]`) : l.debug(`replaceTrack() [localId:${e}, no track]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        yield n.sender.replaceTrack(r);
      });
    }
    setMaxSpatialLayer(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters();
        i.encodings.forEach(
          (a, c) => {
            c <= r ? a.active = true : a.active = false;
          }
        ), yield n.sender.setParameters(i);
      });
    }
    setRtpEncodingParameters(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters();
        i.encodings.forEach(
          (a, c) => {
            i.encodings[c] = L(L({}, a), r);
          }
        ), yield n.sender.setParameters(i);
      });
    }
    getSenderStats(e) {
      this._assertSendDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.sender.getStats();
    }
    stopReceiving(e) {
      return u(this, null, function* () {
        throw this._assertRecvDirection(), l.debug(`stopReceiving() [localId:${e}]`), Error("method not implemented");
      });
    }
    pauseReceiving(e) {
      return u(this, null, function* () {
        throw this._assertRecvDirection(), l.debug(`pauseReceiving() [localId:${e}]`), Error("method not implemented");
      });
    }
    resumeReceiving(e) {
      return u(this, null, function* () {
        throw this._assertRecvDirection(), l.debug(`resumeReceiving() [localId:${e}]`), Error("method not implemented");
      });
    }
    getReceiverStats(e) {
      return u(this, null, function* () {
        this._assertRecvDirection();
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        return r.receiver.getStats();
      });
    }
    _assertSendDirection() {
      if (this._direction !== "send")
        throw new Error(
          'method can just be called for handlers with "send" direction'
        );
    }
    _assertRecvDirection() {
      if (this._direction !== "recv")
        throw new Error(
          'method can just be called for handlers with "recv" direction'
        );
    }
    _generateOffer() {
      return u(this, null, function* () {
        const e = yield this._pc.createOffer();
        return yield this._pc.setLocalDescription(e), e;
      });
    }
    _setAnswer(e) {
      return u(this, null, function* () {
        l.debug(`setAnswer() | calling pc.setRemoteDescription() [answer:${JSON.stringify(e)}]`), yield this._pc.setRemoteDescription(e);
      });
    }
    _addEventListeners() {
      this._pc.addEventListener("iceconnectionstatechange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking":
            this.emit("@connectionstatechange", "connecting");
            break;
          case "connected":
          case "completed":
            this.emit("@connectionstatechange", "connected"), this._transportReady = true;
            break;
          case "failed":
            this.emit("@connectionstatechange", "failed");
            break;
          case "disconnected":
            this.emit("@connectionstatechange", "disconnected");
            break;
          case "closed":
            this.emit("@connectionstatechange", "closed");
            break;
          default:
            l.warn("unknown state");
            break;
        }
      }), this._pc.addEventListener(
        "icecandidate",
        (e) => {
          e.candidate && this.emit("@icecandidate", {
            candidate: e.candidate
          });
        }
      ), this._pc.addEventListener("negotiationneeded", () => {
        this.emit("@negotiationneeded", {}), l.debug("negotiationneeded");
      }), this._pc.addEventListener("icegatheringstatechange", () => {
        switch (this._pc.iceGatheringState) {
          case "gathering":
            l.debug("icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
            break;
          case "complete":
            l.debug("icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
            break;
          default:
            l.warn("unknown state");
            break;
        }
      }), this._pc.addEventListener("icecandidateerror", (e) => {
        l.error("icecandidateerror", {
          error: {
            code: e.errorCode,
            message: e.errorText
          }
        });
      }), this._pc.addEventListener("datachannel", (e) => {
        l.info("data channel created: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
        const { channel: r } = e;
        r.onopen = () => {
          l.info("data channel open: ", {
            rtcChannel: {
              label: e.channel.label
            }
          }), this.safeEmit("dc_open", e.channel);
        }, r.onclose = () => {
          l.warn("data channel closed: ", {
            rtcChannel: {
              label: e.channel.label
            }
          });
        }, r.onerror = () => {
          l.error("data channel error: ", {
            rtcChannel: {
              label: e.channel.label
            }
            // error: error as unknown as LogData, // Need to fix this, where to get message, reason
          });
        }, r.onmessage = (n) => {
          this.safeEmit(
            "datachannel",
            e.channel,
            String.fromCharCode(...new Uint8Array(n.data))
          );
        };
      });
    }
  }
  class hc extends lu {
    // eslint-disable-next-line no-useless-constructor
    constructor(e) {
      super();
      // Handler direction.
      f(this, "_direction");
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      // TODO: fixme
      // private _forcedLocalDtlsRole?: DtlsRole;
      // RTCPeerConnection instance.
      f(this, "_pc");
      // Local stream for sending general media tracks.
      f(this, "_sendWebStream", new MediaStream());
      // Local stream for sending screenshare tracks.
      f(this, "_sendScreenShareStream", new MediaStream());
      // Got transport local and remote parameters.
      f(this, "_transportReady", false);
      f(this, "supportsSendEncodings", false);
      this.supportsSendEncodings = e.supportsSendEncodings;
    }
    /**
     * Creates a factory function.
     */
    static createFactory(e) {
      return () => new hc(e);
    }
    // eslint-disable-next-line class-methods-use-this
    get name() {
      return "Firefox60";
    }
    get pc() {
      return this._pc;
    }
    close() {
      if (l.debug("Firefox60::close()"), this._pc)
        try {
          this._pc.close();
        } catch (e) {
          l.error("Firefox60::pc.close()", { error: e });
        }
    }
    init({
      direction: e,
      iceServers: r,
      iceTransportPolicy: n,
      additionalSettings: i,
      proprietaryConstraints: a,
      onTrackHandler: c
    }) {
      l.debug("Firefox60::init()"), this._direction = e, this._pc = new RTCPeerConnection(
        L({
          iceServers: r || [],
          iceTransportPolicy: n || "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require"
        }, i),
        a
      ), c && this._pc.addEventListener("track", (d) => {
        c(d);
      }), this._addEventListeners();
    }
    connect() {
      return u(this, null, function* () {
        const e = this._pc.createDataChannel("dyte"), r = yield this._pc.createOffer();
        return l.info(`Firefox60::connect offer: ${JSON.stringify(r)}`), yield this._pc.setLocalDescription(r), {
          offerSdp: r,
          callback: (i) => u(this, null, function* () {
            l.debug(`Firefox60::connect() | calling pc.setRemoteDescription() [answer:${JSON.stringify(i)}]`), yield this._pc.setRemoteDescription(i), e.close();
          })
        };
      });
    }
    // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
    updateIceServers(e) {
      return u(this, null, function* () {
        throw l.debug("Firefox60::updateIceServers()"), new Error("not supported");
      });
    }
    restartIce() {
      return u(this, null, function* () {
        l.debug("Firefox60::restartIce()");
        const e = yield this.pc.createOffer({
          iceRestart: true
        });
        return l.debug(`Firefox60::restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`), {
          offerSdp: e,
          callback: (n) => u(this, null, function* () {
            l.info(`Firefox60::restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`), yield this._pc.setRemoteDescription(n);
          })
        };
      });
    }
    getTransportStats() {
      return u(this, null, function* () {
        return this._pc.getStats();
      });
    }
    send(i) {
      return u(this, arguments, function* ({
        track: e,
        encodings: r,
        screenShare: n
      }) {
        this._assertSendDirection(), l.debug(`Firefox60::send() [kind:${e.kind}, track.id:${e.id}]`), l.debug("Firefox60::creating new transceiver");
        const a = this.supportsSendEncodings && r !== undefined ? { sendEncodings: r } : {}, c = this._pc.addTransceiver(e, L({
          direction: "sendonly",
          streams: [
            n ? this._sendScreenShareStream : this._sendWebStream
          ]
        }, a));
        if (!this.supportsSendEncodings && r) {
          r.reverse();
          const h = c.sender.getParameters();
          h.encodings = r, yield c.sender.setParameters(h);
        }
        const d = yield this._pc.createOffer();
        if (!this._transportReady)
          throw new Error("webrtc transport not connected");
        if (yield this._pc.setLocalDescription(d), e.kind === "audio") {
          const h = this._enableStereo, m = this._enableHighBitrate ? h ? 128e3 : 64e3 : h ? 64e3 : 32e3;
          d.sdp = d.sdp.replace(
            "minptime=10;useinbandfec=1",
            `minptime=10;useinbandfec=1;usedtx=1${this.supportsSendEncodings ? "" : `${h ? "" : ";stereo=1;sprop-stereo=1"};maxaveragebitrate=${m}`}`
          );
        }
        return {
          offerSdp: d,
          callback: (h) => u(this, null, function* () {
            return l.debug(`send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(h)}]`), yield this._pc.setRemoteDescription(h), this.midTransceiverMap.set(c.mid, c), c.mid;
          }),
          sender: c.sender,
          mid: c.mid
        };
      });
    }
    stopSending(e) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`Firefox60::stopSending() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated transceiver not found");
        r.sender.replaceTrack(null), this._pc.removeTrack(r.sender), r.direction = "inactive";
        const n = yield this._pc.createOffer();
        return l.debug(`stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a), this.midTransceiverMap.delete(e);
          })
        };
      });
    }
    replaceTrack(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), r ? l.debug(`replaceTrack() [localId:${e}, track.id:${r.id}]`) : l.debug(`Firefox60::replaceTrack() [localId:${e}, no track]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        yield n.sender.replaceTrack(r);
      });
    }
    setMaxSpatialLayer(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters(), a = i.encodings.length - 1 - r;
        i.encodings.forEach(
          (c, d) => {
            d >= a ? c.active = true : c.active = false;
          }
        ), yield n.sender.setParameters(i);
      });
    }
    setRtpEncodingParameters(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters();
        i.encodings.forEach(
          (a, c) => {
            i.encodings[c] = L(L({}, a), r);
          }
        ), yield n.sender.setParameters(i);
      });
    }
    getSenderStats(e) {
      this._assertSendDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.sender.getStats();
    }
    stopReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Firefox60::stopReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "inactive", l.info(`Firefox60::active transcievers: ${JSON.stringify(this._pc.getTransceivers())}`);
        const n = yield this._pc.createOffer();
        return l.debug(`Firefox60::stopRecieving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`Firefox60::stopRecieving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a), this.midTransceiverMap.delete(e);
          })
        };
      });
    }
    pauseReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Firefox60::pauseReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "inactive";
        const n = yield this._pc.createOffer();
        return l.debug(`pauseReceiving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`pauseReceiving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a);
          })
        };
      });
    }
    resumeReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Firefox60::resumeReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "recvonly";
        const n = yield this._generateOffer();
        return l.debug(`resumeReceiving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`resumeReceiving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a);
          })
        };
      });
    }
    getReceiverStats(e) {
      return u(this, null, function* () {
        this._assertRecvDirection();
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        return r.receiver.getStats();
      });
    }
    _assertSendDirection() {
      if (this._direction !== "send")
        throw new Error(
          'method can just be called for handlers with "send" direction'
        );
    }
    _assertRecvDirection() {
      if (this._direction !== "recv")
        throw new Error(
          'method can just be called for handlers with "recv" direction'
        );
    }
    _generateOffer() {
      return u(this, null, function* () {
        const e = yield this._pc.createOffer();
        return yield this._pc.setLocalDescription(e), e;
      });
    }
    _setAnswer(e) {
      return u(this, null, function* () {
        l.debug(`_setAnswer() | calling pc.setRemoteDescription() [answer:${JSON.stringify(e)}]`), yield this._pc.setRemoteDescription(e);
      });
    }
    _addEventListeners() {
      this._pc.addEventListener("datachannel", (e) => {
        l.info("Firefox60::data channel created: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
        const { channel: r } = e;
        r.onopen = () => {
          l.info("Firefox60::data channel open: ", {
            rtcChannel: {
              label: e.channel.label
            }
          }), this.safeEmit("dc_open", e.channel);
        }, r.onclose = () => {
          l.warn("data channel closed: ", {
            rtcChannel: {
              label: e.channel.label
            }
          });
        }, r.onerror = () => {
          l.error("Firefox60::data channel error: ", {
            rtcChannel: {
              label: e.channel.label
            }
            // error: error as unknown as LogData, // Need to fix this, where to get message, reason
          });
        }, r.onmessage = (n) => u(this, null, function* () {
          const i = yield n.data.arrayBuffer();
          this.safeEmit(
            "datachannel",
            e.channel,
            String.fromCharCode(...new Uint8Array(i))
          );
        });
      }), this._pc.addEventListener("iceconnectionstatechange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking":
            this.emit("@connectionstatechange", "connecting");
            break;
          case "connected":
          case "completed":
            this.emit("@connectionstatechange", "connected"), this._transportReady = true;
            break;
          case "failed":
            this.emit("@connectionstatechange", "failed");
            break;
          case "disconnected":
            this.emit("@connectionstatechange", "disconnected");
            break;
          case "closed":
            this.emit("@connectionstatechange", "closed");
            break;
          default:
            l.warn("unknown state");
            break;
        }
      }), this._pc.addEventListener(
        "icecandidate",
        (e) => {
          e.candidate && this.emit("@icecandidate", {
            candidate: e.candidate
          });
        }
      ), this._pc.addEventListener("negotiationneeded", () => {
        this.emit("@negotiationneeded", {}), l.debug("Firefox60::negotiationneeded");
      }), this._pc.addEventListener("icegatheringstatechange", () => {
        switch (this._pc.iceGatheringState) {
          case "gathering":
            l.debug("Firefox60::icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
            break;
          case "complete":
            l.debug("Firefox60::icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
            break;
          default:
            l.warn("unknown state");
            break;
        }
      }), this._pc.addEventListener("icecandidateerror", (e) => {
        l.error("icecandidateerror", {
          error: {
            code: e.errorCode,
            message: e.errorText
          }
        });
      });
    }
  }
  class pu extends lu {
    // eslint-disable-next-line no-useless-constructor
    constructor() {
      super();
      // Handler direction.
      f(this, "_direction");
      // RTCPeerConnection instance.
      f(this, "_pc");
      // Local stream for sending general media tracks.
      f(this, "_sendWebStream", new MediaStream());
      // Local stream for sending screenshare tracks.
      f(this, "_sendScreenShareStream", new MediaStream());
      // Got transport local and remote parameters.
      f(this, "_transportReady", false);
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return () => new pu();
    }
    // eslint-disable-next-line class-methods-use-this
    get name() {
      return "Chrome74";
    }
    get pc() {
      return this._pc;
    }
    close() {
      if (l.debug("Safari12::close()"), this._pc)
        try {
          this._pc.close();
        } catch (e) {
          l.error("Safari12::pc.close()", e);
        }
    }
    init({
      direction: e,
      iceServers: r,
      iceTransportPolicy: n,
      additionalSettings: i,
      proprietaryConstraints: a,
      onTrackHandler: c
    }) {
      l.debug("Safari12::init()"), this._direction = e, this._pc = new RTCPeerConnection(
        L({
          iceServers: r || [],
          iceTransportPolicy: n || "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require"
        }, i),
        a
      ), c && this._pc.addEventListener("track", (d) => {
        c(d);
      }), this._addEventListeners();
    }
    connect() {
      return u(this, null, function* () {
        const e = this._pc.createDataChannel("dyte"), r = yield this._pc.createOffer();
        return l.info(`Safari12::connect offer: ${JSON.stringify(r)}`), yield this._pc.setLocalDescription(r), {
          offerSdp: r,
          callback: (i) => u(this, null, function* () {
            l.debug(
              `Safari12::connect() | calling pc.setRemoteDescription() [answer: ${JSON.stringify(i)}]`
            ), yield this._pc.setRemoteDescription(i), e.close();
          })
        };
      });
    }
    updateIceServers(e) {
      return u(this, null, function* () {
        l.debug("Safari12::updateIceServers()");
        const r = this._pc.getConfiguration();
        r.iceServers = e, this._pc.setConfiguration(r);
      });
    }
    restartIce() {
      return u(this, null, function* () {
        l.debug("Safari12::restartIce()");
        const e = yield this.pc.createOffer({
          iceRestart: true
        });
        return l.debug(
          `restartIce() | calling pc.setLocalDescription() [offer:${JSON.stringify(e)}]`
        ), {
          offerSdp: e,
          callback: (n) => u(this, null, function* () {
            l.info(
              `restartIce() | calling pc.setRemoteDescription() [answer:${JSON.stringify(n)}]`
            ), yield this._pc.setRemoteDescription(n);
          })
        };
      });
    }
    getTransportStats() {
      return u(this, null, function* () {
        return this._pc.getStats();
      });
    }
    send(a) {
      return u(this, arguments, function* ({
        track: e,
        encodings: r,
        codecOption: n,
        screenShare: i
      }) {
        var g;
        this._assertSendDirection(), l.debug(`Safari12::send() [kind: ${e.kind}, track.id: ${e.id}]`), l.debug("Safari12::creating new transceiver");
        const c = this._pc.addTransceiver(e, {
          direction: "sendonly",
          streams: [
            i ? this._sendScreenShareStream : this._sendWebStream
          ],
          sendEncodings: r
        }), d = RTCRtpSender.getCapabilities(e.kind);
        l.info(`Safari12::senders available params: ${JSON.stringify(d)}`);
        const p = [];
        if (n) {
          const T = d.codecs.find(
            (y) => y.mimeType.includes(n.name)
          );
          if (n.parameters) {
            l.info(`Safari12::codecOption.parameters:, ${JSON.stringify(n.parameters)}`);
            const y = ((g = T.sdpFmtpLine) == null ? undefined : g.split(";")) || [];
            y.push(...n.parameters);
            const b = [...new Set(y).values()];
            T.sdpFmtpLine = b.join(";");
          }
          p.push(T);
        }
        l.info(`Safari12::selected codecs: ${JSON.stringify(p)}`), c.setCodecPreferences(p);
        const h = yield this._pc.createOffer();
        if (!this._transportReady)
          throw new Error("webrtc transport not connected");
        if (yield this._pc.setLocalDescription(h), e.kind === "audio") {
          const T = this._enableStereo, y = this._enableHighBitrate ? T ? 128e3 : 64e3 : T ? 64e3 : 32e3;
          h.sdp = h.sdp.replace(
            "minptime=10;useinbandfec=1",
            `minptime=10;useinbandfec=1;usedtx=1${T ? "" : ";stereo=1;sprop-stereo=1"};maxaveragebitrate=${y}`
          );
        }
        return {
          offerSdp: h,
          callback: (T) => u(this, null, function* () {
            return l.debug(
              `Safari12::send() | calling pc.setRemoteDescription() [answer:${JSON.stringify(T)}]`
            ), yield this._pc.setRemoteDescription(T), this.midTransceiverMap.set(c.mid, c), c.mid;
          }),
          sender: c.sender,
          mid: c.mid
        };
      });
    }
    stopSending(e) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`Safari12::stopSending() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.sender.replaceTrack(null), this._pc.removeTrack(r.sender), r.direction = "inactive";
        const n = yield this._pc.createOffer();
        return l.debug(`Safari12::stopSending() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`Safari12::stopSending() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a), this.midTransceiverMap.delete(e);
          })
        };
      });
    }
    replaceTrack(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), r ? l.debug(`Safari12::replaceTrack() [localId:${e}, track.id:${r.id}]`) : l.debug(`Safari12::replaceTrack() [localId:${e}, no track]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        yield n.sender.replaceTrack(r);
      });
    }
    setMaxSpatialLayer(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setMaxSpatialLayer() [localId:${e}, spatialLayer:${r}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters();
        i.encodings.forEach(
          (a, c) => {
            c <= r ? a.active = true : a.active = false;
          }
        ), yield n.sender.setParameters(i);
      });
    }
    setRtpEncodingParameters(e, r) {
      return u(this, null, function* () {
        this._assertSendDirection(), l.debug(`setRtpEncodingParameters() [localId:${e}, params:${JSON.stringify(r)}]`);
        const n = this.midTransceiverMap.get(e);
        if (!n)
          throw new Error("associated RTCRtpTransceiver not found");
        const i = n.sender.getParameters();
        i.encodings.forEach(
          (a, c) => {
            i.encodings[c] = L(L({}, a), r);
          }
        ), yield n.sender.setParameters(i);
      });
    }
    getSenderStats(e) {
      this._assertSendDirection();
      const r = this.midTransceiverMap.get(e);
      if (!r)
        throw new Error("associated RTCRtpTransceiver not found");
      return r.sender.getStats();
    }
    receive(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`recieve() | calling pc.setLocalDescription() [answer:${JSON.stringify(e)}]`);
        const r = this._pc.getTransceivers().at(-1);
        return l.info(
          "Safari12::Transceiver is now receiving"
          // trans,
          // this._pc.getTransceivers(),
        ), this.midTransceiverMap.set(r.mid, r), {
          track: r.receiver.track,
          localId: r.mid
        };
      });
    }
    stopReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Safari12::stopReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "inactive", l.info(`Safari12::active transcievers: ${JSON.stringify(this._pc.getTransceivers())}`);
        const n = yield this._pc.createOffer();
        return l.debug(`stopRecieving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`stopRecieving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a), this.midTransceiverMap.delete(e);
          })
        };
      });
    }
    pauseReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Safari12::pauseReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "inactive";
        const n = yield this._pc.createOffer();
        return l.debug(`pauseReceiving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), yield this._pc.setLocalDescription(n), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`pauseReceiving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a);
          })
        };
      });
    }
    resumeReceiving(e) {
      return u(this, null, function* () {
        this._assertRecvDirection(), l.debug(`Safari12::resumeReceiving() [localId:${e}]`);
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        r.direction = "recvonly";
        const n = yield this._generateOffer();
        return l.debug(`Safari12::resumeReceiving() | calling pc.setLocalDescription() [offer:${JSON.stringify(n)}]`), {
          offerSdp: n,
          callback: (a) => u(this, null, function* () {
            l.debug(`Safari12::resumeReceiving() | calling pc.setRemoteDescription() [answer:${JSON.stringify(a)}]`), yield this._pc.setRemoteDescription(a);
          })
        };
      });
    }
    getReceiverStats(e) {
      return u(this, null, function* () {
        this._assertRecvDirection();
        const r = this.midTransceiverMap.get(e);
        if (!r)
          throw new Error("associated RTCRtpTransceiver not found");
        return r.receiver.getStats();
      });
    }
    _assertSendDirection() {
      if (this._direction !== "send")
        throw new Error(
          'method can just be called for handlers with "send" direction'
        );
    }
    _assertRecvDirection() {
      if (this._direction !== "recv")
        throw new Error(
          'method can just be called for handlers with "recv" direction'
        );
    }
    _generateOffer() {
      return u(this, null, function* () {
        const e = yield this._pc.createOffer();
        return yield this._pc.setLocalDescription(e), e;
      });
    }
    _setAnswer(e) {
      return u(this, null, function* () {
        l.debug(`Safari12::_setAnswer() | calling pc.setRemoteDescription() [answer:${JSON.stringify(e)}]`), yield this._pc.setRemoteDescription(e);
      });
    }
    _addEventListeners() {
      this._pc.addEventListener("iceconnectionstatechange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking":
            this.emit("@connectionstatechange", "connecting");
            break;
          case "connected":
          case "completed":
            this.emit("@connectionstatechange", "connected"), this._transportReady = true;
            break;
          case "failed":
            this.emit("@connectionstatechange", "failed");
            break;
          case "disconnected":
            this.emit("@connectionstatechange", "disconnected");
            break;
          case "closed":
            this.emit("@connectionstatechange", "closed");
            break;
          default:
            l.warn("Safari12::unknown state");
            break;
        }
      }), this._pc.addEventListener(
        "icecandidate",
        (e) => {
          e.candidate && this.emit("@icecandidate", {
            candidate: e.candidate
          });
        }
      ), this._pc.addEventListener("negotiationneeded", () => {
        this.emit("@negotiationneeded", {}), l.debug("Safari12::negotiationneeded");
      }), this._pc.addEventListener("icegatheringstatechange", () => {
        switch (this._pc.iceGatheringState) {
          case "gathering":
            l.debug("Safari12::icegatheringstatechange | gathering"), this.emit("@icegatheringstatechange", "gathering");
            break;
          case "complete":
            l.debug("Safari12::icegatheringstatechange | complete"), this.emit("@icegatheringstatechange", "complete");
            break;
          default:
            l.warn("Safari12::unknown state");
            break;
        }
      }), this._pc.addEventListener("icecandidateerror", (e) => {
        l.error("icecandidateerror", {
          error: {
            code: e.errorCode,
            message: e.errorText
          }
        });
      }), this._pc.ondatachannel = (e) => {
        l.info("Safari12::data channel created: ", {
          rtcChannel: {
            label: e.channel.label
          }
        });
        const { channel: r } = e;
        r.onopen = () => {
          l.info("Safari12::data channel open: ", {
            rtcChannel: {
              label: e.channel.label
            }
          }), this.safeEmit("dc_open", e.channel);
        }, r.onclose = () => {
          l.warn("Safari12::data channel closed: ", {
            rtcChannel: {
              label: e.channel.label
            }
          });
        }, r.onerror = () => {
          l.error("Safari12::data channel error: ", {
            rtcChannel: {
              label: e.channel.label
            }
            // error: error as unknown as LogData, // Need to fix this, where to get message, reason
          });
        }, r.onmessage = (n) => u(this, null, function* () {
          const i = String.fromCharCode(
            ...new Uint8Array(n.data)
          );
          this.safeEmit("datachannel", e.channel, i);
        });
      };
    }
  }
  function fM() {
    if (typeof navigator == "object" && navigator.product === "ReactNative") {
      if (typeof RTCPeerConnection == "undefined") {
        l.warn(
          "Device::this._detectDevice() | unsupported ReactNative without RTCPeerConnection"
        );
        return;
      }
      return l.debug("Device::this._detectDevice() | ReactNative handler chosen"), "Chrome74";
    }
    if (typeof navigator == "object" && typeof navigator.userAgent == "string") {
      const s = navigator.userAgent, t = Bowser.getParser(s), e = t.getEngine();
      if (t.satisfies({
        chrome: ">=74",
        chromium: ">=74",
        "microsoft edge": ">=88"
      }))
        return "Chrome74";
      if (t.satisfies({ chrome: ">=70", chromium: ">=70" }))
        return "Chrome70";
      if (t.satisfies({ chrome: ">=67", chromium: ">=67" }))
        return "Chrome67";
      if (t.satisfies({ chrome: ">=55", chromium: ">=55" }))
        return "Chrome55";
      if (t.satisfies({ firefox: ">=110" }))
        return "Firefox110";
      if (t.satisfies({ firefox: ">=60" }))
        return "Firefox60";
      if (t.satisfies({ ios: { OS: ">=14.3", firefox: ">=30.0" } }) || t.satisfies({ safari: ">=12.0" }) && typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection"))
        return "Safari12";
      if (t.satisfies({ safari: ">=11" }))
        return "Safari11";
      if (t.satisfies({ "microsoft edge": ">=11" }) && t.satisfies({ "microsoft edge": "<=18" }))
        return "Edge11";
      if (e.name && e.name.toLowerCase() === "blink") {
        const r = s.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
        if (r) {
          const n = Number(r[1]);
          return n >= 74 ? "Chrome74" : n >= 70 ? "Chrome70" : n >= 67 ? "Chrome67" : "Chrome55";
        }
        return "Chrome74";
      }
      if (e.name.toLowerCase() === "webkit" && t.getOS().name.toLowerCase() === "ios")
        return typeof RTCRtpTransceiver != "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") ? "Safari12" : "Safari11";
      l.warn("Device::this._detectDevice() | browser not supported");
      return;
    }
    l.warn("Device::this._detectDevice() | unknown device");
  }
  class Pg {
    constructor({ handlerName: t, handlerFactory: e } = {}) {
      // RTC handler factory.
      f(this, "handlerFactory");
      // Handler name.
      f(this, "_handlerName");
      // observer
      f(this, "_observer");
      if (l.debug("constructor()"), t && e)
        throw new TypeError(
          "just one of handlerName or handlerInterface can be given"
        );
      if (e)
        this.handlerFactory = e;
      else {
        if (t)
          l.debug(`Device::constructor() | handler given: ${t}`);
        else if (t = fM(), t)
          l.debug(`Device::constructor() | detected handler: ${t}`);
        else
          throw new Error("device not supported");
        switch (t) {
          case "Chrome74":
            this.handlerFactory = uu.createFactory();
            break;
          case "Safari12":
            this.handlerFactory = pu.createFactory();
            break;
          case "Firefox60":
            this.handlerFactory = hc.createFactory({ supportsSendEncodings: false });
            break;
          case "Firefox110":
            this.handlerFactory = hc.createFactory({ supportsSendEncodings: true });
            break;
          default:
            throw new TypeError(`unknown handlerName "${t}"`);
        }
      }
      const r = this.handlerFactory();
      this._handlerName = r.name, r.close(), this._observer = new at();
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
      return this._handlerName;
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({
      iceServers: t,
      iceTransportPolicy: e,
      additionalSettings: r,
      proprietaryConstraints: n,
      appData: i,
      config: a
    }) {
      return l.debug("Device::createSendTransport()"), this.createTransport({
        direction: "send",
        iceServers: t,
        iceTransportPolicy: e,
        additionalSettings: r,
        proprietaryConstraints: n,
        appData: i,
        config: a
      });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({
      iceServers: t,
      iceTransportPolicy: e,
      additionalSettings: r,
      proprietaryConstraints: n,
      appData: i
    }) {
      return l.debug("Device::createRecvTransport()"), this.createTransport({
        direction: "recv",
        iceServers: t,
        iceTransportPolicy: e,
        additionalSettings: r,
        proprietaryConstraints: n,
        appData: i
      });
    }
  }
  let gM = class extends Pg {
    createTransport({
      direction: t,
      iceServers: e,
      iceTransportPolicy: r,
      additionalSettings: n,
      proprietaryConstraints: i,
      appData: a,
      config: c
    }) {
      const d = v4(), p = new mM({
        id: d,
        direction: t,
        iceServers: e,
        iceTransportPolicy: r,
        additionalSettings: n,
        proprietaryConstraints: i,
        appData: a,
        handlerFactory: this.handlerFactory,
        config: c
      });
      return this._observer.emit("newtransport", p), p;
    }
  };
  var pt;
  class vM {
    constructor(t) {
      E(this, pt, undefined);
      _(this, pt, t);
    }
    joinRoom(t, e, r = false, n = null) {
      return u(this, null, function* () {
        const i = {
          roomUuid: t,
          displayName: e,
          prejoined: r
        };
        return n && (i.location = n), (yield o(this, pt).sendMessagePromiseWithTimeout({
          event: ae.joinRoom,
          protobuf: vf.toBinary(i),
          timeout: 5e3
        })).payload;
      });
    }
    connectTransport(t) {
      return u(this, null, function* () {
        const e = (yield o(this, pt).sendMessagePromise(
          ae.createWebRTCTransport,
          hf.toBinary(t)
        )).payload, { transportId: r, description: n } = Yl.fromBinary(e), i = {
          sdp: n == null ? undefined : n.sdp,
          type: n.type
        };
        return {
          transportId: r,
          answer: i
        };
      });
    }
    produce(t) {
      return u(this, null, function* () {
        var i, a;
        const e = (yield o(this, pt).sendMessagePromise(
          ae.produce,
          Sf.toBinary(t)
        )).payload, r = Mf.fromBinary(e);
        return {
          answer: {
            sdp: (i = r == null ? undefined : r.description) == null ? undefined : i.sdp,
            type: (a = r == null ? undefined : r.description) == null ? undefined : a.type
          },
          producerId: r.producerId
        };
      });
    }
    consume(t) {
      return u(this, null, function* () {
        const e = (yield o(this, pt).sendMessagePromise(
          ae.consume,
          _f.toBinary(t)
        )).payload, {
          consumerIdsMap: { map: r }
        } = Df.fromBinary(e);
        return r;
      });
    }
    closeProducer(t) {
      return u(this, null, function* () {
        const e = (yield o(this, pt).sendMessagePromise(
          ae.closeProducer,
          Cf.toBinary(t)
        )).payload, { description: r } = Of.fromBinary(e);
        return r;
      });
    }
    closeConsumer(t) {
      return u(this, null, function* () {
        return (yield o(this, pt).sendMessagePromise(
          ae.closeConsumer,
          wf.toBinary(t)
        )).payload;
      });
    }
    hostControlForPeer(t, e) {
      return u(this, null, function* () {
        const r = {
          audio: e === "audio",
          screeShare: false,
          video: e === "video",
          participantId: t
        }, n = (yield o(this, pt).sendMessagePromise(
          ae.hostControlPeer,
          bf.toBinary(r)
        )).payload;
        if (!n)
          return false;
        const { status: i } = xf.fromBinary(n);
        return i === "success";
      });
    }
    hostControlForAll(t) {
      return u(this, null, function* () {
        const e = {
          audio: t === "audio",
          screenShare: false,
          video: t === "video"
        }, r = (yield o(this, pt).sendMessagePromise(
          ae.hostControlAllPeers,
          kf.toBinary(e)
        )).payload;
        if (!r)
          return false;
        const { status: n } = $f.fromBinary(r);
        return n === "success";
      });
    }
    kickAll() {
      return u(this, null, function* () {
        const t = {
          propagateKickAcrossRooms: false
        }, e = (yield o(this, pt).sendMessagePromise(
          ae.kickAll,
          Ql.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Lf.fromBinary(e);
        return r === "success";
      });
    }
    kickPeer(t) {
      return u(this, null, function* () {
        const e = (yield o(this, pt).sendMessagePromise(
          ae.kickPeer,
          Pf.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Nf.fromBinary(e);
        return r === "success";
      });
    }
    changeDisplayName(t) {
      return u(this, null, function* () {
        const e = (yield o(this, pt).sendMessagePromise(
          ae.changeDisplayName,
          Rf.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Uf.fromBinary(e);
        return r === "success";
      });
    }
    notifySelfJoinComplete() {
      return u(this, null, function* () {
        const t = {}, e = (yield o(this, pt).sendMessagePromise(
          ae.selfJoinComplete,
          yf.toBinary(t)
        )).payload;
        return ac.fromBinary(e);
      });
    }
  }
  pt = new WeakMap();
  var Yt = /* @__PURE__ */ ((s) => (s.NEW = "new", s.CONNECTING = "connecting", s.RECONNECTING = "reconnecting", s.DISCONNECTED = "disconnected", s.CONNECTED = "connected", s.FAILED = "failed", s))(Yt || {}), xi = /* @__PURE__ */ ((s) => (s[s.HIVE = 1] = "HIVE", s[s.ROOM_NODE = 2] = "ROOM_NODE", s[s.CF = 3] = "CF", s))(xi || {});
  const yM = 2e3;
  var ln, pa, mr;
  class TM extends gg {
    constructor(e, r) {
      super();
      E(this, ln);
      f(this, "_device");
      f(this, "_sendTransport");
      f(this, "_recvTransport");
      f(this, "_consumers");
      // map producer type to Producer
      f(this, "_producers");
      f(this, "_producerStatus");
      f(this, "_producerIdToConsumerIdMap");
      f(this, "_socket");
      f(this, "_socketHandler");
      f(this, "_metrics", {
        sendTransportFailureCount: 0,
        recvTransportFailureCount: 0,
        consumerCreationFailureCount: 0,
        producerCreationFailureCount: 0,
        lastConnectionTime: 0
      });
      f(this, "_transportDisconnectedTimer");
      f(this, "_iceTransportPolicy", "all");
      f(this, "_producerNotReadyFailureCount", 0);
      f(this, "transportConnectionStatus");
      f(this, "transportState");
      f(this, "transportDisconnected");
      E(this, mr, undefined);
      _(this, mr, e), this._device = new gM({}), this._socket = r, o(this, ln, pa).mediaState = {
        recv: { state: Yt.NEW, reconnected: false },
        send: { state: Yt.NEW, reconnected: false }
      }, this.transportDisconnected = {
        recv: false,
        send: false
      }, this._socketHandler = new vM(r), this.reset();
    }
    get socket() {
      return this._socket;
    }
    get producers() {
      return this._producers;
    }
    get consumers() {
      return this._consumers;
    }
    get producerIdToConsumerIdMap() {
      return this._producerIdToConsumerIdMap;
    }
    get hiveSocketHandler() {
      return this._socketHandler;
    }
    get sendTransport() {
      return this._sendTransport;
    }
    get recvTransport() {
      return this._recvTransport;
    }
    reset() {
      this._producers = /* @__PURE__ */ new Map(), this._consumers = /* @__PURE__ */ new Map(), this._producerStatus = /* @__PURE__ */ new Map(), this._producerIdToConsumerIdMap = /* @__PURE__ */ new Map(), this._transportDisconnectedTimer = { recv: undefined, send: undefined };
    }
    setupTransports(e) {
      return u(this, null, function* () {
        var a, c, d, p, h, m, g, T;
        const n = yield qe().getICEServers().catch((y) => (l.warn(`failed to get iceservers from server: ${y.message}`), [])), i = [];
        if (e.send) {
          const y = this.createSendTransport({
            iceServers: n,
            additionalSettings: {
              encodedInsertableStreams: (a = o(this, mr).getValue("modules").e2ee) == null ? undefined : a.enabled
            },
            config: {
              enableHighBitrate: (p = (d = (c = o(this, mr).getValue("defaults").mediaConfiguration) == null ? undefined : c.audio) == null ? undefined : d.enableHighBitrate) != null ? p : false,
              enableStereo: (g = (m = (h = o(this, mr).getValue("defaults").mediaConfiguration) == null ? undefined : h.audio) == null ? undefined : m.enableStereo) != null ? g : false
            },
            iceTransportPolicy: this._iceTransportPolicy
          });
          i.push(y);
        }
        if (e.recv) {
          const y = this.createRecvTransport({
            iceServers: n,
            additionalSettings: {
              encodedInsertableStreams: (T = o(this, mr).getValue("modules").e2ee) == null ? undefined : T.enabled
            },
            iceTransportPolicy: this._iceTransportPolicy
          });
          i.push(y);
        }
        yield Promise.all(i);
      });
    }
    stopAllTransports() {
      var e, r, n, i;
      l.info("closing all the transports"), (e = this._sendTransport) == null || e.close(), (r = this._sendTransport) == null || r.removeAllListeners(), (n = this._recvTransport) == null || n.close(), (i = this._recvTransport) == null || i.removeAllListeners(), this._sendTransport = undefined, this._recvTransport = undefined, this.reset();
    }
    createSendTransport(e) {
      return u(this, null, function* () {
        var n, i;
        l.info("sendTransport::initializing_transport", {
          transport: {
            id: (n = this._sendTransport) == null ? undefined : n.id,
            serverId: (i = this._sendTransport) == null ? undefined : i.serverId,
            type: "send"
          }
        });
        const r = this._device.createSendTransport(e);
        this._transportDisconnectedTimer.send = undefined, l.info("sendTransport::initialized_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "send"
          }
        }), this.handleTransport(r), l.info("sendTransport::connecting_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "send"
          }
        });
        try {
          yield wr((a, c) => u(this, null, function* () {
            var d, p;
            if (this._sendTransport && this._sendTransport.connected) {
              l.info("sendTransport::already_exists_in_connected_state", {
                transport: {
                  id: (d = this._sendTransport) == null ? void 0 : d.id,
                  serverId: (p = this._sendTransport) == null ? void 0 : p.serverId,
                  type: "send"
                }
              });
              return;
            }
            if (!this.socket.isConnected) {
              c(new Error("socket is not connected"));
              return;
            }
            if (r.connectionState === "closed") {
              c(new Error("transport is closed"));
              return;
            }
            a > 0 && l.debug(`retrying transport connect, count: ${a}`, {
              transport: {
                id: r.id,
                serverId: r.serverId,
                type: "send"
              }
            });
            try {
              yield r.connect();
            } catch (h) {
              if (l.error(
                `failed to connect send transport: ${r.id}`,
                {
                  error: h,
                  transport: {
                    id: r.id,
                    serverId: r.serverId,
                    type: "send"
                  }
                }
              ), h.message === "ice connection failed") {
                c(h);
                return;
              }
              throw this._metrics.sendTransportFailureCount += 1, h;
            }
          }), {
            delayTime: 100,
            strategy: "exponential",
            maxRetryCount: K.hasFeature(
              ie.ENABLE_HIVE_INFINITE_RETRIES
            ) ? 1 / 0 : 3
          }), l.info("sendTransport::connected_transport", {
            transport: {
              id: r == null ? void 0 : r.id,
              serverId: r == null ? void 0 : r.serverId,
              type: "send"
            }
          }), this._producerNotReadyFailureCount = 0, this._sendTransport = r, U.onSafeInitialization(() => {
            U.configureSendTransport(r);
          });
        } catch (a) {
          throw l.error(
            `failed to connect send transport after retry:${r.id}`,
            {
              error: a,
              transport: {
                id: r == null ? undefined : r.id,
                serverId: r == null ? undefined : r.serverId,
                type: "send"
              }
            }
          ), r.close(), r.removeAllListeners(), this._metrics.sendTransportFailureCount += 1, this.handleErrors("rejoin"), a;
        }
      });
    }
    createRecvTransport(e) {
      return u(this, null, function* () {
        var n, i, a;
        l.info("recvTransport::initializing_transport", {
          transport: {
            id: (n = this._recvTransport) == null ? undefined : n.id,
            serverId: (i = this._recvTransport) == null ? undefined : i.serverId,
            type: "recv"
          }
        });
        const r = this._device.createRecvTransport(z(L({}, e), {
          additionalSettings: z(L({}, (a = e.additionalSettings) != null ? a : {}), {
            rtcAudioJitterBufferMaxPackets: 25,
            rtcAudioJitterBufferFastAccelerate: true,
            rtcAudioJitterBufferMinDelayMs: 20
          })
        }));
        this._transportDisconnectedTimer.recv = undefined, l.info("recvTransport::initialized_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "recv"
          }
        }), this.handleTransport(r), l.info("recvTransport::connecting_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "recv"
          }
        });
        try {
          yield wr(
            (c, d) => u(this, null, function* () {
              var p, h;
              if (this._recvTransport && this._recvTransport.connected) {
                l.info("recvTransport::already_exists_in_connected_state", {
                  transport: {
                    id: (p = this._recvTransport) == null ? void 0 : p.id,
                    serverId: (h = this._recvTransport) == null ? void 0 : h.serverId,
                    type: "recv"
                  }
                });
                return;
              }
              if (!this.socket.isConnected) {
                d(new Error("socket is not connected"));
                return;
              }
              if (r.connectionState === "closed") {
                d(new Error("transport is closed"));
                return;
              }
              c > 0 && l.debug(`retrying transport connect, count: ${c}`, {
                transport: {
                  id: r == null ? void 0 : r.id,
                  serverId: r == null ? void 0 : r.serverId,
                  type: "recv"
                }
              });
              try {
                yield r.connect();
              } catch (m) {
                if (l.error(
                  `fail to connect recv transport: ${r.id}`,
                  {
                    error: m,
                    transport: {
                      id: r == null ? void 0 : r.id,
                      serverId: r == null ? void 0 : r.serverId,
                      type: "recv"
                    }
                  }
                ), m.message === "ice connection failed") {
                  d(m);
                  return;
                }
                throw this._metrics.recvTransportFailureCount += 1, m;
              }
            }),
            { delayTime: 100, strategy: "exponential", maxRetryCount: K.hasFeature(ie.ENABLE_HIVE_INFINITE_RETRIES) ? 1 / 0 : 3 }
          ), l.info("recvTransport::connected_transport", {
            transport: {
              id: r == null ? void 0 : r.id,
              serverId: r == null ? void 0 : r.serverId,
              type: "recv"
            }
          }), this.producerIdToConsumerIdMap.clear(), this._recvTransport = r, U.onSafeInitialization(() => {
            U.configureRecvTransport(r);
          });
        } catch (c) {
          throw l.error(
            `failed to connect recv transport after retry:${r.id}`,
            {
              error: c,
              transport: {
                id: r == null ? undefined : r.id,
                serverId: r == null ? undefined : r.serverId,
                type: "recv"
              }
            }
          ), r.close(), r.removeAllListeners(), this._metrics.recvTransportFailureCount += 1, this.handleErrors("rejoin"), c;
        }
      });
    }
    handleTransport(e) {
      const { direction: r, id: n } = e, i = r === "recv";
      if (e.on("connect", (p, h, m) => u(this, [p, h, m], function* ({ offer: a }, c, d) {
        try {
          const g = {
            consuming: i,
            description: {
              sdp: a.sdp,
              type: a.type,
              target: i ? $t.SUBSCRIBER : $t.PUBLISHER
            }
          }, { transportId: T, answer: y } = yield this._socketHandler.connectTransport(g);
          e.setServerId(T), c({ answer: y });
        } catch (g) {
          l.error(
            `${i ? "consumer" : "producer"} transport connection error:`,
            {
              error: g,
              transport: {
                id: n,
                // serverId is set after connection
                serverId: e.serverId,
                type: r
              }
            }
          ), d(g);
        }
      })), e.on("connectionstatechange", (a) => u(this, null, function* () {
        this.updateTransportState({
          state: a,
          direction: r
        }), l.info(
          `${i ? "consumer" : "producer"} transport connectionState:`,
          {
            transport: {
              id: n,
              serverId: e.serverId,
              type: r,
              status: a
            }
          }
        );
        const c = () => {
          const d = this._transportDisconnectedTimer[r];
          d !== undefined && (clearTimeout(d), this._transportDisconnectedTimer[r] = undefined);
        };
        switch (a) {
          case "connected":
            c(), this._metrics.lastConnectionTime = performance.now();
            break;
          case "disconnected":
            this._transportDisconnectedTimer[r] = setTimeout(() => {
              this.triggerTransportReconnection(e);
            }, yM);
            break;
          case "failed":
            if (e.closed)
              return;
            c(), this.triggerTransportReconnection(e);
            break;
        }
      })), e.on("icecandidate", (a) => u(this, null, function* () {
        l.debug("sending icecandidate:", {
          iceCandidate: a
        });
      })), e.on(
        "datachannel:events",
        (a, c) => u(this, null, function* () {
          var d, p;
          l.debug("got data channel message on event:", {
            rtcChannel: {
              label: a,
              message: c
            }
          });
          try {
            switch (c.type) {
              case "negotiation": {
                e.awaitQueue.push(
                  () => u(this, null, function* () {
                    return this.negotiateOverDC(c, pc(c), a, e);
                  })
                );
                break;
              }
              case "handshake": {
                const h = {
                  type: "handshake",
                  payload: {
                    message: "pong"
                  }
                };
                e.sendResponseOverDC(a, pc(c), h);
                break;
              }
              case "consumer_toggle": {
                this.handleConsumerToggle(c.payload);
                break;
              }
              case "hub-disconnect": {
                l.debug(`media hub disconnected, full_reconnect: ${(d = c.payload) == null ? void 0 : d.full_reconnect}`), ((p = c.payload) == null ? void 0 : p.full_reconnect) === !0 && this.handleErrors("rejoin");
                break;
              }
              case "error": {
                this.handleErrorOverDC(c.payload, e.id);
                break;
              }
              default:
                l.warn(
                  `unknown event received from hive node, event: ${c.type}`
                );
                break;
            }
          } catch (h) {
            l.error(
              `Unable to handle the incoming datachannel message on channel ${a}`
            );
          }
        })
      ), e.on("dc_error", () => {
        e.direction === "recv" && (l.warn("events datachannel did not open in 5s"), this.handleErrors("reconnectRecvTransport"));
      }), e.on("negotiate", (p, h, m) => u(this, [p, h, m], function* ({ description: a }, c, d) {
        try {
          const g = {
            sdp: a == null ? void 0 : a.sdp,
            type: a == null ? void 0 : a.type
          }, T = yield this.negotiate(e, g);
          c({
            answer: T
          });
        } catch (g) {
          l.error("negotiate error:", {
            transport: {
              id: e.id,
              serverId: e.serverId,
              type: e.direction
            },
            error: g
          }), d(g);
        }
      })), !i) {
        e.on(
          "produce",
          (g, T, y) => u(this, [g, T, y], function* ({
            offer: a,
            kind: c,
            paused: d,
            appData: p
          }, h, m) {
            var $;
            const A = libExports.parse(a.sdp).media.filter(
              (V) => c === "video" ? V.type === "video" : V.type === "audio"
            ).at(-1).msid, I = {
              description: {
                sdp: a.sdp,
                type: a.type,
                target: $t.PUBLISHER
              },
              paused: d,
              kind: c,
              msid: A,
              appData: JSON.stringify(p),
              screenShare: ($ = p.screenShare) != null ? $ : false
            };
            try {
              const { answer: V, producerId: O } = yield this._socketHandler.produce(
                I
              );
              h({ answer: V, producerId: O });
            } catch (V) {
              l.error("create producer error:", V), m(V);
            }
          })
        );
        return;
      }
      e.on("consume_peer", (h, m, g) => u(this, [h, m, g], function* ({ producingPeerId: a, producerId: c }, d, p) {
        l.info("consumePeer:", a);
        const T = {
          producingPeerId: a,
          producerId: c
        };
        try {
          const y = yield this._socketHandler.consume(T);
          l.debug(`consumePeer response for ${a}:`, {
            consumerStateMap: y
          });
          const b = /* @__PURE__ */ new Map();
          Object.entries(y).forEach(
            ([A, I]) => {
              var V, O, q;
              let $ = {};
              try {
                $ = JSON.parse(I.producerState.appData);
              } catch (B) {
              }
              b.set(A, {
                consumerId: I.consumerId,
                trackId: (V = I.producerTrack) == null ? void 0 : V.trackId,
                streamId: I.producerTrack.streamId,
                kind: I.producerState.kind === kt.VIDEO ? "video" : "audio",
                appData: $,
                screenShare: (O = I.producerState) == null ? void 0 : O.screenShare,
                paused: (q = I.producerState) == null ? void 0 : q.pause,
                producingPeerId: a
              });
            }
          ), d({ consumersMap: b });
        } catch (y) {
          l.error("consumePeer error:", {
            error: y
          }), p(y);
        }
      })), e.on(
        "consume",
        (h, m, g) => u(this, [h, m, g], function* ({ producerId: a, producingPeerId: c }, d, p) {
          var y, b, A, I, $, V, O, q, B;
          const T = {
            producingPeerId: c,
            producerId: a
          };
          try {
            const Y = (yield this._socketHandler.consume(T))[a];
            let we = {};
            try {
              we = JSON.parse((y = Y.producerState) == null ? void 0 : y.appData);
            } catch (Pe) {
            }
            l.info("consumer create response:", {
              consumer: {
                remotelyPaused: (b = Y.producerState) == null ? void 0 : b.pause,
                producerId: (A = Y.producerState) == null ? void 0 : A.producerId,
                kind: ($ = (I = Y.producerState) == null ? void 0 : I.kind) == null ? void 0 : $.toString(),
                appData: z(L({}, we), { screenShare: (V = Y.producerState) == null ? void 0 : V.screenShare }),
                id: Y.consumerId
              },
              consumerState: Y
            }), d({
              consumerId: Y.consumerId,
              screenShare: (O = Y.producerState) == null ? void 0 : O.screenShare,
              trackId: (q = Y.producerTrack) == null ? void 0 : q.trackId,
              streamId: Y.producerTrack.streamId,
              kind: Y.producerState.kind === kt.VIDEO ? "video" : "audio",
              paused: (B = Y.producerState) == null ? void 0 : B.pause,
              appData: we
            });
          } catch (ne) {
            l.error("error during consuming on server:", ne), p(ne);
          }
        })
      );
    }
    createProducer(e, r, n) {
      return u(this, null, function* () {
        var a;
        if (this._sendTransport === undefined || this._sendTransport.closed)
          return null;
        l.info("createProducer::initializing_producer", {
          producer: {
            id: "TO_BE_CREATED",
            kind: e,
            status: "initializing",
            appData: r == null ? undefined : r.appData
          }
        });
        const i = this._producerStatus.get(e);
        if ((i == null ? undefined : i.trackId) === r.track.id && (i == null ? undefined : i.status) === Wr.INITIALIZING)
          return l.info("createProducer::producer getting initializing", {
            producer: {
              id: "GETTING_CREATED",
              status: "initializing",
              kind: e,
              appData: r == null ? undefined : r.appData
            }
          }), null;
        this._producerStatus.set(
          e,
          {
            trackId: r.track.id,
            status: Wr.INITIALIZING
          }
        );
        try {
          const c = yield this._sendTransport.produce(r);
          return (a = r.appData) != null && a.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, c), l.info("createProducer::initialized_producer", {
            producer: {
              id: c == null ? void 0 : c.id,
              kind: e,
              status: "producing",
              appData: r == null ? void 0 : r.appData
            }
          }), c.on("close", (m, g) => u(this, [m, g], function* ({ offer: d, reason: p }, h) {
            l.info("producer::closing", {
              debuggingHint: p,
              producer: {
                id: c == null ? void 0 : c.id,
                kind: e,
                status: "closing",
                appData: r == null ? void 0 : r.appData
              }
            });
            const T = {
              producerId: c.id,
              description: {
                sdp: d.sdp,
                type: d.type,
                target: $t.PUBLISHER
              }
            };
            try {
              const y = yield this._socketHandler.closeProducer(T), b = {
                sdp: y == null ? void 0 : y.sdp,
                type: y == null ? void 0 : y.type
              };
              l.info("producer::closed", {
                producer: {
                  id: c == null ? void 0 : c.id,
                  kind: e,
                  status: "closed",
                  appData: r == null ? void 0 : r.appData
                }
              }), h({ answer: b });
            } catch (y) {
              l.error("producer close error", y);
            }
            this._producerStatus.delete(e), this._producers.delete(e), n(), this.reconfigureWebcamLayers();
          })), c.on("trackended", () => {
            l.info("producer::trackended", {
              producer: {
                id: c == null ? void 0 : c.id,
                kind: e,
                status: "UNKNOWN",
                appData: c == null ? void 0 : c.appData
              }
            }), [X.MIC, X.WEBCAM].includes(e) || n();
          }), this._producers.set(e, c), this._producerStatus.set(
            e,
            {
              trackId: r.track.id,
              status: Wr.INITIALIZED
            }
          ), this.reconfigureWebcamLayers(), c.track;
        } catch (c) {
          throw this._producerStatus.set(
            e,
            {
              status: Wr.NOT_INITIALIZED,
              trackId: r.track.id
            }
          ), l.error("createProducer::transport_initialization_failed", {
            producer: {
              id: "FAILED_TO_CREATE",
              kind: e,
              status: "failed",
              appData: r == null ? undefined : r.appData,
              error: c
            }
          }), this._metrics.producerCreationFailureCount += 1, c;
        }
      });
    }
    /**
     * Control which simulcast layers are active on the webcam producer. Used to
     * save bandwidth while screensharing by disabling extra layers. Also used to
     * enable back layers when screenshare is not active.
     * Currently, this is behing a feature flag.
     */
    reconfigureWebcamLayers() {
      return u(this, null, function* () {
        if (!K.hasFeature(
          ie.DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE
        ))
          return;
        const e = this.producers.get(X.WEBCAM);
        e && (yield this._switchProducerSpatialLayer(
          e,
          this.producers.get(X.SCREENSHARE_VIDEO) ? 0 : 3
        ));
      });
    }
    /**
     * switches spatial layers of webcam
     * @layer can be number from 0-3. It will set the max spatial
     * layer to that number.
     * If you pass layer value 0 then there will be only 1 active encoding
     * higher values means more active encodings.
     */
    // eslint-disable-next-line class-methods-use-this
    _switchProducerSpatialLayer(e, r) {
      return u(this, null, function* () {
        try {
          l.debug("switching layer of webcam producer to:", {
            media: {
              video: {
                layer: r
              }
            },
            producer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          }), yield e.setMaxSpatialLayer(r);
        } catch (n) {
          l.error("failed to switch spatial layer", { error: n });
        }
      });
    }
    _initConsumer(e) {
      e && (e.observer.on("close", (r) => u(this, null, function* () {
        l.debug("consumer closed", {
          consumer: {
            closureReason: r,
            id: e.id,
            kind: e.kind,
            appData: e.appData
          }
        }), this._consumers.delete(e.id), R.emit(P.CONSUMER_CLOSED, { id: e.id });
      })), this._consumers.set(e.id, e), this.producerIdToConsumerIdMap.set(e.producerId, e.id), R.emit(P.NEW_CONSUMER, {
        id: e.id,
        appData: e.appData,
        peerId: e.peerId
      }));
    }
    // async consumePeer(producingPeerId: string): Promise<void> {
    // 	if (
    // 		this._recvTransport === undefined
    // 		|| this._recvTransport.closed
    // 		|| !this._recvTransport.connected
    // 	) {
    // 		throw Error('Receiving transport not connected');
    // 	}
    // 	await retry(async (attempt) => {
    // 		if (attempt > 0) {
    // 			DyteLogger.debug(`retrying consumePeer call, retryCount: ${attempt}`);
    // 		}
    // 		try {
    // 			const results = await this._recvTransport.consumePeer(producingPeerId);
    // 			const failedTasks: ConsumerCreationTaskError[] = [];
    // 			results.forEach((result) => {
    // 				if (result.status === 'rejected') {
    // 					failedTasks.push(result.reason as ConsumerCreationTaskError);
    // 				} else {
    // 					this._initConsumer(result.value as Consumer);
    // 				}
    // 			});
    // 			// Note(itzmanish): we don't need this as we have another retry
    // 			// on consumer creation task. will deprecate in next 2-3 major version
    // 			this._recvTransport
    // 				.retryFailedConsumerCreationTasks(failedTasks)
    // 				.then((retriedConsumersResult) => {
    // 					retriedConsumersResult.forEach((result) => {
    // 						if (result.status === 'rejected') {
    // 							DyteLogger.error(
    // 								'consumer creation task is failing',
    // 								result.reason,
    // 							);
    // 							this._consumerCreationFailureCount += 1;
    // 							setTimeout(this.handleFailure.bind(this), 0);
    // 						} else {
    // 							this._initConsumer(result.value as Consumer);
    // 						}
    // 					});
    // 				});
    // 		} catch (error) {
    // 			DyteLogger.error('got error in consumePeer', { error });
    // 			throw error;
    // 		}
    // 	}).catch((e) => {
    // 		DyteLogger.error('consumePeer failed after retries', e);
    // 		this._consumerCreationFailureCount += 1;
    // 		this.handleFailure();
    // 	});
    // }
    createConsumers(e) {
      return u(this, null, function* () {
        if (this._recvTransport === undefined || this._recvTransport.closed || !this._recvTransport.connected)
          return;
        if (e.every((a) => this.getProducer(a.producerId))) {
          l.warn("Cancelled consumer creation for local producer");
          return;
        }
        const n = 3, i = (a, c = 0) => u(this, null, function* () {
          try {
            return yield this._recvTransport.consume(a);
          } catch (d) {
            if (d instanceof yg) {
              if (this._metrics.consumerCreationFailureCount += 1, c <= n)
                return i(a, c + 1);
              throw d;
            }
            throw d instanceof vg && (this._metrics.recvTransportFailureCount += 1), l.error("Error in consume request", d), d;
          }
        });
        try {
          let a = yield i(e);
          yield wr((c) => u(this, null, function* () {
            c > 0 && l.warn(`retrying consumers: attempt: ${c}`, {
              peerIds: e.map(({ producingPeerId: p }) => p)
            });
            const d = [];
            a.forEach((p, h) => {
              if (p.status === "rejected") {
                this._metrics.consumerCreationFailureCount += 1, d.push(e[h]);
                return;
              }
              this._initConsumer(p.value);
            }), d.length && (a = yield i(d));
          }));
        } catch (a) {
          l.error("failed to create consumers", { error: a }), this._metrics.consumerCreationFailureCount += 1, this.handleErrors("reconnectRecvTransport");
        }
      });
    }
    // TODO(roerohan): create dashboard around tracking consumer transport failures (improve logging)
    pauseProducer(e) {
      return u(this, null, function* () {
        const r = this._producers.get(e);
        if (!r) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r.pause(), r.appData.e2ee && R.emit(P.E2EE_INACTIVE_PRODUCER, r), l.info(`Paused the producer of type: ${r.kind}`, {
          producer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    resumeProducer(e) {
      return u(this, null, function* () {
        const r = this._producers.get(e);
        if (!r) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r.resume(), l.info(`Resumed the producer of type: ${r.kind}`, {
          producer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    replaceTrack(e, r) {
      return u(this, null, function* () {
        const n = this._producers.get(e);
        if (!n) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        yield n.replaceTrack({ track: r }), l.info(`Replaced track for the producer of type: ${n.kind}`, {
          producer: {
            id: n.id,
            kind: n.kind,
            appData: n.appData,
            trackId: r.id
          }
        });
      });
    }
    removeProducer(e, r) {
      return u(this, null, function* () {
        const n = this._producers.get(e);
        if (!n) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r && n.track.stop(), yield this.sendTransport.awaitQueue.push(n.close.bind(n), "producer").then(() => {
          o(this, mr).getValue("modules").e2ee.enabled && R.emit(P.E2EE_INACTIVE_PRODUCER, n);
        }).catch((i) => {
          l.error("failed to close producer on server", i);
        });
      });
    }
    pauseConsumer(e) {
      return u(this, null, function* () {
        const r = this._consumers.get(e);
        if (!r) {
          l.warn(`consumer with id: ${e} not found`);
          return;
        }
        this.toggleConsumerOverDC(e, true), l.info(`Paused the consumer of type: ${r.kind}`, {
          consumer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    pauseConsumerOverSocket(e) {
      return u(this, null, function* () {
        try {
          const r = {
            consumerId: e.id,
            pause: !0
          };
          yield this.socket.sendMessagePromise(
            ae.toggleConsumer,
            ic.toBinary(r)
          ), e.pause(), R.emit(P.CONSUMER_PAUSED, { id: e.id }), l.info(`Paused the consumer of type: ${e.kind} over socket`, {
            consumer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          });
        } catch (r) {
          l.error("error on pausing consumer", {
            error: r,
            consumer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          });
        }
      });
    }
    // Experimental
    toggleConsumerOverDC(e, r) {
      return u(this, null, function* () {
        const n = {
          type: "consumer_toggle",
          payload: {
            consumerId: e,
            mute: r
          }
        }, i = this._recvTransport.getDatachannel("events");
        if (!i) {
          l.warn("recvTransport:: events datachannel not found");
          return;
        }
        yield i.request(n), l.info(`HiveSFUHandler::consumer toggled, consumerId: ${e}, muted: ${r}`);
      });
    }
    resumeConsumer(e) {
      return u(this, null, function* () {
        const r = this._consumers.get(e);
        if (!r) {
          l.warn(`consumer with id: ${e} not found`);
          return;
        }
        if (!r.paused) {
          l.warn(`consumer with id:${e} is not paused so not resuming`);
          return;
        }
        try {
          const n = {
            consumerId: e,
            pause: !1
          };
          yield this.socket.sendMessagePromise(
            ae.toggleConsumer,
            ic.toBinary(n)
          ), r.resume(), R.emit(P.CONSUMER_RESUMED, { id: r.id }), l.info(`Resumed the consumer of type: ${r.kind}`, {
            consumer: {
              id: r.id,
              kind: r.kind,
              appData: r.appData
            }
          });
        } catch (n) {
          l.error("error on resuming consumer", n);
        }
      });
    }
    // if force is true it will close the consumer irrespective of failure in
    // close consumer request
    closeConsumer(e, r) {
      return u(this, null, function* () {
        return this.closeConsumers([e], r);
      });
    }
    // if force is true it will close the consumer irrespective of failure in
    // close consumer request
    closeConsumers(e, r = false) {
      return u(this, null, function* () {
        l.info(`Closing consumers: ${JSON.stringify(e)} with force: ${r}`);
        let n = true;
        const i = e.filter((d) => this._consumers.get(d) ? true : (l.warn(`consumer with id: ${d} not found`), false));
        if (!i.length)
          return;
        const a = {
          consumerIds: i
        }, c = () => u(this, null, function* () {
          var d;
          return (d = this._recvTransport) == null ? undefined : d.awaitQueue.push(() => u(this, null, function* () {
            yield this._socketHandler.closeConsumer(a);
          }), "close_consumer").catch((p) => {
            l.warn("error on closing consumer:", {
              error: p
            }), n = r;
          });
        });
        r ? c() : yield c(), n && i.forEach((d) => {
          const p = this.consumers.get(d);
          p && (this.producerIdToConsumerIdMap.delete(p.producerId), p.close(r ? "force closed" : undefined));
        });
      });
    }
    cleanupConsumers(e) {
      return u(this, null, function* () {
        l.debug("cleaning up all consumers");
        const r = [];
        this._consumers.forEach((n) => {
          e ? n.peerId === e && r.push(n.id) : r.push(n.id);
        }), this.closeConsumers(r, true);
      });
    }
    // NOTE(itzmanish): it's not being used anywhere
    stopAllProducers() {
      return u(this, null, function* () {
        l.info("stopping all available producers"), this._producers.forEach((e, r) => {
          l.debug(`closing producer type: ${r}`, {
            producer: {
              id: e == null ? undefined : e.id,
              kind: e.kind,
              appData: e.appData
            }
          }), e.close();
        });
      });
    }
    getProducer(e) {
      return Array.from(this.producers.values()).filter((r) => r.id === e).at(0);
    }
    hasProducer(e) {
      return this.getProducer(e) !== undefined;
    }
    negotiate(e, r) {
      return u(this, null, function* () {
        l.debug(`setting remote offer : ${JSON.stringify(r)} on ${e.direction} transport`, {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        });
        const n = yield e.setRemoteOffer(r), i = {
          transportId: e.serverId,
          description: {
            sdp: n.sdp,
            type: n.type,
            target: $t.SUBSCRIBER
          }
        };
        return l.debug(`sending renegotiate request: ${JSON.stringify(i)} on ${e.direction} transport`, {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        }), yield this.socket.sendMessagePromise(
          ae.renegotiateSessionDescription,
          mf.toBinary(i)
        ), l.info("renegotiation done", {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        }), n;
      });
    }
    // eslint-disable-next-line class-methods-use-this
    negotiateOverDC(e, r, n, i) {
      return u(this, null, function* () {
        const { sdp: a } = e.payload, c = {
          sdp: a,
          type: "offer"
        };
        try {
          l.debug(`got offer over dc: ${a} for transport: ${i.id}`);
          const d = yield i.setRemoteOffer(c), p = {
            type: "answer",
            payload: {
              type: d.type,
              sdp: d.sdp
            }
          };
          l.debug(`datachannel answer: ${JSON.stringify(p)}`), i.sendResponseOverDC(n, r, p);
        } catch (d) {
          l.error("datachannel:events::Error:", d), d.code !== "DC_NOT_FOUND" && i.sendErrorOverDC(n, r, d);
        }
      });
    }
    handleConsumerToggle(e) {
      const { mute: r, trackId: n } = e;
      l.info(`consumer toggled for trackId: ${n} muted: ${r}`);
      const i = this.consumers.get(n);
      if (!i) {
        l.warn(`consumer with trackId: ${n} not found`);
        return;
      }
      i.paused !== r && (l.debug("consumer state is not same", {
        consumer: {
          id: i.id,
          remotelyPaused: i.paused
        }
      }), r ? (i.pause(), R.emit(P.CONSUMER_PAUSED, { id: i.id })) : (i.resume(), R.emit(P.CONSUMER_RESUMED, { id: i.id })));
    }
    handleErrorOverDC(e, r) {
      return u(this, null, function* () {
        l.error(`got error over dc: ${JSON.stringify(e)} for transport: ${r}`);
        const { type: n, error: i, id: a } = e;
        switch (n) {
          case "consumer": {
            this._metrics.consumerCreationFailureCount += 1, l.error(`Error in consumer creation, this should not happen: ${n}, ${i}, ${a}`);
            return;
          }
          case "producer": {
            if (i === "ready-fail") {
              if (this._producerNotReadyFailureCount >= 2) {
                this.handleErrors("reconnectSendTransport");
                return;
              }
              this._producerNotReadyFailureCount += 1, this._metrics.producerCreationFailureCount += 1;
              const [c] = Array.from(this.producers.entries()).find((d) => d[1].id === a);
              if (!c)
                return;
              yield this.removeProducer(c).catch((d) => {
                l.error(
                  "failed to remove ready-fail producer:",
                  {
                    error: d,
                    producer: {
                      id: a,
                      kind: c,
                      appData: null
                    }
                  }
                );
              });
            } else
              i === "general-failure" && this.handleErrors("reconnectSendTransport");
            l.error(`Unrecognized error: ${n}, ${i}, ${a}`);
            break;
          }
          default:
            l.error(`Unrecognized error: ${n}, ${i}, ${a}`);
        }
      });
    }
    handleErrors(e) {
      return u(this, null, function* () {
        switch (e) {
          case "rejoin": {
            l.warn("rejoining room"), this.emit("rejoin");
            break;
          }
          case "reconnectSendTransport": {
            l.warn("reconnecting send transport"), this.triggerTransportReconnection(this._sendTransport);
            break;
          }
          case "reconnectRecvTransport": {
            this.triggerTransportReconnection(this._recvTransport);
            break;
          }
          default:
            l.error(`Could not handle error, unrecognized action ${e}`);
        }
      });
    }
    // private async handleFailure() {
    // 	if (
    // 		this._transportReconnectFailureCount > 0
    // 		|| this._metrics.transportReconnectionCount > 3
    // 	) {
    // 		DyteLogger.warn('transport failure detected');
    // 		if (
    // 			flagsmith.hasFeature(
    // 				FlagsmithFeatureFlags.ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY,
    // 			)
    // 		) {
    // 			DyteLogger.debug('rejoining room');
    // 			this.emit('rejoin');
    // 		}
    // 		return;
    // 	}
    // 	if (
    // 		this._consumerCreationFailureCount > 0
    // 		|| this._consumerNotBoundFailureCount >= 2
    // 	) {
    // 		DyteLogger.warn(
    // 			'consumer creation failure detected or consumer not bound failure increased',
    // 		);
    // 		if (
    // 			flagsmith.hasFeature(
    // 				FlagsmithFeatureFlags.ENABLE_HIVE_EXPERIMENTAL_FAIL_RECOVERY,
    // 			)
    // 		) {
    // 			DyteLogger.debug('reconnecting recv transport');
    // 			this._metrics.transportReconnectionCount += 1;
    // 			this.updateTransportState({
    // 				state: TransportState.RECONNECTING,
    // 				direction: 'consuming',
    // 			});
    // 			this.emit('reconnect_transport', this._recvTransport);
    // 		}
    // 	}
    // 	if (this._producerNotReadyFailureCount >= 2) {
    // 		DyteLogger.warn(
    // 			'producer receiver not getting added needs to reconnect send transport',
    // 		);
    // 		this._metrics.transportReconnectionCount += 1;
    // 		this.updateTransportState({
    // 			state: TransportState.RECONNECTING,
    // 			direction: 'producing',
    // 		});
    // 		this.emit('reconnect_transport', this._sendTransport);
    // 	}
    // }
    triggerTransportReconnection(e) {
      l.info(
        "triggerTransportReconnection::reconnecting_transport",
        {
          transport: {
            type: e.direction,
            id: e.id,
            serverId: e.serverId
          }
        }
      );
      const r = K.hasFeature(
        ie.ENABLE_HIVE_TRANSPORT_RECONNECTION_ON_ICE_FAILED
      ), n = K.hasFeature(
        ie.HIVE_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED
      );
      if (!r)
        return;
      const i = e.direction === "send" ? "sendTransportFailureCount" : "recvTransportFailureCount";
      n && this._socket.isConnected && (this._metrics[i] > 2 && (l.warn("Multiple disconnections, forcing relay"), this._iceTransportPolicy = "relay"), this._metrics[i] += 1), this.updateTransportState({
        state: Yt.RECONNECTING,
        direction: e.direction
      }), this.emit("reconnect_transport", e);
    }
    switchConsumersToLayer(e, r) {
      return u(this, null, function* () {
        const n = this._recvTransport.getDatachannel("events");
        if (!n) {
          l.warn("events datachannel not found");
          return;
        }
        const i = {
          type: "switch_consumer_layer",
          payload: {
            consumerIds: e,
            layer: r
          }
        };
        yield n.request(i), l.info(`HiveSFUHandler::consumer id: ${e} layer switched to ${r}`);
      });
    }
    updateTransportState(e) {
      const { state: r, direction: n } = e;
      r === "disconnected" && (this.transportDisconnected[n] = true), o(this, ln, pa).mediaState[n] = {
        state: r,
        reconnected: r === "connected" ? this.transportDisconnected[n] : o(this, ln, pa).mediaState[n].reconnected
      }, r === "connected" && (this.transportDisconnected[n] = false), R.emit(
        P.TRANSPORT_STATE_UPDATE,
        L({
          transport: n
        }, o(this, ln, pa).mediaState[n])
      );
    }
  }
  ln = new WeakSet(), pa = function() {
    return o(this, mr).getValue("connectionHandler");
  }, mr = new WeakMap();
  var _M = Object.defineProperty, SM = Object.getOwnPropertyDescriptor, me = (s, t, e, r) => {
    for (var n = SM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && _M(t, e, n), n;
  }, ht, he, fr, un, pn, Es, Ya, Qa, Xa, Hr, Ei, gr, ns, Mh;
  const Rg = (Mh = class extends fg {
    constructor(t, e) {
      var d, p;
      super();
      E(this, gr);
      E(this, ht, undefined);
      E(this, he, undefined);
      E(this, fr, undefined);
      E(this, un, undefined);
      E(this, pn, undefined);
      E(this, Es, undefined);
      E(this, Ya, undefined);
      E(this, Qa, undefined);
      E(this, Xa, undefined);
      E(this, Hr, undefined);
      E(this, Ei, undefined);
      f(this, "legacyMode");
      f(this, "roomNodeUrl");
      f(this, "peerDisplayName");
      f(this, "e2ee");
      f(this, "partialJoinRoomPromise");
      this.context = t;
      const {
        roomName: r,
        authToken: n,
        legacyMode: i,
        socketClient: a,
        meetingTitle: c
      } = e;
      this.mediaJoined = false, this.roomName = r, this.authToken = n, this.legacyMode = i, this.meetingTitle = c, _(this, ht, a), _(this, fr, false), _(this, he, new TM(t, a)), this.maxPreferredStreams = 6, _(this, Hr, /* @__PURE__ */ new Set()), _(this, un, false), _(this, pn, 0), _(this, Es, new Li()), this.e2ee = (p = (d = t.getValue("modules").e2ee) == null ? undefined : d.enabled) != null ? p : false, U.legacySwitch(i), this.handleSocketEvents(), this.handleSFUEvents(), this.handleCallstatsEvents(), _(this, Ya, zr(() => u(this, null, function* () {
        if (!o(this, gr, ns).mediaJoinAttempted)
          return;
        const { roomJoined: h } = yield this.joinRoom(
          this.peerDisplayName,
          this.roomUUID,
          {},
          true,
          true
        );
        h && (R.emit(P.RESET_PRODUCER_STATE), R.emit(P.ROOM_NODE_RECONNECTED));
      }), 5e3, { leading: true, maxWait: 1e3 })), _(this, Qa, zr((h) => u(this, null, function* () {
        h.close(), h.removeAllListeners(), yield this.sfuHandler.setupTransports({ send: true }), l.info("send transport reconected!"), R.emit(P.RESET_PRODUCER_STATE);
      }), 1e3)), _(this, Xa, zr((h) => u(this, null, function* () {
        h.close(), h.removeAllListeners(), yield this.sfuHandler.setupTransports({ recv: true }), l.info("recv transport reconnected!"), R.emit(P.UPDATE_ACTIVE, { createAllConsumers: true });
      }), 1e3));
    }
    get mediaState() {
      return o(this, gr, ns).mediaState;
    }
    static init(t, e) {
      return u(this, null, function* () {
        const {
          legacyMode: r = true,
          meetingId: n,
          authToken: i,
          meetingTitle: a,
          socket: c
        } = e;
        return new Rg(
          t,
          {
            legacyMode: r,
            authToken: i,
            socketClient: c,
            roomName: n,
            meetingTitle: a
          }
        );
      });
    }
    get sfuHandler() {
      return o(this, he);
    }
    get rejoinRoom() {
      return o(this, Ya);
    }
    get mediaJoined() {
      return o(this, gr, ns).mediaJoined;
    }
    set mediaJoined(t) {
      o(this, gr, ns).mediaJoined = t;
    }
    reset(t = true) {
      var e, r, n, i;
      (r = (e = o(this, he)) == null ? undefined : e.cleanupConsumers) == null || r.call(e), (i = (n = o(this, he)) == null ? undefined : n.stopAllProducers) == null || i.call(n), o(this, Hr).clear(), t && (this.partialJoinRoomPromise = undefined, o(this, Es).stop(), o(this, he).stopAllTransports(), o(this, he).reset(), _(this, Es, new Li()));
    }
    reconnectTransport(t) {
      return u(this, null, function* () {
        l.info(`HiveNodeClient::Room joining state: ${o(this, fr)}`), !(!t || o(this, fr)) && (t.direction === "send" ? yield o(this, Qa).call(this, t) : yield o(this, Xa).call(this, t));
      });
    }
    setupTransports() {
      return u(this, null, function* () {
        yield o(this, he).setupTransports({ send: true, recv: true });
      });
    }
    stopAllProducers() {
      return u(this, null, function* () {
        yield o(this, he).stopAllProducers();
      });
    }
    joinRoom(a, c) {
      return u(this, arguments, function* (t, e, r = {}, n = false, i = false) {
        o(this, gr, ns).mediaJoinAttempted = true, _(this, fr, true), this.reset(n);
        const d = qe().ipInfo;
        if (d != null && d.loc && !o(this, Ei)) {
          const h = d.loc.split(",");
          _(this, Ei, {
            latitude: parseFloat(h[0]),
            longitude: parseFloat(h[1])
          });
        }
        let p;
        try {
          return p = yield o(this, Es).push(
            () => this._joinRoom(
              t,
              e,
              r,
              i,
              o(this, Ei)
            ),
            "joinRoom"
          ), p;
        } catch (h) {
          p = { roomJoined: false };
        }
        return p.roomJoined || R.emit(P.ROOM_NODE_FAILED), p;
      });
    }
    _partialJoinRoom(t, e, r = false, n = undefined) {
      return u(this, null, function* () {
        const { ipInfo: i } = qe();
        let a = n;
        if (i != null && i.loc && !n) {
          const [c, d] = i.loc.split(",").map(parseFloat);
          a = {
            latitude: c,
            longitude: d
          };
        }
        this.maxPreferredStreams = this.context.getValue("maxPreferredStreams"), yield wr((c, d) => u(this, null, function* () {
          if (!o(this, ht).isConnected) {
            d(new Error("socket is not connected"));
            return;
          }
          c > 0 && l.warn(`retrying sending join room request, count: ${c}`);
          try {
            yield this.sfuHandler.hiveSocketHandler.joinRoom(
              e,
              t,
              r,
              a
            );
          } catch (p) {
            throw l.error("failed to send join room request, error:", { error: p }), p;
          }
        }), { delayTime: 1e3, strategy: "exponential", maxRetryCount: K.hasFeature(ie.ENABLE_HIVE_INFINITE_RETRIES) ? 1 / 0 : 3 }), yield this.setupTransports();
      });
    }
    partialJoinRoom(t, e, r = false, n = undefined) {
      return u(this, null, function* () {
        this.partialJoinRoomPromise = o(this, Es).push(
          () => this._partialJoinRoom(t, e, r, n)
        );
      });
    }
    _joinRoom(a, c) {
      return u(this, arguments, function* (t, e, r = {}, n = false, i = null) {
        this.peerDisplayName = t;
        try {
          this.partialJoinRoomPromise ? yield this.partialJoinRoomPromise : yield this._partialJoinRoom(t, e, n, i);
        } catch (d) {
          l.error("error in partial join room", { error: d });
        } finally {
          this.partialJoinRoomPromise = undefined;
        }
        try {
          return navigator.product !== "ReactNative" && setTimeout(() => u(this, null, function* () {
            const h = {
              userId: this.context.getValue("userId"),
              peerId: this.peerId,
              displayName: t,
              roomUUID: e,
              roomViewType: "groupCall",
              roomName: this.roomName,
              deviceInfo: z(L({}, ve.getDeviceInfo()), {
                userAgent: navigator.userAgent,
                memory: navigator.deviceMemory,
                cpus: navigator.hardwareConcurrency
              }),
              sdkName: this.context.getValue("sdkName"),
              sdkVersion: this.context.getValue("sdkVersion"),
              metaData: {},
              permissions: {}
            };
            U.onSafeInitialization(() => {
              U.roomJoined(h), r != null && r.audio ? U.audioOn() : U.audioOff(), r != null && r.video ? U.videoOn() : U.videoOff();
            });
          })), { roomJoined: yield this.completeJoinRoom() };
        } catch (d) {
          return l.error("error on sending join room request", { error: d }), { roomJoined: false };
        }
      });
    }
    completeJoinRoom() {
      return u(this, null, function* () {
        try {
          this.mediaJoined = !0;
          const {
            maxPreferredStreams: t,
            roomState: e
          } = yield this.sfuHandler.hiveSocketHandler.notifySelfJoinComplete();
          return this.roomUUID = e.roomUuid, _(this, un, !0), _(this, fr, !1), this.maxPreferredStreams = t != null ? t : 6, !0;
        } catch (t) {
          return l.error("error on completing join room:", { error: t }), this.mediaJoined = false, false;
        }
      });
    }
    leaveRoom() {
      return u(this, null, function* () {
        o(this, he).stopAllTransports(), _(this, un, false), o(this, gr, ns).mediaJoinAttempted = false;
        const t = {
          closeRoom: false
        };
        o(this, ht).sendMessagePromise(ae.leaveRoom, Tf.toBinary(t)).then((e) => {
          var n;
          ((n = Af.fromBinary(e.payload)) == null ? undefined : n.closed) || l.warn("weird state on peer closed and should not happen");
        }).catch((e) => {
          l.error("error on sending leave room request", { error: e });
        }), U.callEnded(), v.destruct();
      });
    }
    getConsumers() {
      return o(this, he).consumers;
    }
    activatePeers(t) {
      return u(this, null, function* () {
        return this.createConsumers(t);
      });
    }
    deactivatePeers(t, e = "default") {
      return u(this, null, function* () {
        const r = /* @__PURE__ */ new Set();
        t.forEach((i) => {
          i.screenShare && i.kind === "video" && r.add(i.producingPeerId);
        });
        const n = e === "default" ? t.filter((i) => !r.has(i.producingPeerId)).filter((i) => i.kind !== "audio") : t;
        yield Promise.all(
          n.map((i) => {
            const a = this.sfuHandler.producerIdToConsumerIdMap.get(i.producerId);
            if (!a) {
              l.warn(`consumer not found in deactivate producers: ${i.producerId}`);
              return;
            }
            return this.sfuHandler.closeConsumer(a);
          })
        );
      });
    }
    createConsumers(t) {
      return u(this, null, function* () {
        return t.length === 0 ? Promise.resolve() : this.sfuHandler.createConsumers(t);
      });
    }
    pauseConsumers(t) {
      return u(this, null, function* () {
        t.forEach((e) => {
          this.sfuHandler.pauseConsumer(e);
        });
      });
    }
    resumeConsumers(t) {
      return u(this, null, function* () {
        t.forEach((e) => {
          this.sfuHandler.resumeConsumer(e);
        });
      });
    }
    closeConsumers(t) {
      return u(this, null, function* () {
        const e = t.reduce((r, n) => {
          const i = this.sfuHandler.producerIdToConsumerIdMap.get(n.producerId);
          return i ? (r.push(i), r) : (l.warn(`consumer not found in deactivate producers: ${n.producerId}`), r);
        }, []);
        yield this.sfuHandler.closeConsumers(e);
      });
    }
    shareWebcam(t) {
      return u(this, null, function* () {
        if (t === undefined)
          return null;
        if (o(this, he).producers.has(X.WEBCAM)) {
          const n = o(this, he).producers.get(
            X.WEBCAM
          );
          if (!n.closed && !navigator.isReactNative)
            return yield n.replaceTrack({ track: t }), yield this.resumeWebcam(), t;
          yield o(this, he).removeProducer(X.WEBCAM);
        }
        const e = {
          track: t,
          codecOptions: {
            name: "VP8"
          },
          appData: {
            screenShare: false,
            e2ee: this.e2ee
          },
          stopTracks: false
        };
        if (K.hasFeature(ie.ENABLE_HIVE_SIMULCAST)) {
          let n = t.getConstraints().width;
          n in ih || (n = 320), e.encodings = ih[n];
        }
        const r = () => {
          l.info("Disabling video due to the producer closure"), this.disableWebcam();
        };
        return o(this, he).createProducer(
          X.WEBCAM,
          e,
          r
        );
      });
    }
    shareScreen(t) {
      return u(this, null, function* () {
        const { video: e, audio: r } = t;
        if (e === undefined)
          return;
        const n = {
          track: e,
          codecOptions: {
            name: "VP8"
          },
          appData: {
            screenShare: true,
            e2ee: this.e2ee,
            supportsRemoteControl: ve.isElectron()
          },
          stopTracks: false
        };
        let i = () => {
          l.info("Disabling screenShare due to the producer closure"), this.disableScreenShare();
        };
        if (yield o(this, he).createProducer(
          X.SCREENSHARE_VIDEO,
          n,
          i
        ), r) {
          const a = {
            track: r,
            codecOptions: {
              name: "opus"
            },
            appData: {
              screenShare: true,
              e2ee: this.e2ee,
              supportsRemoteControl: ve.isElectron()
            },
            stopTracks: false,
            zeroRtpOnPause: true
          };
          i = () => {
          }, yield o(this, he).createProducer(
            X.SCREENSHARE_AUDIO,
            a,
            i
          );
        }
        U.screenShareStart();
      });
    }
    shareMic(t) {
      return u(this, null, function* () {
        try {
          if (t === void 0)
            throw new Xe("track undefined");
          if (o(this, he).producers.has(X.MIC)) {
            const n = o(this, he).producers.get(X.MIC);
            if (!n.closed && !navigator.isReactNative) {
              yield n.replaceTrack({ track: t }), yield this.resumeMic();
              return;
            }
            yield o(this, he).removeProducer(X.MIC, !1);
          }
          const e = {
            track: t,
            encodings: [
              {
                priority: "high"
              }
            ],
            codecOptions: {
              name: "opus"
            },
            appData: {
              e2ee: this.e2ee
            },
            stopTracks: !1,
            zeroRtpOnPause: !0
          }, r = () => {
            l.info("Disabling audio due to the producer closure"), this.disableMic();
          };
          yield o(this, he).createProducer(
            X.MIC,
            e,
            r
          );
        } catch (e) {
          throw new w(e);
        }
      });
    }
    pauseMic() {
      const t = o(this, he).producers.get(X.MIC);
      if (!t) {
        l.error("pauseMic::could_not_find_mic_producer");
        return;
      }
      if (t.paused) {
        l.info("pauseMic::mic_producer_already_paused");
        return;
      }
      t.pause();
      const e = {
        producerId: t.id,
        pause: true
      };
      o(this, ht).sendMessage(
        ae.toggleProducer,
        ks.toBinary(e)
      );
    }
    pauseWebcam() {
      return u(this, null, function* () {
        const t = o(this, he).producers.get(
          X.WEBCAM
        );
        if (!t) {
          l.error("pauseWebcam::could_not_find_webcam_producer");
          return;
        }
        t.pause();
        const e = {
          producerId: t.id,
          pause: true
        };
        o(this, ht).sendMessage(
          ae.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    resumeMic() {
      return u(this, null, function* () {
        const t = o(this, he).producers.get(X.MIC);
        if (!t) {
          l.error("resumeMic::could_not_find_mic_producer");
          return;
        }
        if (!t.pause) {
          l.info("resumeMic::mic_producer_already_resumed");
          return;
        }
        t.resume(), t.appData.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, t);
        const e = {
          producerId: t.id,
          pause: false
        };
        o(this, ht).sendMessage(
          ae.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    resumeWebcam() {
      return u(this, null, function* () {
        const t = o(this, he).producers.get(
          X.WEBCAM
        );
        if (!t) {
          l.error("resumeWebcam::could_not_find_webcam_producer");
          return;
        }
        t.resume(), t.appData.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, t);
        const e = {
          producerId: t.id,
          pause: false
        };
        o(this, ht).sendMessage(
          ae.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    disableWebcam() {
      return u(this, null, function* () {
        yield o(this, he).removeProducer(X.WEBCAM);
      });
    }
    disableMic() {
      return u(this, null, function* () {
        yield o(this, he).removeProducer(X.MIC);
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        l.info("screen_sharing_stopped"), U.screenShareStop(), yield o(this, he).removeProducer(X.SCREENSHARE_VIDEO), yield o(this, he).removeProducer(X.SCREENSHARE_AUDIO), o(this, Hr).clear();
      });
    }
    muteSelf() {
      return u(this, null, function* () {
        this.pauseMic();
      });
    }
    unmuteSelf() {
      return u(this, null, function* () {
      });
    }
    resetVideoProducers(t, e) {
      return u(this, null, function* () {
        t && (yield o(this, he).removeProducer(X.WEBCAM, false), this.shareWebcam(t)), e && (yield o(this, he).removeProducer(
          X.SCREENSHARE_VIDEO,
          false
        ), this.shareScreen({ video: e }));
      });
    }
    changeDisplayName(t, e) {
      return u(this, null, function* () {
        const r = {
          displayName: t,
          participantId: e != null ? e : this.peerId
        };
        if (!(yield this.sfuHandler.hiveSocketHandler.changeDisplayName(
          r
        )))
          throw new Error("failed to change display name!");
      });
    }
    kick(t) {
      return u(this, null, function* () {
        const e = {
          participantId: t
        };
        if (!(yield this.sfuHandler.hiveSocketHandler.kickPeer(e)))
          throw new Error("failed to kickout the participant!");
      });
    }
    kickAll() {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.hiveSocketHandler.kickAll()))
          throw new Error("failed to kickout all participant!");
      });
    }
    muteAll(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.hiveSocketHandler.hostControlForAll(
          "audio"
        )))
          throw new Error("failed to mute all participant");
      });
    }
    muteAllVideo() {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.hiveSocketHandler.hostControlForAll(
          "video"
        )))
          throw new Error("failed to mute all video participant");
      });
    }
    disableAudio(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.hiveSocketHandler.hostControlForPeer(
          t,
          "audio"
        )))
          throw new Error("failed to mute given participant");
      });
    }
    disableVideo(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.hiveSocketHandler.hostControlForPeer(
          t,
          "video"
        )))
          throw new Error("failed to mute video of given participant");
      });
    }
    pinPeer(t) {
      return u(this, null, function* () {
        const e = {
          participantId: t != null ? t : ""
        };
        try {
          yield o(this, ht).sendMessagePromise(
            ae.globalPinPeer,
            Ef.toBinary(e)
          );
        } catch (r) {
          l.error("Error in pinning peer:", { error: r });
        }
      });
    }
    validateScreenShare(t) {
      return this.peerId === t.peerId && this.sfuHandler.hasProducer(t.producerId) && o(this, Hr).add(t.consumerPeerId), o(this, Hr).size;
    }
    switchConsumersToLayer(t, e) {
      return u(this, null, function* () {
        this.sfuHandler.switchConsumersToLayer(t, e);
      });
    }
    handleSocketEvents() {
      return u(this, null, function* () {
        o(this, ht).on(
          ae.peerProducerCreateBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const { participantId: e, producerState: r } = Ff.fromBinary(t);
                if (e === this.peerId)
                  return;
                l.info(`producer created broadcast: ${e}, producer state: ${r}`), R.emit(P.NEW_PRODUCER, {
                  peerId: e,
                  producer: z(L({}, r), {
                    kind: r.kind === kt.AUDIO ? "audio" : "video",
                    producingPeerId: e
                  })
                });
              } catch (e) {
                l.error("error in peer-producer-create-broadcast", { error: e });
              }
          }
        ), o(this, ht).on(
          ae.peerProducerToggleBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const {
                  participantId: e,
                  producerState: { kind: r, pause: n, producerId: i }
                } = Vf.fromBinary(t), a = r === kt.AUDIO ? "audio" : "video";
                if (l.info(`producer toggle broadcast: ${e}, producerId: ${i}, kind:${a}, paused:${n}`), e === this.peerId && n) {
                  R.emit(
                    a === "audio" ? P.MUTE_SELF : P.MUTE_SELF_VIDEO
                  );
                  return;
                }
                R.emit(P.PRODUCER_TOGGLE, {
                  peerId: e,
                  producerId: i,
                  paused: n,
                  kind: a
                }), Array.from(this.getConsumers().values()).filter((d) => d.producerId === i).forEach((d) => {
                  d.paused !== n && (l.debug(`consumer state mismatched for ${d.id}. updating consumer pause state ${d.paused} to ${n}`), n ? (d.pause(), R.emit(P.CONSUMER_PAUSED, {
                    id: d.id
                  })) : (d.resume(), R.emit(P.CONSUMER_RESUMED, {
                    id: d.id
                  })));
                });
              } catch (e) {
                l.error("error in producer toggle broadcast handler", { error: e });
              }
          }
        ), o(this, ht).on(ae.peerLeaveBroadcast, ({ payload: t }) => {
          if (this.mediaJoined)
            try {
              const { participantId: e } = oc.fromBinary(t);
              if (e === this.peerId)
                return;
              l.info(`peer left broadcast:${e}`), o(this, Hr).delete(e), this.sfuHandler.cleanupConsumers(e), R.emit(P.PEER_CLOSED, { id: e });
            } catch (e) {
              l.error("error in peer left broadcast", { error: e });
            }
        }), o(this, ht).on(
          ae.peerProducerCloseBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const {
                  participantId: e,
                  producerState: { producerId: r }
                } = Hf.fromBinary(t);
                if (e === this.peerId)
                  return;
                l.info(`producer closed broadcast:${e}`), R.emit(P.PRODUCER_CLOSED, {
                  peerId: e,
                  producerId: r
                });
                const n = this.sfuHandler.producerIdToConsumerIdMap.get(r);
                if (!n) {
                  l.warn(`no consumer found for producer:${r}`);
                  return;
                }
                l.info(`closing consumer ${n}, producer id: ${r}`), this.sfuHandler.closeConsumer(n).then(() => {
                  l.info(`closed consumer: ${n}`), this.sfuHandler.producerIdToConsumerIdMap.delete(r), R.emit(P.CONSUMER_CLOSED, {
                    id: n
                  });
                }).catch((i) => {
                  l.error("error closing consumer", { error: i });
                });
              } catch (e) {
                l.error("error on producer close broadcast", { error: e });
              }
          }
        ), o(this, ht).on(
          ae.mediaRoomTerminationBroadcastResponse,
          () => {
            !this.mediaJoined && !o(this, fr) && !o(this, un) || (l.warn("media hub termination broadcast received, rejoining room"), R.emit(P.ROOM_NODE_DISCONNECTED), this.rejoinRoom());
          }
        );
      });
    }
    handleSFUEvents() {
      o(this, he).on("reconnect_transport", (t) => u(this, null, function* () {
        try {
          yield this.reconnectTransport(t), l.info(`transport reconnected [id:${t.id}]`);
        } catch (e) {
          l.error("error on reconnection transports", { error: e });
        }
      })), o(this, he).on("rejoin", (t) => {
        var e;
        if (((e = o(this, gr, ns).socketState) == null ? undefined : e.state) !== "connected") {
          l.warn("Ignoring rejoin attempt because socket is not connected");
          return;
        }
        if (o(this, pn) > 3 && !t) {
          l.warn("cannot rejoin more already rejoined 3 times");
          return;
        }
        if (o(this, fr) && !t) {
          l.warn("room joining in progress, cannot start rejoining");
          return;
        }
        _(this, pn, o(this, pn) + 1), l.warn(`rejoining the room because transports are failing. [rejoinCount: ${o(this, pn)}]`), this.mediaJoined = false, R.emit(P.ROOM_NODE_DISCONNECTED), this.rejoinRoom();
      });
    }
    handleCallstatsEvents() {
      U.onSafeInitialization(() => {
        U.onConsumerScore((t) => {
          t.forEach((e, r) => {
            const n = this.sfuHandler.consumers.get(r);
            n && R.emit(P.CONSUMER_SCORE_UPDATE, {
              id: r,
              kind: n.kind,
              peerId: n.peerId,
              score: e.score,
              scoreStats: e
            });
          });
        }), U.onProducerScore((t) => {
          t.forEach((e, r) => {
            const n = Array.from(this.sfuHandler.producers.values()).find(
              (i) => i.id === r
            );
            n && R.emit(P.PRODUCER_SCORE_UPDATE, {
              id: r,
              kind: n.kind,
              appData: n.appData,
              score: e.score,
              scoreStats: e
            });
          });
        });
      });
    }
  }, ht = new WeakMap(), he = new WeakMap(), fr = new WeakMap(), un = new WeakMap(), pn = new WeakMap(), Es = new WeakMap(), Ya = new WeakMap(), Qa = new WeakMap(), Xa = new WeakMap(), Hr = new WeakMap(), Ei = new WeakMap(), gr = new WeakSet(), ns = function() {
    return this.context.getValue("connectionHandler");
  }, Mh);
  let ce = Rg;
  me([
    v.trace("HiveNodeClient.reset")
  ], ce.prototype, "reset");
  me([
    v.trace("HiveNodeClient.reconnect")
  ], ce.prototype, "reconnectTransport");
  me([
    v.trace("HiveNodeClient.setupTransport")
  ], ce.prototype, "setupTransports");
  me([
    v.trace("HiveNodeClient.stopAllProducers")
  ], ce.prototype, "stopAllProducers");
  me([
    v.trace("HiveNodeClient.joinRoom")
  ], ce.prototype, "joinRoom");
  me([
    v.trace("HiveNodeClient.completeJoinRoom")
  ], ce.prototype, "completeJoinRoom");
  me([
    v.trace("HiveNodeClient.leaveRoom")
  ], ce.prototype, "leaveRoom");
  me([
    v.trace("HiveNodeClient.activatePeers")
  ], ce.prototype, "activatePeers");
  me([
    v.trace("HiveNodeClient.deactivatePeers")
  ], ce.prototype, "deactivatePeers");
  me([
    v.trace("HiveNodeClient.createConsumers")
  ], ce.prototype, "createConsumers");
  me([
    v.trace("HiveNodeClient.pauseConsumers")
  ], ce.prototype, "pauseConsumers");
  me([
    v.trace("HiveNodeClient.resumeConsumers")
  ], ce.prototype, "resumeConsumers");
  me([
    v.trace("HiveNodeClient.closeConsumers")
  ], ce.prototype, "closeConsumers");
  me([
    v.trace("HiveNodeClient.shareWebcam")
  ], ce.prototype, "shareWebcam");
  me([
    v.trace("HiveNodeClient.shareScreen")
  ], ce.prototype, "shareScreen");
  me([
    v.trace("HiveNodeClient.shareMic")
  ], ce.prototype, "shareMic");
  me([
    v.trace("HiveNodeClient.pauseMic")
  ], ce.prototype, "pauseMic");
  me([
    v.trace("HiveNodeClient.pauseWebcam")
  ], ce.prototype, "pauseWebcam");
  me([
    v.trace("HiveNodeClient.resumeMic")
  ], ce.prototype, "resumeMic");
  me([
    v.trace("HiveNodeClient.resumeWebcam")
  ], ce.prototype, "resumeWebcam");
  me([
    v.trace("HiveNodeClient.disableWebcam")
  ], ce.prototype, "disableWebcam");
  me([
    v.trace("HiveClient.disableMic")
  ], ce.prototype, "disableMic");
  me([
    v.trace("HiveClient.disableScreenShare")
  ], ce.prototype, "disableScreenShare");
  me([
    v.trace("HiveNodeClient.muteSelf")
  ], ce.prototype, "muteSelf");
  me([
    v.trace("HiveNodeClient.resetVideoProducers")
  ], ce.prototype, "resetVideoProducers");
  me([
    v.trace("HiveNodeClient.changeDisplayName")
  ], ce.prototype, "changeDisplayName");
  me([
    v.trace("HiveNodeClient.kickPeer")
  ], ce.prototype, "kick");
  me([
    v.trace("HiveNodeClient.kickAllPeers")
  ], ce.prototype, "kickAll");
  me([
    v.trace("HiveNodeClient.muteAll")
  ], ce.prototype, "muteAll");
  me([
    v.trace("HiveNodeClient.muteAllVideo")
  ], ce.prototype, "muteAllVideo");
  me([
    v.trace("HiveNodeClient.disableAudio")
  ], ce.prototype, "disableAudio");
  me([
    v.trace("HiveNodeClient.disableVideo")
  ], ce.prototype, "disableVideo");
  me([
    v.trace("HiveNodeClient.pinPeer")
  ], ce.prototype, "pinPeer");
  me([
    v.trace("HiveNodeClient.validateScreenShare")
  ], ce.prototype, "validateScreenShare");
  me([
    v.trace("HiveNodeClient.init")
  ], ce, "init");
  class EM {
    constructor() {
      f(this, "_orderedArray");
      f(this, "_map");
      this._map = /* @__PURE__ */ new Map(), this._orderedArray = [];
    }
    add(t, e) {
      if (!this._map.has(t))
        return this._map.set(t, { peerId: t, priority: e }), this._orderedArray.splice(Math.max(e - 1, 0), 0, t), this.index(t);
      const r = this.index(t);
      this.delete(t);
      const n = this.add(t, e);
      return r !== n ? n : -1;
    }
    delete(t) {
      if (this._map.has(t)) {
        const e = this.index(t);
        this._map.delete(t), this._orderedArray.splice(e, 1);
      }
    }
    index(t) {
      return this._map.has(t) ? this._orderedArray.indexOf(t) : -1;
    }
    [Symbol.iterator]() {
      return this._orderedArray[Symbol.iterator]();
    }
  }
  class CM {
    constructor() {
      f(this, "_activeSpeakerPeers");
      f(this, "_compulsoryPeers");
      this._activeSpeakerPeers = new EM(), this._compulsoryPeers = /* @__PURE__ */ new Set();
    }
    add(t, e) {
      if (!t)
        return -1;
      if (e < 0)
        return this._compulsoryPeers.add(t), 0;
      if (this.compulsoryPeers.includes(t) && (e > 0 || e === 246267631)) {
        if (l.info("DyteSelectedPeer::removing_compulsory_peer", {
          selectedPeer: {
            peerId: t
          }
        }), this._removeFromCompulsoryPeer(t), e === 246267631)
          return -1;
      } else if (e === 229490415)
        return this.delete(t), -1;
      return this._activeSpeakerPeers.add(t, e);
    }
    delete(t) {
      l.info("DyteSelectedPeer::deleting_peer_from_selectedPeer", {
        selectedPeer: {
          peerId: t
        }
      }), this._removeFromCompulsoryPeer(t), this._activeSpeakerPeers.delete(t);
    }
    index(t) {
      return this._activeSpeakerPeers.index(t);
    }
    get peers() {
      return Array.from(new Set(this.compulsoryPeers.concat(this.activeSpeakerPeers)));
    }
    get compulsoryPeers() {
      return Array.from(this._compulsoryPeers.values());
    }
    get activeSpeakerPeers() {
      return Array.from(this._activeSpeakerPeers);
    }
    _removeFromCompulsoryPeer(t) {
      this._compulsoryPeers.delete(t);
    }
  }
  const bg = new CM();
  var wM = Object.defineProperty, PM = Object.getOwnPropertyDescriptor, Ht = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? PM(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && wM(t, e, n), n;
  };
  const RM = ["ACTIVE_GRID", "PAGINATED", "MANUAL"];
  var vr, yr, is, hn, xt, Oh;
  let Ct = (Oh = class extends Ft {
    constructor(t, e, r) {
      super();
      // eslint-disable-next-line class-methods-use-this
      E(this, yr);
      /**
       * Returns a list of participants waiting to join the meeting.
       */
      f(this, "waitlisted");
      /**
       * Returns a list of all participants in the meeting.
       */
      f(this, "joined");
      /**
       * @deprecated
       * Returns a list of participants whose streams are currently consumed.
       */
      f(this, "active");
      /**
       * Returns a list of participants whose video streams are currently consumed.
       */
      f(this, "videoSubscribed");
      /**
       * Returns a list of participants whose audio streams are currently consumed.
       */
      f(this, "audioSubscribed");
      /**
       * Returns a list of participants who have been pinned.
       */
      f(this, "pinned");
      /**
       * Returns all added participants irrespective of whether they are currently
       * in the meeting or not
       */
      f(this, "all");
      E(this, vr, undefined);
      E(this, hn, undefined);
      E(this, xt, undefined);
      f(this, "rateLimitConfig", {
        maxInvocations: 5,
        period: 1
      });
      /**
       * Indicates whether the meeting is in 'ACTIVE_GRID' mode or 'PAGINATED' mode.
       *
       * In 'ACTIVE_GRID' mode, participants are populated in the participants.active map
       * dynamically. The participants present in the map will keep changing when other
       * participants unmute their audio or turn on their videos.
       *
       * In 'PAGINATED' mode, participants are populated in the participants.active map
       * just once, and the participants in the map will only change if the page number is
       * changed by the user using setPage(page).
       */
      f(this, "viewMode");
      /**
       * This indicates the current page that has been set by the user in PAGINATED mode.
       * If the meeting is in ACTIVE_GRID mode, this value will be 0.
       */
      f(this, "currentPage");
      /**
       * This stores the `participantId` of the last participant who spoke in the meeting.
       */
      f(this, "lastActiveSpeaker");
      /**
       * This constructs a new DyteParticipant object and maintains
       * the maps of active/joined/waitlisted/pinned/selectedPeers maps.
       * @param self : DyteSelf
       */
      /**
       * Keeps a list of all participants who have been present in the selected peers list.
       */
      f(this, "selectedPeers", bg);
      _(this, vr, t), _(this, hn, e), _(this, xt, r), this.waitlisted = new ca(), this.joined = new ca(), this.videoSubscribed = new ca(), this.audioSubscribed = new ca(), this.active = this.videoSubscribed, this.pinned = new ca(), this.all = new eM(), this.viewMode = "ACTIVE_GRID", this.currentPage = 0, this.setupEvents();
    }
    /**
     * Return the controls for Picture-in-Picture
     */
    get pip() {
      return o(this, vr).getValue("pip");
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get socketJoined() {
      var t;
      return ((t = o(this, vr).getValue("connectionHandler")) == null ? undefined : t.socketJoined) === true;
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get mediaJoined() {
      var t;
      return ((t = o(this, vr).getValue("connectionHandler")) == null ? undefined : t.mediaJoined) === true;
    }
    get rateLimits() {
      return this.rateLimitConfig;
    }
    updateRateLimits(t, e) {
      this.rateLimitConfig.maxInvocations = t, this.rateLimitConfig.period = e;
    }
    setupEvents() {
      R.on(P.E2EE_ACTIVE_CONSUMER, ({ peerId: t }) => {
        var e;
        ((e = o(this, vr).getValue("modules").e2ee) == null ? undefined : e.enabled) !== true && this.emit("media_decode_error", {
          reason: `Got encrypted media for participantId ${t}, but encryption wasn't enabled in init.defaults`,
          code: "1702"
        });
      });
    }
    /**
     * Returns the number of participants who are joined in the meeting.
     */
    get count() {
      return this.joined.size;
    }
    /**
     * Returns the maximum number of participants that can be present in
     * the active map.
     */
    get maxActiveParticipantsCount() {
      return o(this, yr, is).maxPreferredStreams;
    }
    /**
     * Updates the maximum number of participants that are populated in
     * the active map.
     *
     * @param limit: Updated max limit
     */
    setMaxActiveParticipantsCount(t) {
      if (t < 0 || t > 24)
        throw new w("0 <= Max active participants count limit <= 24");
      o(this, yr, is).maxPreferredStreams = t, this.mediaJoined && R.emit(P.UPDATE_ACTIVE);
    }
    /**
     * Returns the number of pages that are available in the meeting in PAGINATED mode.
     * If the meeting is in ACTIVE_GRID mode, this value will be 0.
     */
    get pageCount() {
      if (this.viewMode === "PAGINATED") {
        const t = this.selectedPeers.compulsoryPeers.length, e = this.joined.toArray().filter((r) => r.stageStatus === "ON_STAGE");
        return Math.ceil(
          (e.length - t) / (this.maxActiveParticipantsCount - t)
        );
      }
      return 0;
    }
    /**
     * Accepts requests from waitlisted participants if user
     * has appropriate permissions.
     * @param id peerId or userId of the waitlisted participant.
     */
    acceptWaitingRoomRequest(t) {
      var r, n;
      if (!this.socketJoined)
        throw new w(
          "Can`t accept waiting room request without joining room"
        );
      const e = (n = (r = this.waitlisted.get(t)) == null ? undefined : r.userId) != null ? n : t;
      return o(this, xt).acceptWaitingRoomRequest([e]);
    }
    /**
     * We need a new event for socket service events
     * since if we send them all together, sequence of events
     * can be unreliable
     */
    acceptAllWaitingRoomRequest(t) {
      return u(this, null, function* () {
        const e = t.map((r) => {
          var n, i;
          return (i = (n = this.waitlisted.get(r)) == null ? undefined : n.userId) != null ? i : r;
        });
        return o(this, xt).acceptWaitingRoomRequest(e);
      });
    }
    /**
     * Rejects requests from waitlisted participants if user
     * has appropriate permissions.
     * @param id participantId of the waitlisted participant.
     */
    rejectWaitingRoomRequest(t) {
      return u(this, null, function* () {
        var r, n;
        if (!this.socketJoined)
          throw new w(
            "Can`t reject waiting room request without joining room"
          );
        const e = (n = (r = this.waitlisted.get(t)) == null ? undefined : r.userId) != null ? n : t;
        o(this, xt).rejectWaitingRoomRequest([e]);
      });
    }
    setViewMode(t) {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::set_view_mode", {
          pageNavigation: {
            viewMode: t,
            currentPage: this.currentPage,
            pageCount: this.pageCount,
            maxActiveParticipantsCount: this.maxActiveParticipantsCount
          }
        }), !((r) => RM.includes(r))(t))
          throw l.error("DyteParticipants::setViewMode::invalid_view_mode", {
            pageNavigation: {
              viewMode: t,
              currentPage: this.currentPage,
              pageCount: this.pageCount,
              maxActiveParticipantsCount: this.maxActiveParticipantsCount
            }
          }), new w(
            `Invalid view mode: ${t}. Try ACTIVE_GRID, PAGINATED or MANUAL.`
          );
        if (this.viewMode === t) {
          l.info(
            "DyteParticipants::setViewMode::view_mode_same_as_previous"
          );
          return;
        }
        if (t === "MANUAL" && !(o(this, yr, is) instanceof ce))
          throw new w(
            "Manual Subscription is not enabled for your Organization. Please contact support."
          );
        this.viewMode = t, t === "PAGINATED" ? (this.currentPage = 1, R.emit(P.UPDATE_ACTIVE, { page: this.currentPage })) : t === "ACTIVE_GRID" && (this.currentPage = 0, R.emit(P.UPDATE_ACTIVE)), this.emit("viewModeChanged", {
          viewMode: t,
          currentPage: this.currentPage,
          pageCount: this.pageCount
        });
      });
    }
    subscribe(r) {
      return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
        if (this.viewMode !== "MANUAL")
          throw new w("MANUAL subscription mode was not activated.");
        const n = [];
        t.forEach((i) => {
          const a = this.joined.get(i);
          if (a) {
            if (e.includes("audio")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                audio: true
              }), this.videoSubscribed.add(a);
              const c = a.producers.find((d) => d.kind === "audio" && !d.screenShare);
              c && n.push(c);
            }
            if (e.includes("video")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                video: true
              }), this.audioSubscribed.add(a);
              const c = a.producers.find((d) => d.kind === "video" && !d.screenShare);
              c && n.push(c);
            }
            if (e.includes("screenshareAudio")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                screenshareAudio: true
              });
              const c = a.producers.find(
                (d) => d.kind === "audio" && d.screenShare
              );
              n.push(c);
            }
            if (e.includes("screenshareVideo")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                screenshareVideo: true
              });
              const c = a.producers.find(
                (d) => d.kind === "video" && d.screenShare
              );
              n.push(c);
            }
          }
        }), yield o(this, yr, is).createConsumers(n);
      });
    }
    unsubscribe(r) {
      return u(this, arguments, function* (t, e = ["audio", "video", "screenshareAudio", "screenshareVideo"]) {
        if (this.viewMode !== "MANUAL")
          throw new w("MANUAL subscription mode was not activated.");
        const n = [];
        t.forEach((i) => {
          const a = this.joined.get(i);
          if (a) {
            if (e.includes("audio")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                audio: false
              });
              const c = a.producers.find((d) => d.kind === "audio" && !d.screenShare);
              c && n.push(c);
            }
            if (e.includes("video")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                video: false
              });
              const c = a.producers.find((d) => d.kind === "video" && !d.screenShare);
              c && n.push(c);
            }
            if (e.includes("screenshareAudio")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                screenshareAudio: false
              });
              const c = a.producers.find(
                (d) => d.kind === "audio" && d.screenShare
              );
              n.push(c);
            }
            if (e.includes("screenshareVideo")) {
              a.manualProducerConfig = z(L({}, a.manualProducerConfig), {
                screenshareVideo: false
              });
              const c = a.producers.find(
                (d) => d.kind === "video" && d.screenShare
              );
              n.push(c);
            }
          }
        }), yield o(this, yr, is).closeConsumers(n);
      });
    }
    // NOTE(itzmanish): hive systems specific code
    getPeerIdsForCurrentPage() {
      l.info("DyteParticipants::getPeerIdsForCurrentPage()", {
        pageNavigation: {
          viewMode: this.viewMode,
          currentPage: this.currentPage,
          pageCount: this.pageCount,
          maxActiveParticipantsCount: this.maxActiveParticipantsCount
        }
      });
      const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
        (c) => this.joined.has(c)
      ), r = Array.from(this.pinned.keys()).filter(
        (c) => !e.includes(c)
      ), n = Array.from(this.joined.toArray().filter((c) => c.stageStatus === "ON_STAGE").map((c) => c.id)), i = Math.max(
        (this.currentPage - 1) * (this.maxActiveParticipantsCount - e.length - r.length)
      ), a = this.currentPage * (this.maxActiveParticipantsCount - e.length - r.length);
      return e.concat(r, n.slice(i, a));
    }
    setPage(t) {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::set_page", {
          pageNavigation: {
            settingPage: t,
            viewMode: this.viewMode,
            currentPage: this.currentPage,
            pageCount: this.pageCount,
            maxActiveParticipantsCount: this.maxActiveParticipantsCount
          }
        }), this.viewMode === "PAGINATED") {
          if (!Number.isInteger(t))
            throw l.error("DyteParticipants::invalid_page_number"), new w(`Invalid page: ${t}. Page must be an integer and greater than 0 and less than or equal to .pageCount`);
          this.currentPage = t, R.emit(P.UPDATE_ACTIVE, { page: t }), this.emit("pageChanged", {
            viewMode: this.viewMode,
            currentPage: this.currentPage,
            pageCount: this.pageCount
          });
        }
      });
    }
    disableAllAudio(t) {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::disable_all_audio", {
          actions: { disableAllAudio: { allowUnmute: t } }
        }), !this.mediaJoined)
          throw new w("Can`t disable all audio without joining room");
        if (o(this, hn).permissions.canAllowParticipantAudio)
          return o(this, yr, is).muteAll(t);
        throw l.error("DyteParticipants::unauthorized_disable_all_audio", {
          actions: { disableAllAudio: { allowUnmute: t } }
        }), new w(
          "Unauthorized: User does not have permission to disable peer audio."
        );
      });
    }
    disableAllVideo() {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::disable_all_video"), !this.mediaJoined)
          throw new w("Can`t disable all video without joining room");
        if (o(this, hn).permissions.canAllowParticipantVideo)
          return o(this, yr, is).muteAllVideo();
        throw l.error("DyteParticipants::unauthorized_disable_all_video"), new w(
          "Unauthorized: User does not have permission to disable peer video."
        );
      });
    }
    disableAudio(t) {
      return u(this, null, function* () {
        this.joined.get(t).disableAudio();
      });
    }
    disableVideo(t) {
      return u(this, null, function* () {
        this.joined.get(t).disableVideo();
      });
    }
    kick(t) {
      return u(this, null, function* () {
        yield R.emitAsync(P.KICK_PEER, {
          peerId: t
        });
      });
    }
    kickAll() {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::kick_all"), o(this, vr).getValue("viewType") !== "LIVESTREAM" && !this.socketJoined)
          throw new w("Can`t kick all without joining room");
        if (!o(this, hn).permissions.kickParticipant)
          throw l.error("DyteParticipants::unauthorized_kick_all"), new w(
            "Unauthorized: User does not have permission to kick peers."
          );
        const e = K.hasFeature(ie.PROPAGATE_KICK_ALL);
        o(this, xt).kickAll(e);
      });
    }
    broadcastMessage(t, e, r) {
      return u(this, null, function* () {
        if (l.info("DyteParticipants::broadcastMessage"), !this.socketJoined)
          throw new w("Can`t broadcast message without joining room");
        if (!(t != null && t.trim()))
          throw new w("`type` must be a non-empty string.");
        if (r) {
          let n = [];
          "participantIds" in r ? n = r.participantIds : n = this.joined.toArray().filter(
            (i) => {
              var a;
              return (a = r.presetNames) == null ? undefined : a.includes(i.presetName);
            }
          ).map((i) => i.id), o(this, xt).broadcastToPeers(t, n, e);
        } else
          o(this, xt).broadcastMessage(t, e);
      });
    }
    getAllJoinedPeers(t, e, r) {
      return u(this, null, function* () {
        return (yield o(this, xt).getRoomPeers(t, e, r)).peers.map(es.formatSocketServiceMessage);
      });
    }
    updatePermissions(t, e) {
      return u(this, null, function* () {
        const r = this.joined.toArray().filter((i) => t.includes(i.id)).map((i) => i.userId), n = [...new Set(r)];
        if (!n.length)
          throw new w("Cannot update permissions, no valid userIDs found");
        o(this, xt).updatePermissions(n, e);
      });
    }
    getParticipantsInMeetingPreJoin() {
      return u(this, null, function* () {
        return o(this, xt).getRoomPeersNonPaginated();
      });
    }
  }, vr = new WeakMap(), yr = new WeakSet(), is = function() {
    return o(this, vr).getValue("roomNodeClient");
  }, hn = new WeakMap(), xt = new WeakMap(), Oh);
  Ht([
    v.trace("DyteParticipants.setViewMode")
  ], Ct.prototype, "setViewMode", 1);
  Ht([
    v.trace("DyteParticipants.setPage")
  ], Ct.prototype, "setPage", 1);
  Ht([
    v.trace("DyteParticipants.disableAllAudio")
  ], Ct.prototype, "disableAllAudio", 1);
  Ht([
    v.trace("DyteParticipants.disableAllVideo")
  ], Ct.prototype, "disableAllVideo", 1);
  Ht([
    v.trace("DyteParticipants.disablePeerAudio")
  ], Ct.prototype, "disableAudio", 1);
  Ht([
    v.trace("DyteParticipants.disablePeerVideo")
  ], Ct.prototype, "disableVideo", 1);
  Ht([
    v.trace("DyteParticipants.kickPeer")
  ], Ct.prototype, "kick", 1);
  Ht([
    v.trace("DyteParticipants.kickAll")
  ], Ct.prototype, "kickAll", 1);
  Ht([
    v.trace("DyteParticipants.broadcastMessage"),
    At(Fi, "rateLimitConfig")
  ], Ct.prototype, "broadcastMessage", 1);
  Ht([
    v.trace("DyteParticipants.getAllJoinedPeers"),
    At({ maxInvocations: 10, period: 60 })
  ], Ct.prototype, "getAllJoinedPeers", 1);
  Ht([
    v.trace("DyteParticipant.updatePermissions"),
    At({ maxInvocations: 1e3, period: 60 })
  ], Ct.prototype, "updatePermissions", 1);
  Ht([
    v.trace("DyteParticipants.getParticipantsInMeetingPreJoin")
  ], Ct.prototype, "getParticipantsInMeetingPreJoin", 1);
  Ct = Ht([
    vt("1200")
  ], Ct);
  var bM = Object.defineProperty, kM = Object.getOwnPropertyDescriptor, Bi = (s, t, e, r) => {
    for (var n = kM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && bM(t, e, n), n;
  };
  const kg = class {
    constructor(s, t, e) {
      f(this, "participants");
      f(this, "self");
      f(this, "selectedPeers", bg);
      f(this, "maxSpatialLayerUpdates", /* @__PURE__ */ new Map());
      f(this, "consumerPeerMap");
      f(this, "roomSocketHandler");
      f(this, "context");
      f(this, "videoPeerConsumerMap", /* @__PURE__ */ new Map());
      f(this, "updateConsumerSpatialLayers", zr(() => {
        const s = {}, t = new Map(this.maxSpatialLayerUpdates);
        this.maxSpatialLayerUpdates.clear(), Array.from(t.entries()).forEach(([e, r]) => {
          s[r] === undefined && (s[r] = {
            layer: r,
            consumerIds: []
          }), s[r].consumerIds.push(e);
        }), Object.keys(s).forEach((e) => {
          const r = s[e];
          l.log(`Switching max spatial layer to ${r.layer}`, { consumerIds: r.consumerIds }), this.roomNodeClient.switchConsumersToLayer(r.consumerIds, r.layer);
        });
      }, 2e3));
      f(this, "updateConsumers", (s, t) => {
        l.info("Consuming producers", { producers: s }), l.info("Closing consumers for producers", { producers: t }), this.roomNodeClient.closeConsumers(t).then(() => {
          this.roomNodeClient.createConsumers(s).catch((e) => l.error("Error activating peers", { error: e }));
        }).catch((e) => l.error("Error deactivating peers", { error: e }));
      });
      f(this, "updateConsumersDebounced", zr(this.updateConsumers, 200, { trailing: true }));
      this.context = s, this.roomSocketHandler = e, this.participants = new Ct(s, t, this.roomSocketHandler), this.self = t, this.consumerPeerMap = /* @__PURE__ */ new Map(), t.config.viewType !== "CHAT" && this.setupEventsGlobal();
    }
    get mediaJoined() {
      var s;
      return ((s = this.roomNodeClient) == null ? undefined : s.mediaJoined) === true;
    }
    get pip() {
      return this.context.getValue("pip");
    }
    /**
     * Socket Service only
     */
    waitingRoomRequestHandler(s) {
      const t = s.requests.filter(
        (r) => !this.participants.waitlisted.toArray().find((n) => n.userId === r.userId)
      ), e = this.participants.waitlisted.toArray().filter(
        (r) => !s.requests.find((n) => n.userId === r.userId)
      );
      t.forEach((r) => this.participants.waitlisted.add(
        new Qr(
          this.context,
          {
            id: r.peerId,
            displayName: r.displayName,
            audioMuted: true,
            videoEnabled: false,
            audioTrack: undefined,
            videoTrack: undefined,
            stageStatus: "OFF_STAGE",
            userId: r.userId,
            flags: {},
            isHost: false,
            customParticipantId: r.customParticipantId,
            picture: r.picture,
            metadata: {
              preset_name: r.presetName
            }
          },
          this.self,
          this.roomSocketHandler
        )
      )), e.forEach((r) => this.participants.waitlisted.delete(r.id));
    }
    get maxPreferredStreams() {
      return this.participants.maxActiveParticipantsCount;
    }
    selectPagePeers(s) {
      return u(this, null, function* () {
        const { compulsoryPeers: t } = this.selectedPeers, e = t.filter(
          (d) => this.participants.joined.has(d)
        ), r = Array.from(this.participants.pinned.keys()).filter(
          (d) => !e.includes(d)
        ), n = Array.from(this.participants.joined.toArray().filter((d) => d.stageStatus === "ON_STAGE").map((d) => d.id)), i = Math.max(
          (s - 1) * (this.roomNodeClient.maxPreferredStreams - e.length - r.length)
        ), a = s * (this.roomNodeClient.maxPreferredStreams - e.length - r.length);
        return e.concat(r, n.slice(i, a));
      });
    }
    selectActivePeers() {
      return u(this, null, function* () {
        const s = /* @__PURE__ */ new Map(), t = Array.from(
          this.participants.joined.toArray().filter((p) => p.stageStatus === "ON_STAGE").map((p) => (s.set(p.id, true), p.id))
        ), e = this.selectedPeers.peers, r = this.participants.pinned.toArray().reduce((p, h) => (h.stageStatus !== "ON_STAGE" ? this.participants.pinned.delete(h.id) : p.push(h.id), p), []), n = this.self.stageStatus === "ON_STAGE" ? 1 : 0, i = this.participants.maxActiveParticipantsCount - n, a = new Set(
          e.concat(r).filter((p) => p !== this.self.id && s.has(p))
        );
        let c = Array.from(a);
        const d = i - a.size;
        if (d >= 0) {
          const p = t.filter((h) => !a.has(h) && h !== this.self.id).slice(0, d);
          c = Array.from(a).concat(p);
        } else
          c = c.slice(0, i);
        return c;
      });
    }
    updateActive(s, t) {
      return u(this, null, function* () {
        const { page: e, createAllConsumers: r } = t != null ? t : {};
        let { strategies: n } = t != null ? t : {}, i, a;
        switch (s) {
          case "PAGINATED": {
            if (!e)
              return;
            i = yield this.selectPagePeers(e), l.info(
              "ParticipantController::updateActive::updating_current_page_peers",
              { peerIds: i }
            ), n != null || (n = {
              video: this.updateParticipantsMap.bind(this)
            }), a = this.updateConsumersDebounced;
            break;
          }
          case "ACTIVE_GRID": {
            i = yield this.selectActivePeers(), l.info(
              "ParticipantController::updateActive::updating_current_selected_peers",
              { peerIds: i }
            ), n != null || (n = {
              video: this.updateParticipantsMapMinReplacement.bind(this),
              audio: this.updateParticipantsMap.bind(this)
            }), a = this.updateConsumers;
            break;
          }
          default:
            throw new Error(`View mode ${s} not supported`);
        }
        let c, d;
        const p = this.updateGrid(i, n);
        r ? (c = this.mapPeerIdsToProducers(i, ["audio", "video", "screenshare"]), d = []) : (c = [
          ...this.mapPeerIdsToProducers([
            ...p.video.add
          ], ["video"]),
          ...this.mapPeerIdsToProducers([
            ...p.audio.add
          ], ["audio"])
        ], d = [
          ...this.mapPeerIdsToProducers([
            ...p.video.remove
          ], ["video"]),
          ...this.mapPeerIdsToProducers([
            ...p.audio.remove
          ], ["audio"])
        ]), a(c, d);
      });
    }
    computeActivateParticipants(s, t) {
      const e = s.map((n, i) => ({
        peerId: n,
        priority: i + 1
      })), r = t == null ? undefined : t.map((n, i) => ({
        peerId: n,
        priority: -(i + 1)
      }));
      e.push(...r != null ? r : []), e.length > 0 && this.updateActiveParticipantsWithPriorities(e);
    }
    fromSocketService(s) {
      const t = kg.formatSocketServiceMessage(s);
      return new Qr(this.context, z(L({}, t), {
        isHost: false,
        videoEnabled: false,
        audioMuted: true,
        videoTrack: undefined,
        audioTrack: undefined
      }), this.self, this.roomSocketHandler);
    }
    updatePipSource(s, t) {
      var e, r;
      t ? (e = this.pip) == null || e.enableSource(s) : (r = this.pip) == null || r.disableSource(s);
    }
    onMediaJoined(s, t) {
      if (!this.mediaJoined || s === this.self.id)
        return;
      const e = this.participants.joined.get(s);
      if (!e) {
        l.warn(`Recieved media.peerJoinedBroadcast for non-existent peer ${s}`);
        return;
      }
      t.forEach((r) => {
        r.kind === kt.AUDIO && !r.screenShare ? e.setAudioEnabled(!r.pause) : r.kind === kt.VIDEO && !r.screenShare && (e.setVideoEnabled(!r.pause), this.updatePipSource(e.id, !r.pause)), e.producers.push(z(L({}, r), {
          producingTransportId: r.producingTransportId,
          kind: r.kind === kt.AUDIO ? "audio" : "video",
          producingPeerId: s
        }));
      });
    }
    /**
    	* NOTE(roerohan): The following piece of code updates .active and ensures that the positions
    	* in the peer map are not affected by the order of the peerIds
    	* sent in the input. If a participant is present in the 3rd position in the
    	* map, and room node sends the peerId in the 2nd position, the participant
    	* should remain in the 3rd position.
    */
    updateParticipantsMapMinReplacement(s, t) {
      const e = Array.from(s.keys()), r = new Map(s), n = [], i = [], a = new Set(t), c = [];
      return e.forEach((d, p) => {
        (!a.has(d) || !this.participants.joined.get(d)) && c.push(p);
      }), t.forEach((d) => {
        if (s.get(d))
          return;
        if (e.length < t.length) {
          e.push(d), n.push(d);
          return;
        }
        const p = c.shift();
        i.push(e[p]), e[p] = d, n.push(e[p]);
      }), e.forEach((d, p) => {
        a.has(d) || i.concat(
          e.splice(p, 1)
        );
      }), Array.from(s.keys()).forEach((d) => {
        s.delete(d, !a.has(d));
      }), e.forEach((d) => {
        if (!this.participants.joined.get(d)) {
          l.warn(
            "updateActiveParticipants::participant_not_in_joined_list",
            {
              dyteParticipant: { id: d }
            }
          );
          return;
        }
        s.add(
          this.participants.joined.get(d),
          !r.get(d)
        ), n.push(d);
      }), s.emit("participantsUpdate"), [n, i];
    }
    updateParticipantsMap(s, t) {
      const e = Array.from(s.keys()), r = [], n = [];
      return e.forEach((i) => {
        t.includes(i) || (s.delete(i, true), n.push(i));
      }), t.forEach((i) => {
        s.get(i) || (s.add(this.participants.joined.get(i)), r.push(i));
      }), s.emit("participantsUpdate"), [r, n];
    }
    updatePinnedParticipants() {
      this.participants.pinned.forEach((s) => {
        s.setIsPinned(false), this.participants.pinned.delete(s.id);
      });
    }
    setupEventsGlobal() {
      this.roomSocketHandler.on(F.joinRoom, ({ peer: s }) => {
        if (!s.waitlisted) {
          const t = K.hasFeature(ie.DEBUG_SOCKET_JOIN);
          t && l.info("Processing socket join", { peers: s.peerId }), this.onParticipantJoined(this.fromSocketService(s)), t && l.info("Processed socket join", { peers: s.peerId });
        }
      }), this.roomSocketHandler.on(F.leaveRoom, (s) => {
        this.selectedPeers.delete(s.peer.peerId), this.onParticipantLeave(s.peer.peerId);
      }), R.on(
        P.SOCKET_SERVICE_ROOM_JOINED,
        () => {
          this.self.permissions.acceptWaitingRequests && this.roomSocketHandler.getWaitingRoomRequests();
        }
      ), this.self.permissions.on("permissionsUpdate", (s) => {
        const { acceptWaitingRequests: t } = s;
        t !== undefined && (t ? this.roomSocketHandler.getWaitingRoomRequests() : this.participants.waitlisted.clear());
      }), R.on(P.SOCKET_SERVICE_DISCONNECTED, () => {
        this.participants.joined.clear(), this.participants.videoSubscribed.clear(), this.participants.audioSubscribed.clear(), this.participants.pinned.clear(), this.participants.currentPage = 0, this.participants.viewMode = "ACTIVE_GRID", this.participants.emit("viewModeChanged", {
          viewMode: "ACTIVE_GRID",
          currentPage: this.participants.currentPage,
          pageCount: this.participants.pageCount
        });
      }), R.on(
        P.CONSUMER_PAUSED,
        ({ id: s }) => {
          this.processConsumerPaused(s);
        }
      ), R.on(
        P.CONSUMER_RESUMED,
        ({ id: s }) => {
          this.processConsumerResumed(s);
        }
      ), R.on(
        P.NEW_CONSUMER,
        ({ id: s }) => {
          this.processNewConsumer(s);
        }
      ), R.on(
        P.CONSUMER_CLOSED,
        ({ id: s }) => {
          this.processConsumerClosed(s);
        }
      ), R.on(
        P.ROOM_MESSAGE,
        (r) => u(this, [r], function* ({
          payload: s,
          type: t,
          timestamp: e
        }) {
          this.participants.emit("broadcastedMessage", {
            type: t,
            payload: s,
            timestamp: e
          });
        })
      ), R.on(
        P.MESSAGE,
        (r) => u(this, [r], function* ({
          payload: s,
          type: t,
          timestamp: e
        }) {
          t !== "spotlight" && this.participants.emit("broadcastedMessage", {
            type: t,
            payload: s,
            timestamp: e
          });
        })
      ), R.on(
        P.LOW_CONSUMER_SCORE,
        ({
          peerId: s,
          score: t,
          kind: e
        }) => {
          const r = this.participants.joined.get(s);
          r && (r.emit("poorConnection", { score: t, kind: e }), this.participants.emit("poorConnection", {
            participantId: s,
            score: t,
            kind: e
          }));
        }
      ), R.on(
        P.CONSUMER_SCORE_UPDATE,
        ({
          score: s,
          kind: t,
          appData: e,
          peerId: r,
          scoreStats: n
        }) => {
          var c;
          const i = t === "video" && ((c = e == null ? undefined : e.screenShare) != null ? c : false), a = this.participants.joined.get(r);
          a && (a.emit("mediaScoreUpdate", {
            kind: t,
            isScreenshare: i,
            score: s,
            participantId: r,
            scoreStats: n
          }), this.participants.emit("mediaScoreUpdate", {
            kind: t,
            isScreenshare: i,
            score: s,
            participantId: r,
            scoreStats: n
          }));
        }
      ), R.onAsync(P.KICK_PEER, (t) => u(this, [t], function* ({ peerId: s }) {
        const e = this.participants.joined.get(s);
        yield this.roomNodeClient.kick(s), yield this.roomSocketHandler.kick(s), e ? e.emit("kicked") : this.participants.joined.emit("kicked", { id: s });
      })), R.on(P.UPDATE_ACTIVE, (...e) => u(this, [...e], function* ({ page: s, createAllConsumers: t } = {}) {
        yield this.updateActive(s ? "PAGINATED" : "ACTIVE_GRID", { page: s, createAllConsumers: t });
      }));
    }
    onParticipantPinned(s) {
      return u(this, null, function* () {
        if (!s) {
          this.self.isPinned && this.self.setIsPinned(false), this.participants.pinned.size !== 0 && this.updatePinnedParticipants();
          return;
        }
        if (s === this.self.id) {
          this.participants.pinned.size !== 0 && this.updatePinnedParticipants(), this.self.setIsPinned(true);
          return;
        }
        const t = this.participants.joined.get(s);
        this.self.isPinned && this.self.setIsPinned(false), this.updatePinnedParticipants(), t.setIsPinned(true), this.participants.pinned.add(t);
      });
    }
    onParticipantJoined(s) {
      return u(this, null, function* () {
        var e, r, n;
        if (this.self.id !== s.id && !((e = s.flags) != null && e.recorder) && !((r = s.flags) != null && r.hidden_participant) && !((n = s.flags) != null && n.hiddenParticipant) && (this.participants.videoSubscribed.delete(s.id), this.participants.audioSubscribed.delete(s.id), this.participants.joined.add(s), this.participants.waitlisted.delete(s.id), s.stageStatus === "REQUESTED_TO_JOIN_STAGE" && R.emit(P.UPDATE_STAGE_REQUESTS, {
          request: {
            displayName: s.name,
            userId: s.userId,
            peerId: s.id
          },
          add: true
        })), R.emit(P.PEER_JOINED_INTERNAL, s), this.self.config.viewType === gt.Webinar && s.stageStatus !== "ON_STAGE" || this.roomNodeClient === undefined || this.participants.videoSubscribed.size >= this.roomNodeClient.maxPreferredStreams)
          return;
        const t = this.participants.currentPage;
        this.updateActive(
          t ? "PAGINATED" : "ACTIVE_GRID",
          { page: t }
        );
      });
    }
    onParticipantLeave(s) {
      return u(this, null, function* () {
        const t = this.participants.joined.get(s);
        this.participants.joined.delete(s, true, true), this.participants.pinned.delete(s, true, true), this.participants.waitlisted.delete(s, true, true), t && t.stageStatus === "REQUESTED_TO_JOIN_STAGE" && R.emit(P.UPDATE_STAGE_REQUESTS, {
          request: {
            displayName: t.name,
            userId: t.userId,
            peerId: t.id
          },
          add: false
        });
        const { currentPage: e } = this.participants, r = this.maxPreferredStreams * (e - 1), n = this.participants.videoSubscribed.get(s);
        r === 0 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.joined.size <= r ? e === 2 ? this.participants.setViewMode("ACTIVE_GRID") : this.participants.setPage(e - 1) : n && this.updateActive(
          e ? "PAGINATED" : "ACTIVE_GRID",
          { page: e }
        );
      });
    }
    processMedia(s) {
      var h;
      const t = this.roomNodeClient.getConsumers(), {
        peerId: e,
        kind: r,
        appData: n,
        remotelyPaused: i,
        track: a,
        producerId: c,
        rtpReceiver: d
      } = (h = t.get(s)) != null ? h : {};
      if (!e)
        return l.warn("processMedia::Peer ID is undefined", {
          consumer: {
            id: s,
            kind: r,
            peerId: e,
            appData: {
              supportsRemoteControl: n == null ? undefined : n.supportsRemoteControl,
              screenShare: n == null ? undefined : n.screenShare
            },
            remotelyPaused: i,
            producerId: c
          }
        }), {};
      const p = n;
      return r === "video" && p.screenShare !== true && this.videoPeerConsumerMap.set(e, s), l.info("ParticipantController::processMedia", {
        consumer: {
          id: s,
          peerId: e,
          kind: r,
          appData: p,
          remotelyPaused: i,
          producerId: c
        }
      }), this.consumerPeerMap.set(s, {
        type: r,
        peerId: e,
        appData: p,
        remotelyPaused: i,
        producerId: c
      }), {
        peerId: e,
        kind: r,
        appData: p,
        remotelyPaused: i,
        track: a,
        producerId: c,
        rtpReceiver: d
      };
    }
    processConsumerClosed(s) {
      const {
        peerId: t,
        type: e,
        appData: r,
        remotelyPaused: n,
        producerId: i
      } = this.consumerPeerMap.get(s) || {}, a = this.participants.joined.get(t);
      if (l.info("ParticipantController::processConsumerClosed", {
        consumer: {
          id: s,
          peerId: t,
          appData: r,
          kind: e,
          remotelyPaused: n,
          producerId: i
        }
      }), this.consumerPeerMap.delete(s), e === "video" && r.screenShare !== true && this.videoPeerConsumerMap.delete(t), !a)
        return;
      const c = [];
      r && r.screenShare ? (a.setScreenShareEnabled(false), U.consumerSharedMediaState(s, { screen: false }), a.screenShareTracks.video && c.push(a.screenShareTracks.video.id), a.screenShareTracks.audio && c.push(a.screenShareTracks.audio.id), a.screenShareTracks = {
        audio: undefined,
        video: undefined
      }) : e === "audio" ? (a.setAudioEnabled(false), a.audioTrack && c.push(a.audioTrack.id), U.consumerSharedMediaState(s, { audio: false }), a.audioTrack = undefined) : e === "video" && (a.setVideoEnabled(false), this.updatePipSource(a.id, false), a.videoTrack && c.push(a.videoTrack.id), U.consumerSharedMediaState(s, { video: false }), a.videoTrack = undefined), r.e2ee && c.forEach((d) => {
        R.emit(
          P.E2EE_INACTIVE_CONSUMER,
          {
            peerId: t,
            trackId: d
          }
        );
      });
    }
    processConsumerResumed(s) {
      const {
        peerId: t,
        kind: e,
        appData: r,
        track: n,
        remotelyPaused: i,
        producerId: a,
        rtpReceiver: c
      } = this.processMedia(s);
      if (!t)
        return;
      l.info("ParticipantController::processConsumerResumed", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          appData: r,
          remotelyPaused: i,
          producerId: a
        }
      });
      const d = this.participants.joined.get(t);
      if (d) {
        if (r.e2ee && R.emit(P.E2EE_ACTIVE_CONSUMER, { peerId: t, rtpReceiver: c, track: n }), r.screenShare) {
          e === "video" ? d.screenShareTracks.video = n : e === "audio" && (d.screenShareTracks.audio = n), d.setScreenShareEnabled(true), U.consumerSharedMediaState(s, { screen: true });
          return;
        }
        e === "video" ? (d.videoTrack = n, d.setVideoEnabled(true), this.updatePipSource(d.id, true), U.consumerSharedMediaState(s, { video: true })) : e === "audio" && (d.audioTrack = n, d.setAudioEnabled(d.audioEnabled), U.consumerSharedMediaState(s, {
          audio: d.audioEnabled
        }));
      }
    }
    processConsumerPaused(s) {
      l.info(
        `ParticipantController::processConsumerPaused called for consumerId: ${s}`
      );
      const {
        peerId: t,
        kind: e,
        track: r,
        appData: n,
        remotelyPaused: i,
        producerId: a
      } = this.processMedia(s);
      if (!t)
        return;
      l.info("ParticipantController::processConsumerPaused", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          appData: n,
          remotelyPaused: i,
          producerId: a
        }
      });
      const c = this.participants.joined.get(t);
      c && (r && n.e2ee && R.emit(P.E2EE_INACTIVE_CONSUMER, { peerId: t, trackId: r.id }), e === "video" ? (c.videoTrack = r, c.setVideoEnabled(false), this.updatePipSource(c.id, false), U.consumerSharedMediaState(s, { video: false })) : e === "audio" && (c.audioTrack = r, c.setAudioEnabled(c.audioEnabled), U.consumerSharedMediaState(s, {
        audio: c.audioEnabled
      })));
    }
    processNewConsumer(s) {
      const {
        peerId: t,
        kind: e,
        remotelyPaused: r,
        track: n,
        appData: i,
        producerId: a,
        rtpReceiver: c
      } = this.processMedia(s);
      if (!t)
        return;
      l.info("ParticipantController::processNewConsumer", {
        consumer: {
          id: s,
          peerId: t,
          kind: e,
          remotelyPaused: r,
          appData: i,
          producerId: a
        }
      });
      const d = this.participants.joined.get(t);
      if (d) {
        if (i.screenShare) {
          e === "video" ? d.screenShareTracks.video = n : e === "audio" && (d.screenShareTracks.audio = n), (!r || this.self.permissions.isRecorder || K.hasFeature(ie.SCREEENSHARE_ERR_HACK)) && d.setScreenShareEnabled(true), i.supportsRemoteControl && (d.supportsRemoteControl = true), this.participants.broadcastMessage("screenshareConsumerCreated", {
            producerId: a,
            peerId: t,
            screenShare: true,
            consumerId: s,
            consumerPeerId: this.self.id
          }), l.info("ParticipantController::newScreenshareConsumer::screenshareConsumerCreated", {
            consumer: {
              id: s,
              peerId: t,
              kind: e,
              remotelyPaused: r,
              appData: i,
              producerId: a
            }
          });
          return;
        }
        e === "video" ? (d.videoTrack = n, r || (d.setVideoEnabled(true), this.updatePipSource(d.id, true)), U.consumerSharedMediaState(s, {
          video: !r
        })) : e === "audio" && (d.audioTrack = n, r || d.setAudioEnabled(true), U.consumerSharedMediaState(s, {
          audio: !r
        })), !r && i.e2ee && R.emit(P.E2EE_ACTIVE_CONSUMER, { peerId: t, rtpReceiver: c, track: n });
      }
    }
    static formatSocketServiceMessage(s) {
      var e, r, n, i, a, c;
      if (!s)
        return;
      const t = su(s.stageType);
      return {
        id: s.peerId,
        userId: s.userId,
        name: s.displayName,
        displayName: s.displayName,
        stageType: t,
        customParticipantId: s.customParticipantId,
        presetId: s.presetId,
        picture: s.displayPictureUrl,
        waitlisted: s.waitlisted,
        stageStatus: t,
        metadata: {
          preset_name: (e = s.flags) == null ? undefined : e.presetName
        },
        recorderType: (r = s.flags) == null ? undefined : r.recorderType,
        flags: {
          hiddenParticipant: (n = s.flags) == null ? undefined : n.hiddenParticipant,
          hidden_participant: (i = s.flags) == null ? undefined : i.hiddenParticipant,
          recorder: ((a = s.flags) == null ? undefined : a.recorderType) !== undefined && ((c = s.flags) == null ? undefined : c.recorderType) !== "NONE"
        }
      };
    }
    mapPeerIdsToProducers(s, t) {
      const e = (n, i) => n.filter(({ kind: a, screenShare: c }) => i.includes(a) || c && i.includes("screenshare"));
      return s.flatMap((n) => {
        const i = this.participants.joined.get(n);
        if (i)
          return e(i.producers, t);
      }).filter((n) => !!n);
    }
    updateGrid(s, t) {
      let e = [], r = [], n = [], i = [];
      return t.video && ([e, n] = t.video(
        this.participants.videoSubscribed,
        s
      )), t.audio && ([r, i] = t.audio(
        this.participants.audioSubscribed,
        s
      )), {
        video: { add: e, remove: n },
        audio: { add: r, remove: i }
      };
    }
    // XXX dead code, this event is not fired
    onSelectedPeers(s, t) {
      return u(this, null, function* () {
        this.participants.viewMode === "ACTIVE_GRID" && this.computeActivateParticipants(s, t);
      });
    }
    updateActiveParticipantsWithPriorities(s, t = false) {
      if (!this.mediaJoined) {
        l.warn(
          "Skipped::ParticipantController::updateActiveParticipantsWithPriorities",
          {
            roomJoined: this.mediaJoined
          }
        );
        return;
      }
      s.forEach((r) => {
        this.selectedPeers.add(r.peerId, r.priority);
      });
      const e = this.selectedPeers.activeSpeakerPeers.at(0);
      e !== undefined && e !== this.participants.lastActiveSpeaker && (this.participants.lastActiveSpeaker = e, this.participants.emit("activeSpeaker", {
        peerId: e,
        volume: 1
        // priority
      })), t && (this.participants.viewMode === "ACTIVE_GRID" ? this.updateActive("ACTIVE_GRID") : this.participants.viewMode === "PAGINATED" && this.updateActive("ACTIVE_GRID", { strategies: { audio: this.updateParticipantsMap.bind(this) } }));
    }
  };
  let es = kg;
  Bi([
    v.trace("ParticipantController.setupEvents")
  ], es.prototype, "setupEventsGlobal");
  Bi([
    v.trace("ParticipantController.processMedia")
  ], es.prototype, "processMedia");
  Bi([
    v.trace("ParticipantController.processConsumerClosed")
  ], es.prototype, "processConsumerClosed");
  Bi([
    v.trace("ParticipantController.processConsumerResumed")
  ], es.prototype, "processConsumerResumed");
  Bi([
    v.trace("ParticipantController.processConsumerPaused")
  ], es.prototype, "processConsumerPaused");
  Bi([
    v.trace("ParticipantController.processNewConsumer")
  ], es.prototype, "processNewConsumer");
  var IM = Object.defineProperty, AM = Object.getOwnPropertyDescriptor, DM = (s, t, e, r) => {
    for (var n = AM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && IM(t, e, n), n;
  };
  class Ig extends es {
    // eslint-disable-next-line class-methods-use-this
    get roomNodeClient() {
      return this.context.getValue("roomNodeClient");
    }
    constructor(t, e, r) {
      super(t, e, r), this.setupEvents();
    }
    setupEvents() {
      this.roomSocketHandler.on(
        F.getWaitingRoomRequests,
        this.waitingRoomRequestHandler.bind(this)
      ), R.on(P.SOCKET_PEERS, (t) => u(this, null, function* () {
        t == null || t.forEach((e) => this.onParticipantJoined(this.fromSocketService(e)));
      })), this.roomSocketHandler.on(
        oe.peerJoinedBroadcast,
        ({ participant: t }) => this.onMediaJoined(
          t.peerId,
          t.producerStates
        )
      ), this.roomSocketHandler.on(
        oe.selfJoinComplete,
        ({ participants: t, selectedPeers: e, roomState: r }) => {
          t.forEach((a) => this.onMediaJoined(a.peerId, a.producerStates));
          const { audioPeers: n, compulsoryPeers: i } = e != null ? e : {};
          r.pinnedPeerIds.length !== 0 && this.onParticipantPinned(r.pinnedPeerIds[0]), this.computeActivateParticipants(n != null ? n : [], i), R.emit(P.UPDATE_ACTIVE, { createAllConsumers: true });
        }
      ), R.on(
        P.MAX_SPATIAL_LAYER_CHANGE,
        ({ peerId: t, maxSpatialLayer: e }) => {
          const r = this.videoPeerConsumerMap.get(t);
          r && (this.maxSpatialLayerUpdates.set(r, e), this.updateConsumerSpatialLayers());
        }
      ), R.on(
        P.NEW_PRODUCER,
        ({ peerId: t, producer: e }) => {
          const r = this.participants.joined.get(t);
          if (!r) {
            l.warn(
              "ParticipantController::NEW_PRODUCER::participant not found",
              {
                producer: {
                  id: e == null ? undefined : e.producerId,
                  kind: e == null ? undefined : e.kind,
                  status: "UNKNOWN",
                  appData: { screenShare: e == null ? undefined : e.screenShare }
                },
                dyteParticipant: { id: t }
              }
            );
            return;
          }
          r.producers.push(e), l.info(
            "ParticipantController::NEW_PRODUCER::producer_added_to_participant",
            {
              producer: {
                id: e == null ? undefined : e.producerId,
                peerId: t,
                kind: e == null ? undefined : e.kind,
                status: "UNKNOWN",
                appData: { screenShare: e == null ? undefined : e.screenShare }
              }
            }
          ), (e == null ? undefined : e.kind) === "audio" || e != null && e.screenShare || this.currentActiveGridParticipants.has(t) ? this.roomNodeClient.createConsumers([e]).catch((n) => {
            l.error("ParticipantController::createConsumer failed", { error: n });
          }) : l.info(
            "ParticipantController::NEW_PRODUCER::not_consuming_producer",
            {
              producer: {
                id: e == null ? undefined : e.producerId,
                peerId: t,
                kind: e == null ? undefined : e.kind,
                status: "UNKNOWN",
                appData: { screenShare: e == null ? undefined : e.screenShare }
              }
            }
          );
        }
      ), R.on(
        P.PRODUCER_CLOSED,
        ({ peerId: t, producerId: e }) => {
          const r = this.participants.joined.get(t);
          if (!r) {
            l.warn(
              "ParticipantController::NEW_PRODUCER::participant not found",
              {
                dyteParticipant: { id: t }
              }
            );
            return;
          }
          r.producers = r.producers.filter(
            (n) => n.producerId !== e
          );
        }
      ), R.on(
        P.PRODUCER_TOGGLE,
        ({
          peerId: t,
          producerId: e,
          paused: r,
          kind: n
        }) => {
          const i = this.participants.joined.get(t);
          if (i) {
            n === "audio" && i.setAudioEnabled(!r);
            const a = i.producers.find(
              (c) => c.producerId === e
            );
            a && (a.pause = r);
          }
        }
      ), this.roomSocketHandler.on(
        oe.globalPeerPinBroadcast,
        ({ participantId: t }) => {
          if (!this.mediaJoined)
            return;
          const e = t;
          this.onParticipantPinned(e);
          const r = this.participants.joined.get(e);
          this.roomNodeClient.activatePeers(r.producers).catch((n) => {
            l.error("unable to create consumers", {
              error: n
            });
          });
        }
      ), this.roomSocketHandler.on(oe.selectedPeer, ({ audioPeers: t, compulsoryPeers: e }) => {
        this.mediaJoined && this.onSelectedPeers(e.concat(t));
      }), this.roomSocketHandler.on(oe.selectedPeerDiff, ({ entries: t }) => {
        if (!this.mediaJoined || this.participants.viewMode !== "ACTIVE_GRID")
          return;
        const e = t.map((r) => ({
          peerId: r.peerId,
          priority: r.priority
        }));
        this.updateActiveParticipantsWithPriorities(e, true);
      });
    }
  }
  DM([
    v.trace("ParticipantController.setupEvents")
  ], Ig.prototype, "setupEvents");
  var MM = Object.defineProperty, OM = Object.getOwnPropertyDescriptor, NM = (s, t, e, r) => {
    for (var n = OM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && MM(t, e, n), n;
  };
  class Ag extends es {
    // eslint-disable-next-line class-methods-use-this
    get roomNodeClient() {
      return this.context.getValue("roomNodeClient");
    }
    constructor(t, e, r) {
      super(t, e, r), this.setupEvents();
    }
    setupEvents() {
      this.roomSocketHandler.on(
        F.getWaitingRoomRequests,
        this.waitingRoomRequestHandler.bind(this)
      ), R.on(P.SOCKET_PEERS, (t) => u(this, null, function* () {
        const e = K.hasFeature(ie.DEBUG_SOCKET_JOIN);
        if (e) {
          const r = t && (t == null ? undefined : t.length) < 20 ? {
            peers: JSON.stringify(t.map((n) => n.peerId))
          } : undefined;
          l.info("Processing socket peers", r);
        }
        t == null || t.forEach((r) => {
          r.waitlisted || this.onParticipantJoined(this.fromSocketService(r));
        }), e && l.info("Processed socket peers");
      })), this.roomSocketHandler.on(
        ae.peerJoinedBroadcast,
        ({ participant: t }) => {
          K.hasFeature(ie.DEBUG_SOCKET_JOIN) && l.info("mediaEvents.peerJoinedBroadcast", { peers: t.peerId }), this.onMediaJoined(
            t.peerId,
            t.producerStates
          );
        }
      ), this.roomSocketHandler.on(
        ae.selfJoinComplete,
        ({ participants: t, selectedPeers: e, roomState: r }) => {
          if (K.hasFeature(ie.DEBUG_SOCKET_JOIN)) {
            const a = t && (t == null ? undefined : t.length) < 20 ? {
              peers: JSON.stringify(t.map((c) => c.peerId))
            } : undefined;
            l.info("mediaEvents.selfJoinComplete", a);
          }
          t.forEach((a) => this.onMediaJoined(a.peerId, a.producerStates));
          const { audioPeers: n, compulsoryPeers: i } = e != null ? e : {};
          r.pinnedPeerIds.length !== 0 && this.onParticipantPinned(r.pinnedPeerIds[0]), this.computeActivateParticipants(n != null ? n : [], i), R.emit(P.UPDATE_ACTIVE, { createAllConsumers: true });
        }
      ), R.on(
        P.MAX_SPATIAL_LAYER_CHANGE,
        ({ peerId: t, maxSpatialLayer: e }) => {
          const r = this.videoPeerConsumerMap.get(t);
          r && (this.maxSpatialLayerUpdates.set(r, e), this.updateConsumerSpatialLayers());
        }
      ), R.on(
        P.NEW_PRODUCER,
        ({ peerId: t, producer: e }) => {
          const r = this.participants.joined.get(t);
          if (!r) {
            l.warn(
              "ParticipantController::NEW_PRODUCER::participant not found",
              {
                producer: {
                  id: e == null ? undefined : e.producerId,
                  kind: e == null ? undefined : e.kind,
                  status: "UNKNOWN",
                  appData: { screenShare: e == null ? undefined : e.screenShare }
                },
                dyteParticipant: { id: t }
              }
            );
            return;
          }
          if (r.producers.push(e), l.info(
            "ParticipantController::NEW_PRODUCER::producer_added_to_participant",
            {
              producer: {
                id: e == null ? undefined : e.producerId,
                peerId: t,
                kind: e == null ? undefined : e.kind,
                status: "UNKNOWN",
                appData: { screenShare: e == null ? undefined : e.screenShare }
              }
            }
          ), this.participants.viewMode === "MANUAL") {
            let n = false;
            const i = e.kind === "audio", a = e.kind === "video", c = r.manualProducerConfig;
            (i && (c.audio && !e.screenShare || c.screenshareAudio && e.screenShare) || a && (c.video && !e.screenShare || c.screenshareVideo && e.screenShare)) && (n = true), n ? this.roomNodeClient.createConsumers([e]) : l.info(
              "ParticipantController::NEW_PRODUCER::not_consuming_producer",
              {
                producer: {
                  id: e == null ? undefined : e.producerId,
                  peerId: t,
                  kind: e == null ? undefined : e.kind,
                  status: "UNKNOWN",
                  appData: { screenShare: e == null ? undefined : e.screenShare }
                }
              }
            );
            return;
          }
          (e == null ? undefined : e.kind) === "audio" && this.participants.audioSubscribed.get(t) || (e == null ? undefined : e.kind) === "video" && this.participants.videoSubscribed.get(t) || e != null && e.screenShare ? this.roomNodeClient.createConsumers([e]).catch((n) => {
            l.error("ParticipantController::createConsumer failed", { error: n });
          }) : l.info(
            "ParticipantController::NEW_PRODUCER::not_consuming_producer",
            {
              producer: {
                id: e == null ? undefined : e.producerId,
                peerId: t,
                kind: e == null ? undefined : e.kind,
                status: "UNKNOWN",
                appData: { screenShare: e == null ? undefined : e.screenShare }
              }
            }
          );
        }
      ), R.on(
        P.PRODUCER_CLOSED,
        ({ peerId: t, producerId: e }) => {
          const r = this.participants.joined.get(t);
          if (!r) {
            l.warn(
              "ParticipantController::PRODUCER_CLOSED::participant not found",
              {
                dyteParticipant: { id: t }
              }
            );
            return;
          }
          r.producers = r.producers.filter(
            (n) => n.producerId !== e
          );
        }
      ), R.on(
        P.PRODUCER_TOGGLE,
        ({
          peerId: t,
          producerId: e,
          paused: r,
          kind: n
        }) => {
          const i = this.participants.joined.get(t);
          if (i) {
            n === "audio" && i.setAudioEnabled(!r);
            const a = i.producers.find(
              (c) => c.producerId === e
            );
            a && (a.pause = r);
          }
        }
      ), this.roomSocketHandler.on(
        ae.globalPeerPinBroadcast,
        (t) => {
          let e;
          if (t && (e = t.participantId), !this.mediaJoined)
            return;
          const r = e;
          this.onParticipantPinned(r);
          const n = this.participants.joined.get(r);
          n && this.roomNodeClient.activatePeers(n.producers).catch((i) => {
            l.error("unable to create consumers", {
              error: i
            });
          });
        }
      ), this.roomSocketHandler.on(ae.selectedPeer, ({ audioPeers: t, compulsoryPeers: e }) => {
        this.mediaJoined && this.onSelectedPeers(e.concat(t));
      }), this.roomSocketHandler.on(ae.selectedPeerDiff, ({ entries: t }) => {
        if (!this.mediaJoined)
          return;
        const e = t.map((r) => ({
          peerId: r.peerId,
          priority: r.priority
        }));
        this.updateActiveParticipantsWithPriorities(e, true);
      });
    }
  }
  NM([
    v.trace("ParticipantController.setupEvents")
  ], Ag.prototype, "setupEvents");
  const Se = sr(
    Kl().permissions
  );
  var j, Ci, wi, Nc, St, Nt;
  const Bn = class extends Ft {
    constructor(e, r, n, i = false) {
      super();
      E(this, St);
      E(this, j, undefined);
      E(this, Ci, undefined);
      E(this, wi, undefined);
      E(this, Nc, (e) => {
        var h, m, g;
        const p = e, {
          chat: r,
          connectedMeetings: n,
          plugins: i,
          polls: a,
          media: c
        } = p, d = na(p, [
          "chat",
          "connectedMeetings",
          "plugins",
          "polls",
          "media"
        ]);
        if (r && (r.private && ss(o(this, j).chat.private, r.private), r.public && ss(o(this, j).chat.public, r.public), this.emit("chatUpdate")), n && ss(o(this, j).connectedMeetings, n), c) {
          const T = (b) => {
            switch (b) {
              case Is.NONE:
                return W.Allowed;
              case Is.ALLOWED:
                return W.Allowed;
              case Is.NOT_ALLOWED:
                return W.NotAllowed;
              case Is.CAN_REQUEST:
                return W.CanRequest;
              default:
                return;
            }
          }, y = {
            audio: undefined,
            video: undefined,
            screenshare: undefined
          };
          (h = c.audio) != null && h.canProduce && (y.audio = {
            canProduce: T(c.audio.canProduce)
          }), (m = c.video) != null && m.canProduce && (y.video = {
            canProduce: T(c.video.canProduce)
          }), (g = c.screenshare) != null && g.canProduce && (y.screenshare = {
            canProduce: T(c.screenshare.canProduce)
          }), ss(o(this, j).media, y);
        }
        i && (ss(o(this, j).plugins, i), this.emit("pluginsUpdate")), a && (ss(o(this, j).polls, a), this.emit("pollsUpdate")), Object.keys(d).length !== 0 && ss(o(this, j), d), this.emit("permissionsUpdate", e);
      });
      if (!r)
        throw l.error("DytePermissionsPreset::load_preset_permissions_failed"), new w("Could not load preset permissions.");
      _(this, wi, e), _(this, Ci, n), _(this, j, r), i && this.setupEvents();
    }
    setupEvents() {
      R.on(P.UPDATE_PERMISSIONS, o(this, Nc));
    }
    /** @deprecated. Use init() */
    static fromResponse(e, r, n) {
      return new Bn(n, e, r, true);
    }
    /** @deprecated. Use init() */
    static default(e, r) {
      return new Bn(e, Se, r);
    }
    static init(e, r, n) {
      let i;
      return n ? i = new Bn(e, n, r, true) : i = new Bn(e, Se, r), i;
    }
    get mediaRoomType() {
      const { sfu: e } = o(this, wi).getValue("roomNodeOptions");
      return e === xi.CF ? "CF" : "HIVE";
    }
    /**
     * The `stageEnabled` property returns a boolean value.
     * If `true`, stage management is available for the participant.
     */
    get stageEnabled() {
      var e;
      return ((e = o(this, j)) == null ? undefined : e.stageEnabled) || o(this, Ci) === gt.Webinar || o(this, Ci) === gt.Livestream;
    }
    get acceptStageRequests() {
      var e, r;
      return this.stageEnabled ? ((e = o(this, j)) == null ? undefined : e.acceptStageRequests) || ((r = o(this, j)) == null ? undefined : r.canAcceptProductionRequests) : false;
    }
    /**
     * The `stageAccess` property dictactes how a user interacts with the stage.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`;
     */
    get stageAccess() {
      var e, r, n;
      return ((e = o(this, j)) == null ? undefined : e.stageAccess) === W.NotAllowed ? W.NotAllowed : ((r = o(this, j)) == null ? undefined : r.stageAccess) === W.CanRequest ? W.CanRequest : ((n = o(this, j)) == null ? undefined : n.stageAccess) === W.Allowed || o(this, j).media.audio.canProduce === W.Allowed || o(this, j).media.video.canProduce === W.Allowed || o(this, j).media.screenshare.canProduce === W.Allowed ? W.Allowed : o(this, j).media.audio.canProduce === W.CanRequest || o(this, j).media.video.canProduce === W.CanRequest || o(this, j).media.screenshare.canProduce === W.CanRequest ? W.CanRequest : W.NotAllowed;
    }
    /**
     * The `acceptWaitingRequests` returns boolean value.
     * If `true`, participant can accept the request of waiting participant.
     */
    get acceptWaitingRequests() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.acceptWaitingRequests) != null ? r : Se.acceptWaitingRequests;
    }
    /**
     * The `requestProduceVideo` returns boolean value.
     * If `true`, participant can send request to participants
     * about producing video.
     */
    get requestProduceVideo() {
      var e, r, n;
      return ((n = (r = (e = o(this, j)) == null ? undefined : e.media) == null ? undefined : r.video) == null ? undefined : n.canProduce) === W.CanRequest;
    }
    /**
     * The `requestProduceAudio` returns boolean value.
     * If `true`, participant can send request to participants
     * about producing audio.
     */
    get requestProduceAudio() {
      var e, r, n;
      return ((n = (r = (e = o(this, j)) == null ? undefined : e.media) == null ? undefined : r.audio) == null ? undefined : n.canProduce) === W.CanRequest;
    }
    /**
     * The `requestProduceScreenshare` returns boolean value.
     * If `true`, participant can send request to participants
     * about sharing screen.
     */
    get requestProduceScreenshare() {
      var e, r, n;
      return ((n = (r = (e = o(this, j)) == null ? undefined : e.media) == null ? undefined : r.screenshare) == null ? undefined : n.canProduce) === W.CanRequest;
    }
    /**
     * The `canAllowParticipantAudio` returns boolean value.
     * If `true`, participant can enable other participants` audio.
     */
    get canAllowParticipantAudio() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.disableParticipantAudio) != null ? r : Se.disableParticipantAudio;
    }
    /**
     * The `canAllowParticipantScreensharing` returns boolean value.
     * If `true`, participant can enable other participants` screen share.
     */
    get canAllowParticipantScreensharing() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.canAcceptProductionRequests) != null ? r : Se.canAcceptProductionRequests;
    }
    /**
     * The `canAllowParticipantVideo` returns boolean value.
     * If `true`, participant can enable other participants` video.
     */
    get canAllowParticipantVideo() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.disableParticipantVideo) != null ? r : Se.disableParticipantVideo;
    }
    /**
     * If `true`, a participant can disable other participants` audio.
     */
    get canDisableParticipantAudio() {
      return this.canAllowParticipantAudio;
    }
    /**
     * If `true`, a participant can disable other participants` video.
     */
    get canDisableParticipantVideo() {
      return this.canAllowParticipantVideo;
    }
    /**
     * The `kickParticipant` returns boolean value.
     * If `true`, participant can remove other participants from the meeting.
     */
    get kickParticipant() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.kickParticipant) != null ? r : Se.kickParticipant;
    }
    /**
     * The `pinParticipant` returns boolean value.
     * If `true`, participant can pin a participant in the meeting.
     */
    get pinParticipant() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.pinParticipant) != null ? r : Se.pinParticipant;
    }
    /**
     * The `canRecord` returns boolean value.
     * If `true`, participant can record the meeting.
     */
    get canRecord() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.canRecord) != null ? r : Se.canRecord;
    }
    /**
     * @deprecated in favour of `waitingRoomBehaviour`.
     * The `waitingRoomType` returns string value.
     * type of waiting room behavior
     * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
     */
    get waitingRoomType() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.waitingRoomType) != null ? r : Se.waitingRoomType;
    }
    /**
     * The `waitingRoomType` returns string value.
     * type of waiting room behavior
     * possible values are `SKIP`, `ON_PRIVILEGED_USER_ENTRY`, `SKIP_ON_ACCEPT`
     */
    get waitingRoomBehaviour() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.waitingRoomType) != null ? r : Se.waitingRoomType;
    }
    /**
     * The `plugins` tells if the participant can act on plugins
     * there are 2 permissions with boolean values, `canStart` and `canClose`.
     */
    get plugins() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.plugins) != null ? r : Se.plugins;
    }
    /**
     * The `polls` tells if the participant can use polls.
     * There are 3 permissions with boolean values, `canCreate`, `canVote`, `canViewResults`
     */
    get polls() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.polls) != null ? r : Se.polls;
    }
    /**
     * @deprecated in favour of `canProduceVideo`
     * The `produceVideo` shows permissions for enabling video.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get produceVideo() {
      return this.canProduceVideo;
    }
    /**
     * @deprecated
     * The `requestProduce` returns boolean value.
     * If `true`, participant can send request to participants
     * about producing audio, video or screenshare.
     */
    get requestProduce() {
      return o(this, j).media.audio.canProduce === W.CanRequest || o(this, j).media.video.canProduce === W.CanRequest || o(this, j).media.screenshare.canProduce === W.CanRequest;
    }
    /**
     * The `canProduceVideo` shows permissions for enabling video.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get canProduceVideo() {
      var r;
      const e = (r = o(this, j).media.video.canProduce) != null ? r : Se.media.video.canProduce;
      return this.stageEnabled && (o(this, St, Nt) === "ACCEPTED_TO_JOIN_STAGE" || o(this, St, Nt) === "ON_STAGE") && e === W.CanRequest ? W.Allowed : this.stageEnabled && (o(this, St, Nt) === "OFF_STAGE" || o(this, St, Nt) === "REQUESTED_TO_JOIN_STAGE") && e === W.Allowed ? W.NotAllowed : e;
    }
    /**
     * @deprecated in favour of `canProduceScreenshare`
     * The `produceVideo` shows permissions for sharing screen.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get produceScreenshare() {
      return this.canProduceScreenshare;
    }
    /**
     * The `canProduceScreenshare` shows permissions for sharing screen.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get canProduceScreenshare() {
      var r;
      const e = (r = o(this, j).media.screenshare.canProduce) != null ? r : Se.media.screenshare.canProduce;
      return this.stageEnabled && (o(this, St, Nt) === "ACCEPTED_TO_JOIN_STAGE" || o(this, St, Nt) === "ON_STAGE") && e === W.CanRequest ? W.Allowed : this.stageEnabled && (o(this, St, Nt) === "OFF_STAGE" || o(this, St, Nt) === "REQUESTED_TO_JOIN_STAGE") && e === W.Allowed ? W.NotAllowed : e;
    }
    /**
     * @deprecated in favour of `canProduceAudio`
     * The `produceAudio` shows permissions for enabling audio.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get produceAudio() {
      return this.canProduceAudio;
    }
    /**
     * The `canProduceAudio` shows permissions for enabling audio.
     * There possible values are `ALLOWED`, `NOT_ALLOWED`, `CAN_REQUEST`
     */
    get canProduceAudio() {
      var r;
      const e = (r = o(this, j).media.audio.canProduce) != null ? r : Se.media.audio.canProduce;
      return this.stageEnabled && (o(this, St, Nt) === "ACCEPTED_TO_JOIN_STAGE" || o(this, St, Nt) === "ON_STAGE") && e === W.CanRequest ? W.Allowed : this.stageEnabled && (o(this, St, Nt) === "OFF_STAGE" || o(this, St, Nt) === "REQUESTED_TO_JOIN_STAGE") && e === W.Allowed ? W.NotAllowed : e;
    }
    /**
     * The `chatPublic` shows permissions for public chat
     * there are 4 permissions
     * `canSend` - if true, the participant can send chat
     * `text` - if true, the participant can send text
     * `files` - if true, the participant can send files
     */
    get chatPublic() {
      var e, r, n;
      return (n = (r = (e = o(this, j)) == null ? undefined : e.chat) == null ? undefined : r.public) != null ? n : Se.chat.public;
    }
    /**
     * The `chatPrivate` shows permissions for public chat
     * there are 4 permissions
     * `canSend` - if true, the participant can send private chat
     * `text` - if true, the participant can send text as private chat
     * `files` - if true, the participant can send files as private chat
     * `canReceive` - (optional) if true, the participant can receive private chat
     */
    get chatPrivate() {
      var e, r, n;
      return (n = (r = (e = o(this, j)) == null ? undefined : e.chat) == null ? undefined : r.private) != null ? n : Se.chat.private;
    }
    get chatChannel() {
      var e, r, n;
      return (n = (r = (e = o(this, j)) == null ? undefined : e.chat) == null ? undefined : r.channel) != null ? n : Se.chat.channel;
    }
    get chatMessage() {
      var e, r, n;
      return (n = (r = (e = o(this, j)) == null ? undefined : e.chat) == null ? undefined : r.message) != null ? n : Se.chat.message;
    }
    get connectedMeetings() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.connectedMeetings) != null ? r : Se == null ? undefined : Se.connectedMeetings;
    }
    /**
     * The `hiddenParticipant` returns boolean value.
     * If `true`, participant is hidden.
     */
    get hiddenParticipant() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.hiddenParticipant) != null ? r : Se.hiddenParticipant;
    }
    /**
     * The `showParticipantList` returns boolean value.
     * If `true`, participant list can be shown to the participant.
     */
    get showParticipantList() {
      var e;
      return (e = o(this, j).showParticipantList) != null ? e : Se.showParticipantList;
    }
    /**
     * @deprecated in favour of `canChangeParticipantPermissions`
     * The `canChangeParticipantRole` returns boolean value.
     * If `true`, allow changing the participants' role.
     */
    get canChangeParticipantRole() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.canChangeParticipantPermissions) != null ? r : Se.canChangeParticipantPermissions;
    }
    /**
     * The `canChangeParticipantPermissions` returns boolean value.
     * If `true`, allow changing the participants' permissions.
     */
    get canChangeParticipantPermissions() {
      var e, r;
      return (r = (e = o(this, j)) == null ? undefined : e.canChangeParticipantPermissions) != null ? r : Se.canChangeParticipantPermissions;
    }
    /**
     * @deprecated
     * The `canChangeTheme` returns boolean value.
     * If `true`, the participant can change the meeting theme.
     */
    // eslint-disable-next-line class-methods-use-this
    get canChangeTheme() {
      return false;
    }
    /**
     * @deprecated in favour of individual production settings
     * The `canPresent` returns boolean value.
     * If `true`, the participant can become a presentor.
     */
    get canPresent() {
      return o(this, j).media.audio.canProduce === W.Allowed || o(this, j).media.video.canProduce === W.Allowed || o(this, j).media.screenshare.canProduce === W.Allowed;
    }
    /**
     * @deprecated Use `acceptStageRequests` instead.
     */
    get acceptPresentRequests() {
      return this.acceptStageRequests;
    }
    get canEditDisplayName() {
      var e;
      return (e = o(this, j).canEditDisplayName) != null ? e : false;
    }
    /**
     * @deprecated DyteSelf.config.maxScreenShareCount
     */
    // eslint-disable-next-line class-methods-use-this
    get maxScreenShareCount() {
      return 1;
    }
    // eslint-disable-next-line class-methods-use-this
    get isRecorder() {
      return o(this, j).isRecorder;
    }
    get canSpotlight() {
      return o(this, j).canSpotlight;
    }
    /** Livestream */
    get canLivestream() {
      return o(this, j).canLivestream;
    }
    get transcriptionEnabled() {
      return o(this, j).transcriptionEnabled;
    }
  };
  let bl = Bn;
  j = new WeakMap(), Ci = new WeakMap(), wi = new WeakMap(), Nc = new WeakMap(), St = new WeakSet(), Nt = function() {
    return o(this, wi).getValue("stageStatus");
  };
  var Nl;
  class LM extends Ft {
    constructor() {
      super(...arguments);
      f(this, "localMediaHandler");
      E(this, Nl, undefined);
    }
    updatePermission() {
      return u(this, null, function* () {
        var d, p;
        const e = (h, m) => {
          this.mediaPermissions[h] = m;
          const g = { message: this.mediaPermissions[h], kind: h };
          m === "DENIED" ? R.emit(P.MEDIA_PERMISSION_ERROR, g) : R.emit(P.MEDIA_PERMISSION_UPDATE, g);
        };
        if (ve.getName() === "firefox")
          return;
        const r = "microphone", n = "camera", i = yield (d = navigator == null ? undefined : navigator.permissions) == null ? undefined : d.query({ name: r }), a = yield (p = navigator == null ? undefined : navigator.permissions) == null ? undefined : p.query({
          name: n
        }), c = (h, m) => {
          switch (m) {
            case "granted":
              e(h, "ACCEPTED");
              break;
            case "denied":
              e(h, "DENIED");
              break;
            case "prompt":
              e(h, "NOT_REQUESTED");
              break;
          }
          this.localMediaHandler.repopulateAvailableDevices();
        };
        i && (i.onchange = () => c("audio", i.state)), a && (a.onchange = () => c("video", a.state));
      });
    }
    // eslint-disable-next-line class-methods-use-this
    populateMediaPermissionsInCallstats(n) {
      return u(this, arguments, function* ({
        message: e,
        kind: r
      }) {
        U.onSafeInitialization(() => {
          switch (r) {
            case "audio": {
              U.mediaPermission("AUDIO", e), U.mediaPermission("SPEAKER", e);
              break;
            }
            case "video": {
              U.mediaPermission("VIDEO", e);
              break;
            }
            case "screenshare": {
              U.mediaPermission("SCREENSHARE", e);
              break;
            }
          }
        });
      });
    }
    init() {
      return u(this, arguments, function* (e = {}, r = false, n = null) {
        var i, a, c, d, p;
        if (ve.init(), !this.localMediaHandler)
          try {
            let h = !0;
            if (n != null && n.getValue("defaults").mediaHandler)
              h = !1, this.localMediaHandler = n.getValue("defaults").mediaHandler.localMediaHandler;
            else if (navigator.RNLocalMediaHandlerImpl) {
              const { RNLocalMediaHandlerImpl: m } = navigator;
              this.localMediaHandler = yield m.init();
            } else
              this.localMediaHandler = new Dt(
                n,
                e.constraints,
                (i = n == null ? void 0 : n.getValue("defaults")) == null ? void 0 : i.isNonPreferredDevice,
                (a = n == null ? void 0 : n.getValue("defaults")) == null ? void 0 : a.autoSwitchAudioDevice
              );
            if (R.on(
              P.MEDIA_PERMISSION_UPDATE,
              (m) => u(this, null, function* () {
                if (this.populateMediaPermissionsInCallstats({
                  message: m.message,
                  kind: m.kind
                }), m.message === "NOT_REQUESTED")
                  switch (m == null ? void 0 : m.kind) {
                    case "audio":
                      this.rawAudioTrack && (l.info("Disabling audio due to media permission update"), this.disableAudio());
                      break;
                    case "video":
                      this.rawVideoTrack && (l.info("Disabling video due to media permission update"), this.disableVideo());
                      break;
                    default:
                      break;
                  }
                this.emit("mediaPermissionUpdate", m);
              })
            ), R.on(
              P.MEDIA_PERMISSION_ERROR,
              (m) => u(this, null, function* () {
                const { kind: g, message: T, constraints: y } = m;
                this.populateMediaPermissionsInCallstats({
                  message: T,
                  kind: g
                }), g === "audio" ? (l.info(`Disabling audio due to media permission error  skipping: ${this.localMediaHandler.audioUpdateInProgress}`), this.localMediaHandler.audioUpdateInProgress === !1 && this.disableAudio()) : g === "video" && (l.info(`Disabling video due to media permission error skipping: ${this.localMediaHandler.videoUpdateInProgress}`), this.localMediaHandler.videoUpdateInProgress === !1 && this.disableVideo()), l.error("SelfController::mediaPermissionError", {
                  error: { message: T },
                  constraints: y,
                  mediaPermissionsErrors: {
                    kind: g,
                    message: T
                  }
                }), this.emit("mediaPermissionError", m), this.emit("mediaPermissionUpdate", { message: T, kind: g });
              })
            ), h) {
              l.info(`Setting up DyteSelfMedia streams using media handler. audio:${!!(e != null && e.audio)} video:${(c = e == null ? void 0 : e.video) != null ? c : !0}`);
              const m = this.localMediaHandler.setupStreams({
                video: (d = e == null ? void 0 : e.video) != null ? d : !0,
                audio: (p = e == null ? void 0 : e.audio) != null ? p : !0
              });
              r || (yield m);
            }
          } catch (h) {
            l.error("DyteSelf::init::Failed To Setup Streams", {
              error: { name: h.name, message: h.message }
            });
          }
      });
    }
    /**
     * Returns the `audioTrack`.
     */
    get audioTrack() {
      return this.localMediaHandler.audioTrack;
    }
    /**
     * Returns the `rawAudioTrack` having no middleware executed on it.
     */
    get rawAudioTrack() {
      return this.localMediaHandler.rawAudioTrack;
    }
    /**
     * Returns the current audio and video permissions given by the user.
     * 'ACCEPTED' if the user has given permission to use the media.
     * 'CANCELED' if the user has canceled the screenshare.
     * 'DENIED' if the user has denied permission to use the media.
     * 'SYS_DENIED' if the user's system has denied permission to use the media.
     * 'UNAVAILABLE' if the media is not available (or being used by a different application).
     */
    get mediaPermissions() {
      return this.localMediaHandler.permissions;
    }
    /**
     * Adds the audio middleware to be executed on the raw audio stream.
     * If there are more than 1 audio middlewares,
     * they will be executed in the sequence they were added in.
     * If you want the sequence to be altered, please remove all previous middlewares and re-add.
     */
    addAudioMiddleware(e) {
      return u(this, null, function* () {
        return this.localMediaHandler.addAudioMiddleware(e);
      });
    }
    /**
     * Removes the audio middleware, if it is there.
     */
    removeAudioMiddleware(e) {
      return u(this, null, function* () {
        return this.localMediaHandler.removeAudioMiddleware(e);
      });
    }
    /**
     * Returns the `videoTrack`.
     */
    get videoTrack() {
      return this.localMediaHandler.videoTrack;
    }
    /**
     * Returns the `videoTrack` having no middleware executed on it.
     */
    get rawVideoTrack() {
      return this.localMediaHandler.rawVideoTrack;
    }
    /**
     * Adds the video middleware to be executed on the raw video stream.
     * If there are more than 1 video middlewares,
     * they will be executed in the sequence they were added in.
     * If you want the sequence to be altered, please remove all previous middlewares and re-add.
     */
    addVideoMiddleware(e) {
      return u(this, null, function* () {
        return this.localMediaHandler.addVideoMiddleware(e);
      });
    }
    /**
     * Sets global config to be used by video middlewares.
     * @param config config
     * @param config.disablePerFrameCanvasRendering If set to true,
     * Instead of calling Middleware for every frame,
     * Middleware will only be called once that too with empty canvas,
     *  it is the responsibility of the middleware author to keep updating this canvas.
     * `meeting.self.rawVideoTrack` can be used to retrieve video track for the periodic updates.
     */
    setVideoMiddlewareGlobalConfig() {
      return u(this, arguments, function* (e = {
        disablePerFrameCanvasRendering: false
      }) {
        return this.localMediaHandler.setVideoMiddlewareGlobalConfig(e);
      });
    }
    /**
     * Removes the video middleware, if it is there.
     */
    removeVideoMiddleware(e) {
      return u(this, null, function* () {
        return this.localMediaHandler.removeVideoMiddleware(e);
      });
    }
    /**
     * Returns the screen share tracks.
     */
    get screenShareTracks() {
      return this.localMediaHandler.screenShareTracks;
    }
    /**
     * Returns true if audio is enabled.
     */
    get audioEnabled() {
      return this.localMediaHandler.audioEnabled;
    }
    /**
     * Returns true if video is enabled.
     */
    get videoEnabled() {
      return this.localMediaHandler.videoEnabled;
    }
    /**
     * Returns true if screen share is enabled.
     */
    get screenShareEnabled() {
      return this.localMediaHandler.screenShareEnabled;
    }
    enableAudio() {
      return u(this, null, function* () {
        yield this.localMediaHandler.enableAudio(), this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      });
    }
    enableVideo() {
      return u(this, null, function* () {
        yield this.localMediaHandler.enableVideo(), this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        });
      });
    }
    disableAudio() {
      return u(this, null, function* () {
        this.localMediaHandler.disableAudio(), this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      });
    }
    enableScreenShare() {
      return u(this, null, function* () {
        yield this.localMediaHandler.enableScreenShare(), this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        yield this.localMediaHandler.disableScreenShare(), this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      });
    }
    disableVideo() {
      return u(this, null, function* () {
        yield this.localMediaHandler.disableVideo(), this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        });
      });
    }
    /**
     * Returns the media devices currently being used.
     */
    getCurrentDevices() {
      return this.localMediaHandler.getCurrentDevices();
    }
    /**
     * Returns the local participant's audio devices.
     */
    getAudioDevices() {
      return u(this, null, function* () {
        return yield this.localMediaHandler.getAudioDevices();
      });
    }
    /**
     * Returns the local participant's video devices.
     */
    getVideoDevices() {
      return u(this, null, function* () {
        return yield this.localMediaHandler.getVideoDevices();
      });
    }
    /**
     * Returns the local participant's speaker devices.
     */
    getSpeakerDevices() {
      return u(this, null, function* () {
        return yield this.localMediaHandler.getSpeakerDevices();
      });
    }
    /**
     * Returns the local participant's device, indexed by ID and kind.
     * @param deviceId The ID of the device.
     * @param kind The kind of the device: audio, video, or speaker.
     */
    getDeviceById(e, r) {
      let n;
      return r === "audio" ? n = "audioinput" : r === "video" ? n = "videoinput" : r === "speaker" && (n = "audiooutput"), this.localMediaHandler.getDeviceById(e, n);
    }
    /**
     * Change the current media device that is being used by the local participant.
     * @param device The device that is to be used. A device of the same `kind` will be replaced.
     * the primary stream.
     */
    setDevice(e) {
      return u(this, null, function* () {
        switch (e.kind) {
          case "audioinput":
            try {
              yield this.localMediaHandler.setAudioDevice(e);
            } catch (r) {
            } finally {
              this.emit("audioUpdate", {
                audioEnabled: this.audioEnabled,
                audioTrack: this.audioTrack
              });
            }
            break;
          case "audiooutput":
            yield this.localMediaHandler.setSpeakerDevice(e);
            break;
          case "videoinput":
            try {
              yield this.localMediaHandler.setVideoDevice(e);
            } catch (r) {
            } finally {
              this.emit("videoUpdate", {
                videoEnabled: this.videoEnabled,
                videoTrack: this.videoTrack
              });
            }
            break;
        }
        this.emit("deviceUpdate", {
          device: e
        });
      });
    }
  }
  Nl = new WeakMap();
  const da = {}, $s = {
    /**
     * Lock a method to prevent concurrency
     * @param config - configuration for the lock
     * @param config.methodName - config.methodName Name of method to expose in logs
     *	and to the user (if necessary).
     * @param config.lockName - Unique string to differentiate the method from others.
     * @param config.timeout - Release lock in given milliseconds if method doesn't get resolved.
     *
     *	Do not use common function names such as joinRoom as the lockName,
     *	instead use filename.functionname, if a suitable name couldn't be found.
     * @returns locked instance.
     *
     * It will throw error with name `UnsupportedConcurrentMethodExecution`,
     *	if lock couldn't be acquired.
     *
     * Note:
     *	Make sure that the methodName is explanatory on its own, if exposed to end users.
     * Eg: `meeting.joinRoom` is a much better choice than `joinRoom`.
     */
    executeWithLock({
      methodName: s,
      lockName: t,
      timeout: e
    }) {
      return (r, n, i) => {
        const a = i.value;
        return i.value = function(...d) {
          if (da[t]) {
            const m = new Error(
              `Unsupported concurrent calls on Dyte method: ${s}.`
            );
            throw m.name = "UnsupportedConcurrentMethodExecution", l.error("DyteLocker::UnsupportedConcurrentMethodExecution", {
              error: {
                stack: m.stack
              },
              dyteLocker: {
                methodName: s,
                lockName: t
              }
            }), m;
          }
          da[t] = true;
          const p = setTimeout(
            () => delete da[t],
            e
          ), h = a.apply(this, d);
          return Promise.resolve(h).then(() => {
            delete da[t], clearTimeout(p);
          }).catch(() => {
            delete da[t], clearTimeout(p);
          }), h;
        }, i;
      };
    }
  };
  var xM = Object.defineProperty, $M = Object.getOwnPropertyDescriptor, Mt = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? $M(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && xM(t, e, n), n;
  }, Pi, Pt, Ri, Tr, Cs, Fn, Ke, Ze, Ye, st, bi, ki, Za, kl, Nh;
  let ot = (Nh = class extends LM {
    constructor(t, e, r, n, i) {
      var a;
      super();
      E(this, Cs);
      // eslint-disable-next-line class-methods-use-this
      E(this, Ke);
      /**
       * Returns true if the local participant has joined the meeting.
       */
      E(this, Ye);
      E(this, Za);
      f(this, "name");
      f(this, "picture");
      f(this, "customParticipantId");
      f(this, "waitlistStatus");
      E(this, Pi, undefined);
      E(this, Pt, undefined);
      E(this, Ri, undefined);
      f(this, "role");
      f(this, "userId");
      f(this, "organizationId");
      f(this, "supportsRemoteControl", false);
      f(this, "device");
      E(this, Tr, undefined);
      /* Name of the preset used to join the meeting */
      f(this, "presetName");
      /**
       * Returns the current state of room
       * init - Inital State
       * joined - User is in the meeting
       * waitlisted - User is in the waitlist state
       * rejected - User's was in the waiting room, but the entry was rejected
       * kicked - A priveleged user removed the user from the meeting
       * left - User left the meeting
       * ended - The meeting was ended
       */
      f(this, "roomState", "init");
      E(this, bi, /* @__PURE__ */ new Set());
      E(this, ki, /* @__PURE__ */ new Set());
      _(this, Tr, t), this.userId = e.id, this.name = e.name, this.picture = e.picture, this.customParticipantId = (a = e.customParticipantId) != null ? a : e.clientSpecificId, this.waitlistStatus = "none", _(this, Pt, r), _(this, Pi, n), _(this, Ri, false), this.organizationId = e.organizationId, this.supportsRemoteControl = ve.isElectron(), this.device = ve.getDeviceInfo(), this.presetName = i, n.viewType !== gt.Chat && this.updatePermission(), this.updateVideo = this.updateVideo.bind(this), Le(this, Za, kl).call(this);
    }
    get stageStatus() {
      return o(this, Tr).getValue("stageStatus");
    }
    get id() {
      return o(this, Tr).getValue("peerId");
    }
    static __init__(t, e, r, n, i, a = false) {
      return u(this, null, function* () {
        var m, g, T, y, b;
        let c = (g = (m = t.getValue("defaults")) == null ? undefined : m.audio) != null ? g : true, d = (y = (T = t.getValue("defaults")) == null ? undefined : T.video) != null ? y : true;
        r.canProduceAudio !== "ALLOWED" && (c = false), r.canProduceVideo !== "ALLOWED" && (d = false);
        const p = new ot(t, e, r, n, i);
        if (n.viewType === gt.Chat)
          return p;
        const h = yD(n.mediaConstraints);
        return ss(h, (b = t.getValue("defaults")) == null ? undefined : b.mediaConfiguration), yield p.init({
          audio: c,
          video: d,
          constraints: h
        }, a, t), p.setupEvents(), p;
      });
    }
    setupEvents() {
      this.on("videoUpdate", Le(this, Za, kl)), this.localMediaHandler.on("AUDIO_TRACK_CHANGE", () => u(this, null, function* () {
        if (l.info("DyteSelf::setupEvents::AUDIO_TRACK_CHANGE", L({}, Ks(this))), o(this, Ye, st) && this.audioEnabled)
          try {
            yield o(this, Ke, Ze).shareMic(this.audioTrack);
          } catch (t) {
            l.error("DyteSelf::setupEvents::Error while sharing mic", {
              error: t
            }), this.localMediaHandler.disableAudio();
          }
        this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        });
      })), this.localMediaHandler.on("VIDEO_TRACK_CHANGE", () => u(this, null, function* () {
        if (l.info("DyteSelf::setupEvents::VIDEO_TRACK_CHANGE", L({}, Ks(this))), o(this, Ye, st) && this.rawVideoTrack === undefined)
          l.info("DyteSelf::VIDEO_TRACK_CHANGE::Forcing_disable_video"), this.disableVideo();
        else if (this.videoEnabled && o(this, Ye, st))
          try {
            const t = yield o(this, Ke, Ze).shareWebcam(this.videoTrack);
            t && t.id !== this.videoTrack.id && K.hasFeature(ie.EXP_RESHARE) && (yield o(this, Ke, Ze).shareWebcam(this.videoTrack));
          } catch (t) {
            l.error("DyteSelf::setupEvents::failed shareWebcam", {
              error: t
            }), this.videoEnabled && (yield this.localMediaHandler.disableVideo());
          }
        this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        });
      })), this.localMediaHandler.on(
        "DEVICE_CHANGE",
        (e) => u(this, [e], function* ({ device: t }) {
          this.emit("deviceUpdate", {
            device: t
          });
        })
      ), this.localMediaHandler.on("DEVICE_LIST_UPDATED", (t) => {
        this.emit("deviceListUpdate", t);
      }), this.localMediaHandler.on("SCREENSHARE_TRACK_CHANGE", () => u(this, null, function* () {
        if (!o(this, Ye, st)) {
          l.error(
            "DyteSelf.SCREENSHARE_TRACK_CHANGE.LocalMediaInitialized_WithoutRoomNode"
          );
          return;
        }
        if (this.screenShareEnabled)
          try {
            yield o(this, Ke, Ze).shareScreen(this.screenShareTracks);
          } catch (t) {
            l.error(
              "DyteSelf::setupEvents::Error while sharing screen",
              {
                error: t
              }
            ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
          }
        l.info("DyteSelf::setupEvents::SCREENSHARE_TRACK_CHANGE", L({}, Ks(this))), this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        });
      })), this.localMediaHandler.on("SCREENSHARE_ENDED", () => u(this, null, function* () {
        l.log("Disabling screenshare due to SCREENSHARE_ENDED"), yield this.disableScreenShare(), l.info("DyteSelf::setupEvents::SCREENSHARE_ENDED", L({}, Ks(this)));
      })), this.localMediaHandler.on("AUDIO_TRACK_SILENT", () => {
        U.mediaTrackMuted("AUDIO");
      }), this.localMediaHandler.on("FORCE_MUTE_AUDIO", () => {
        this.disableAudio();
      }), this.localMediaHandler.on("FORCE_MUTE_VIDEO", () => u(this, null, function* () {
        o(this, Ye, st) && (yield o(this, Ke, Ze).pauseWebcam()), this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        }), U.videoOff();
      })), o(this, Pt).on("permissionsUpdate", (t) => {
        var e, r, n;
        (e = t == null ? undefined : t.media) != null && e.audio && o(this, Pt).canProduceAudio !== W.Allowed && (this.disableAudio(), l.info(`Disabled audio due to dynamic preset change: canProduceAudio: ${this.permissions.canProduceAudio}`)), (r = t == null ? undefined : t.media) != null && r.video && o(this, Pt).canProduceVideo !== W.Allowed && (this.disableVideo(), l.info(`Disabled video due to dynamic preset change: canProduceVideo: ${this.permissions.canProduceVideo}`)), (n = t == null ? undefined : t.media) != null && n.screenshare && o(this, Pt).canProduceScreenshare !== W.Allowed && (this.disableScreenShare(), l.info(`Disabled screenshare due to dynamic preset change: canProduceScreenshare: ${this.permissions.canProduceScreenshare}`));
      });
    }
    /**
     * Returns the current permission given to the user for the meeting.
     */
    get permissions() {
      return o(this, Pt);
    }
    /**
     * Returns configuration for the meeting.
     */
    get config() {
      return o(this, Pi);
    }
    /**
     * Returns true if the local participant has joined the meeting.
     */
    get roomJoined() {
      var t;
      return o(this, Pi).viewType === gt.Livestream && this.stageStatus !== "ON_STAGE" ? ((t = o(this, Tr).getValue("connectionHandler")) == null ? undefined : t.socketJoined) === true : o(this, Ye, st);
    }
    /**
     * The name of the user can be set by calling this method.
     * This will get reflected to other participants ONLY if
     * this method is called before the room is joined.
     * @param name Name of the user.
     */
    setName(t) {
      if (!t)
        throw new w("Name cannot be empty.");
      this.name = t;
    }
    setupTracks() {
      return u(this, arguments, function* (t = {}) {
        var e, r;
        return t.forceReset && (o(this, Ke, Ze).stopAllProducers(), this.localMediaHandler.removeAllTracks()), this.localMediaHandler.setupStreams({
          video: (e = t.video) != null ? e : true,
          audio: (r = t.audio) != null ? r : true
        });
      });
    }
    destructMediaHandler() {
      return u(this, null, function* () {
        return this.localMediaHandler.destruct();
      });
    }
    removeDocumentEventListeners() {
      return u(this, null, function* () {
        return this.localMediaHandler.removeDocumentEventListeners();
      });
    }
    enableAudio() {
      return u(this, null, function* () {
        if (this.permissions.canProduceAudio !== W.NotAllowed && !(o(this, Pt).canProduceAudio === W.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.audioEnabled) {
          if (yield this.localMediaHandler.enableAudio(), o(this, Ye, st) && this.stageStatus === "ON_STAGE") {
            if (this.audioTrack)
              try {
                yield o(this, Ke, Ze).shareMic(this.audioTrack);
              } catch (t) {
                l.error("DyteSelf::enableAudio::Error while sharing mic", {
                  error: t
                }), this.localMediaHandler.disableAudio();
              }
            if (!this.audioEnabled)
              return;
            o(this, Ke, Ze).unmuteSelf();
          }
          this.emit("audioUpdate", {
            audioEnabled: this.audioEnabled,
            audioTrack: this.audioTrack
          }), U.audioOn();
        }
      });
    }
    enableVideo() {
      return u(this, null, function* () {
        if (o(this, Pt).canProduceVideo !== W.NotAllowed && !(o(this, Pt).canProduceVideo === W.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.videoEnabled) {
          if (yield this.localMediaHandler.enableVideo(), o(this, Ye, st) && this.stageStatus === "ON_STAGE")
            try {
              yield o(this, Ke, Ze).shareWebcam(this.videoTrack);
            } catch (t) {
              l.error("DyteSelf::enableVideo::Error while sharing video", {
                error: t
              }), this.videoEnabled && (yield this.localMediaHandler.disableVideo());
            }
          this.emit("videoUpdate", {
            videoEnabled: this.videoEnabled,
            videoTrack: this.videoTrack
          }), l.info("DyteSelf.enableVideo", L({}, Ks(this))), U.videoOn();
        }
      });
    }
    updateVideoConstraints(t) {
      return u(this, null, function* () {
        if (!this.localMediaHandler.updateVideoConstraints)
          throw new w("Unsupported");
        yield this.localMediaHandler.updateVideoConstraints(t);
      });
    }
    enableScreenShare() {
      return u(this, null, function* () {
        if (!o(this, Ye, st))
          throw new w("Can`t enable screenshare without joining room");
        if (o(this, Pt).canProduceScreenshare !== W.NotAllowed && !(o(this, Pt).canProduceScreenshare === W.CanRequest && (this.stageStatus === "OFF_STAGE" || this.stageStatus === "REQUESTED_TO_JOIN_STAGE")) && !this.screenShareEnabled && (yield this.localMediaHandler.enableScreenShare(), this.screenShareTracks.audio || this.screenShareTracks.video)) {
          try {
            yield o(this, Ke, Ze).shareScreen(this.screenShareTracks);
          } catch (t) {
            l.error(
              "DyteSelf::enableScreenShare::Error while sharing screen",
              {
                error: t
              }
            ), this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare());
          }
          this.emit("screenShareUpdate", {
            screenShareEnabled: this.screenShareEnabled,
            screenShareTracks: this.screenShareTracks
          });
        }
      });
    }
    updateScreenshareConstraints(t) {
      return u(this, null, function* () {
        if (!this.localMediaHandler.updateScreenshareConstraints)
          throw new w("Unsupported");
        yield this.localMediaHandler.updateScreenshareConstraints(t);
      });
    }
    disableAudio() {
      return u(this, null, function* () {
        this.audioEnabled && (this.localMediaHandler.disableAudio(), o(this, Ye, st) && o(this, Ke, Ze).muteSelf(), this.emit("audioUpdate", {
          audioEnabled: this.audioEnabled,
          audioTrack: this.audioTrack
        }), U.audioOff());
      });
    }
    disableVideo() {
      return u(this, null, function* () {
        this.videoEnabled && (yield this.localMediaHandler.disableVideo(), o(this, Ye, st) && (yield o(this, Ke, Ze).pauseWebcam()), this.emit("videoUpdate", {
          videoEnabled: this.videoEnabled,
          videoTrack: this.videoTrack
        }), U.videoOff());
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        this.screenShareEnabled && (yield this.localMediaHandler.disableScreenShare(), o(this, Ye, st) && (yield o(this, Ke, Ze).disableScreenShare()), this.emit("screenShareUpdate", {
          screenShareEnabled: this.screenShareEnabled,
          screenShareTracks: this.screenShareTracks
        }));
      });
    }
    /**
     * Returns all media devices accessible by the local participant.
     */
    getAllDevices() {
      return this.localMediaHandler.getAllDevices();
    }
    /**
     * @access private
     * Not for external use.
     */
    setIsPinned(t, e = true) {
      var n;
      _(this, Ri, t);
      const r = t ? "pinned" : "unpinned";
      (n = o(this, Cs, Fn)) == null || n.updateSource(this.id, { pinned: t }), e && this.emit(r, this);
    }
    /**
     * Returns true if the current user is pinned.
     */
    get isPinned() {
      return o(this, Ri);
    }
    /**
     * Returns `self.id` if user has permission
     * to pin participants.
     */
    pin() {
      return u(this, null, function* () {
        if (!o(this, Ye, st))
          throw new w("Can`t pin participants without joining room");
        return o(this, Ke, Ze).pinPeer(this.id);
      });
    }
    /**
     * Returns `self.id` if user has permission
     * to unpin participants.
     */
    unpin() {
      return u(this, null, function* () {
        if (!o(this, Ye, st))
          throw new w("Can`t unpin participants without joining room");
        return o(this, Ke, Ze).pinPeer(null);
      });
    }
    setDevice(t) {
      return u(this, null, function* () {
        var r, n, i;
        if (!t)
          throw new w("No device selected");
        const e = this.getCurrentDevices();
        if (t.deviceId && (((r = e == null ? undefined : e.audio) == null ? undefined : r.deviceId) === t.deviceId || ((n = e == null ? undefined : e.video) == null ? undefined : n.deviceId) === t.deviceId || ((i = e == null ? undefined : e.speaker) == null ? undefined : i.deviceId) === t.deviceId) && (l.warn("DyteSelf.setDevice.setting_to_in_use_device", { devices: [t] }), K.hasFeature(ie.SKIP_SETTING_IN_USE_DEVICE)))
          throw new w("Cannot set device currently in use");
        switch (t.kind) {
          case "audioinput":
            try {
              yield this.localMediaHandler.setAudioDevice(t);
            } catch (a) {
              o(this, Ye, st) && (yield o(this, Ke, Ze).muteSelf()), this.emit("audioUpdate", {
                audioEnabled: this.audioEnabled,
                audioTrack: this.audioTrack
              });
            }
            break;
          case "audiooutput":
            yield this.localMediaHandler.setSpeakerDevice(t);
            break;
          case "videoinput":
            try {
              yield this.localMediaHandler.setVideoDevice(t);
            } catch (a) {
              o(this, Ye, st) && (yield o(this, Ke, Ze).pauseWebcam()), this.emit("videoUpdate", {
                videoEnabled: this.videoEnabled,
                videoTrack: this.videoTrack
              });
            }
            break;
        }
      });
    }
    cleanUpTracks() {
      var t, e, r, n;
      (t = this.audioTrack) == null || t.stop(), (e = this.rawAudioTrack) == null || e.stop(), (r = this.videoTrack) == null || r.stop(), (n = this.rawVideoTrack) == null || n.stop();
    }
    registerVideoElement(t, e = false) {
      var r, n;
      e ? o(this, bi).add(t) : o(this, ki).add(t), this.updateVideo(t), e || (n = o(this, Cs, Fn)) == null || n.addSource(
        this.id,
        t,
        this.videoEnabled,
        this.isPinned,
        this.name,
        this.picture,
        (r = this.raised) != null ? r : false
      );
    }
    deregisterVideoElement(t, e = false) {
      t.srcObject = undefined, e ? o(this, bi).delete(t) : (o(this, ki).delete(t), o(this, Cs, Fn).removeSource(this.id));
    }
    /**
     * Internal method, do not use
     */
    updateVideo(t, e = false) {
      var r, n, i;
      if (this.videoEnabled) {
        if (this.videoTrack == null)
          return;
        const a = (r = t.srcObject) == null ? undefined : r.getTracks()[0];
        if ((a == null ? undefined : a.id) === this.videoTrack.id)
          return;
        const c = new MediaStream();
        c.addTrack(this.videoTrack), t.srcObject = c, e || (n = o(this, Cs, Fn)) == null || n.enableSource(this.id);
      } else
        t.srcObject = undefined, e || (i = o(this, Cs, Fn)) == null || i.disableSource(this.id);
      t.style.display = this.videoEnabled ? "block" : "none";
    }
  }, Pi = new WeakMap(), Pt = new WeakMap(), Ri = new WeakMap(), Tr = new WeakMap(), Cs = new WeakSet(), Fn = function() {
    return o(this, Tr).getValue("pip");
  }, Ke = new WeakSet(), Ze = function() {
    return o(this, Tr).getValue("roomNodeClient");
  }, Ye = new WeakSet(), st = function() {
    var t;
    return ((t = o(this, Tr).getValue("connectionHandler")) == null ? undefined : t.mediaJoined) === true;
  }, bi = new WeakMap(), ki = new WeakMap(), Za = new WeakSet(), kl = function() {
    Array.from(o(this, ki)).forEach((t) => this.updateVideo(t, false)), Array.from(o(this, bi)).forEach((t) => this.updateVideo(t, true));
  }, Nh);
  Mt([
    v.trace("DyteSelf.setupEvents")
  ], ot.prototype, "setupEvents", 1);
  Mt([
    v.trace("DyteSelf.setupTracks")
  ], ot.prototype, "setupTracks", 1);
  Mt([
    v.trace("DyteSelf.destructMediaHandler")
  ], ot.prototype, "destructMediaHandler", 1);
  Mt([
    v.trace("DyteSelf.removeDocumentEventListeners")
  ], ot.prototype, "removeDocumentEventListeners", 1);
  Mt([
    $s.executeWithLock({
      methodName: "meeting.self.enableAudio",
      lockName: "DyteSelf.toggleAudio",
      timeout: 3e3
    }),
    v.trace("DyteSelf.enableAudio")
  ], ot.prototype, "enableAudio", 1);
  Mt([
    $s.executeWithLock({
      methodName: "meeting.self.enableVideo",
      lockName: "DyteSelf.toggleVideo",
      timeout: 3e3
    }),
    v.trace("DyteSelf.enableVideo")
  ], ot.prototype, "enableVideo", 1);
  Mt([
    v.trace("DyteSelf.updateVideoConstraints")
  ], ot.prototype, "updateVideoConstraints", 1);
  Mt([
    v.trace("DyteSelf.enableScreenShare"),
    $s.executeWithLock({
      methodName: "meeting.self.enableScreenShare",
      lockName: "DyteSelf.toggleScreenShare",
      timeout: 3e3
    })
  ], ot.prototype, "enableScreenShare", 1);
  Mt([
    v.trace("DyteSelf.updateScreenshareConstraints")
  ], ot.prototype, "updateScreenshareConstraints", 1);
  Mt([
    $s.executeWithLock({
      methodName: "meeting.self.disableAudio",
      lockName: "DyteSelf.toggleAudio",
      timeout: 3e3
    }),
    v.trace("DyteSelf.disableAudio")
  ], ot.prototype, "disableAudio", 1);
  Mt([
    $s.executeWithLock({
      methodName: "meeting.self.disableVideo",
      lockName: "DyteSelf.toggleVideo",
      timeout: 3e3
    }),
    v.trace("DyteSelf.disableVideo")
  ], ot.prototype, "disableVideo", 1);
  Mt([
    $s.executeWithLock({
      methodName: "meeting.self.disableScreenShare",
      lockName: "DyteSelf.toggleScreenShare",
      timeout: 3e3
    }),
    v.trace("DyteSelf.disableScreenShare")
  ], ot.prototype, "disableScreenShare", 1);
  Mt([
    v.trace("DyteSelf.setDevice")
  ], ot.prototype, "setDevice", 1);
  ot = Mt([
    vt("1100")
  ], ot);
  class UM extends Tg {
    constructor(e) {
      super(e);
      f(this, "sessionDescription");
      this.sessionDescription = e.sessionDescription;
    }
  }
  class FM extends wg {
  }
  class VM extends Cg {
    retryFailedConsumerCreationTasks(t) {
      return u(this, null, function* () {
        return uc(
          t.map(
            (e) => u(this, null, function* () {
              return wr((r) => u(this, null, function* () {
                return r > 0 && l.warn(`retrying failed consumer creation task: ${JSON.stringify(e)}`), this.consumerCreationTask(L({}, e));
              }));
            })
          )
        );
      });
    }
    consumerCreationTask(g) {
      return u(this, arguments, function* ({
        consumerId: t,
        producerId: e,
        producingPeerId: r,
        producingTransportId: n,
        streamId: i,
        trackId: a,
        paused: c,
        screenShare: d,
        appData: p,
        kind: h,
        sessionDescription: m
      }) {
        const T = `${i}:${h}`, y = {
          consumerId: t,
          producerId: e,
          producingPeerId: r,
          producingTransportId: n,
          streamId: i,
          trackId: a,
          sessionDescription: m,
          appData: p,
          kind: h,
          paused: c,
          screenShare: d,
          name: "consumer creation task error",
          message: "consumer creation failed"
        };
        return new Promise((A, I) => u(this, null, function* () {
          const $ = setTimeout(() => {
            this.consumerTrackEvents.delete(T), y.isTimedout = true, I(y);
          }, 5e3), V = (B, ne) => {
            try {
              if (B.readyState === "ended")
                clearTimeout($), I(y);
              else {
                const Y = B;
                Y.enabled = !0, this.handler.midTransceiverMap.set(ne.mid, ne);
                const we = new UM({
                  id: t,
                  localId: ne.mid,
                  track: Y,
                  paused: c,
                  producerId: e,
                  producingPeerId: r,
                  handler: this.handler,
                  appData: z(L({}, p), { screenShare: d, peerId: r }),
                  reuseTrack: !0,
                  rtpReceiver: ne.receiver,
                  producingTransportId: n,
                  sessionDescription: m
                });
                this.consumers.set(t, we), we.once("close", () => {
                  this.consumers.delete(we.id), this.handler.midTransceiverMap.delete(ne.mid);
                }), l.info("consumer created for ", {
                  consumer: {
                    id: t,
                    kind: h,
                    appData: {
                      screenShare: d
                    },
                    peerId: r,
                    producerId: e
                  }
                }), this.observer.emit("newconsumer", we), clearTimeout($), A(we);
              }
            } catch (Y) {
              l.warn("error while creating consumer:", Y), clearTimeout($), I(y);
            }
          }, O = this.consumerTrackPool.get(t);
          if ((O == null ? undefined : O.length) === 2) {
            V(O[0], O[1]);
            return;
          }
          const q = this.unknownTracksMap.get(T);
          q ? (this.unknownTracksMap.delete(T), V(q.track, q.transceiver)) : this.consumerTrackEvents.set(T, V), m && (yield this.safeEmitAsPromise("negotiate", {
            description: m
          }));
        }));
      });
    }
    connect() {
      return u(this, null, function* () {
        try {
          const { offerSdp: t, callback: e } = yield this.handler.connect(), { answer: r } = yield this.safeEmitAsPromise("connect", {
            offer: t
          });
          if (yield e(r), !(yield this.isConnected))
            throw new Error("ice connection failed");
        } catch (t) {
          throw l.error("transport failed to connect:", t), t;
        }
      });
    }
    _ontrack(t) {
      const { track: e, transceiver: r } = t;
      l.info(`track event received [trackId: ${e.id}]`);
      const n = `${r.mid}:${e.kind}`;
      e.addEventListener("ended", () => {
        l.info(`rtc consumer track ended [trackId: ${e.id}]`), this.consumerTrackPool.delete(e.id), this.unknownTracksMap.delete(n);
      }), this.consumerTrackPool.set(e.id, [e, r]);
      const i = this.consumerTrackEvents.get(n);
      i ? (i(e, r), this.consumerTrackEvents.delete(n)) : (l.warn(`track event handler not found ${n}`), this.unknownTracksMap.set(n, t));
    }
    consume(t) {
      return u(this, null, function* () {
        if (l.debug(`consume() producers: ${JSON.stringify(t)}`), this.closed)
          throw new Xe("closed");
        if (this.direction !== "recv")
          throw new Cn("not a receiving Transport");
        if (this.listenerCount("connect") === 0 && this.connectionState === "new")
          throw new TypeError('no "connect" listener set into this transport');
        if (!(yield this.isConnected))
          return Promise.reject(new Error("Transport not connected"));
        const e = [], r = /* @__PURE__ */ new Map();
        return t.forEach((n) => {
          var a;
          const i = (a = r.get(n.producingPeerId)) != null ? a : [];
          r.set(n.producingPeerId, i.concat([n]));
        }), r.forEach((n, i) => u(this, null, function* () {
          const { consumersMap: a } = yield this.safeEmitAsPromise("consume_peer", {
            producingPeerId: i
          });
          a.forEach((c, d) => {
            const {
              consumerId: p,
              trackId: h,
              screenShare: m,
              paused: g,
              streamId: T,
              kind: y,
              appData: b,
              producingTransportId: A,
              sessionDescription: I
            } = c;
            e.push(
              this.consumerCreationTask({
                consumerId: p,
                trackId: h,
                streamId: T,
                kind: y,
                producerId: d,
                producingPeerId: i,
                producingTransportId: A,
                paused: g,
                screenShare: m,
                appData: b,
                sessionDescription: I
              })
            );
          });
        })), uc(e);
      });
    }
    /**
     * Create a Producer.
     */
    produce() {
      return u(this, arguments, function* ({
        track: t,
        encodings: e,
        codecOptions: r,
        stopTracks: n = true,
        disableTrackOnPause: i = true,
        zeroRtpOnPause: a = false,
        appData: c = {}
      } = {}) {
        if (l.debug(`produce() [track:${t.id}]`), t) {
          if (this.direction !== "send")
            throw new Cn("not a sending Transport");
          if (t.readyState === "ended")
            throw new Xe("track ended");
          if (this.listenerCount("connect") === 0 && this.connectionState === "new")
            throw new TypeError('no "connect" listener set into this transport');
          if (this.listenerCount("produce") === 0)
            throw new TypeError('no "produce" listener set into this transport');
          if (c && typeof c != "object")
            throw new TypeError("if given, appData must be an object");
        } else
          throw new TypeError("missing track");
        if (!(yield this.isConnected))
          return Promise.reject(new Error("Transport not connected"));
        const { producerId: d, localId: p, rtpSender: h } = yield this.awaitQueue.push(() => u(this, null, function* () {
          const {
            offerSdp: g,
            callback: T,
            sender: y,
            mid: b
          } = yield this.handler.send({
            track: t,
            encodings: e,
            codecOption: r,
            screenShare: c == null ? undefined : c.screenShare
          }), { answer: A, producerId: I } = yield this.safeEmitAsPromise(
            "produce",
            {
              offer: g,
              kind: t.kind,
              paused: i ? !t.enabled : false,
              appData: z(L({}, c || {}), { mid: b })
            }
          ), $ = yield T(A);
          return { producerId: I, localId: $, rtpSender: y };
        }), "producer"), m = new FM({
          id: d,
          localId: p,
          track: t,
          stopTracks: n,
          disableTrackOnPause: i,
          zeroRtpOnPause: a,
          appData: c,
          handler: this.handler,
          rtpSender: h
        });
        return this.producers.set(d, m), m.observer.on("close", () => {
          this.producers.delete(m.id);
        }), this.emit("newproducer", m), this.observer.emit("newproducer", m), m;
      });
    }
  }
  class HM extends Pg {
    createTransport({
      direction: t,
      iceServers: e,
      iceTransportPolicy: r,
      additionalSettings: n,
      proprietaryConstraints: i,
      appData: a,
      config: c
    }) {
      const d = v4(), p = new VM({
        id: d,
        direction: t,
        iceServers: e,
        iceTransportPolicy: r,
        additionalSettings: n,
        proprietaryConstraints: i,
        appData: a,
        handlerFactory: this.handlerFactory,
        config: c
      });
      return this._observer.emit("newtransport", p), p;
    }
  }
  var mt;
  class BM {
    constructor(t) {
      E(this, mt, undefined);
      _(this, mt, t);
    }
    joinRoom(t, e, r = false, n = null) {
      return u(this, null, function* () {
        const i = {
          roomUuid: t,
          displayName: e,
          prejoined: r
        };
        return n && (i.location = n), (yield o(this, mt).sendMessagePromiseWithTimeout({
          event: oe.joinRoom,
          protobuf: vf.toBinary(i),
          timeout: 5e3
        })).payload;
      });
    }
    connectTransport(t) {
      return u(this, null, function* () {
        const e = (yield o(this, mt).sendMessagePromise(
          oe.createWebRTCTransport,
          hf.toBinary(t)
        )).payload, { transportId: r, description: n } = Yl.fromBinary(e), i = {
          sdp: n == null ? undefined : n.sdp,
          type: n.type
        };
        return {
          transportId: r,
          answer: i
        };
      });
    }
    produce(t) {
      return u(this, null, function* () {
        var i, a;
        const e = (yield o(this, mt).sendMessagePromise(
          oe.produce,
          Sf.toBinary(t)
        )).payload, r = Mf.fromBinary(e);
        return {
          answer: {
            sdp: (i = r == null ? undefined : r.description) == null ? undefined : i.sdp,
            type: (a = r == null ? undefined : r.description) == null ? undefined : a.type
          },
          producerId: r.producerId
        };
      });
    }
    consume(t) {
      return u(this, null, function* () {
        const e = (yield o(this, mt).sendMessagePromise(
          oe.consume,
          _f.toBinary(t)
        )).payload, {
          consumerIdsMap: { map: r },
          description: n
        } = Df.fromBinary(e);
        return { consumerStateMap: r, sessionDescription: n };
      });
    }
    closeProducer(t) {
      return u(this, null, function* () {
        const e = (yield o(this, mt).sendMessagePromise(
          oe.closeProducer,
          Cf.toBinary(t)
        )).payload, { description: r } = Of.fromBinary(e);
        return r;
      });
    }
    closeConsumer(t) {
      return u(this, null, function* () {
        return (yield o(this, mt).sendMessagePromise(
          oe.closeConsumer,
          wf.toBinary(t)
        )).payload;
      });
    }
    hostControlForPeer(t, e) {
      return u(this, null, function* () {
        const r = {
          audio: e === "audio",
          screeShare: false,
          video: e === "video",
          participantId: t
        }, n = (yield o(this, mt).sendMessagePromise(
          oe.hostControlPeer,
          bf.toBinary(r)
        )).payload;
        if (!n)
          return false;
        const { status: i } = xf.fromBinary(n);
        return i === "success";
      });
    }
    hostControlForAll(t) {
      return u(this, null, function* () {
        const e = {
          audio: t === "audio",
          screenShare: false,
          video: t === "video"
        }, r = (yield o(this, mt).sendMessagePromise(
          oe.hostControlAllPeers,
          kf.toBinary(e)
        )).payload;
        if (!r)
          return false;
        const { status: n } = $f.fromBinary(r);
        return n === "success";
      });
    }
    kickAll() {
      return u(this, null, function* () {
        const t = {}, e = (yield o(this, mt).sendMessagePromise(
          oe.kickAll,
          Ql.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Lf.fromBinary(e);
        return r === "success";
      });
    }
    kickPeer(t) {
      return u(this, null, function* () {
        const e = (yield o(this, mt).sendMessagePromise(
          oe.kickPeer,
          Pf.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Nf.fromBinary(e);
        return r === "success";
      });
    }
    changeDisplayName(t) {
      return u(this, null, function* () {
        const e = (yield o(this, mt).sendMessagePromise(
          oe.changeDisplayName,
          Rf.toBinary(t)
        )).payload;
        if (!e)
          return false;
        const { status: r } = Uf.fromBinary(e);
        return r === "success";
      });
    }
    notifySelfJoinComplete() {
      return u(this, null, function* () {
        const t = {}, e = (yield o(this, mt).sendMessagePromise(
          oe.selfJoinComplete,
          yf.toBinary(t)
        )).payload;
        return ac.fromBinary(e);
      });
    }
  }
  mt = new WeakMap();
  const qM = Error("task execution aborted");
  class jM {
    constructor(t, e) {
      f(this, "id");
      f(this, "executor");
      f(this, "cancel");
      this.id = t, this.executor = e;
    }
    execute() {
      return u(this, null, function* () {
        return new Promise((t, e) => {
          this.cancel = () => e(qM), this.executor.then((r) => t(r));
        });
      });
    }
  }
  let hh = 0;
  const No = /* @__PURE__ */ new Map();
  class Kd {
    static execute(t) {
      const e = hh;
      hh += 1;
      const r = new jM(e, t);
      return No.set(e, r), {
        id: e,
        value: r.execute().finally(() => No.delete(e))
      };
    }
    static stop(t) {
      const e = No.get(t);
      e && (e.cancel(), No.delete(t));
    }
  }
  const GM = 2e3;
  var mn, ha, _r;
  class JM extends gg {
    constructor(e, r) {
      super();
      E(this, mn);
      f(this, "_device");
      f(this, "_sendTransport");
      f(this, "_recvTransport");
      f(this, "_consumers");
      // map producer type to Producer
      f(this, "_producers");
      f(this, "_producerStatus");
      f(this, "_producerIdToConsumerIdMap");
      f(this, "_socket");
      f(this, "_socketHandler");
      f(this, "_totalTransportReconnectionCount");
      f(this, "_transportReconnectFailureCount");
      f(this, "_consumerCreationFailureCount");
      f(this, "_producerNotReadyFailureCount");
      f(this, "_consumerNotBoundFailureCount");
      f(this, "_transportDisconnectedTimer");
      f(this, "_iceTransportPolicy", "all");
      f(this, "_transportConnectionFailCount", 0);
      f(this, "lastConnectionTime", 0);
      f(this, "transportConnectionStatus");
      f(this, "transportDisconnected");
      E(this, _r, undefined);
      _(this, _r, e), this._device = new HM({}), this._socket = r, o(this, mn, ha).mediaState = {
        recv: { state: Yt.NEW, reconnected: false },
        send: { state: Yt.NEW, reconnected: false }
      }, this.transportDisconnected = {
        consuming: false,
        producing: false
      }, this._socketHandler = new BM(r), this.reset();
    }
    get socket() {
      return this._socket;
    }
    get producers() {
      return this._producers;
    }
    get consumers() {
      return this._consumers;
    }
    get producerIdToConsumerIdMap() {
      return this._producerIdToConsumerIdMap;
    }
    get cfSocketHandler() {
      return this._socketHandler;
    }
    get sendTransport() {
      return this._sendTransport;
    }
    get recvTransport() {
      return this._recvTransport;
    }
    reset() {
      this._producers = /* @__PURE__ */ new Map(), this._consumers = /* @__PURE__ */ new Map(), this._producerStatus = /* @__PURE__ */ new Map(), this._producerIdToConsumerIdMap = /* @__PURE__ */ new Map(), this.transportConnectionStatus = /* @__PURE__ */ new Map(), this._transportReconnectFailureCount = 0, this._consumerCreationFailureCount = 0, this._totalTransportReconnectionCount = 0, this._producerNotReadyFailureCount = 0, this._consumerNotBoundFailureCount = 0, this._transportDisconnectedTimer = { consuming: undefined, producing: undefined };
    }
    setupTransports(e, r) {
      return u(this, null, function* () {
        const i = yield qe().getICEServers().catch((c) => (l.warn(`failed to get iceservers from server: ${c.message}`), [])), a = e.map((c) => {
          var p, h, m, g, T, y, b, A;
          const d = this.transportConnectionStatus.get(c);
          if (d && !r)
            return d;
          switch (d && r && Kd.stop(d.id), c) {
            case "send": {
              const I = Kd.execute(this.createSendTransport({
                iceServers: i,
                additionalSettings: {
                  encodedInsertableStreams: (p = o(this, _r).getValue("modules").e2ee) == null ? undefined : p.enabled
                },
                config: {
                  enableHighBitrate: (g = (m = (h = o(this, _r).getValue("defaults").mediaConfiguration) == null ? undefined : h.audio) == null ? undefined : m.enableHighBitrate) != null ? g : false,
                  enableStereo: (b = (y = (T = o(this, _r).getValue("defaults").mediaConfiguration) == null ? undefined : T.audio) == null ? undefined : y.enableStereo) != null ? b : false
                },
                iceTransportPolicy: this._iceTransportPolicy
              }));
              return this.transportConnectionStatus.set(c, I), I.value;
            }
            case "recv": {
              const I = Kd.execute(this.createRecvTransport({
                iceServers: i,
                additionalSettings: {
                  encodedInsertableStreams: (A = o(this, _r).getValue("modules").e2ee) == null ? undefined : A.enabled
                },
                iceTransportPolicy: this._iceTransportPolicy
              }));
              return this.transportConnectionStatus.set(c, I), I.value;
            }
            default:
              return l.warn(
                `What are you thinking when passing this transportType: ${c}?`,
                {
                  transport: {
                    type: c
                  }
                }
              ), Promise.reject(Error("TYPE_OF_TRANSPORT_UNKNOWN"));
          }
        });
        return Promise.all(a).finally(() => {
          e.forEach((c) => {
            this.transportConnectionStatus.delete(c);
          });
        });
      });
    }
    stopAllTransports() {
      var e, r, n, i;
      l.info(" closing all the transports"), (e = this._sendTransport) == null || e.close(), (r = this._sendTransport) == null || r.removeAllListeners(), (n = this._recvTransport) == null || n.close(), (i = this._recvTransport) == null || i.removeAllListeners(), this._sendTransport = undefined, this._recvTransport = undefined, this.reset();
    }
    createSendTransport(e) {
      return u(this, null, function* () {
        var n, i, a, c;
        if (this._sendTransport && this._sendTransport.connected) {
          l.info("sendTransport::already_exists_in_connected_state", {
            transport: {
              id: (n = this._sendTransport) == null ? undefined : n.id,
              serverId: (i = this._sendTransport) == null ? undefined : i.serverId,
              type: "send"
            }
          });
          return;
        }
        l.info("sendTransport::initializing_transport", {
          transport: {
            id: (a = this._sendTransport) == null ? undefined : a.id,
            serverId: (c = this._sendTransport) == null ? undefined : c.serverId,
            type: "send"
          }
        });
        const r = this._device.createSendTransport(e);
        this._transportDisconnectedTimer.producing = undefined, l.info("sendTransport::initialized_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "send"
          }
        }), this.handleTransport(r, false), l.info("sendTransport::connecting_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "send"
          }
        });
        try {
          yield wr((d, p) => u(this, null, function* () {
            this.socket.isConnected || p(new Error("socket is not connected")), r.connectionState === "closed" && p(new Error("transport is closed")), d > 0 && l.debug(`retrying transport connect, count: ${d}`, {
              transport: {
                id: r.id,
                serverId: r.serverId,
                type: "send"
              }
            });
            try {
              yield r.connect();
            } catch (h) {
              throw l.error(
                `failed to connect send transport: ${r.id}`,
                {
                  error: h,
                  transport: {
                    id: r.id,
                    serverId: r.serverId,
                    type: "send"
                  }
                }
              ), h.message === "ice connection failed" && p(h), h;
            }
          }), { delayTime: 100, strategy: "exponential", maxRetryCount: K.hasFeature(ie.ENABLE_CF_INFINITE_RETRIES) ? 1 / 0 : 3 }), l.info("sendTransport::connected_transport", {
            transport: {
              id: r == null ? void 0 : r.id,
              serverId: r == null ? void 0 : r.serverId,
              type: "send"
            }
          }), this._transportReconnectFailureCount = Math.max(
            0,
            this._transportReconnectFailureCount - 1
          ), this._producerNotReadyFailureCount = 0, this._sendTransport = r, U.onSafeInitialization(() => {
            U.configureSendTransport(r);
          });
        } catch (d) {
          throw l.error(
            `failed to connect send transport after retry:${r.id}`,
            {
              error: d,
              transport: {
                id: r == null ? undefined : r.id,
                serverId: r == null ? undefined : r.serverId,
                type: "send"
              }
            }
          ), r.close(), r.removeAllListeners(), this._transportReconnectFailureCount += 1, this.handleFailure(), d;
        }
      });
    }
    createRecvTransport(e) {
      return u(this, null, function* () {
        var n, i, a, c, d;
        if (this._recvTransport && this._recvTransport.connected) {
          l.info("recvTransport::already_exists_in_connected_state", {
            transport: {
              id: (n = this._recvTransport) == null ? undefined : n.id,
              serverId: (i = this._recvTransport) == null ? undefined : i.serverId,
              type: "recv"
            }
          });
          return;
        }
        l.info("recvTransport::initializing_transport", {
          transport: {
            id: (a = this._recvTransport) == null ? undefined : a.id,
            serverId: (c = this._recvTransport) == null ? undefined : c.serverId,
            type: "recv"
          }
        });
        const r = this._device.createRecvTransport(z(L({}, e), {
          additionalSettings: z(L({}, (d = e.additionalSettings) != null ? d : {}), {
            rtcAudioJitterBufferMaxPackets: 25,
            rtcAudioJitterBufferFastAccelerate: true,
            rtcAudioJitterBufferMinDelayMs: 20
          })
        }));
        this._transportDisconnectedTimer.consuming = undefined, l.info("recvTransport::initialized_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "recv"
          }
        }), this.handleTransport(r, true), l.info("recvTransport::connecting_transport", {
          transport: {
            id: r == null ? undefined : r.id,
            serverId: r == null ? undefined : r.serverId,
            type: "recv"
          }
        });
        try {
          yield wr(
            (p, h) => u(this, null, function* () {
              this.socket.isConnected || h(new Error("socket is not connected")), r.connectionState === "closed" && h(new Error("transport is closed")), p > 0 && l.debug(`retrying transport connect, count: ${p}`, {
                transport: {
                  id: r == null ? void 0 : r.id,
                  serverId: r == null ? void 0 : r.serverId,
                  type: "recv"
                }
              });
              try {
                yield r.connect();
              } catch (m) {
                throw l.error(
                  `fail to connect recv transport: ${r.id}`,
                  {
                    error: m,
                    transport: {
                      id: r == null ? void 0 : r.id,
                      serverId: r == null ? void 0 : r.serverId,
                      type: "recv"
                    }
                  }
                ), m.message === "ice connection failed" && h(m), m;
              }
            }),
            { delayTime: 100, strategy: "exponential", maxRetryCount: K.hasFeature(ie.ENABLE_CF_INFINITE_RETRIES) ? 1 / 0 : 3 }
          ), l.info("recvTransport::connected_transport", {
            transport: {
              id: r == null ? void 0 : r.id,
              serverId: r == null ? void 0 : r.serverId,
              type: "recv"
            }
          }), this._transportReconnectFailureCount = Math.max(
            0,
            this._transportReconnectFailureCount - 1
          ), this._consumerCreationFailureCount = 0, this._consumerNotBoundFailureCount = 0, this.producerIdToConsumerIdMap.clear(), this._recvTransport = r, U.onSafeInitialization(() => {
            U.configureRecvTransport(r);
          });
        } catch (p) {
          throw l.error(
            `failed to connect recv transport after retry:${r.id}`,
            {
              error: p,
              transport: {
                id: r == null ? undefined : r.id,
                serverId: r == null ? undefined : r.serverId,
                type: "recv"
              }
            }
          ), r.close(), r.removeAllListeners(), this._transportReconnectFailureCount += 1, this.handleFailure(), p;
        }
      });
    }
    handleTransport(e, r) {
      if (e.on("connect", (c, d, p) => u(this, [c, d, p], function* ({ offer: n }, i, a) {
        try {
          const h = {
            consuming: r,
            description: {
              sdp: n.sdp,
              type: n.type,
              target: r ? $t.SUBSCRIBER : $t.PUBLISHER
            }
          }, { transportId: m, answer: g } = yield this._socketHandler.connectTransport(h);
          e.setServerId(m), i({ answer: g });
        } catch (h) {
          l.error(
            `${r ? "consumer" : "producer"} transport connection error:`,
            {
              error: h,
              transport: {
                id: e == null ? undefined : e.id,
                serverId: e == null ? undefined : e.serverId,
                type: r ? "recv" : "send"
              }
            }
          ), a(h);
        }
      })), e.on("connectionstatechange", (n) => u(this, null, function* () {
        this.updateTransportState({
          state: n,
          direction: r ? "consuming" : "producing"
        }), l.info(
          `${r ? "consumer" : "producer"} transport connectionState:`,
          {
            transport: {
              id: e == null ? undefined : e.id,
              serverId: e == null ? undefined : e.serverId,
              type: r ? "recv" : "send",
              status: n
            }
          }
        );
        const i = () => {
          this._transportDisconnectedTimer[r ? "consuming" : "producing"] !== undefined && (clearTimeout(this._transportDisconnectedTimer[r ? "consuming" : "producing"]), this._transportDisconnectedTimer[r ? "consuming" : "producing"] = undefined);
        };
        switch (n) {
          case "connected":
            i(), this.lastConnectionTime = performance.now();
            break;
          case "disconnected":
            this._transportDisconnectedTimer[r ? "consuming" : "producing"] = setTimeout(() => {
              this.triggerTransportReconnection(e, r);
            }, GM);
            break;
          case "failed":
            if (e.closed)
              return;
            i(), this.triggerTransportReconnection(e, r);
            break;
        }
      })), e.on("icecandidate", (n) => u(this, null, function* () {
        l.debug("sending icecandidate:", {
          iceCandidate: n
        });
      })), e.on(
        "datachannel:events",
        (n, i) => u(this, null, function* () {
          var a, c;
          l.debug("got data channel message on event:", {
            rtcChannel: {
              label: n,
              message: i
            }
          });
          try {
            switch (i.type) {
              case "negotiation": {
                this.negotiateOverDC(i, pc(i), n, e);
                break;
              }
              case "handshake": {
                const d = {
                  type: "handshake",
                  payload: {
                    message: "pong"
                  }
                };
                e.sendResponseOverDC(n, pc(i), d);
                break;
              }
              case "consumer_toggle": {
                this.handleConsumerToggle(i.payload);
                break;
              }
              case "hub-disconnect": {
                l.debug(`media hub disconnected, full_reconnect: ${(a = i.payload) == null ? void 0 : a.full_reconnect}`), ((c = i.payload) == null ? void 0 : c.full_reconnect) === !0 && this.emit("rejoin");
                break;
              }
              case "error": {
                this.handleErrorOverDC(i.payload, e.id);
                break;
              }
              default:
                l.warn(
                  `unknown event received from cf node, event: ${i.type}`
                );
                break;
            }
          } catch (d) {
            l.error(
              `Unable to handle the incoming datachannel message on channel ${n}`
            );
          }
        })
      ), e.on("dc_error", () => {
        e.direction === "recv" && (l.warn("events datachannel did not open in 5s"), this.handleFailure());
      }), e.on("negotiate", (c, d, p) => u(this, [c, d, p], function* ({ description: n }, i, a) {
        try {
          const h = {
            sdp: n == null ? void 0 : n.sdp,
            type: n == null ? void 0 : n.type
          }, m = yield this.negotiate(e, h);
          i({
            answer: m
          });
        } catch (h) {
          l.error("negotiate error:", {
            transport: {
              id: e.id,
              serverId: e.serverId,
              type: e.direction
            },
            error: h
          }), a(h);
        }
      })), !r) {
        e.on(
          "produce",
          (h, m, g) => u(this, [h, m, g], function* ({
            offer: n,
            kind: i,
            paused: a,
            appData: c
          }, d, p) {
            var A;
            const y = libExports.parse(n.sdp).media.filter(
              (I) => i === "video" ? I.type === "video" : I.type === "audio"
            ).at(-1).msid, b = {
              description: {
                sdp: n.sdp,
                type: n.type,
                target: $t.PUBLISHER
              },
              paused: a,
              kind: i,
              msid: y,
              appData: JSON.stringify(c),
              screenShare: (A = c.screenShare) != null ? A : false
            };
            try {
              const { answer: I, producerId: $ } = yield this._socketHandler.produce(
                b
              );
              d({ answer: I, producerId: $ });
            } catch (I) {
              l.error("create producer error:", { error: I }), p(I);
            }
          })
        );
        return;
      }
      e.on("consume_peer", (c, d, p) => u(this, [c, d, p], function* ({ producingPeerId: n }, i, a) {
        l.info("consumePeer:", n);
        const h = {
          producingPeerId: n
        };
        try {
          const m = yield this._socketHandler.consume(h);
          l.debug(`consumePeer response for ${n}:`, {
            consumerStateMap: m.consumerStateMap
          });
          const g = /* @__PURE__ */ new Map();
          Object.entries(m.consumerStateMap).forEach(
            ([T, y]) => {
              var A, I, $;
              let b = {};
              try {
                b = JSON.parse(y.producerState.appData);
              } catch (V) {
              }
              g.set(T, {
                consumerId: y.consumerId,
                trackId: (A = y.producerTrack) == null ? void 0 : A.trackId,
                streamId: y.producerTrack.streamId,
                kind: y.producerState.kind === kt.VIDEO ? "video" : "audio",
                appData: b,
                screenShare: (I = y.producerState) == null ? void 0 : I.screenShare,
                paused: ($ = y.producerState) == null ? void 0 : $.pause,
                sessionDescription: m.sessionDescription,
                producingPeerId: n
              });
            }
          ), i({ consumersMap: g });
        } catch (m) {
          l.error("consumePeer error:", {
            error: m
          }), a(m);
        }
      })), e.on(
        "consume",
        (d, p, h) => u(this, [d, p, h], function* ({ producerId: n, producingPeerId: i }, a, c) {
          var g, T, y, b, A, I, $, V, O;
          const m = {
            producingPeerId: i,
            producerId: n
          };
          try {
            const q = yield this._socketHandler.consume(m), B = q.consumerStateMap[n];
            let ne = {};
            try {
              ne = JSON.parse((g = B.producerState) == null ? void 0 : g.appData);
            } catch (Y) {
            }
            l.info("consumer create response:", {
              consumer: {
                remotelyPaused: (T = B.producerState) == null ? void 0 : T.pause,
                producerId: (y = B.producerState) == null ? void 0 : y.producerId,
                kind: (A = (b = B.producerState) == null ? void 0 : b.kind) == null ? void 0 : A.toString(),
                appData: z(L({}, ne), { screenShare: (I = B.producerState) == null ? void 0 : I.screenShare }),
                id: B.consumerId,
                sessionDescription: q.sessionDescription
              },
              consumerState: B
            }), a({
              consumerId: B.consumerId,
              screenShare: ($ = B.producerState) == null ? void 0 : $.screenShare,
              trackId: (V = B.producerTrack) == null ? void 0 : V.trackId,
              streamId: B.producerTrack.streamId,
              kind: B.producerState.kind === kt.VIDEO ? "video" : "audio",
              paused: (O = B.producerState) == null ? void 0 : O.pause,
              appData: ne,
              sessionDescription: q.sessionDescription
            });
          } catch (q) {
            l.error("error during consuming on server:", q), c(q);
          }
        })
      );
    }
    createProducer(e, r, n) {
      return u(this, null, function* () {
        var a;
        if (this._sendTransport === undefined || this._sendTransport.closed)
          return null;
        l.info("createProducer::initializing_producer", {
          producer: {
            id: "TO_BE_CREATED",
            kind: e,
            status: "initializing",
            appData: r == null ? undefined : r.appData
          }
        });
        const i = this._producerStatus.get(e);
        if ((i == null ? undefined : i.trackId) === r.track.id && (i == null ? undefined : i.status) === Wr.INITIALIZING)
          return l.info("createProducer::producer getting initializing", {
            producer: {
              id: "GETTING_CREATED",
              status: "initializing",
              kind: e,
              appData: r == null ? undefined : r.appData
            }
          }), null;
        this._producerStatus.set(
          e,
          {
            trackId: r.track.id,
            status: Wr.INITIALIZING
          }
        );
        try {
          const c = yield this._sendTransport.produce(r);
          return (a = r.appData) != null && a.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, c), l.info("createProducer::initialized_producer", {
            producer: {
              id: c == null ? void 0 : c.id,
              kind: e,
              status: "producing",
              appData: r == null ? void 0 : r.appData
            }
          }), c.on("close", (m, g) => u(this, [m, g], function* ({ offer: d, reason: p }, h) {
            l.info("producer::closing", {
              debuggingHint: p,
              producer: {
                id: c == null ? void 0 : c.id,
                kind: e,
                status: "closing",
                appData: r == null ? void 0 : r.appData
              }
            });
            const T = {
              producerId: c.id,
              description: {
                sdp: d.sdp,
                type: d.type,
                target: $t.PUBLISHER
              }
            };
            try {
              const y = yield this._socketHandler.closeProducer(T), b = {
                sdp: y == null ? void 0 : y.sdp,
                type: y == null ? void 0 : y.type
              };
              l.info("producer::closed", {
                producer: {
                  id: c == null ? void 0 : c.id,
                  kind: e,
                  status: "closed",
                  appData: r == null ? void 0 : r.appData
                }
              }), h({ answer: b });
            } catch (y) {
              l.error("producer close error", y);
            }
            this._producerStatus.delete(e), this._producers.delete(e), n(), this.reconfigureWebcamLayers();
          })), c.on("trackended", () => {
            l.info("producer::trackended", {
              producer: {
                id: c == null ? void 0 : c.id,
                kind: e,
                status: "UNKNOWN",
                appData: c == null ? void 0 : c.appData
              }
            }), [X.MIC, X.WEBCAM].includes(e) || n();
          }), this._producers.set(e, c), this._producerStatus.set(
            e,
            {
              trackId: r.track.id,
              status: Wr.INITIALIZED
            }
          ), this.reconfigureWebcamLayers(), c.track;
        } catch (c) {
          throw this._producerStatus.set(
            e,
            {
              status: Wr.NOT_INITIALIZED,
              trackId: r.track.id
            }
          ), l.error("createProducer::transport_initialization_failed", {
            producer: {
              id: "FAILED_TO_CREATE",
              kind: e,
              status: "failed",
              appData: r == null ? undefined : r.appData,
              error: c
            }
          }), c;
        }
      });
    }
    /**
     * Control which simulcast layers are active on the webcam producer. Used to
     * save bandwidth while screensharing by disabling extra layers. Also used to
     * enable back layers when screenshare is not active.
     * Currently, this is behing a feature flag.
     */
    reconfigureWebcamLayers() {
      return u(this, null, function* () {
        if (!K.hasFeature(
          ie.DISABLE_WEBCAM_LAYERS_ON_SCREENSHARE
        ))
          return;
        const e = this.producers.get(X.WEBCAM);
        e && (yield this._switchProducerSpatialLayer(
          e,
          this.producers.get(X.SCREENSHARE_VIDEO) ? 0 : 3
        ));
      });
    }
    /**
     * switches spatial layers of webcam
     * @layer can be number from 0-3. It will set the max spatial
     * layer to that number.
     * If you pass layer value 0 then there will be only 1 active encoding
     * higher values means more active encodings.
     */
    // eslint-disable-next-line class-methods-use-this
    _switchProducerSpatialLayer(e, r) {
      return u(this, null, function* () {
        try {
          l.debug("switching layer of webcam producer to:", {
            media: {
              video: {
                layer: r
              }
            },
            producer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          }), yield e.setMaxSpatialLayer(r);
        } catch (n) {
          l.error("failed to switch spatial layer", { error: n });
        }
      });
    }
    _initConsumer(e) {
      e && (e.observer.on("close", (r) => u(this, null, function* () {
        l.debug("consumer closed", {
          consumer: {
            closureReason: r,
            id: e.id,
            kind: e.kind,
            appData: e.appData
          }
        }), this._consumers.delete(e.id), R.emit(P.CONSUMER_CLOSED, { id: e.id });
      })), this._consumers.set(e.id, e), this.producerIdToConsumerIdMap.set(e.producerId, e.id), R.emit(P.NEW_CONSUMER, {
        id: e.id,
        appData: e.appData,
        peerId: e.peerId
      }));
    }
    // async consumePeer(producingPeerId: string): Promise<void> {
    // 	if (
    // 		this._recvTransport === undefined
    // 		|| this._recvTransport.closed
    // 		|| !this._recvTransport.connected
    // 	) {
    // 		throw Error('Receiving transport not connected');
    // 	}
    // 	await retry(async (attempt) => {
    // 		if (attempt > 0) {
    // 			DyteLogger.debug(`retrying consumePeer call, retryCount: ${attempt}`);
    // 		}
    // 		try {
    // 			const results = await this._recvTransport.consumePeer(producingPeerId);
    // 			const failedTasks: ConsumerCreationTaskError[] = [];
    // 			results.forEach(async (result) => {
    // 				if (result.status === 'rejected') {
    // 					failedTasks.push(result.reason as ConsumerCreationTaskError);
    // 				} else {
    // 					this._initConsumer(result.value as Consumer);
    // 				}
    // 			});
    // 			// Note(itzmanish): we don't need this as we have another retry
    // 			// on consumer creation task. will deprecate in next 2-3 major version
    // 			this._recvTransport
    // 				.retryFailedConsumerCreationTasks(failedTasks)
    // 				.then((retriedConsumersResult) => {
    // 					retriedConsumersResult.forEach(async (result) => {
    // 						if (result.status === 'rejected') {
    // 							DyteLogger.error(
    // 								'consumer creation task is failing',
    // 								result.reason,
    // 							);
    // 							this._consumerCreationFailureCount += 1;
    // 							setTimeout(this.handleFailure.bind(this), 0);
    // 						} else {
    // 							this._initConsumer(result.value as Consumer);
    // 						}
    // 					});
    // 				});
    // 		} catch (error) {
    // 			DyteLogger.error('got error in consumePeer', { error });
    // 			throw error;
    // 		}
    // 	}).catch((e) => {
    // 		DyteLogger.error('consumePeer failed after retries', e);
    // 		this._consumerCreationFailureCount += 1;
    // 		this.handleFailure();
    // 	});
    // }
    createConsumers(e) {
      return u(this, null, function* () {
        if (this._recvTransport === undefined || this._recvTransport.closed || !this._recvTransport.connected)
          return;
        if (e.every((n) => this.getProducer(n.producerId))) {
          l.warn("why are you creating a consumer for local producer?");
          return;
        }
        yield wr((n) => u(this, null, function* () {
          n > 0 && l.debug(`retrying consume call, retryCount: ${n}`), (yield this._recvTransport.consume(e).catch((a) => {
            throw l.error("failed to consume:", { error: a }), a;
          })).forEach((a) => {
            a.status === "rejected" ? (l.error(
              "consumer creation task is failing",
              a.reason
            ), this._consumerCreationFailureCount += 1, setTimeout(this.handleFailure.bind(this), 0)) : this._initConsumer(a.value);
          });
        })).catch((n) => {
          l.error("create consumer failed after retries", { error: n }), this._consumerCreationFailureCount += 1, this.handleFailure();
        });
      });
    }
    pauseProducer(e) {
      return u(this, null, function* () {
        const r = this._producers.get(e);
        if (!r) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r.pause(), r.appData.e2ee && R.emit(P.E2EE_INACTIVE_PRODUCER, r), l.info(`Paused the producer of type: ${r.kind}`, {
          producer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    resumeProducer(e) {
      return u(this, null, function* () {
        const r = this._producers.get(e);
        if (!r) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r.resume(), l.info(`Resumed the producer of type: ${r.kind}`, {
          producer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    replaceTrack(e, r) {
      return u(this, null, function* () {
        const n = this._producers.get(e);
        if (!n) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        yield n.replaceTrack({ track: r }), l.info(`Replaced track for the producer of type: ${n.kind}`, {
          producer: {
            id: n.id,
            kind: n.kind,
            appData: n.appData,
            trackId: r.id
          }
        });
      });
    }
    removeProducer(e, r) {
      return u(this, null, function* () {
        const n = this._producers.get(e);
        if (!n) {
          l.warn(`producer type: ${e} not found`);
          return;
        }
        r && n.track.stop(), yield this.sendTransport.awaitQueue.push(n.close.bind(n), "producer").then(() => {
          o(this, _r).getValue("modules").e2ee.enabled && R.emit(P.E2EE_INACTIVE_PRODUCER, n);
        }).catch((i) => {
          l.error("failed to close producer on server", i);
        });
      });
    }
    pauseConsumer(e) {
      return u(this, null, function* () {
        const r = this._consumers.get(e);
        if (!r) {
          l.warn(`consumer with id: ${e} not found`);
          return;
        }
        this.toggleConsumerOverDC(e, true), l.info(`Paused the consumer of type: ${r.kind}`, {
          consumer: {
            id: r.id,
            kind: r.kind,
            appData: r.appData
          }
        });
      });
    }
    pauseConsumerOverSocket(e) {
      return u(this, null, function* () {
        try {
          const r = {
            consumerId: e.id,
            pause: !0
          };
          yield this.socket.sendMessagePromise(
            oe.toggleConsumer,
            ic.toBinary(r)
          ), e.pause(), R.emit(P.CONSUMER_PAUSED, { id: e.id }), l.info(`Paused the consumer of type: ${e.kind} over socket`, {
            consumer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          });
        } catch (r) {
          l.error("error on pausing consumer", {
            error: r,
            consumer: {
              id: e.id,
              kind: e.kind,
              appData: e.appData
            }
          });
        }
      });
    }
    // Experimental
    toggleConsumerOverDC(e, r) {
      return u(this, null, function* () {
        const n = {
          type: "consumer_toggle",
          payload: {
            consumerId: e,
            mute: r
          }
        }, i = this._recvTransport.getDatachannel("events");
        if (!i) {
          l.warn("recvTransport:: events datachannel not found");
          return;
        }
        yield i.request(n), l.info(`HiveSFUHandler::consumer toggled, consumerId: ${e}, muted: ${r}`);
      });
    }
    resumeConsumer(e) {
      return u(this, null, function* () {
        const r = this._consumers.get(e);
        if (!r) {
          l.warn(`consumer with id: ${e} not found`);
          return;
        }
        if (!r.paused) {
          l.warn(`consumer with id:${e} is not paused so not resuming`);
          return;
        }
        try {
          const n = {
            consumerId: e,
            pause: !1
          };
          yield this.socket.sendMessagePromise(
            oe.toggleConsumer,
            ic.toBinary(n)
          ), r.resume(), R.emit(P.CONSUMER_RESUMED, { id: r.id }), l.info(`Resumed the consumer of type: ${r.kind}`, {
            consumer: {
              id: r.id,
              kind: r.kind,
              appData: r.appData
            }
          });
        } catch (n) {
          l.error("error on resuming consumer", n);
        }
      });
    }
    // if force is true it will close the consumer irrespective of failure in
    // close consumer request
    closeConsumer(e, r) {
      return u(this, null, function* () {
        return this.closeConsumers([e], r);
      });
    }
    // if force is true it will close the consumer irrespective of failure in
    // close consumer request
    closeConsumers(e, r = false) {
      return u(this, null, function* () {
        l.info(`Closing consumers: ${JSON.stringify(e)} with force: ${r}`);
        let n = true;
        const i = e.filter((d) => this._consumers.get(d) ? true : (l.warn(`consumer with id: ${d} not found`), false));
        if (!i.length)
          return;
        const a = {
          consumerIds: i
        }, c = () => u(this, null, function* () {
          var d;
          return (d = this._recvTransport) == null ? undefined : d.awaitQueue.push(() => u(this, null, function* () {
            yield this._socketHandler.closeConsumer(a);
          }), "close_consumer").catch((p) => {
            l.warn("error on closing consumer:", {
              error: p
            }), n = r;
          });
        });
        r ? c() : yield c(), n && i.forEach((d) => {
          const p = this.consumers.get(d);
          this.producerIdToConsumerIdMap.delete(p.producerId), p.close(r ? "force closed" : undefined);
        });
      });
    }
    cleanupConsumers(e) {
      return u(this, null, function* () {
        l.debug("cleaning up all consumers");
        const r = [];
        this._consumers.forEach((n) => {
          e ? n.peerId === e && r.push(n.id) : r.push(n.id);
        }), this.closeConsumers(r, true);
      });
    }
    // NOTE(itzmanish): it's not being used anywhere
    stopAllProducers() {
      return u(this, null, function* () {
        l.info("stopping all available producers"), this._producers.forEach((e, r) => {
          l.debug(`closing producer type: ${r}`, {
            producer: {
              id: e == null ? undefined : e.id,
              kind: e.kind,
              appData: e.appData
            }
          }), e.close();
        });
      });
    }
    getProducer(e) {
      return Array.from(this.producers.values()).filter((r) => r.id === e).at(0);
    }
    hasProducer(e) {
      return this.getProducer(e) !== undefined;
    }
    negotiate(e, r) {
      return u(this, null, function* () {
        l.debug(`setting remote offer : ${JSON.stringify(r)} on ${e.direction} transport`, {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        });
        const n = yield e.setRemoteOffer(r), i = {
          transportId: e.serverId,
          description: {
            sdp: n.sdp,
            type: n.type,
            target: $t.SUBSCRIBER
          }
        };
        return l.debug(`sending renegotiate request: ${JSON.stringify(i)} on ${e.direction} transport`, {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        }), yield this.socket.sendMessagePromise(
          oe.renegotiateSessionDescription,
          mf.toBinary(i)
        ), l.info("renegotiation done", {
          transport: {
            id: e.id,
            serverId: e.serverId,
            type: e.direction
          }
        }), n;
      });
    }
    // eslint-disable-next-line class-methods-use-this
    negotiateOverDC(e, r, n, i) {
      return u(this, null, function* () {
        const { sdp: a } = e.payload, c = {
          sdp: a,
          type: "offer"
        };
        try {
          l.debug(`got offer over dc: ${a} for transport: ${i.id}`);
          const d = yield i.setRemoteOffer(c), p = {
            type: "answer",
            payload: {
              type: d.type,
              sdp: d.sdp
            }
          };
          l.debug(`datachannel answer: ${JSON.stringify(p)}`), i.sendResponseOverDC(n, r, p);
        } catch (d) {
          l.error("datachannel:events::Error:", d), d.code !== "DC_NOT_FOUND" && i.sendErrorOverDC(n, r, d);
        }
      });
    }
    handleConsumerToggle(e) {
      const { mute: r, trackId: n } = e;
      l.info(`consumer toggled for trackId: ${n} muted: ${r}`);
      const i = this.consumers.get(n);
      if (!i) {
        l.warn(`consumer with trackId: ${n} not found`);
        return;
      }
      i.paused !== r && (l.debug("consumer state is not same", {
        consumer: {
          id: i.id,
          remotelyPaused: i.paused
        }
      }), r ? (i.pause(), R.emit(P.CONSUMER_PAUSED, { id: i.id })) : (i.resume(), R.emit(P.CONSUMER_RESUMED, { id: i.id })));
    }
    handleErrorOverDC(e, r) {
      return u(this, null, function* () {
        l.error(`got error over dc: ${JSON.stringify(e)} for transport: ${r}`);
        const { type: n, error: i, id: a } = e;
        if (n === "consumer") {
          if (i === "bind-fail") {
            if (this._consumerNotBoundFailureCount >= 2) {
              this.handleFailure();
              return;
            }
            this._consumerNotBoundFailureCount += 1;
            const c = this.consumers.get(a);
            if (!c)
              return;
            try {
              yield this.closeConsumer(c.id), yield this.createConsumers([{
                kind: c.kind,
                pause: c.paused,
                producerId: c.producerId,
                producingTransportId: c.producingTransportId,
                screenShare: c.appData.screenShare,
                producingPeerId: c.peerId
              }]);
            } catch (d) {
              l.error(
                "failed to recreate consumer on downtrack bound failure,",
                {
                  consumer: {
                    id: c.id,
                    producerId: c.producerId,
                    kind: c.kind,
                    appData: c.appData
                  }
                }
              );
            }
          }
        } else if (n === "producer")
          if (i === "ready-fail") {
            if (this._producerNotReadyFailureCount >= 2) {
              this.handleFailure();
              return;
            }
            this._producerNotReadyFailureCount += 1;
            const [c] = Array.from(this.producers.entries()).find((d) => d[1].id === a);
            if (!c)
              return;
            yield this.removeProducer(c).catch((d) => {
              l.error(
                "failed to remove ready-fail producer:",
                {
                  error: d,
                  producer: {
                    id: a,
                    kind: c,
                    appData: null
                  }
                }
              );
            });
          } else
            i === "general-failure" && (this.updateTransportState({
              state: Yt.RECONNECTING,
              direction: "producing"
            }), this.emit("reconnect_transport", this._sendTransport));
      });
    }
    handleFailure() {
      return u(this, null, function* () {
        if (this._transportReconnectFailureCount > 0 || this._totalTransportReconnectionCount > 3) {
          l.warn("transport failure detected"), K.hasFeature(
            ie.ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY
          ) && (l.debug("rejoining room"), this.emit("rejoin"));
          return;
        }
        (this._consumerCreationFailureCount > 0 || this._consumerNotBoundFailureCount >= 2) && (l.warn(
          "consumer creation failure detected or consumer not bound failure increased"
        ), K.hasFeature(
          ie.ENABLE_CF_EXPERIMENTAL_FAIL_RECOVERY
        ) && (l.debug("reconnecting recv transport"), this._totalTransportReconnectionCount += 1, this.updateTransportState({
          state: Yt.RECONNECTING,
          direction: "consuming"
        }), this.emit("reconnect_transport", this._recvTransport))), this._producerNotReadyFailureCount >= 2 && (l.warn(
          "producer receiver not getting added needs to reconnect send transport"
        ), this._totalTransportReconnectionCount += 1, this.updateTransportState({
          state: Yt.RECONNECTING,
          direction: "producing"
        }), this.emit("reconnect_transport", this._sendTransport));
      });
    }
    triggerTransportReconnection(e, r) {
      l.info(
        "triggerTransportReconnection:: reconnecting transport",
        {
          transport: {
            type: e.direction,
            id: e.id,
            serverId: e.serverId
          }
        }
      );
      const n = K.hasFeature(
        ie.ENABLE_CF_TRANSPORT_RECONNECTION_ON_ICE_FAILED
      ), i = K.hasFeature(
        ie.CF_TRANSPORT_FORCE_RELAY_ON_ICE_FAILED
      );
      n && (i && this._socket.isConnected && (performance.now() - this.lastConnectionTime > 20 * 1e3 && (this._transportConnectionFailCount = 0), this._transportConnectionFailCount > 2 && (l.warn("Multiple disconnections, forcing relay"), this._iceTransportPolicy = "relay"), this._transportConnectionFailCount += 1), this.updateTransportState({
        state: Yt.RECONNECTING,
        direction: r ? "consuming" : "producing"
      }), this.emit("reconnect_transport", e));
    }
    switchConsumersToLayer(e, r) {
      return u(this, null, function* () {
        const n = this._recvTransport.getDatachannel("events");
        if (!n) {
          l.warn("events datachannel not found");
          return;
        }
        const i = {
          type: "switch_consumer_layer",
          payload: {
            consumerIds: e,
            layer: r
          }
        };
        yield n.request(i), l.info(`CFSFUHandler::consumer id: ${e} layer switched to ${r}`);
      });
    }
    updateTransportState(e) {
      const { state: r, direction: n } = e;
      r === "disconnected" && (this.transportDisconnected[n] = true), o(this, mn, ha).mediaState[n] = {
        state: r,
        reconnected: r === "connected" ? this.transportDisconnected[n] : o(this, mn, ha).mediaState[n].reconnected
      }, r === "connected" && (this.transportDisconnected[n] = false), R.emit(
        P.TRANSPORT_STATE_UPDATE,
        L({
          transport: n
        }, o(this, mn, ha).mediaState[n])
      );
    }
  }
  mn = new WeakSet(), ha = function() {
    return o(this, _r).getValue("connectionHandler");
  }, _r = new WeakMap();
  var WM = Object.defineProperty, KM = Object.getOwnPropertyDescriptor, ue = (s, t, e, r) => {
    for (var n = KM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && WM(t, e, n), n;
  }, ft, fe, Sr, fn, gn, ws, eo, to, ro, Br, Ii, Er, as, Lh;
  const Dg = (Lh = class extends fg {
    constructor(t, e) {
      var d, p;
      super();
      E(this, Er);
      E(this, ft, undefined);
      E(this, fe, undefined);
      E(this, Sr, undefined);
      E(this, fn, undefined);
      E(this, gn, undefined);
      E(this, ws, undefined);
      E(this, eo, undefined);
      E(this, to, undefined);
      E(this, ro, undefined);
      E(this, Br, undefined);
      E(this, Ii, undefined);
      f(this, "legacyMode");
      f(this, "roomNodeUrl");
      f(this, "peerDisplayName");
      f(this, "activatedProducingPeerIds");
      f(this, "e2ee");
      f(this, "partialJoinRoomPromise");
      this.context = t;
      const {
        roomName: r,
        authToken: n,
        legacyMode: i,
        socketClient: a,
        meetingTitle: c
      } = e;
      this.mediaJoined = false, this.roomName = r, this.authToken = n, this.legacyMode = i, this.meetingTitle = c, _(this, ft, a), _(this, Sr, false), _(this, fe, new JM(t, a)), this.maxPreferredStreams = 6, this.activatedProducingPeerIds = /* @__PURE__ */ new Set(), _(this, Br, /* @__PURE__ */ new Set()), _(this, fn, false), _(this, gn, 0), _(this, ws, new Li()), this.e2ee = (p = (d = t.getValue("modules").e2ee) == null ? undefined : d.enabled) != null ? p : false, U.legacySwitch(i), this.handleSocketEvents(), this.handleSFUEvents(), this.handleCallstatsEvents(), _(this, eo, zr(() => u(this, null, function* () {
        if (!o(this, Er, as).mediaJoinAttempted)
          return;
        const { roomJoined: h } = yield this.joinRoom(
          this.peerDisplayName,
          this.roomUUID,
          {},
          true,
          true
        );
        h && (R.emit(P.RESET_PRODUCER_STATE), R.emit(P.ROOM_NODE_RECONNECTED));
      }), 5e3, { leading: true, maxWait: 1e3 })), _(this, to, zr((h) => u(this, null, function* () {
        h.close(), h.removeAllListeners(), yield this.sfuHandler.setupTransports(["send"]), l.info("send transport reconected!"), R.emit(P.RESET_PRODUCER_STATE);
      }), 1e3)), _(this, ro, zr((h) => u(this, null, function* () {
        h.close(), h.removeAllListeners(), yield this.sfuHandler.setupTransports(["recv"]), l.info("recv transport reconnected!"), this.activatedProducingPeerIds = /* @__PURE__ */ new Set(), R.emit(P.UPDATE_ACTIVE, { createAllConsumers: true });
      }), 1e3));
    }
    get mediaState() {
      return o(this, Er, as).mediaState;
    }
    get mediaJoined() {
      return o(this, Er, as).mediaJoined;
    }
    set mediaJoined(t) {
      o(this, Er, as).mediaJoined = t;
    }
    static init(t, e) {
      return u(this, null, function* () {
        const {
          legacyMode: r = true,
          meetingId: n,
          authToken: i,
          meetingTitle: a,
          socket: c
        } = e;
        return new Dg(
          t,
          {
            legacyMode: r,
            authToken: i,
            socketClient: c,
            roomName: n,
            meetingTitle: a
          }
        );
      });
    }
    get sfuHandler() {
      return o(this, fe);
    }
    get rejoinRoom() {
      return o(this, eo);
    }
    reset(t = true) {
      var e, r, n, i;
      (r = (e = o(this, fe)) == null ? undefined : e.cleanupConsumers) == null || r.call(e), (i = (n = o(this, fe)) == null ? undefined : n.stopAllProducers) == null || i.call(n), o(this, Br).clear(), this.activatedProducingPeerIds.clear(), t && (o(this, ws).stop(), this.sfuHandler.stopAllTransports(), this.sfuHandler.reset(), _(this, ws, new Li()));
    }
    reconnectTransport(t) {
      return u(this, null, function* () {
        l.info(`CFNodeClient::Room joining state: ${o(this, Sr)}`), !(!t || o(this, Sr)) && (t.direction === "send" ? yield o(this, to).call(this, t) : yield o(this, ro).call(this, t));
      });
    }
    setupTransports(t = false) {
      return u(this, null, function* () {
        yield o(this, fe).setupTransports(["recv", "send"], t);
      });
    }
    stopAllProducers() {
      return u(this, null, function* () {
        yield o(this, fe).stopAllProducers();
      });
    }
    joinRoom(a, c) {
      return u(this, arguments, function* (t, e, r = {}, n = false, i = false) {
        o(this, Er, as).mediaJoinAttempted = true, _(this, Sr, true), this.reset(n);
        const d = qe().ipInfo;
        if (d != null && d.loc && !o(this, Ii)) {
          const h = d.loc.split(",");
          _(this, Ii, {
            latitude: parseFloat(h[0]),
            longitude: parseFloat(h[1])
          });
        }
        let p;
        try {
          return p = yield o(this, ws).push(
            () => this._joinRoom(
              t,
              e,
              r,
              i,
              o(this, Ii)
            ),
            "joinRoom"
          ), p;
        } catch (h) {
          p = { roomJoined: false };
        }
        return p.roomJoined || R.emit(P.ROOM_NODE_FAILED), p;
      });
    }
    _partialJoinRoom(t, e, r = false, n = undefined) {
      return u(this, null, function* () {
        const i = qe().ipInfo;
        let a = n;
        if (i != null && i.loc && !n) {
          const c = i.loc.split(",");
          a = {
            latitude: parseFloat(c[0]),
            longitude: parseFloat(c[1])
          };
        }
        yield wr((c, d) => (o(this, ft).isConnected || d(new Error("socket is not connected")), c > 0 && l.warn(`retrying sending join room request, count: ${c}`), this.sfuHandler.cfSocketHandler.joinRoom(
          e,
          t,
          r,
          a
        ).catch((p) => {
          throw l.error("failed to send join room request, error:", { error: p }), p;
        })), { delayTime: 1e3, strategy: "exponential", maxRetryCount: K.hasFeature(ie.ENABLE_CF_INFINITE_RETRIES) ? 1 / 0 : 3 }), yield this.setupTransports(true);
      });
    }
    partialJoinRoom(t, e, r = false, n = undefined) {
      return u(this, null, function* () {
        this.partialJoinRoomPromise = o(this, ws).push(
          () => this._partialJoinRoom(t, e, r, n)
        );
      });
    }
    _joinRoom(a, c) {
      return u(this, arguments, function* (t, e, r = {}, n = false, i = null) {
        this.peerDisplayName = t;
        try {
          return this.partialJoinRoomPromise ? yield this.partialJoinRoomPromise : yield this._partialJoinRoom(t, e, n, i), navigator.product !== "ReactNative" && setTimeout(() => u(this, null, function* () {
            const h = {
              userId: this.context.getValue("userId"),
              peerId: this.peerId,
              displayName: t,
              roomUUID: e,
              roomViewType: "groupCall",
              roomName: this.roomName,
              deviceInfo: z(L({}, ve.getDeviceInfo()), {
                userAgent: navigator.userAgent,
                memory: navigator.deviceMemory,
                cpus: navigator.hardwareConcurrency
              }),
              sdkName: this.context.getValue("sdkName"),
              sdkVersion: this.context.getValue("sdkVersion"),
              metaData: {},
              permissions: {}
            };
            U.onSafeInitialization(() => {
              U.roomJoined(h), r != null && r.audio ? U.audioOn() : U.audioOff(), r != null && r.video ? U.videoOn() : U.videoOff();
            });
          })), { roomJoined: yield this.completeJoinRoom() };
        } catch (d) {
          return l.error("error on sending join room request", { error: d }), { roomJoined: false };
        } finally {
          this.partialJoinRoomPromise = undefined;
        }
      });
    }
    completeJoinRoom() {
      return u(this, null, function* () {
        try {
          const {
            maxPreferredStreams: t,
            roomState: e
          } = yield this.sfuHandler.cfSocketHandler.notifySelfJoinComplete();
          return this.roomUUID = e.roomUuid, this.maxPreferredStreams = t != null ? t : 6, _(this, Sr, !1), _(this, fn, !0), this.mediaJoined = !0, R.emit(P.UPDATE_ACTIVE, { createAllConsumers: !0 }), !0;
        } catch (t) {
          return l.error("error on completing join room:", { error: t }), false;
        }
      });
    }
    leaveRoom() {
      return u(this, null, function* () {
        o(this, fe).stopAllTransports(), _(this, fn, false), o(this, Er, as).mediaJoinAttempted = false;
        const t = {
          closeRoom: false
        };
        o(this, ft).sendMessagePromise(oe.leaveRoom, Tf.toBinary(t)).then((e) => {
          var n;
          ((n = Af.fromBinary(e.payload)) == null ? undefined : n.closed) || l.warn("weird state on peer closed and should not happen");
        }).catch((e) => {
          l.error("error on sending leave room request", { error: e });
        }), U.callEnded(), v.destruct();
      });
    }
    getConsumers() {
      return o(this, fe).consumers;
    }
    activatePeers(t) {
      return u(this, null, function* () {
        return this.createConsumers(t);
      });
    }
    deactivatePeers(t, e = "default") {
      return u(this, null, function* () {
        const r = /* @__PURE__ */ new Set();
        t.forEach((i) => {
          i.screenShare && i.kind === "video" && r.add(i.producingPeerId);
        });
        const n = e === "default" ? t.filter((i) => !r.has(i.producingPeerId)).filter((i) => i.kind !== "audio") : t;
        yield Promise.all(
          n.map((i) => {
            const a = this.sfuHandler.producerIdToConsumerIdMap.get(i.producerId);
            if (!a) {
              l.warn(`consumer not found in deactivate producers: ${i.producerId}`);
              return;
            }
            return this.sfuHandler.closeConsumer(a);
          })
        );
      });
    }
    createConsumers(t) {
      return u(this, null, function* () {
        return this.sfuHandler.createConsumers(t);
      });
    }
    pauseConsumers(t) {
      return u(this, null, function* () {
        t.forEach((e) => {
          this.sfuHandler.pauseConsumer(e);
        });
      });
    }
    resumeConsumers(t) {
      return u(this, null, function* () {
        t.forEach((e) => {
          this.sfuHandler.resumeConsumer(e);
        });
      });
    }
    closeConsumers(t) {
      return u(this, null, function* () {
        yield Promise.all(
          t.map((e) => {
            const r = this.sfuHandler.producerIdToConsumerIdMap.get(e.producerId);
            if (!r) {
              l.warn(`consumer not found in deactivate producers: ${e.producerId}`);
              return;
            }
            return this.sfuHandler.closeConsumer(r);
          })
        );
      });
    }
    consumePeer(t, e, r) {
      return u(this, null, function* () {
        if (l.info(`current activated Peer ids: ${JSON.stringify(Array.from(this.activatedProducingPeerIds.values()))}, forced?:${r}`), !this.activatedProducingPeerIds.has(t) || r)
          try {
            yield o(this, fe).createConsumers(e), this.activatedProducingPeerIds.add(t);
          } catch (n) {
            l.error("consumePeer failed in CFNodeClient.ts", { error: n });
          }
        else
          l.info(`not creating consumer for this peerId: ${t}`);
      });
    }
    shareWebcam(t) {
      return u(this, null, function* () {
        if (t === undefined)
          return null;
        if (o(this, fe).producers.has(X.WEBCAM)) {
          const i = o(this, fe).producers.get(
            X.WEBCAM
          );
          if (!i.closed && !navigator.isReactNative)
            return yield i.replaceTrack({ track: t }), yield this.resumeWebcam(), t;
          yield o(this, fe).removeProducer(X.WEBCAM);
        }
        const e = {
          track: t,
          codecOptions: {
            name: "VP8"
          },
          appData: {
            screenShare: false,
            e2ee: this.e2ee
          },
          stopTracks: false
        };
        let r = t.getConstraints().width;
        r in ah || (r = 640), e.encodings = gD[r], K.hasFeature(ie.ENABLE_CF_SIMULCAST) && (e.encodings = ah[r]);
        const n = () => {
          l.info("Disabling video due to the producer closure"), this.disableWebcam();
        };
        return o(this, fe).createProducer(
          X.WEBCAM,
          e,
          n
        );
      });
    }
    shareScreen(t) {
      return u(this, null, function* () {
        const { video: e, audio: r } = t;
        if (e === undefined)
          return;
        const n = {
          track: e,
          codecOptions: {
            name: "VP8"
          },
          appData: {
            screenShare: true,
            e2ee: this.e2ee,
            supportsRemoteControl: ve.isElectron()
          },
          stopTracks: false
        };
        let i = () => {
          l.info("Disabling screenShare due to the producer closure"), this.disableScreenShare();
        };
        if (yield o(this, fe).createProducer(
          X.SCREENSHARE_VIDEO,
          n,
          i
        ), r) {
          const a = {
            track: r,
            codecOptions: {
              name: "opus"
            },
            appData: {
              screenShare: true,
              e2ee: this.e2ee,
              supportsRemoteControl: ve.isElectron()
            },
            stopTracks: false,
            zeroRtpOnPause: true
          };
          i = () => {
          }, yield o(this, fe).createProducer(
            X.SCREENSHARE_AUDIO,
            a,
            i
          );
        }
        U.screenShareStart();
      });
    }
    shareMic(t) {
      return u(this, null, function* () {
        try {
          if (t === void 0)
            throw new Xe("track undefined");
          if (o(this, fe).producers.has(X.MIC)) {
            const n = o(this, fe).producers.get(X.MIC);
            if (!n.closed && !navigator.isReactNative) {
              yield n.replaceTrack({ track: t }), yield this.resumeMic();
              return;
            }
            yield o(this, fe).removeProducer(X.MIC, !1);
          }
          const e = {
            track: t,
            encodings: [
              {
                priority: "high"
              }
            ],
            codecOptions: {
              name: "opus"
            },
            appData: {
              e2ee: this.e2ee
            },
            stopTracks: !1,
            zeroRtpOnPause: !0
          }, r = () => {
            l.info("Disabling audio due to the producer closure"), this.disableMic();
          };
          yield o(this, fe).createProducer(
            X.MIC,
            e,
            r
          );
        } catch (e) {
          throw new w(e);
        }
      });
    }
    pauseMic() {
      const t = o(this, fe).producers.get(X.MIC);
      if (!t) {
        l.error("pauseMic::could_not_find_mic_producer");
        return;
      }
      if (t.paused) {
        l.info("pauseMic::mic_producer_already_paused");
        return;
      }
      t.pause();
      const e = {
        producerId: t.id,
        pause: true
      };
      o(this, ft).sendMessage(
        oe.toggleProducer,
        ks.toBinary(e)
      );
    }
    pauseWebcam() {
      return u(this, null, function* () {
        const t = o(this, fe).producers.get(
          X.WEBCAM
        );
        if (!t) {
          l.error("pauseWebcam::could_not_find_webcam_producer");
          return;
        }
        t.pause();
        const e = {
          producerId: t.id,
          pause: true
        };
        o(this, ft).sendMessage(
          oe.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    resumeMic() {
      return u(this, null, function* () {
        const t = o(this, fe).producers.get(X.MIC);
        if (!t) {
          l.error("resumeMic::could_not_find_mic_producer");
          return;
        }
        if (!t.pause) {
          l.info("resumeMic::mic_producer_already_resumed");
          return;
        }
        t.resume(), t.appData.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, t);
        const e = {
          producerId: t.id,
          pause: false
        };
        o(this, ft).sendMessage(
          oe.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    resumeWebcam() {
      return u(this, null, function* () {
        const t = o(this, fe).producers.get(
          X.WEBCAM
        );
        if (!t) {
          l.error("resumeWebcam::could_not_find_webcam_producer");
          return;
        }
        t.resume(), t.appData.e2ee && R.emit(P.E2EE_ACTIVE_PRODUCER, t);
        const e = {
          producerId: t.id,
          pause: false
        };
        o(this, ft).sendMessage(
          oe.toggleProducer,
          ks.toBinary(e)
        );
      });
    }
    disableWebcam() {
      return u(this, null, function* () {
        yield o(this, fe).removeProducer(X.WEBCAM);
      });
    }
    disableMic() {
      return u(this, null, function* () {
        yield o(this, fe).removeProducer(X.MIC);
      });
    }
    disableScreenShare() {
      return u(this, null, function* () {
        l.info("screen_sharing_stopped"), U.screenShareStop(), yield o(this, fe).removeProducer(X.SCREENSHARE_VIDEO), yield o(this, fe).removeProducer(X.SCREENSHARE_AUDIO), o(this, Br).clear();
      });
    }
    muteSelf() {
      return u(this, null, function* () {
        this.pauseMic();
      });
    }
    unmuteSelf() {
      return u(this, null, function* () {
      });
    }
    resetVideoProducers(t, e) {
      return u(this, null, function* () {
        t && (yield o(this, fe).removeProducer(X.WEBCAM, false), this.shareWebcam(t)), e && (yield o(this, fe).removeProducer(
          X.SCREENSHARE_VIDEO,
          false
        ), this.shareScreen({ video: e }));
      });
    }
    changeDisplayName(t, e) {
      return u(this, null, function* () {
        const r = {
          displayName: t,
          participantId: e != null ? e : this.peerId
        };
        if (!(yield this.sfuHandler.cfSocketHandler.changeDisplayName(
          r
        )))
          throw new Error("failed to change display name!");
      });
    }
    kick(t) {
      return u(this, null, function* () {
        const e = {
          participantId: t
        };
        if (!(yield this.sfuHandler.cfSocketHandler.kickPeer(e)))
          throw new Error("failed to kickout the participant!");
      });
    }
    kickAll() {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.cfSocketHandler.kickAll()))
          throw new Error("failed to kickout all participant!");
      });
    }
    muteAll(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.cfSocketHandler.hostControlForAll(
          "audio"
        )))
          throw new Error("failed to mute all participant");
      });
    }
    muteAllVideo() {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.cfSocketHandler.hostControlForAll(
          "video"
        )))
          throw new Error("failed to mute all video participant");
      });
    }
    disableAudio(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.cfSocketHandler.hostControlForPeer(
          t,
          "audio"
        )))
          throw new Error("failed to mute given participant");
      });
    }
    disableVideo(t) {
      return u(this, null, function* () {
        if (!(yield this.sfuHandler.cfSocketHandler.hostControlForPeer(
          t,
          "video"
        )))
          throw new Error("failed to mute video of given participant");
      });
    }
    pinPeer(t) {
      return u(this, null, function* () {
        const e = {
          participantId: t != null ? t : ""
        };
        try {
          yield o(this, ft).sendMessagePromise(
            oe.globalPinPeer,
            Ef.toBinary(e)
          );
        } catch (r) {
          l.error("Error in pinning peer:", { error: r });
        }
      });
    }
    validateScreenShare(t) {
      return this.peerId === t.peerId && this.sfuHandler.hasProducer(t.producerId) && o(this, Br).add(t.consumerPeerId), o(this, Br).size;
    }
    switchConsumersToLayer(t, e) {
      return u(this, null, function* () {
        this.sfuHandler.switchConsumersToLayer(t, e);
      });
    }
    handleSocketEvents() {
      return u(this, null, function* () {
        o(this, ft).on(
          oe.peerProducerCreateBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const { participantId: e, producerState: r } = Ff.fromBinary(t);
                if (e === this.peerId)
                  return;
                l.info(`producer created broadcast: ${e}, producer state: ${r}`), R.emit(P.NEW_PRODUCER, {
                  peerId: e,
                  producer: z(L({}, r), {
                    kind: r.kind === kt.AUDIO ? "audio" : "video"
                  })
                });
              } catch (e) {
                l.error("error in peer-producer-create-broadcast", { error: e });
              }
          }
        ), o(this, ft).on(
          oe.peerProducerToggleBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const {
                  participantId: e,
                  producerState: { kind: r, pause: n, producerId: i }
                } = Vf.fromBinary(t), a = r === kt.AUDIO ? "audio" : "video";
                l.info(`producer toggle broadcast: ${e}, producerId: ${i}, kind:${a}, paused:${n}`), R.emit(P.PRODUCER_TOGGLE, {
                  peerId: e,
                  producerId: i,
                  paused: n,
                  kind: a
                }), Array.from(this.getConsumers().values()).filter((d) => d.producerId === i).forEach((d) => {
                  d.paused !== n && (l.debug(`consumer state mismatched for ${d.id}. updating consumer pause state ${d.paused} to ${n}`), n ? (d.pause(), R.emit(P.CONSUMER_PAUSED, {
                    id: d.id
                  })) : (d.resume(), R.emit(P.CONSUMER_RESUMED, {
                    id: d.id
                  })));
                });
              } catch (e) {
                l.error("error in producer toggle broadcast handler", { error: e });
              }
          }
        ), o(this, ft).on(oe.peerLeaveBroadcast, ({ payload: t }) => {
          if (this.mediaJoined)
            try {
              const { participantId: e } = oc.fromBinary(t);
              if (e === this.peerId)
                return;
              l.info(`peer left broadcast:${e}`), o(this, Br).delete(e), this.sfuHandler.cleanupConsumers(e);
            } catch (e) {
              l.error("error in peer left broadcast", { error: e });
            }
        }), o(this, ft).on(
          oe.peerProducerCloseBroadcast,
          ({ payload: t }) => {
            if (this.mediaJoined)
              try {
                const {
                  participantId: e,
                  producerState: { producerId: r }
                } = Hf.fromBinary(t);
                if (e === this.peerId)
                  return;
                l.info(`producer closed broadcast:${e}`), R.emit(P.PRODUCER_CLOSED, {
                  peerId: e,
                  producerId: r
                });
                const n = this.sfuHandler.producerIdToConsumerIdMap.get(r);
                if (!n) {
                  l.warn(`no consumer found for producer:${r}`);
                  return;
                }
                l.info(`closing consumer ${n}, producer id: ${r}`), this.sfuHandler.closeConsumer(n).then(() => {
                  l.info(`closed consumer: ${n}`), this.sfuHandler.producerIdToConsumerIdMap.delete(r), R.emit(P.CONSUMER_CLOSED, {
                    id: n
                  });
                }).catch((i) => {
                  l.error("error closing consumer", { error: i });
                });
              } catch (e) {
                l.error("error on producer close broadcast", { error: e });
              }
          }
        ), o(this, ft).on(
          oe.mediaRoomTerminationBroadcastResponse,
          () => {
            !this.mediaJoined && !o(this, Sr) && !o(this, fn) || (l.warn("media hub termination broadcast received, rejoining room"), R.emit(P.ROOM_NODE_DISCONNECTED), this.rejoinRoom());
          }
        );
      });
    }
    handleSFUEvents() {
      o(this, fe).on("reconnect_transport", (t) => u(this, null, function* () {
        try {
          yield this.reconnectTransport(t), l.info(`transport reconnected [id:${t.id}]`);
        } catch (e) {
          l.error("error on reconnection transports", { error: e });
        }
      })), o(this, fe).on("rejoin", (t) => {
        var e;
        if (((e = o(this, Er, as).socketState) == null ? undefined : e.state) !== "connected") {
          l.warn("Ignoring rejoin attempt because socket is not connected");
          return;
        }
        if (o(this, gn) > 3 && !t) {
          l.warn("cannot rejoin more already rejoined 3 times");
          return;
        }
        if (o(this, Sr) && !t) {
          l.warn("room joining in progress, cannot start rejoining");
          return;
        }
        _(this, gn, o(this, gn) + 1), l.warn(`rejoining the room because transports are failing. [rejoinCount: ${o(this, gn)}]`), this.mediaJoined = false, R.emit(P.ROOM_NODE_DISCONNECTED), this.rejoinRoom();
      });
    }
    handleCallstatsEvents() {
      U.onSafeInitialization(() => {
        U.onConsumerScore((t) => {
          t.forEach((e, r) => {
            const n = this.sfuHandler.consumers.get(r);
            n && R.emit(P.CONSUMER_SCORE_UPDATE, {
              id: r,
              kind: n.kind,
              peerId: n.peerId,
              score: e.score,
              scoreStats: e
            });
          });
        }), U.onProducerScore((t) => {
          t.forEach((e, r) => {
            const n = Array.from(this.sfuHandler.producers.values()).find(
              (i) => i.id === r
            );
            n && R.emit(P.PRODUCER_SCORE_UPDATE, {
              id: r,
              kind: n.kind,
              appData: n.appData,
              score: e.score,
              scoreStats: e
            });
          });
        });
      });
    }
  }, ft = new WeakMap(), fe = new WeakMap(), Sr = new WeakMap(), fn = new WeakMap(), gn = new WeakMap(), ws = new WeakMap(), eo = new WeakMap(), to = new WeakMap(), ro = new WeakMap(), Br = new WeakMap(), Ii = new WeakMap(), Er = new WeakSet(), as = function() {
    return this.context.getValue("connectionHandler");
  }, Lh);
  let de = Dg;
  ue([
    v.trace("CFNodeClient.reset")
  ], de.prototype, "reset");
  ue([
    v.trace("CFNodeClient.reconnect")
  ], de.prototype, "reconnectTransport");
  ue([
    v.trace("CFNodeClient.setupTransport")
  ], de.prototype, "setupTransports");
  ue([
    v.trace("CFNodeClient.stopAllProducers")
  ], de.prototype, "stopAllProducers");
  ue([
    v.trace("CFNodeClient.joinRoom")
  ], de.prototype, "joinRoom");
  ue([
    v.trace("CFNodeClient.completeJoinRoom")
  ], de.prototype, "completeJoinRoom");
  ue([
    v.trace("CFNodeClient.leaveRoom")
  ], de.prototype, "leaveRoom");
  ue([
    v.trace("CFNodeClient.activatePeers")
  ], de.prototype, "activatePeers");
  ue([
    v.trace("CFNodeClient.deactivatePeers")
  ], de.prototype, "deactivatePeers");
  ue([
    v.trace("CFNodeClient.createConsumers")
  ], de.prototype, "createConsumers");
  ue([
    v.trace("CFNodeClient.pauseConsumers")
  ], de.prototype, "pauseConsumers");
  ue([
    v.trace("CFNodeClient.resumeConsumers")
  ], de.prototype, "resumeConsumers");
  ue([
    v.trace("CFNodeClient.closeConsumers")
  ], de.prototype, "closeConsumers");
  ue([
    v.trace("CFNodeClient.consumePeer")
  ], de.prototype, "consumePeer");
  ue([
    v.trace("CFNodeClient.shareWebcam")
  ], de.prototype, "shareWebcam");
  ue([
    v.trace("CFNodeClient.shareScreen")
  ], de.prototype, "shareScreen");
  ue([
    v.trace("CFNodeClient.shareMic")
  ], de.prototype, "shareMic");
  ue([
    v.trace("CFNodeClient.pauseMic")
  ], de.prototype, "pauseMic");
  ue([
    v.trace("CFNodeClient.pauseWebcam")
  ], de.prototype, "pauseWebcam");
  ue([
    v.trace("CFNodeClient.resumeMic")
  ], de.prototype, "resumeMic");
  ue([
    v.trace("CFNodeClient.resumeWebcam")
  ], de.prototype, "resumeWebcam");
  ue([
    v.trace("CFNodeClient.disableWebcam")
  ], de.prototype, "disableWebcam");
  ue([
    v.trace("CFClient.disableMic")
  ], de.prototype, "disableMic");
  ue([
    v.trace("CFClient.disableScreenShare")
  ], de.prototype, "disableScreenShare");
  ue([
    v.trace("CFNodeClient.muteSelf")
  ], de.prototype, "muteSelf");
  ue([
    v.trace("CFNodeClient.resetVideoProducers")
  ], de.prototype, "resetVideoProducers");
  ue([
    v.trace("CFNodeClient.changeDisplayName")
  ], de.prototype, "changeDisplayName");
  ue([
    v.trace("CFNodeClient.kickPeer")
  ], de.prototype, "kick");
  ue([
    v.trace("CFNodeClient.kickAllPeers")
  ], de.prototype, "kickAll");
  ue([
    v.trace("CFNodeClient.muteAll")
  ], de.prototype, "muteAll");
  ue([
    v.trace("CFNodeClient.muteAllVideo")
  ], de.prototype, "muteAllVideo");
  ue([
    v.trace("CFNodeClient.disableAudio")
  ], de.prototype, "disableAudio");
  ue([
    v.trace("CFNodeClient.disableVideo")
  ], de.prototype, "disableVideo");
  ue([
    v.trace("CFNodeClient.pinPeer")
  ], de.prototype, "pinPeer");
  ue([
    v.trace("CFNodeClient.validateScreenShare")
  ], de.prototype, "validateScreenShare");
  ue([
    v.trace("CFNodeClient.init")
  ], de, "init");
  function zM(s, t) {
    return u(this, null, function* () {
      const e = s.getValue("roomNodeClient");
      if (e) {
        if (e instanceof ce)
          return e;
        throw new Error("Room Node Client already setup");
      }
      const r = yield ce.init(s, t);
      return s.setValue("roomNodeClient", r), r;
    });
  }
  function YM(s, t) {
    return u(this, null, function* () {
      const e = s.getValue("roomNodeClient");
      if (e) {
        if (e instanceof de)
          return e;
        throw new Error("Room Node Client already setup");
      }
      const r = yield de.init(s, t);
      return s.setValue("roomNodeClient", r), r;
    });
  }
  function Mg(r, n) {
    return u(this, arguments, function* (s, t, e = xi.HIVE) {
      return e === xi.CF ? YM(s, t) : zM(s, t);
    });
  }
  function Og(s) {
    const t = s.getValue("roomNodeClient");
    try {
      t == null || t.leaveRoom();
    } catch (e) {
      l.error("roomNodeClient::cleanupRoomNodeClient");
    }
    s.setValue("roomNodeClient", undefined);
  }
  var QM = Object.defineProperty, XM = Object.getOwnPropertyDescriptor, ZM = (s, t, e, r) => {
    for (var n = XM(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && QM(t, e, n), n;
  };
  let Fs;
  var so, xh;
  const Ng = (xh = class {
    constructor(s, t) {
      f(this, "socket");
      E(this, so, undefined);
      _(this, so, t), this.socket = s, this.handleSocketEvents();
    }
    static create(s, t) {
      return Fs || (Fs = new Ng(s, t)), Fs;
    }
    static cleanup() {
      var s;
      try {
        (s = Fs == null ? void 0 : Fs.socket) == null || s.disconnect();
      } catch (t) {
        l.error("roomSocketHandler::cleanup");
      }
      Fs = undefined;
    }
    joinRoom(s, t) {
      return u(this, null, function* () {
        var n;
        this.socket.joinAttempted = true;
        const e = {
          capabilities: [],
          peer: {
            displayName: (n = s.name) != null ? n : "Participant",
            customParticipantId: s.customParticipantId,
            peerId: s.id,
            userId: s.userId,
            displayPictureUrl: s.picture,
            waitlisted: false
          },
          roomUuid: ""
        }, r = this.socket.sendMessagePromise(
          F.joinRoom,
          kR.toBinary(e)
        );
        try {
          const { peer: i } = $n.fromBinary((yield r).payload);
          o(this, so).getValue("connectionHandler").socketJoined = !0, R.emit(P.SOCKET_SERVICE_ROOM_JOINED, { peer: i });
          const a = this.getRoomState(), c = this.getRoomPeersNonPaginated(), [{ room: d }, { peers: p }] = yield Promise.all([a, c]);
          return R.emit(P.ROOM_STATE, d), R.emit(P.SOCKET_PEERS, p), { peer: i };
        } catch (i) {
          throw l.error("RoomSocketHandler.joinRoom.failed", {
            error: i
          }), new w(
            "Error: RoomSocketHandler.joinRoom failed.",
            "0002",
            i
          );
        }
      });
    }
    getAllAddedParticipants() {
      return u(this, null, function* () {
        try {
          return pb.fromBinary(
            (yield this.socket.sendMessagePromise(F.getAllAddedParticipants)).payload
          ).participants.map(
            (r) => {
              var n = r, { id: t } = n, e = na(n, ["id"]);
              return z(L({}, e), { userId: t });
            }
          );
        } catch (s) {
          return [];
        }
      });
    }
    getRoomPeers(s, t, e) {
      return u(this, null, function* () {
        let r;
        try {
          const n = {
            // F
            seachQuery: s,
            limit: t,
            offset: e
          }, i = yield this.socket.sendMessagePromise(
            F.getRoomPeersInfo,
            yR.toBinary(n)
          );
          r = $d.fromBinary(i.payload);
        } catch (n) {
          l.error("getRoomPeers::binary_decode_error", { error: n });
        }
        return r;
      });
    }
    getRoomPeersNonPaginated() {
      return u(this, null, function* () {
        let s;
        try {
          const t = yield this.socket.sendMessagePromise(
            F.getRoomPeersInfo
          );
          s = $d.fromBinary(t.payload);
        } catch (t) {
          l.error("getRoomJoinedPeers::binary_decode_error", { error: t });
        }
        return s;
      });
    }
    /**
     *  TODO:(ishita1805): uncomment this code when
     * socket service sends entire peer objects for roomEvents.getStagePeers
     */
    getStagePeers() {
      return u(this, null, function* () {
        let s;
        try {
          const t = yield this.socket.sendMessagePromise(
            F.getRoomPeersInfo
          );
          s = $d.fromBinary(t.payload);
        } catch (t) {
          l.error("getRoomJoinedPeers::binary_decode_error", { error: t });
        }
        return s;
      });
    }
    getPeerInfo(s) {
      return u(this, null, function* () {
        let t;
        try {
          const e = yield this.socket.sendMessagePromise(
            F.getPeerInfo,
            qf.toBinary({ peerId: s })
          );
          t = $n.fromBinary(e.payload);
        } catch (e) {
          l.error("getPeerInfo::binary_decode_error", { error: e });
        }
        return t;
      });
    }
    getRoomState() {
      return u(this, null, function* () {
        let s = qp.create();
        try {
          const t = yield this.socket.sendMessagePromise(F.getRoomInfo);
          s = qp.fromBinary(t.payload);
        } catch (t) {
          l.error("getRoomState::binary_decode_error", { error: t });
        }
        return s;
      });
    }
    getRoomStageState() {
      return u(this, null, function* () {
        let s = Wp.create();
        try {
          const t = yield this.socket.sendMessagePromise(F.getRoomStageState);
          s = Wp.fromBinary(t.payload);
        } catch (t) {
          l.error("getRoomStageState::binary_decode_error", { error: t });
        }
        return s;
      });
    }
    broadcastMessage(s, t) {
      return u(this, null, function* () {
        const e = {
          type: s,
          payload: new TextEncoder().encode(JSON.stringify(t)),
          timestamp: Date.now(),
          peerIds: []
          // Broadcast to all
        };
        return this.socket.sendMessagePromise(
          F.broadcastMessage,
          ko.toBinary(e)
        );
      });
    }
    broadcastToPeers(s, t, e) {
      return u(this, null, function* () {
        const r = {
          type: s,
          payload: new TextEncoder().encode(JSON.stringify(e)),
          timestamp: Date.now(),
          peerIds: t
          // Broadcast to peers
        };
        return this.socket.sendMessage(
          F.broadcastToPeers,
          ko.toBinary(r)
        );
      });
    }
    leaveRoom() {
      return u(this, null, function* () {
        this.socket.joinAttempted = false, this.socket.sendMessagePromise(
          F.leaveRoom,
          AR.toBinary({})
        );
      });
    }
    kick(s) {
      return u(this, null, function* () {
        const t = {
          peerIds: [s]
        };
        this.socket.sendMessage(
          F.kick,
          gb.toBinary(t)
        );
      });
    }
    kickAll(s = false) {
      return u(this, null, function* () {
        const t = {
          propagateKickAcrossRooms: s
        };
        this.socket.sendMessage(
          F.kickAll,
          Ql.toBinary(t)
        );
      });
    }
    getWaitingRoomRequests() {
      this.socket.sendMessage(F.getWaitingRoomRequests);
    }
    acceptWaitingRoomRequest(s) {
      const t = {
        userIds: s
      };
      this.socket.sendMessage(
        F.acceptWaitingRoomRequests,
        Tb.toBinary(t)
      );
    }
    rejectWaitingRoomRequest(s) {
      const t = {
        userIds: s
      };
      this.socket.sendMessage(
        F.denyWaitingRoomRequests,
        Sb.toBinary(t)
      );
    }
    updatePermissions(s, t) {
      return u(this, null, function* () {
        const e = {
          updatePeersPresets: []
        };
        return s.forEach((r) => {
          e.updatePeersPresets.push({
            userIds: r,
            patch: t
          });
        }), this.socket.sendMessagePromise(
          Ho.updateUserPreset,
          Yb.toBinary(e)
        );
      });
    }
    handleSocketEvents() {
      this.socket.on(F.broadcastMessage, ({ payload: s }) => {
        try {
          const t = ko.fromBinary(s);
          R.emit(P.ROOM_MESSAGE, {
            payload: JSON.parse(new TextDecoder().decode(t.payload)),
            type: t.type,
            timestamp: t.timestamp
          });
        } catch (t) {
          l.error("failed to decode broadcast message:", t);
        }
      }), this.socket.on(F.broadcastToPeers, ({ payload: s }) => {
        try {
          const t = ko.fromBinary(s);
          R.emit(P.MESSAGE, {
            payload: JSON.parse(new TextDecoder().decode(t.payload)),
            type: t.type,
            timestamp: t.timestamp
          });
        } catch (t) {
          l.error("failed to decode peer broadcast message:", t);
        }
      });
    }
    on(s, t) {
      let e, r;
      switch (s) {
        case F.joinRoom:
        case F.leaveRoom:
        case F.kick:
        case F.kickAll: {
          e = $n.fromBinary.bind($n), r = $n.create();
          break;
        }
        case F.getWaitingRoomRequests: {
          e = (n, i) => n ? Jp.fromBinary(n, i) : { requests: [] }, r = Jp.create();
          break;
        }
        case F.recordingPaused:
        case F.recordingStarted:
        case F.recordingStopped: {
          e = rh.fromBinary.bind(rh);
          break;
        }
        case Ho.updateUserPreset: {
          e = Kp.fromBinary.bind(Kp);
          break;
        }
        case oe.peerJoinedBroadcast:
        case ae.peerJoinedBroadcast: {
          e = Up.fromBinary.bind(Up);
          break;
        }
        case oe.selfJoinComplete:
        case ae.selfJoinComplete: {
          e = ac.fromBinary.bind(ac);
          break;
        }
        case oe.globalPeerPinBroadcast:
        case ae.globalPeerPinBroadcast: {
          e = Vp.fromBinary.bind(Vp);
          break;
        }
        case oe.selectedPeer:
        case ae.selectedPeer: {
          e = ll.fromBinary.bind(ll);
          break;
        }
        case oe.selectedPeerDiff:
        case ae.selectedPeerDiff: {
          e = $p.fromBinary.bind($p);
          break;
        }
        case oe.leaveRoom:
        case ae.leaveRoom: {
          e = oc.fromBinary.bind(oc);
          break;
        }
      }
      this.socket.on(s, ({ payload: n }) => {
        let i = r;
        if (!e)
          return t(undefined);
        try {
          i = e(n);
        } catch (a) {
          l.error("roomSocketHandler::on::binary_decode_error", {
            error: a
          });
        }
        return t(i);
      });
    }
    getUserPermissions(s) {
      return u(this, null, function* () {
        const t = {
          userIds: [s]
        };
        try {
          const e = yield this.socket.sendMessagePromise(
            Ho.getUserPresets,
            qb.toBinary(t)
          ), r = Wb.fromBinary(e.payload).peerPresets[0], n = new TextDecoder().decode(r.preset), i = JSON.parse(n).permissions;
          return { chat: i.chat, polls: i.polls, plugins: i.plugins };
        } catch (e) {
          throw l.error("Error in getting user preset", { error: e }), e;
        }
      });
    }
  }, so = new WeakMap(), xh);
  let mc = Ng;
  ZM([
    v.trace("RoomSocketHandler.joinRoom")
  ], mc.prototype, "joinRoom");
  var eO = Object.defineProperty, tO = Object.getOwnPropertyDescriptor, Dn = (s, t, e, r) => {
    for (var n = tO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && eO(t, e, n), n;
  }, Ps, er, it, Rt, Bt, $h;
  const Lg = ($h = class {
    /**
     * Use await SelfController.init(roomNodeClient) instead
     */
    constructor(s, t, e, r) {
      // eslint-disable-next-line class-methods-use-this
      E(this, Rt);
      f(this, "self");
      f(this, "authToken");
      E(this, Ps, undefined);
      f(this, "viewType");
      E(this, er, undefined);
      E(this, it, undefined);
      const { socket: n } = e, i = s.getValue("authToken");
      this.self = t, _(this, it, s), this.viewType = r, this.authToken = i, _(this, Ps, n), _(this, er, e), t.config.viewType !== gt.Chat && this.setupEvents();
    }
    get peerId() {
      return o(this, it).getValue("peerId");
    }
    get mediaJoined() {
      return o(this, it).getValue("connectionHandler").mediaJoined;
    }
    static init(s, t, e, r, n) {
      return u(this, null, function* () {
        const i = qe(), a = s.getValue("peerId"), c = !!s.getValue("cachedUserDetails"), d = yield ot.__init__(
          s,
          e,
          r,
          n,
          n.name,
          c
        );
        if (navigator.product !== "ReactNative") {
          const p = !K.hasFeature(ie.PRECALL_BANDWIDTH_TEST);
          setTimeout(() => u(this, null, function* () {
            const h = yield d.getAllDevices();
            l.info("populated_full_device_list", {
              devices: JSON.stringify(h)
            }), U.onSafeInitialization(() => u(this, null, function* () {
              U.devices("AUDIO", h == null ? undefined : h.filter((m) => m.kind === "audioinput")), U.devices("VIDEO", h == null ? undefined : h.filter((m) => m.kind === "videoinput")), U.devices("SPEAKER", h == null ? undefined : h.filter((m) => m.kind === "audiooutput"));
            })), l.info("Callstats:: initializing");
            try {
              yield U.initialize({
                peerId: a,
                engineName: ve.getDeviceInfo().engineName,
                env: s.getValue("env"),
                iceServers: yield i.getICEServers(),
                apiBase: s.getValue("apiBase"),
                flags: K.getAllFlags(),
                logger: l,
                apiHostnames: pf(s),
                skipConnectivityChecks: p
              }), l.info("Callstats:: initialized");
            } catch (m) {
              l.error("Callstats:: initialization failed", { error: m });
            }
          }), 0);
        } else
          l.info("Callstats:: Skipped initialization due to navigator product being ReactNative.");
        return new Lg(s, d, t, n.viewType);
      });
    }
    shareMediaTracks() {
      return u(this, null, function* () {
        var c;
        const {
          audioTrack: s,
          videoTrack: t,
          permissions: e,
          audioEnabled: r,
          videoEnabled: n,
          screenShareEnabled: i,
          screenShareTracks: a
        } = this.self;
        if (e.canProduceAudio && r)
          try {
            yield o(this, Rt, Bt).shareMic(s);
          } catch (d) {
            this.self.disableAudio();
          }
        if (e.canProduceVideo && n)
          try {
            const d = yield o(this, Rt, Bt).shareWebcam(t);
            d && d.id !== t.id && K.hasFeature(ie.EXP_RESHARE) && (yield o(this, Rt, Bt).shareWebcam(d));
          } catch (d) {
            this.self.disableVideo();
          }
        if (e.canProduceScreenshare && i)
          try {
            yield (c = o(this, Rt, Bt)) == null ? void 0 : c.shareScreen({
              video: a.video,
              audio: a.audio
            });
          } catch (d) {
            this.self.disableScreenShare();
          }
      });
    }
    kickHandler(s) {
      return u(this, null, function* () {
        let t = "kicked";
        (s == null ? undefined : s.kickType) === "kickAll" && (t = "ended"), this.leaveRoom(t);
      });
    }
    /**
     * Waitlist handlers
     */
    waitlistedHandler() {
      l.info("SelController.waitlisted"), this.self.waitlistStatus = "waiting", this.self.roomState = "waitlisted", this.self.emit("waitlisted");
    }
    waitlistAcceptHandler() {
      if (l.info("SelController.waitlistAccepted"), this.self.waitlistStatus === "accepted") {
        l.warn("SelfController.WAITLIST_ACCEPTED.UserAlreadyAccepted");
        return;
      }
      this.self.waitlistStatus = "accepted", this.joinRoom();
    }
    waitlistRejectedHandler() {
      if (l.info("SelfController.waitlistRejected"), this.self.waitlistStatus === "rejected") {
        l.warn("SelfController.WAITLIST_REJECTED.UserAlreadyRejected");
        return;
      }
      this.self.waitlistStatus = "rejected", this.leaveRoom("rejected");
    }
    resetSelf(s) {
      return u(this, null, function* () {
        U.callEnded(), o(this, Rt, Bt).reset(), s && (yield this.joinRoom(s));
      });
    }
    setupEvents() {
      R.on(P.RESET_PRODUCER_STATE, () => u(this, null, function* () {
        this.mediaJoined && this.shareMediaTracks();
      })), R.on(P.ROOM_NODE_RECONNECTED, () => {
        this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: true });
      }), R.on(P.ROOM_NODE_DISCONNECTED, () => {
        this.self.roomState !== "disconnected" && (this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" }));
      }), R.on(P.ROOM_NODE_FAILED, () => {
        this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
      }), R.on(P.SOCKET_SERVICE_RECONNECTED, ({ wasJoinAttempted: s }) => {
        s === false && (this.self.roomState = "init"), this.resetSelf(s);
      }), R.on(P.SOCKET_SERVICE_DISCONNECTED, ({ joinAttempted: s }) => {
        if (this.self.roomState === "disconnected")
          return;
        let { peerId: t } = this;
        s && K.hasFeature(ie.REFRESH_ID_ON_DISCONNECTION) && (t = v4()), o(this, Ps).updateURL(t), v.resetPeerId(t), qe().setHeader("dyte-tracing-id", t), va.remapContext(t, o(this, it)), this.self.roomState = "disconnected", this.self.emit("roomLeft", { state: "disconnected" });
      }), R.on(P.SOCKET_SERVICE_FAILED, () => {
        this.self.roomState = "failed", this.self.emit("roomLeft", { state: "failed" });
      }), o(this, er).on(F.waitingRoomRequestAccepted, () => {
        this.waitlistAcceptHandler();
      }), o(this, er).on(Ho.updateUserPreset, (s) => {
        s.updatePeersPresets.forEach((t) => {
          t.userIds === this.self.userId && R.emit(P.UPDATE_PERMISSIONS, t.patch);
        });
      }), o(this, er).on(F.waitingRoomRequestDenied, () => {
        this.waitlistRejectedHandler();
      }), o(this, er).on(F.kick, () => {
        this.kickHandler({ kickType: "kick" });
      }), o(this, er).on(F.kickAll, () => {
        this.kickHandler({ kickType: "kickAll" });
      }), R.onAsync(P.JOIN_MEDIA_ROOM, this.joinMediaRoom.bind(this)), R.on(
        P.PRODUCER_SCORE_UPDATE,
        ({
          score: s,
          kind: t,
          appData: e,
          scoreStats: r
        }) => {
          var i;
          const n = (i = e == null ? undefined : e.screenShare) != null ? i : false;
          this.self.emit("mediaScoreUpdate", {
            kind: t,
            isScreenshare: n,
            score: s,
            participantId: this.self.id,
            scoreStats: r
          });
        }
      ), R.on(P.MUTE_SELF, () => u(this, null, function* () {
        this.self.audioEnabled && (yield this.self.disableAudio(), U.audioOff());
      })), R.on(P.MUTE_SELF_VIDEO, () => u(this, null, function* () {
        this.self.videoEnabled && (yield this.self.disableVideo(), U.videoOff());
      })), R.onAsync(
        P.LEAVE_MEDIA_ROOM,
        this.leaveMediaRoom.bind(this)
      ), R.on(
        P.PIP_HANGUP,
        this.leaveRoom.bind(this)
      );
    }
    joinRoom(s = false) {
      return u(this, null, function* () {
        try {
          const { peer: t } = yield o(this, er).joinRoom(
            this.self,
            this.self.config.viewType
          );
          o(this, er).socket.flush();
          const e = su(t.stageType);
          if (o(this, it).setValue("stageStatus", e, !1), t.waitlisted) {
            this.waitlistedHandler();
            return;
          }
          yield this.joinMediaRoom(s), o(this, it).notify("stageStatus");
        } catch (t) {
          throw l.error("Error in joinRoom", { error: t }), t;
        }
      });
    }
    leaveRoom(s = "left") {
      return u(this, null, function* () {
        var t, e;
        if (s === "rejected") {
          try {
            (t = o(this, Ps)) == null || t.disconnect();
          } catch (r) {
            l.error("SelfController::leaveRoom::socketDisconnect");
          }
          this.self.roomState = s, this.self.emit("roomLeft", { state: s });
          return;
        }
        this.self.setIsPinned(false), o(this, it).setValue("stageStatus", "OFF_STAGE", false), yield this.leaveMediaRoom(s), o(this, it).notify("stageStatus");
        try {
          (e = o(this, Ps)) == null || e.disconnect();
        } catch (r) {
          l.error("SelfController::leaveRoom::socketDisconnect");
        }
        Og(o(this, it)), mc.cleanup(), this.self.roomState = s, this.self.emit("roomLeft", { state: s });
      });
    }
    partialMediaRoom() {
      var s;
      (s = o(this, Rt, Bt)) == null || s.partialJoinRoom(
        this.self.name,
        o(this, it).getValue("meetingId"),
        undefined
      );
    }
    joinMediaRoom(s = false) {
      return u(this, null, function* () {
        var h, m;
        const {
          peerId: t,
          viewType: e,
          meetingId: r,
          authToken: n,
          stageStatus: i,
          roomNodeOptions: a
        } = o(this, it).getAllValues(), {
          sfu: c,
          roomNodeUrl: d,
          meetingTitle: p
        } = a;
        try {
          if (e === gt.Livestream) {
            if (i !== "ON_STAGE") {
              this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
              return;
            }
            yield Mg(o(this, it), {
              socket: o(this, Ps),
              peerId: t,
              meetingId: r,
              authToken: n,
              roomNodeUrl: d,
              meetingTitle: p
            }, c);
          }
          const { roomJoined: g } = (m = yield (h = o(this, Rt, Bt)) == null ? void 0 : h.joinRoom(
            this.self.name,
            r,
            {
              audio: this.self.audioEnabled,
              video: this.self.videoEnabled,
              screen: this.self.screenShareEnabled
            },
            s,
            s
          )) != null ? m : {};
          if (!g)
            return;
          i === "ON_STAGE" && (yield this.shareMediaTracks()), this.self.roomState = "joined", this.self.emit("roomJoined", { reconnected: s });
        } catch (g) {
          throw l.error("Error:SelfController.mediaRoomJoin", g), new w("Error: could not join media room", g);
        }
      });
    }
    leaveMediaRoom(s) {
      return u(this, null, function* () {
        const t = o(this, it).getValue("viewType");
        yield this.cleanupSelf(), !(s === "stageLeft" && t === gt.Webinar) && o(this, Rt, Bt) && (o(this, Rt, Bt).mediaJoined && s !== "disconnected" && (yield o(this, Rt, Bt).leaveRoom()), !(s === "stageLeft" && t === gt.Livestream) && (o(this, Rt, Bt).mediaJoined = false));
      });
    }
    cleanupSelf() {
      return u(this, null, function* () {
        yield this.self.disableAudio(), yield this.self.disableVideo(), yield this.self.disableScreenShare(), this.self.cleanUpTracks(), this.self.destructMediaHandler(), navigator.isReactNative || this.self.removeDocumentEventListeners();
      });
    }
  }, Ps = new WeakMap(), er = new WeakMap(), it = new WeakMap(), Rt = new WeakSet(), Bt = function() {
    return o(this, it).getValue("roomNodeClient");
  }, $h);
  let Us = Lg;
  Dn([
    v.trace("SelfController.resetSelf")
  ], Us.prototype, "resetSelf");
  Dn([
    v.trace("SelfController.setupEvents")
  ], Us.prototype, "setupEvents");
  Dn([
    v.trace("SelfController.joinRoom")
  ], Us.prototype, "joinRoom");
  Dn([
    v.trace("SelfController.leaveRoom")
  ], Us.prototype, "leaveRoom");
  Dn([
    v.trace("SelfController.joinMediaRoom")
  ], Us.prototype, "joinMediaRoom");
  Dn([
    v.trace("SelfController.leaveMediaRoom")
  ], Us.prototype, "leaveMediaRoom");
  Dn([
    v.trace("SelfController.init")
  ], Us, "init");
  var no;
  class rO {
    constructor(t) {
      E(this, no, undefined);
      _(this, no, t);
    }
    on(t, e) {
      let r;
      t === F.roomPeerCount ? r = Bp.fromBinary.bind(Bp) : r = Zp.fromBinary.bind(Zp), o(this, no).on(t, ({ payload: n }) => {
        const i = r(n);
        return e(i);
      });
    }
  }
  no = new WeakMap();
  var io;
  class sO {
    constructor(t) {
      E(this, io, undefined);
      _(this, io, t);
    }
    on(t, e) {
      let r, n;
      switch (t) {
        case F.transcript: {
          r = xd.fromBinary.bind(
            xd
          ), n = xd.create();
          break;
        }
        default: {
          l.debug("AISocketHandler switch case hit default, event not accounted for.");
          break;
        }
      }
      o(this, io).on(t, ({ payload: i }) => {
        let a = n;
        try {
          a = r(i);
        } catch (c) {
          l.error("chatSocketHandler::on::binary_decode_error", {
            error: c
          });
        }
        return e(a);
      });
    }
  }
  io = new WeakMap();
  var nO = Object.defineProperty, iO = Object.getOwnPropertyDescriptor, hu = (s, t, e, r) => {
    for (var n = iO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && nO(t, e, n), n;
  }, qr;
  class nd {
    constructor(t) {
      E(this, qr, undefined);
      _(this, qr, t);
    }
    getPolls() {
      return o(this, qr).sendMessagePromise(Ar.getPolls);
    }
    createPoll(t, e, r = false, n = false) {
      const i = {
        anonymous: r,
        hideVotes: n,
        question: t,
        options: e
      };
      return o(this, qr).sendMessage(
        Ar.createPoll,
        BI.toBinary(i)
      );
    }
    votePoll(t, e) {
      const r = {
        index: e,
        pollId: t
      };
      return o(this, qr).sendMessage(
        Ar.votePoll,
        jI.toBinary(r)
      );
    }
    on(t, e) {
      let r, n;
      switch (t) {
        case Ar.updatePoll:
        case Ar.createPoll:
        case Ar.votePoll: {
          r = Bd.fromBinary.bind(Bd), n = Bd.create();
          break;
        }
      }
      o(this, qr).on(t, ({ payload: i }) => {
        let a = n;
        try {
          a = r(i);
        } catch (c) {
          l.error("pollSocketHandler::on::binary_decode_error", {
            error: c
          });
        }
        return e(a);
      });
    }
    removeListeners(t) {
      o(this, qr).removeListeners(t);
    }
  }
  qr = new WeakMap();
  hu([
    v.trace("PollSocketHandler.getPolls")
  ], nd.prototype, "getPolls");
  hu([
    v.trace("PollSocketHandler.createPoll")
  ], nd.prototype, "createPoll");
  hu([
    v.trace("PollSocketHandler.votePoll")
  ], nd.prototype, "votePoll");
  var bt;
  class aO {
    constructor(t) {
      E(this, bt, undefined);
      _(this, bt, t);
    }
    getStageRequests() {
      return u(this, null, function* () {
        const { payload: t } = yield o(this, bt).sendMessagePromise(
          F.getStageRequests
        );
        return t ? Hd.fromBinary(t) : { stageRequests: [] };
      });
    }
    requestAccess() {
      o(this, bt).sendMessage(F.requestStageAccess);
    }
    cancelRequestAccess() {
      o(this, bt).sendMessage(F.cancelStageRequest);
    }
    grantAccess(t) {
      return u(this, null, function* () {
        const e = {
          userIds: t
        };
        o(this, bt).sendMessage(
          F.grantStageAccess,
          MI.toBinary(e)
        );
      });
    }
    denyAccess(t) {
      return u(this, null, function* () {
        const e = {
          userIds: t
        };
        o(this, bt).sendMessage(
          F.denyStageAccess,
          NI.toBinary(e)
        );
      });
    }
    joinStage() {
      return o(this, bt).sendMessagePromise(
        F.joinStage,
        undefined,
        undefined,
        F.peerStageStatusUpdate
      );
    }
    leaveStage(t) {
      const e = {
        userIds: [t]
      };
      return o(this, bt).sendMessagePromise(
        F.leaveStage,
        th.toBinary(e),
        undefined,
        F.peerStageStatusUpdate
      );
    }
    kick(t) {
      const e = {
        userIds: t
      };
      return o(this, bt).sendMessagePromise(
        F.leaveStage,
        th.toBinary(e)
      );
    }
    on(t, e) {
      let r;
      switch (t) {
        case F.grantStageAccess:
        case F.denyStageAccess: {
          r = undefined;
          break;
        }
        case F.getStagePeers: {
          r = eh.fromBinary.bind(
            eh
          );
          break;
        }
        case F.getStageRequests:
        case F.requestStageAccess:
        case F.cancelStageRequest: {
          r = Hd.fromBinary.bind(
            Hd
          );
          break;
        }
        case F.peerStageStatusUpdate: {
          r = Hp.fromBinary.bind(Hp);
          break;
        }
      }
      o(this, bt).on(t, ({ payload: n, id: i }) => {
        if (!n || !r)
          return e(undefined, i);
        const a = r(n);
        return e(a, i);
      });
    }
    getPeerInfo(t) {
      return u(this, null, function* () {
        const e = yield o(this, bt).sendMessagePromise(
          F.getPeerInfo,
          qf.toBinary({ peerId: t })
        );
        return $n.fromBinary(e.payload);
      });
    }
  }
  bt = new WeakMap();
  var Qe;
  class oO {
    constructor(t) {
      E(this, Qe, undefined);
      _(this, Qe, t);
    }
    addPlugin(t, e) {
      o(this, Qe).sendMessage(
        J.addPlugin,
        zk.toBinary({ pluginId: t, staggered: e })
      );
    }
    removePlugin(t) {
      o(this, Qe).sendMessage(
        J.removePlugin,
        Qk.toBinary({ pluginId: t, staggered: false })
      );
    }
    getActivePlugins() {
      return u(this, null, function* () {
        const { payload: t } = yield o(this, Qe).sendMessagePromise(
          J.getPlugins
        );
        return t ? _I.fromBinary(t) : { plugins: [] };
      });
    }
    customPluginEventToRoom(t, e, r) {
      const n = {
        pluginId: t,
        pluginData: new TextEncoder().encode(JSON.stringify(e))
      };
      o(this, Qe).sendMessage(
        J.customPluginEventToRoom,
        oI.toBinary(n),
        r
      );
    }
    customPluginEventToPeers(t, e, r, n) {
      const i = {
        pluginId: t,
        peerIds: e,
        pluginData: new TextEncoder().encode(JSON.stringify(r))
      };
      o(this, Qe).sendMessage(
        J.customPluginEventToPeers,
        dI.toBinary(i),
        n
      );
    }
    enablePluginForRoom(t, e) {
      o(this, Qe).sendMessage(
        J.enablePluginForRoom,
        Zk.toBinary({ pluginId: t }),
        e
      );
    }
    enablePluginForPeers(t, e, r) {
      o(this, Qe).sendMessage(
        J.enablePluginForPeers,
        sI.toBinary({ pluginId: t, peerIds: e }),
        r
      );
    }
    disablePluginForRoom(t, e) {
      o(this, Qe).sendMessage(
        J.disablePluginForRoom,
        tI.toBinary({ pluginId: t }),
        e
      );
    }
    disablePluginForPeers(t, e, r) {
      o(this, Qe).sendMessage(
        J.disablePluginForPeers,
        iI.toBinary({ pluginId: t, peerIds: e }),
        r
      );
    }
    storeInsertKeys(t, e, r, n) {
      const i = {
        pluginId: t,
        storeName: e,
        insertKeys: r.map((a) => ({
          storeKey: a.key,
          payload: new TextEncoder().encode(JSON.stringify(a.payload))
        }))
      };
      o(this, Qe).sendMessage(
        J.storeInsertKeys,
        zp.toBinary(i),
        n
      );
    }
    storeGetKeys(t, e, r, n) {
      const i = {
        pluginId: t,
        storeName: e,
        getKeys: r.map((a) => ({ storeKey: a.key }))
      };
      o(this, Qe).sendMessage(
        J.storeGetKeys,
        hI.toBinary(i),
        n
      );
    }
    storeDeleteKeys(t, e, r, n) {
      const i = {
        pluginId: t,
        storeName: e,
        deleteKeys: r.map((a) => ({ storeKey: a.key }))
      };
      o(this, Qe).sendMessage(
        J.storeDeleteKeys,
        fI.toBinary(i),
        n
      );
    }
    storeDelete(t, e, r) {
      o(this, Qe).sendMessage(
        J.storeDelete,
        vI.toBinary({ pluginId: t, storeName: e }),
        r
      );
    }
    /**
     * @deprecated
     */
    // eslint-disable-next-line class-methods-use-this
    getPluginDataOld(t, e) {
      l.info("getPluginDataOld", {
        plugin: { id: t, storeName: e }
      });
    }
    /**
     * @deprecated
     */
    storePluginDataOld(t, e, r) {
      const n = {
        pluginId: t,
        storeName: e,
        insertKeys: [
          {
            storeKey: r.key,
            payload: new TextEncoder().encode(JSON.stringify(r))
          }
        ]
      };
      o(this, Qe).sendMessage(
        J.storeInsertKeys,
        zp.toBinary(n)
      );
    }
    on(t, e) {
      let r;
      switch (t) {
        case J.addPlugin:
        case J.enablePluginForPeers:
        case J.enablePluginForRoom: {
          r = hl.fromBinary.bind(hl);
          break;
        }
        case J.removePlugin:
        case J.disablePluginForPeers:
        case J.disablePluginForRoom: {
          r = Yp.fromBinary.bind(
            Yp
          );
          break;
        }
        case J.customPluginEventToPeers:
        case J.customPluginEventToRoom: {
          r = Xp.fromBinary.bind(Xp);
          break;
        }
        case J.storeInsertKeys:
        case J.storeGetKeys:
        case J.storeDeleteKeys:
        case J.storeDelete: {
          r = Qp.fromBinary.bind(Qp);
          break;
        }
      }
      o(this, Qe).on(t, ({ payload: n, id: i }) => {
        const a = r(n);
        return e(a, i);
      });
    }
  }
  Qe = new WeakMap();
  var cO = Object.defineProperty, dO = (s, t, e) => t in s ? cO(s, t, { enumerable: true, configurable: true, writable: true, value: e }) : s[t] = e, lO = (s, t, e) => (dO(s, t + "" , e), e), mu = (s, t, e) => {
    if (!t.has(s))
      throw TypeError("Cannot " + e);
  }, N = (s, t, e) => (mu(s, t, "read from private field"), e ? e.call(s) : t.get(s)), Re = (s, t, e) => {
    if (t.has(s))
      throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(s) : t.set(s, e);
  }, ge = (s, t, e, r) => (mu(s, t, "write to private field"), t.set(s, e), e), De = (s, t, e) => (mu(s, t, "access private method"), e), os, qs, js, Ue, Gs, Ae, Be, cs, tt, Jr, As, rr, Gn, Dr, Il, xg, ma, Jo, Al, $g, fu, Ug, fc, gu, Dl, Fg, Ca, gc, ya, vc, yc, vu, Jn, wa, Ta, Tc, yu = { exports: {} }, Wn = typeof Reflect == "object" ? Reflect : null, mh = Wn && typeof Wn.apply == "function" ? Wn.apply : function(t, e, r) {
    return Function.prototype.apply.call(t, e, r);
  }, Wo;
  Wn && typeof Wn.ownKeys == "function" ? Wo = Wn.ownKeys : Object.getOwnPropertySymbols ? Wo = function(t) {
    return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
  } : Wo = function(t) {
    return Object.getOwnPropertyNames(t);
  };
  function uO(s) {
    console && console.warn && console.warn(s);
  }
  var Vg = Number.isNaN || function(t) {
    return t !== t;
  };
  function Te() {
    Te.init.call(this);
  }
  yu.exports = Te;
  yu.exports.once = fO;
  Te.EventEmitter = Te;
  Te.prototype._events = undefined;
  Te.prototype._eventsCount = 0;
  Te.prototype._maxListeners = undefined;
  var fh = 10;
  function id(s) {
    if (typeof s != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s);
  }
  Object.defineProperty(Te, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return fh;
    },
    set: function(s) {
      if (typeof s != "number" || s < 0 || Vg(s))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + ".");
      fh = s;
    }
  });
  Te.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  Te.prototype.setMaxListeners = function(t) {
    if (typeof t != "number" || t < 0 || Vg(t))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
    return this._maxListeners = t, this;
  };
  function Hg(s) {
    return s._maxListeners === undefined ? Te.defaultMaxListeners : s._maxListeners;
  }
  Te.prototype.getMaxListeners = function() {
    return Hg(this);
  };
  Te.prototype.emit = function(t) {
    for (var e = [], r = 1; r < arguments.length; r++)
      e.push(arguments[r]);
    var n = t === "error", i = this._events;
    if (i !== undefined)
      n = n && i.error === undefined;
    else if (!n)
      return false;
    if (n) {
      var a;
      if (e.length > 0 && (a = e[0]), a instanceof Error)
        throw a;
      var c = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
      throw c.context = a, c;
    }
    var d = i[t];
    if (d === undefined)
      return false;
    if (typeof d == "function")
      mh(d, this, e);
    else
      for (var p = d.length, h = Jg(d, p), r = 0; r < p; ++r)
        mh(h[r], this, e);
    return true;
  };
  function Bg(s, t, e, r) {
    var n, i, a;
    if (id(e), i = s._events, i === undefined ? (i = s._events = /* @__PURE__ */ Object.create(null), s._eventsCount = 0) : (i.newListener !== undefined && (s.emit("newListener", t, e.listener ? e.listener : e), i = s._events), a = i[t]), a === undefined)
      a = i[t] = e, ++s._eventsCount;
    else if (typeof a == "function" ? a = i[t] = r ? [e, a] : [a, e] : r ? a.unshift(e) : a.push(e), n = Hg(s), n > 0 && a.length > n && !a.warned) {
      a.warned = true;
      var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      c.name = "MaxListenersExceededWarning", c.emitter = s, c.type = t, c.count = a.length, uO(c);
    }
    return s;
  }
  Te.prototype.addListener = function(t, e) {
    return Bg(this, t, e, false);
  };
  Te.prototype.on = Te.prototype.addListener;
  Te.prototype.prependListener = function(t, e) {
    return Bg(this, t, e, true);
  };
  function pO() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function qg(s, t, e) {
    var r = { fired: false, wrapFn: undefined, target: s, type: t, listener: e }, n = pO.bind(r);
    return n.listener = e, r.wrapFn = n, n;
  }
  Te.prototype.once = function(t, e) {
    return id(e), this.on(t, qg(this, t, e)), this;
  };
  Te.prototype.prependOnceListener = function(t, e) {
    return id(e), this.prependListener(t, qg(this, t, e)), this;
  };
  Te.prototype.removeListener = function(t, e) {
    var r, n, i, a, c;
    if (id(e), n = this._events, n === undefined)
      return this;
    if (r = n[t], r === undefined)
      return this;
    if (r === e || r.listener === e)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, r.listener || e));
    else if (typeof r != "function") {
      for (i = -1, a = r.length - 1; a >= 0; a--)
        if (r[a] === e || r[a].listener === e) {
          c = r[a].listener, i = a;
          break;
        }
      if (i < 0)
        return this;
      i === 0 ? r.shift() : hO(r, i), r.length === 1 && (n[t] = r[0]), n.removeListener !== undefined && this.emit("removeListener", t, c || e);
    }
    return this;
  };
  Te.prototype.off = Te.prototype.removeListener;
  Te.prototype.removeAllListeners = function(t) {
    var e, r, n;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== undefined && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
    if (arguments.length === 0) {
      var i = Object.keys(r), a;
      for (n = 0; n < i.length; ++n)
        a = i[n], a !== "removeListener" && this.removeAllListeners(a);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (e = r[t], typeof e == "function")
      this.removeListener(t, e);
    else if (e !== undefined)
      for (n = e.length - 1; n >= 0; n--)
        this.removeListener(t, e[n]);
    return this;
  };
  function jg(s, t, e) {
    var r = s._events;
    if (r === undefined)
      return [];
    var n = r[t];
    return n === undefined ? [] : typeof n == "function" ? e ? [n.listener || n] : [n] : e ? mO(n) : Jg(n, n.length);
  }
  Te.prototype.listeners = function(t) {
    return jg(this, t, true);
  };
  Te.prototype.rawListeners = function(t) {
    return jg(this, t, false);
  };
  Te.listenerCount = function(s, t) {
    return typeof s.listenerCount == "function" ? s.listenerCount(t) : Gg.call(s, t);
  };
  Te.prototype.listenerCount = Gg;
  function Gg(s) {
    var t = this._events;
    if (t !== undefined) {
      var e = t[s];
      if (typeof e == "function")
        return 1;
      if (e !== undefined)
        return e.length;
    }
    return 0;
  }
  Te.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Wo(this._events) : [];
  };
  function Jg(s, t) {
    for (var e = new Array(t), r = 0; r < t; ++r)
      e[r] = s[r];
    return e;
  }
  function hO(s, t) {
    for (; t + 1 < s.length; t++)
      s[t] = s[t + 1];
    s.pop();
  }
  function mO(s) {
    for (var t = new Array(s.length), e = 0; e < t.length; ++e)
      t[e] = s[e].listener || s[e];
    return t;
  }
  function fO(s, t) {
    return new Promise(function(e, r) {
      function n(a) {
        s.removeListener(t, i), r(a);
      }
      function i() {
        typeof s.removeListener == "function" && s.removeListener("error", n), e([].slice.call(arguments));
      }
      Wg(s, t, i, { once: true }), t !== "error" && gO(s, n, { once: true });
    });
  }
  function gO(s, t, e) {
    typeof s.on == "function" && Wg(s, "error", t, e);
  }
  function Wg(s, t, e, r) {
    if (typeof s.on == "function")
      r.once ? s.once(t, e) : s.on(t, e);
    else if (typeof s.addEventListener == "function")
      s.addEventListener(t, function n(i) {
        r.once && s.removeEventListener(t, n), e(i);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s);
  }
  var vO = yu.exports;
  class yO extends MessageType {
    constructor() {
      super("message.v1.SocketMessage", [
        { no: 1, name: "event", kind: "scalar", T: 13 },
        { no: 2, name: "id", kind: "scalar", opt: true, T: 9 },
        { no: 3, name: "payload", kind: "scalar", opt: true, T: 12 },
        { no: 4, name: "metadata", kind: "scalar", opt: true, T: 12 }
      ]);
    }
  }
  const gh = new yO();
  class Kg {
    static encode(t) {
      return gh.toBinary(t);
    }
    static decode(t) {
      return gh.fromBinary(new Uint8Array(t));
    }
  }
  function TO(s, t) {
    return Math.floor(Math.random() * (t - s + 1) + s);
  }
  class _O {
    constructor(t = {}) {
      lO(this, "opts"), Re(this, os, undefined), this.opts = {
        initialTimeout: t.initialTimeout || 1e3,
        maxTimeout: t.maxTimeout || 1e4,
        factor: t.factor || 2
      }, ge(this, os, 0);
    }
    wait() {
      return u(this, null, function* () {
        ge(this, os, N(this, os) + 1);
        const t = TO(0, Math.min(this.opts.maxTimeout, this.opts.initialTimeout * wu(2, N(this, os))));
        yield new Promise((e) => {
          setTimeout(e, t);
        });
      });
    }
    getAttempts() {
      return N(this, os);
    }
    reset() {
      ge(this, os, 0);
    }
  }
  os = /* @__PURE__ */ new WeakMap();
  const rs = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  class SO {
    constructor(t) {
      Re(this, qs, undefined), Re(this, js, undefined), ge(this, qs, console), ge(this, js, t);
    }
    debug(...t) {
      rs[N(this, js)] > rs.debug || N(this, qs).debug("[Sockrates]:", ...t);
    }
    info(...t) {
      rs[N(this, js)] > rs.info || N(this, qs).info("[Sockrates]:", ...t);
    }
    warn(...t) {
      rs[N(this, js)] > rs.warn || N(this, qs).warn("[Sockrates]:", ...t);
    }
    error(...t) {
      rs[N(this, js)] > rs.error || N(this, qs).error("[Sockrates]:", ...t);
    }
  }
  qs = /* @__PURE__ */ new WeakMap();
  js = /* @__PURE__ */ new WeakMap();
  var zg = /* @__PURE__ */ ((s) => (s[s.CONNECTING = 0] = "CONNECTING", s[s.OPEN = 1] = "OPEN", s[s.CLOSING = 2] = "CLOSING", s[s.CLOSED = 3] = "CLOSED", s))(zg || {});
  const EO = "2", CO = "3";
  class wO {
    constructor(t, e) {
      Re(this, Il), Re(this, ma), Re(this, Al), Re(this, fu), Re(this, fc), Re(this, Dl), Re(this, Ca), Re(this, ya), Re(this, yc), Re(this, Jn), Re(this, Ta), Re(this, Ue, undefined), Re(this, Gs, undefined), Re(this, Ae, undefined), Re(this, Be, undefined), Re(this, cs, undefined), Re(this, tt, undefined), Re(this, Jr, undefined), Re(this, As, undefined), Re(this, rr, undefined), Re(this, Gn, undefined), Re(this, Dr, undefined);
      var r, i, c, p, m, T, b, I, V, q;
      ge(this, Gs, t), ge(this, cs, []), ge(this, tt, new vO()), ge(this, Jr, true), ge(this, rr, false), ge(this, Ae, e != null ? e : {}), ((r = N(this, Ae)).autoReconnect) != null || (r.autoReconnect = true), ((i = N(this, Ae)).retryConnectionInterval) != null || (i.retryConnectionInterval = 1e3), ((c = N(this, Ae)).pingTimeout) != null || (c.pingTimeout = 3e4), ((p = N(this, Ae)).connectionTimeout) != null || (p.connectionTimeout = 5e3), ((m = N(this, Ae)).debug) != null || (m.debug = true), ((T = N(this, Ae)).maxReconnectionAttempts) != null || (T.maxReconnectionAttempts = 10), ((b = N(this, Ae)).disconnectOnPingTimeout) != null || (b.disconnectOnPingTimeout = true), ((I = N(this, Ae)).queueOnDisconnect) != null || (I.queueOnDisconnect = false), ((V = N(this, Ae)).flushOnReconnect) != null || (V.flushOnReconnect = false), ge(this, As, {
        code: undefined,
        reason: undefined
      }), ge(this, Be, (q = N(this, Ae).logger) != null ? q : new SO(N(this, Ae).debug ? "debug" : "info")), ge(this, Dr, new _O());
    }
    get readyState() {
      var t;
      return (t = N(this, Ue)) == null ? undefined : t.readyState;
    }
    get url() {
      return N(this, Gs);
    }
    updateURL(t) {
      ge(this, Gs, t), De(this, Dl, Fg).call(this);
    }
    get config() {
      return N(this, Ae);
    }
    get sendQueue() {
      return N(this, cs);
    }
    flush() {
      if (!N(this, Ae).queueOnDisconnect)
        return false;
      const t = [];
      return N(this, cs).forEach((e) => {
        this.send(e.event, e.id, e.payload, e.metadata) || t.push(e);
      }), ge(this, cs, t), N(this, cs);
    }
    connect(t = false) {
      return u(this, null, function* () {
        if (!t && [0, 1].includes(this.readyState)) {
          N(this, Be).debug("Websocket was already connecting or connected.");
          return;
        }
        if (N(this, Jr) !== false)
          return new Promise((e, r) => {
            De(this, Jn, wa).call(this), De(this, Ta, Tc).call(this);
            try {
              ge(this, Ue, new WebSocket(De(this, Il, xg).call(this, N(this, Gs)))), N(this, Ue).binaryType = "arraybuffer", N(this, Be).debug("Connecting to", N(this, Gs));
              const n = setTimeout(() => {
                N(this, Be).debug("Connection timeout. Closing socket"), ge(this, Jr, !0), De(this, Ta, Tc).call(this), N(this, Ue).close(3001, "Connection Timeout"), N(this, Ae).autoReconnect && !N(this, rr) && (N(this, tt).emit("reconnecting"), De(this, Ca, gc).call(this)), r(new Error("Connection timed out!"));
              }, N(this, Ae).connectionTimeout);
              N(this, Ue).onopen = () => {
                N(this, Be).debug(`Ready State: ${zg[N(this, Ue).readyState]}`), n && clearTimeout(n), De(this, yc, vu).call(this), ge(this, As, {
                  code: void 0,
                  reason: void 0
                }), N(this, tt).emit("connected"), N(this, Ae).flushOnReconnect && this.flush(), e();
              }, N(this, Ue).onclose = (i) => {
                try {
                  n && clearTimeout(n);
                  const { code: a, reason: c } = i;
                  r(c), N(this, Be).debug("Socket closed. Close event:", i), N(this, Be).debug("Connection closed code:", a), N(this, Be).debug("Connection closed reason:", c), N(this, rr) || De(this, fc, gu).call(this, a, c);
                } catch (a) {
                  De(this, ma, Jo).call(this, a);
                }
              }, N(this, Ue).onerror = (i) => {
                De(this, ma, Jo).call(this, i);
              }, N(this, Ue).onmessage = (i) => De(this, Al, $g).call(this, i);
            } catch (n) {
              De(this, ma, Jo).call(this, n, r);
            }
          });
      });
    }
    send(t, e, r, n) {
      const i = { event: t, id: e, payload: r, metadata: n };
      if (N(this, Ae).queueOnDisconnect && (!N(this, Ue) || N(this, Ue).readyState !== 1))
        return N(this, Be).debug("Queuing message since socket is not connected!", i), N(this, cs).push(i), false;
      const a = Kg.encode(i);
      return De(this, ya, vc).call(this, a);
    }
    emit(t, e, r, n) {
      return this.send(t, e, r, n);
    }
    sendRaw(t) {
      return De(this, ya, vc).call(this, t);
    }
    receive(t, e) {
      return N(this, tt).on(t.toString(), e);
    }
    on(t, e) {
      if (typeof t == "string" && (t === "connected" || t === "disconnected" || t === "errored" || t === "reconnected" || t === "reconnecting" || t === "reconnectAttempt" || t === "reconnectFailure" || t === "failed")) {
        N(this, tt).on(t, e);
        return;
      }
      this.receive(t, e);
    }
    removeAllListeners() {
      N(this, tt).removeAllListeners();
    }
    removeReceiver(t, e) {
      this.removeListener(t, e);
    }
    removeListener(t, e) {
      N(this, tt).removeListener(t.toString(), e);
    }
    removeReceivers(t) {
      this.removeListeners(t);
    }
    removeListeners(t) {
      N(this, tt).listeners(t.toString()).map((e) => this.removeListener(t, e));
    }
    disconnect() {
      ge(this, Jr, false), De(this, Jn, wa).call(this), this.removeAllListeners(), ge(this, As, {
        code: 1e3,
        reason: "Sockrates disconnect method called"
      }), N(this, Ue).close(1e3, "Sockrates disconnect method called.");
    }
  }
  Ue = /* @__PURE__ */ new WeakMap();
  Gs = /* @__PURE__ */ new WeakMap();
  Ae = /* @__PURE__ */ new WeakMap();
  Be = /* @__PURE__ */ new WeakMap();
  cs = /* @__PURE__ */ new WeakMap();
  tt = /* @__PURE__ */ new WeakMap();
  Jr = /* @__PURE__ */ new WeakMap();
  As = /* @__PURE__ */ new WeakMap();
  rr = /* @__PURE__ */ new WeakMap();
  Gn = /* @__PURE__ */ new WeakMap();
  Dr = /* @__PURE__ */ new WeakMap();
  Il = /* @__PURE__ */ new WeakSet();
  xg = function(s) {
    if (s.startsWith("ws://") || s.startsWith("wss://"))
      return s;
    if (s.startsWith("https://"))
      return `wss://${s.substring(8)}`;
    if (s.startsWith("http://"))
      return `ws://${s.substring(7)}`;
    throw new Error("Invalid URL. URL must start with http(s):// or ws(s)://.");
  };
  ma = /* @__PURE__ */ new WeakSet();
  Jo = function(s, t) {
    N(this, Be).error("Error:", { error: s }), N(this, tt).emit("errored", { error: s }), t == null || t(s);
  };
  Al = /* @__PURE__ */ new WeakSet();
  $g = function(s) {
    if (De(this, yc, vu).call(this), s.data === EO) {
      N(this, Be).debug("Received ping from server"), De(this, ya, vc).call(this, CO);
      return;
    }
    const t = Kg.decode(s.data), { id: e, payload: r } = t;
    N(this, Be).debug("Received message", { event: t.event, messageID: e }), N(this, tt).emit(t.event.toString(), { id: e, payload: r });
  };
  fu = /* @__PURE__ */ new WeakSet();
  Ug = function() {
    return N(this, Ue).readyState === 1;
  };
  fc = /* @__PURE__ */ new WeakSet();
  gu = function(s, t) {
    ge(this, As, { reason: t, code: s }), N(this, tt).emit("disconnected", { code: s, reason: t });
  };
  Dl = /* @__PURE__ */ new WeakSet();
  Fg = function() {
    const { reason: s, code: t } = N(this, As);
    t && t !== 1e3 && N(this, Jr) && N(this, Ae).autoReconnect && !N(this, rr) && (N(this, Be).debug(`Triggering reconnection due to ${s}.`), N(this, tt).emit("reconnecting"), De(this, Ca, gc).call(this));
  };
  Ca = /* @__PURE__ */ new WeakSet();
  gc = function(s = true) {
    return u(this, null, function* () {
      if (s && N(this, rr)) {
        N(this, Be).debug("Reconnect called when already in a reconnect loop. Ignoring.");
        return;
      }
      if (N(this, rr) || N(this, Dr).reset(), N(this, Ae).maxReconnectionAttempts !== null && N(this, Dr).getAttempts() >= N(this, Ae).maxReconnectionAttempts) {
        N(this, tt).emit("failed"), ge(this, rr, false);
        return;
      }
      ge(this, rr, true), De(this, Ta, Tc).call(this), De(this, Jn, wa).call(this);
      try {
        if (yield N(this, Dr).wait(), N(this, Jr) === !1)
          return;
        if (N(this, Be).debug(`Reconnection attempt ${N(this, Dr).getAttempts()}`), N(this, tt).emit("reconnectAttempt", { attempt: N(this, Dr).getAttempts() }), yield this.connect(), !De(this, fu, Ug).call(this))
          throw Error("Reconnect Failed");
        ge(this, rr, !1), ge(this, As, {
          code: void 0,
          reason: void 0
        }), N(this, tt).emit("reconnected");
      } catch (t) {
        N(this, Be).debug("Failed to reconnect."), N(this, tt).emit("reconnectFailure", { attempt: N(this, Dr).getAttempts() }), De(this, Ca, gc).call(this, false);
      }
    });
  };
  ya = /* @__PURE__ */ new WeakSet();
  vc = function(s) {
    try {
      return N(this, Ue).send(s), !0;
    } catch (t) {
      return N(this, Be).error(t.message), false;
    }
  };
  yc = /* @__PURE__ */ new WeakSet();
  vu = function() {
    this.config.disconnectOnPingTimeout && (N(this, Be).debug("Resetting ping timeout"), De(this, Jn, wa).call(this), ge(this, Gn, setTimeout(() => {
      var s;
      N(this, Be).debug("Disconnecting the socket due to ping timeout"), ge(this, Jr, true);
      const t = 3002, e = "Ping timeout";
      (s = N(this, Ue)) == null || s.close(t, e), De(this, fc, gu).call(this, t, e);
    }, N(this, Ae).pingTimeout)));
  };
  Jn = /* @__PURE__ */ new WeakSet();
  wa = function() {
    N(this, Gn) && (clearTimeout(N(this, Gn)), ge(this, Gn, undefined));
  };
  Ta = /* @__PURE__ */ new WeakSet();
  Tc = function() {
    N(this, Ue) && (N(this, Ue).onopen = undefined, N(this, Ue).onerror = undefined, N(this, Ue).onmessage = undefined, N(this, Ue).onclose = undefined);
  };
  var PO = Object.defineProperty, RO = Object.getOwnPropertyDescriptor, ad = (s, t, e, r) => {
    for (var n = RO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && PO(t, e, n), n;
  };
  const vh = 65535, bO = 3e3;
  var Rs, Me, Oe, Ve, zt, jr, ao, Ml, oo, Ol, Uh;
  const Yg = (Uh = class {
    constructor(s, {
      peerId: t,
      meetingId: e,
      authToken: r,
      capabilities: n
    }) {
      E(this, Oe);
      E(this, ao);
      E(this, oo);
      E(this, Rs, undefined);
      E(this, Me, undefined);
      f(this, "roomName");
      f(this, "authToken");
      f(this, "capabilities");
      E(this, zt, undefined);
      E(this, jr, undefined);
      var i;
      if (!t || !e || !r)
        throw new w("peerId, roomName, or authToken can not be empty");
      _(this, zt, undefined), _(this, jr, s), this.capabilities = n, this.roomName = e, this.authToken = r, _(this, Rs, Le(this, ao, Ml).call(this, t)), _(this, Me, new wO(o(this, Rs), {
        autoReconnect: true,
        disconnectOnPingTimeout: (i = n.includes("PING")) != null ? i : false,
        queueOnDisconnect: true,
        flushOnReconnect: false,
        logger: l
      })), this.handleSocketConnectionEvents();
    }
    get joinAttempted() {
      return o(this, Oe, Ve).socketJoinAttempted;
    }
    set joinAttempted(s) {
      o(this, Oe, Ve).socketJoinAttempted = s;
    }
    get peerId() {
      return o(this, jr).getValue("peerId");
    }
    updateURL(s) {
      s !== this.peerId && (_(this, Rs, Le(this, ao, Ml).call(this, s)), l.debug("SocketService:: Connection URL updated.")), o(this, Me).updateURL(o(this, Rs));
    }
    static getSocketEdgeDomain(s) {
      return jn({ servicePrefix: "socket-edge", baseURI: s });
    }
    get url() {
      return o(this, Rs);
    }
    connect() {
      return u(this, null, function* () {
        o(this, Oe, Ve).socketJoinAttempted = true, yield o(this, Me).connect(), o(this, Oe, Ve).socketJoinAttempted = true, o(this, Oe, Ve).socketState = {
          state: "connected",
          reconnected: false,
          reconnectionAttempt: undefined
        };
      });
    }
    disconnect() {
      return u(this, null, function* () {
        o(this, Oe, Ve).socketJoinAttempted = false, o(this, Me).disconnect(), o(this, Oe, Ve).socketJoinAttempted = true, o(this, Oe, Ve).socketState = {
          state: "disconnected",
          reconnected: false,
          reconnectionAttempt: undefined
        };
      });
    }
    get isConnected() {
      try {
        return o(this, Me).readyState === 1;
      } catch (s) {
        return false;
      }
    }
    sendMessage(s, t, e) {
      const r = {};
      return v.injectContext(r), o(this, Me).send(
        s,
        e != null ? e : Le(this, oo, Ol).call(this),
        t,
        new TextEncoder().encode(JSON.stringify(r))
      );
    }
    sendMessagePromise(s, t, e, r) {
      const n = parseInt({}.SOCKET_SERVICE_MESSAGE_REQUEST_TIMEOUT, 10) || 2e4;
      return this.sendMessagePromiseWithTimeout({
        event: s,
        timeout: n,
        protobuf: t,
        messageId: e,
        resp: r
      });
    }
    sendMessagePromiseWithTimeout({
      event: s,
      timeout: t,
      protobuf: e,
      messageId: r,
      resp: n
    }) {
      const i = n != null ? n : s;
      return new Promise(
        (a, c) => {
          const d = (T, y) => {
            o(this, Me).removeListener(i, T), o(this, Me).removeListener(vh, y), o(this, Me).removeListener(
              ae.errorResponse,
              y
            ), o(this, Me).removeListener(
              oe.errorResponse,
              y
            );
          }, p = r != null ? r : Le(this, oo, Ol).call(this), h = {};
          v.injectContext(h);
          const m = ({
            id: T,
            payload: y
          }) => {
            if (p === T) {
              let b;
              try {
                const A = _P.fromBinary(y);
                b = new Error(A.errorMessage);
              } catch (A) {
                b = new Error("failed to parse error message", { cause: A });
                try {
                  const I = uR.fromBinary(y);
                  b = new Error(I.message);
                } catch (I) {
                  b = new Error("failed to parse error message", { cause: I });
                }
              }
              c(b), d(g, m);
            }
          }, g = ({
            id: T,
            payload: y
          }) => {
            p === T && (a({ id: T, payload: y }), d(g, m));
          };
          o(this, Me).on(i, g), o(this, Me).on(vh, m), o(this, Me).on(ae.errorResponse, m), o(this, Me).on(oe.errorResponse, m), setTimeout(() => {
            d(g, m), c(new Error(`request timeout for callback eventId:${s}`));
          }, t), o(this, Me).send(
            s,
            p,
            e,
            new TextEncoder().encode(JSON.stringify(h))
          );
        }
      );
    }
    on(s, t) {
      o(this, Me).on(s, t);
    }
    onStateEvent(s, t) {
      o(this, Me).on(s, t);
    }
    removeListener(s, t) {
      o(this, Me).removeListener(s, t);
    }
    removeListeners(s) {
      o(this, Me).removeListeners(s);
    }
    flush() {
      return o(this, Me).flush();
    }
    handleSocketConnectionEvents() {
      this.onStateEvent("connected", () => u(this, null, function* () {
        l.info("SocketService::Connected to socket-edge"), o(this, zt) && (clearTimeout(o(this, zt)), _(this, zt, undefined)), o(this, Oe, Ve).updateSocketConnectionState("connected");
      })), this.onStateEvent("disconnected", ({ code: s, reason: t }) => {
        var n;
        l.info("SocketService::Disconnected from socket-edge", { error: { code: s, reason: t } });
        const { recv: e, send: r } = (n = o(this, Oe, Ve).mediaState) != null ? n : {};
        e != null && e.state && (e == null ? undefined : e.state) !== Yt.CONNECTED || r != null && r.state && (r == null ? undefined : r.state) !== Yt.CONNECTED ? R.emit(
          P.SOCKET_SERVICE_DISCONNECTED,
          {
            joinAttempted: o(this, Oe, Ve).joinAttempted
          }
        ) : _(this, zt, setTimeout(() => {
          R.emit(
            P.SOCKET_SERVICE_DISCONNECTED,
            { joinAttempted: o(this, Oe, Ve).joinAttempted }
          ), _(this, zt, undefined);
        }, bO)), o(this, Oe, Ve).updateSocketConnectionState("disconnected");
      }), this.onStateEvent("reconnecting", () => u(this, null, function* () {
        l.info("SocketService::Reconnecting to socket-edge"), o(this, Oe, Ve).updateSocketConnectionState("reconnecting");
      })), this.onStateEvent("reconnectAttempt", (t) => u(this, [t], function* ({ attempt: s }) {
        l.info("SocketService::Attempting to reconnect to socket-edge", {
          socket: {
            retryAttempt: s
          }
        }), o(this, Oe, Ve).updateSocketConnectionState("reconnectAttempt", s);
      })), this.onStateEvent("reconnectFailure", ({ attempt: s }) => {
        l.info("SocketService::Reconnect attempt to socket-edge failed", {
          socket: {
            retryAttempt: s
          }
        }), o(this, Oe, Ve).updateSocketConnectionState("reconnectFailure", s);
      }), this.onStateEvent("reconnected", () => u(this, null, function* () {
        l.info("SocketService::Reconnected to socket-edge", { connectionState: { joinAttempted: o(this, Oe, Ve).joinAttempted } }), o(this, zt) && (clearTimeout(o(this, zt)), _(this, zt, undefined)), R.emit(P.SOCKET_SERVICE_RECONNECTED, {
          wasJoinAttempted: o(this, Oe, Ve).joinAttempted
        }), o(this, Oe, Ve).updateSocketConnectionState("reconnected");
      })), this.onStateEvent("failed", () => u(this, null, function* () {
        l.info("SocketService::Failed to connect to socket-edge"), R.emit(P.SOCKET_SERVICE_FAILED), o(this, Oe, Ve).updateSocketConnectionState("failed");
      }));
    }
  }, Rs = new WeakMap(), Me = new WeakMap(), Oe = new WeakSet(), Ve = function() {
    return o(this, jr).getValue("connectionHandler");
  }, zt = new WeakMap(), jr = new WeakMap(), ao = new WeakSet(), Ml = function(s) {
    let t = Yg.getSocketEdgeDomain(o(this, jr).getValue("baseURI"));
    typeof ol(o(this, jr), "socket_server_base") == "string" && (t = ol(o(this, jr), "socket_server_base"));
    const e = `wss://${t}`, r = new URL(`${e}/ws`), n = this.peerId, i = z(L({
      roomID: this.roomName,
      peerID: s,
      authToken: this.authToken,
      useMediaV2: true
    }, n !== s && { oldPeerID: n }), {
      ping: this.capabilities.includes("PING"),
      capabilities: this.capabilities.map((a) => cc[a]).join(" "),
      joinWithDetails: true
    });
    return Object.entries(i).forEach(([a, c]) => {
      r.searchParams.append(a, c.toString());
    }), r.href;
  }, oo = new WeakSet(), Ol = function() {
    return `${this.peerId}-${(Math.random() + 1).toString(36).substring(7)}`;
  }, Uh);
  let Eo = Yg;
  ad([
    v.trace("SocketService.connect")
  ], Eo.prototype, "connect");
  ad([
    v.trace("SocketService.disconnect")
  ], Eo.prototype, "disconnect");
  ad([
    v.trace("SocketService.sendMessagePromise")
  ], Eo.prototype, "sendMessagePromise");
  ad([
    v.trace("SocketService.sendMessagePromiseWithTimeout")
  ], Eo.prototype, "sendMessagePromiseWithTimeout");
  const ls = class {
    static handleConnectedRoomsDumpRaw({ payload: t }) {
      var i;
      const e = UR.fromBinary(t), r = e.meetings.map((a) => {
        var c;
        return {
          id: a.id,
          title: a.title,
          participants: (c = a.participants) != null ? c : []
        };
      });
      return {
        parentMeeting: {
          id: e.parentMeeting.id,
          title: e.parentMeeting.title,
          participants: (i = e.parentMeeting.participants) != null ? i : []
        },
        meetings: r
      };
    }
    static handleTransferPeerRaw({ payload: t }) {
      const e = lb.fromBinary(t);
      return { authToken: e.authToken, meetingId: e.meetingId };
    }
    static handleMovedPeerRaw({ payload: t }) {
      const e = jf.fromBinary(t);
      return {
        meetingId: e.meetingId,
        customParticipantId: e.customParticipantId
      };
    }
    static handleConnectedRoomsUpdatedRaw({ payload: t }) {
      return Gp.fromBinary(t).payloads.map((r) => ({
        id: r.id,
        title: r.title
      }));
    }
    static handleConnectedRoomsDeletedRaw({ payload: t }) {
      return eb.fromBinary(t).payloads;
    }
    static getConnectedRoomsDump() {
      return u(this, null, function* () {
        const t = yield ls.socketService.sendMessagePromise(
          F.getConnectedRoomsDump
        );
        return ls.handleConnectedRoomsDumpRaw(t);
      });
    }
    static createConnectedRooms(t) {
      return u(this, null, function* () {
        const { payload: e } = yield ls.socketService.sendMessagePromise(
          F.createConnectedRooms,
          BR.toBinary({ payloads: t })
        );
        return Gp.fromBinary(e).payloads.map((n) => ({
          id: n.id,
          title: n.title
        }));
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static updateConnectedRooms(t) {
      return u(this, null, function* () {
      });
    }
    static disableConnectedRooms(t) {
      return u(this, null, function* () {
        const e = t.map((n) => ({ id: n })), r = yield ls.socketService.sendMessagePromise(
          F.deleteConnectedRooms,
          XR.toBinary({ payloads: e })
        );
        return ls.handleConnectedRoomsDeletedRaw(
          r
        );
      });
    }
    static movePeersBetweenRooms(t) {
      return u(this, null, function* () {
        try {
          const e = yield ls.socketService.sendMessagePromise(
            F.movePeers,
            ab.toBinary({
              sourceMeetingId: t.sourceMeetingId,
              destinationMeetingId: t.destinationMeetingId,
              participants: t.participants
            })
          );
          return new TextDecoder().decode(e.payload).includes("error") ? { success: !1, error: "failed to move participants" } : { success: !0 };
        } catch (e) {
          return { success: false, error: e };
        }
      });
    }
  };
  let ke = ls;
  f(ke, "socketService"), f(ke, "currentMeetingId");
  var kO = Object.defineProperty, IO = Object.getOwnPropertyDescriptor, od = (s, t, e, r) => {
    for (var n = IO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && kO(t, e, n), n;
  };
  const Js = class {
    constructor(s, t) {
      f(this, "apiBase");
      f(this, "selfController");
      f(this, "pollController");
      f(this, "chatController");
      f(this, "metaController");
      f(this, "storesManager");
      f(this, "stageController");
      f(this, "pluginController");
      f(this, "internalsController");
      f(this, "recordingController");
      f(this, "livestreamController");
      f(this, "participantController");
      this.apiBase = s, this.storesManager = t.storesManager, this.metaController = t.metaController, this.selfController = t.selfController, this.chatController = t.chatController, this.pollController = t.pollController, this.stageController = t.stageController, this.pluginController = t.pluginController, this.recordingController = t.recordingController, this.internalsController = t.internalsController, this.participantController = t.participantController, this.livestreamController = t.livestreamController;
    }
    static init(s) {
      return u(this, null, function* () {
        var $;
        const {
          peerId: t,
          apiBase: e,
          authToken: r,
          meetingId: n,
          organizationId: i,
          cachedUserDetails: a
        } = s.getAllValues();
        if (R.reset(), mc.cleanup(), Og(s), ve.isSupported() === false)
          throw new w("Browser not supported", "0010", true);
        const c = EA(
          s,
          {
            authToken: r,
            baseURL: e,
            cachedUserDetails: a
          }
        );
        c.setRoomName(n), c.setRoomUUID(n), c.setOrganizationId(i), c.setHeader("dyte-tracing-id", t), s.setValue("apiClient", c);
        const d = new nD();
        s.setValue("connectionHandler", d);
        const p = Js.createSocketService(s), h = p.connect(), m = c.getPlugins(), [{
          sfu: g,
          userResponse: T,
          meetingTitle: y,
          roomNodeUrl: b
        }] = yield Promise.all(
          [Js.getRoomMetadata(), Js.setupFlagsmith(s)]
        );
        v.location.country = ($ = c.ipInfo) == null ? undefined : $.country, s.setValue("roomNodeOptions", { sfu: g, meetingTitle: y, roomNodeUrl: b });
        const { theme: A, controllers: I } = yield Js.setupControllers(
          p,
          s,
          T,
          m
        );
        WA(A) && Js.createRoomNodeClient(s, p), ww();
        try {
          yield h, I.selfController.partialMediaRoom();
        } catch (V) {
          throw l.error(
            "[Socket Service] Failed to connect to socket server:",
            { error: V }
          ), new w("Failed to connect to websocket", "0012");
        }
        return new Js(e, I);
      });
    }
    static getRoomMetadata() {
      return u(this, null, function* () {
        const s = qe(), [
          { roomNodeUrl: t, meetingTitle: e, sfu: r = xi.HIVE },
          n
        ] = yield Promise.all(
          [
            s.getRoomNodeData(),
            s.getUserDetails()
          ]
        );
        return {
          sfu: r,
          roomNodeUrl: t,
          meetingTitle: e,
          userResponse: n
        };
      });
    }
    static setupFlagsmith(s) {
      return u(this, null, function* () {
        const {
          peerId: t,
          baseURI: e,
          overrides: r,
          meetingId: n,
          organizationId: i
        } = s.getAllValues(), a = Cw(n), c = z(L({
          entity: al.PEER,
          clientId: i,
          isAnonUser: !i,
          sdkVersion: s.getValue("sdkVersion"),
          meetingHash: a,
          roomName: n
        }, ve.getDeviceInfo()), {
          isReactNative: navigator.isReactNative
        });
        try {
          const d = r != null && r.whitelabelled_flags_endpoint ? jn({ servicePrefix: "flags", baseURI: e }) : "edge.api.flagsmith.com";
          yield K.identify(
            `${al.PEER}_${t}`,
            JSON.parse(JSON.stringify(c)),
            !1,
            // force evaluate
            5e3,
            // timeout
            d
          ), l.info(
            "flagsmith::allFlags",
            { flags: JSON.stringify(K.getAllFlags()) },
            !0
          );
        } catch (d) {
          l.error("Failed to fetch flagsmith flags");
        }
      });
    }
    static setupControllers(s, t, e, r) {
      return u(this, null, function* () {
        var G, D, je;
        const n = t.getValue("modules"), { preset: i, participant: a } = e, c = t.getValue("defaults"), { sfu: d, meetingTitle: p } = t.getValue("roomNodeOptions"), h = El.init(i, !n.theme), { viewType: m, mediaConstraints: { audio: g } } = h;
        t.setValue("viewType", m), t.setValue("defaults", L({
          mediaConfiguration: {
            audio: {
              enableHighBitrate: (G = g.enableHighBitrate) != null ? G : false,
              enableStereo: (D = g.enableStereo) != null ? D : false
            }
          }
        }, c));
        const T = bl.init(
          t,
          m,
          i.permissions
        );
        t.setValue("maxPreferredStreams", ve.isMobile() ? h.maxVideoStreams.mobile : h.maxVideoStreams.desktop);
        let y, b, A, I, $, V, O, q;
        const B = new sO(s);
        ke.socketService = s;
        const ne = new nd(s), Y = new Qt(s), we = new aO(s), Pe = mc.create(s, t), Tt = new oO(s), M = new rO(s), C = new _n(s), k = yield Us.init(
          t,
          Pe,
          a,
          T,
          h
        ), H = yield ng.init(
          t,
          k.self,
          Pe,
          B,
          p
        );
        if (n.participant && (d === xi.CF && (q = new Ig(
          t,
          k.self,
          Pe
        )), q = new Ag(
          t,
          k.self,
          Pe
        )), (je = n.e2ee) != null && je.enabled && n.e2ee.manager.init(l, R), n.chat && (b = yield tr.init(
          t,
          Y,
          C,
          k.self,
          q.participants
        )), n.internals && ($ = yield iu.init()), n.livestream && h.viewType === gt.Livestream && K.hasFeature(ie.LIVESTREAM) && (O = new pg(
          k.self,
          M
        )), h.viewType !== gt.Chat) {
          if (n.poll && (y = yield Zf.init(
            t,
            k.self,
            ne
          )), n.recording && (V = new cg(
            t,
            k.self,
            Pe
          )), n.stage && (A = new ig(
            t,
            we,
            Pe,
            k.self,
            q.participants
          )), n.plugin) {
            if (!q)
              throw new w(
                "The plugin module cannot be initialized without the `participant` module"
              );
            const kr = yield r;
            I = yield yo.init(
              t,
              kr,
              Tt,
              Y,
              b == null ? undefined : b.chat,
              k.self,
              q.participants
            );
          }
          if (n.pip) {
            const kr = yield dl._init(t, k.self);
            t.setValue("pip", kr);
          }
        }
        const Fe = {
          storesManager: new zD(t, Tt),
          pollController: y,
          selfController: k,
          metaController: H,
          chatController: b,
          stageController: A,
          pluginController: I,
          recordingController: V,
          internalsController: $,
          livestreamController: O,
          participantController: q
        };
        return {
          theme: h,
          permissions: T,
          controllers: Fe
        };
      });
    }
    static createRoomNodeClient(s, t) {
      return u(this, null, function* () {
        const {
          peerId: e,
          meetingId: r,
          authToken: n,
          roomNodeOptions: i
        } = s.getAllValues(), {
          sfu: a,
          roomNodeUrl: c,
          meetingTitle: d
        } = i;
        return Mg(s, {
          socket: t,
          peerId: e,
          meetingId: r,
          authToken: n,
          roomNodeUrl: c,
          meetingTitle: d
        }, a);
      });
    }
    static createSocketService(s) {
      const {
        peerId: t,
        meetingId: e,
        authToken: r
      } = s.getAllValues(), n = ["PING"];
      return new Eo(s, {
        peerId: t,
        meetingId: e,
        authToken: r,
        capabilities: n
      });
    }
  };
  let Co = Js;
  od([
    v.trace("Controller.init")
  ], Co, "init");
  od([
    v.trace("setupFlagsmith")
  ], Co, "setupFlagsmith");
  od([
    v.trace("Controller.createSocketServiceAndRoomNodeClient")
  ], Co, "createRoomNodeClient");
  od([
    v.trace("Controller.createSocketService")
  ], Co, "createSocketService");
  var AO = Object.defineProperty, DO = Object.getOwnPropertyDescriptor, MO = (s, t, e, r) => {
    for (var n = DO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && AO(t, e, n), n;
  }, co, Lc;
  class Qg extends Ft {
    constructor(e, r) {
      super();
      E(this, co, undefined);
      f(this, "meetings", []);
      f(this, "parentMeeting", null);
      E(this, Lc, undefined);
      _(this, Lc, e), _(this, co, r.self);
    }
    get supportsConnectedMeetings() {
      return o(this, co).id !== "";
    }
    get isActive() {
      return this.meetings.length !== 0;
    }
    // eslint-disable-next-line class-methods-use-this
    get currentMeetingId() {
      return ke.currentMeetingId;
    }
    validateConnectedMeetingsAction() {
      if (!this.supportsConnectedMeetings)
        throw new Error(`You are not allowed to perform this action.
						Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
    }
    getConnectedMeetings() {
      return u(this, null, function* () {
        return this.validateConnectedMeetingsAction(), yield ke.getConnectedRoomsDump();
      });
    }
    /**
     * create connected meetings
     */
    createMeetings(e) {
      return u(this, null, function* () {
        return this.validateConnectedMeetingsAction(), (yield ke.createConnectedRooms(
          e
        )).map((n) => ({
          id: n.id,
          title: n.title
        }));
      });
    }
    /**
     * update meeting title
     */
    updateMeetings(e) {
      return u(this, null, function* () {
        this.validateConnectedMeetingsAction(), yield ke.updateConnectedRooms(
          e.map((r) => ({ meetingId: r.id, title: r.title }))
        );
      });
    }
    /**
     * delete connected meetings
     */
    deleteMeetings(e) {
      return u(this, null, function* () {
        this.validateConnectedMeetingsAction();
        const r = this.meetings.map((i) => e.includes(i.id) && i.participants.length !== 0 ? this.moveParticipants(
          i.id,
          this.parentMeeting.id,
          i.participants.map((a) => a.id)
        ) : Promise.resolve());
        return yield Promise.all(r), yield ke.disableConnectedRooms(
          e
        );
      });
    }
    /**
     * Trigger event to move participants
     *
     * @param {string} sourceMeetingId - id of source meeting
     * @param {string} destinationMeetingId - id of destination meeting
     * @param {string[]} participantIds - list of id of the participants
     */
    moveParticipants(e, r, n) {
      return u(this, null, function* () {
        this.validateConnectedMeetingsAction();
        const i = yield ke.movePeersBetweenRooms(
          {
            sourceMeetingId: e,
            destinationMeetingId: r,
            participants: n.map((a) => ({
              id: a
            }))
          }
        );
        return i.success && this.moveSuccessHandler(e, r, n), i;
      });
    }
    /**
     * Trigger event to move participants with custom preset
     */
    moveParticipantsWithCustomPreset(e, r, n) {
      return u(this, null, function* () {
        this.validateConnectedMeetingsAction();
        const i = yield ke.movePeersBetweenRooms(
          {
            sourceMeetingId: e,
            destinationMeetingId: r,
            participants: n
          }
        );
        return i.success && this.moveSuccessHandler(e, r, n.map((a) => a.id)), i;
      });
    }
    moveSuccessHandler(e, r, n) {
      const i = /* @__PURE__ */ new Map();
      [
        ...this.parentMeeting.participants,
        ...this.meetings.flatMap((a) => a.participants)
      ].forEach((a) => i.set(a.id, a)), r === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.concat(
        n.map((a) => i.get(a))
      )), e === this.parentMeeting.id && (this.parentMeeting.participants = this.parentMeeting.participants.filter(
        (a) => !n.includes(a.id)
      )), this.meetings = this.meetings.map((a) => {
        if (r === a.id) {
          const c = a.participants.concat(
            n.map((d) => i.get(d))
          );
          return z(L({}, a), {
            participants: c
          });
        }
        if (e === a.id) {
          const c = a.participants.filter(
            (d) => !n.includes(d.id)
          );
          return z(L({}, a), {
            participants: c
          });
        }
        return a;
      });
    }
  }
  co = new WeakMap(), Lc = new WeakMap();
  MO([
    At({ maxInvocations: 60, period: 60 })
  ], Qg.prototype, "getConnectedMeetings");
  var OO = Object.defineProperty, NO = Object.getOwnPropertyDescriptor, Tu = (s, t, e, r) => {
    for (var n = NO(t, e) , i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (a(t, e, n) ) || n);
    return n && OO(t, e, n), n;
  }, Ai, bs, zd, xc;
  const ds = (zd = class {
    constructor(s, t, e) {
      f(this, "connectedMeetings");
      E(this, Ai, undefined);
      E(this, bs, undefined);
      E(this, xc, undefined);
      _(this, xc, s), _(this, Ai, e), this.connectedMeetings = new Qg(s, t), this.setCurrentMeeting(t);
    }
    static init(s, t, e) {
      return ds.instance || (ds.instance = new ds(
        s,
        t,
        e
      )), ds.instance.connectedMeetings.supportsConnectedMeetings && (ds.instance.setupEvents(), t.self.once(
        "roomJoined",
        () => ds.instance.getConnectedMeetings()
      )), ds.instance;
    }
    setCurrentMeeting(s) {
      _(this, bs, s), ke.currentMeetingId = s.meta.meetingId;
    }
    getConnectedMeetings() {
      this.connectedMeetings.getConnectedMeetings();
    }
    setupEvents() {
      ke.socketService && (ke.socketService.on(
        F.getConnectedRoomsDump,
        this.handleConnectedRoomsDump.bind(this)
      ), ke.socketService.on(
        F.transferPeer,
        this.handleTransferPeer.bind(this)
      ), ke.socketService.on(
        F.movedPeer,
        this.handleMovedPeer.bind(this)
      ), ke.socketService.on(
        F.connectedRoomsUpdated,
        this.handleConnectedRoomsUpdated.bind(this)
      ), ke.socketService.on(
        F.connectedRoomsDeleted,
        this.handleConnectedRoomsDeleted.bind(this)
      ));
    }
    // event handlers
    handleTransferPeer(s) {
      const t = ke.handleTransferPeerRaw(s);
      return this.switchMeeting(t);
    }
    switchMeeting(e) {
      return u(this, arguments, function* ({
        authToken: s,
        meetingId: t
      }) {
        if (!this.connectedMeetings.supportsConnectedMeetings)
          throw new Error(`You are not allowed to perform this action.
								Please connect with Dyte team to move you to V2 APIs & to enable connected meetings.`);
        this.connectedMeetings.emit("changingMeeting", t);
        const r = {
          video: o(this, bs).self.videoEnabled,
          audio: o(this, bs).self.audioEnabled
        };
        yield o(this, bs).leave("connected-meeting"), ke.socketService = undefined;
        const n = yield FO.init(z(L({}, o(this, Ai)), {
          cachedUserDetails: null,
          defaults: L(L({}, o(this, Ai).defaults), r),
          authToken: s
        }));
        n.self.setName(o(this, bs).self.name);
        try {
          yield n.join();
        } catch (i) {
          v.addLogInCurrentSpan("error", "ConnectedMeetingsController.joinRoom", { error: i });
        }
        return this.connectedMeetings.emit("meetingChanged", n), this.setCurrentMeeting(n), n;
      });
    }
    handleConnectedRoomsDump(s) {
      const t = ke.handleConnectedRoomsDumpRaw(s);
      this.connectedMeetings.meetings = t.meetings.map((e) => ({
        id: e.id,
        title: e.title,
        participants: e.participants || []
      })), this.connectedMeetings.parentMeeting = {
        id: t.parentMeeting.id,
        title: t.parentMeeting.title,
        participants: t.parentMeeting.participants
      }, this.emitStateUpdate();
    }
    // eslint-disable-next-line class-methods-use-this
    handleMovedPeer(s) {
      return ke.handleMovedPeerRaw(s);
    }
    handleConnectedRoomsUpdated(s) {
      const t = ke.handleConnectedRoomsUpdatedRaw(s), e = /* @__PURE__ */ new Map();
      this.connectedMeetings.meetings.forEach((r) => {
        e.set(r.id, r);
      }), t.forEach((r) => {
        e.has(r.id) ? e.get(r.id).title = r.title : e.set(r.id, z(L({}, r), { participants: [] }));
      }), this.connectedMeetings.meetings = Array.from(e.values()), this.emitStateUpdate();
    }
    handleConnectedRoomsDeleted(s) {
      const e = ke.handleConnectedRoomsDeletedRaw(s).map((r) => r.id);
      this.connectedMeetings.meetings = this.connectedMeetings.meetings.filter(
        (r) => !e.includes(r.id)
      ), this.emitStateUpdate();
    }
    emitStateUpdate() {
      this.connectedMeetings.emit("stateUpdate", {
        meetings: this.connectedMeetings.meetings,
        parentMeeting: this.connectedMeetings.parentMeeting
      });
    }
  }, Ai = new WeakMap(), bs = new WeakMap(), xc = new WeakMap(), f(zd, "instance"), zd);
  let cd = ds;
  Tu([
    v.trace("ConnectedMeetingsController.getConnectedMeetings")
  ], cd.prototype, "getConnectedMeetings");
  Tu([
    v.trace("ConnectedMeetingsController.setupEvents")
  ], cd.prototype, "setupEvents");
  Tu([
    v.trace("ConnectedMeetingsController.switchMeeting")
  ], cd.prototype, "switchMeeting");
  class LO {
    constructor() {
      f(this, "battery");
      f(this, "init", () => u(this, null, function* () {
        try {
          "getBattery" in navigator && (this.battery = yield navigator.getBattery(), this.battery.addEventListener("chargingchange", this.updateChargeInfo), this.battery.addEventListener("levelchange", this.updateLevelInfo), this.updateLevelInfo(), this.updateChargeInfo());
        } catch (t) {
          l.error("Error getting battery", t);
        }
      }));
      f(this, "updateChargeInfo", () => {
        var t;
        l.log(
          `Battery charging? ${(t = this.battery) != null && t.charging ? "Yes" : "No"}`
        );
      });
      f(this, "updateLevelInfo", () => {
        if (!this.battery) {
          l.log("Battery level: Not known");
          return;
        }
        l.log(`Battery level: ${this.battery.level * 100}%`);
      });
      f(this, "cleanup", () => {
        var t, e;
        "getBattery" in navigator && ((t = this.battery) == null || t.removeEventListener(
          "chargingchange",
          this.updateChargeInfo
        ), (e = this.battery) == null || e.removeEventListener("levelchange", this.updateLevelInfo));
      });
    }
  }
  const yh = new LO();
  function xO(s, t) {
    try {
      const { meetingId: e, orgId: r, participantId: n } = JSON.parse(atob(s.split(".")[1]));
      if (!e)
        throw Error(`Received V1 auth token ${s}`);
      let i = "dyte.io";
      t && (i = t);
      const a = `https://api.${i}`;
      return {
        meetingId: e,
        orgId: r,
        participantId: n,
        baseURI: i,
        apiBase: a
      };
    } catch (e) {
      throw l.error(
        "constants::decodeAuthToken",
        {
          error: e,
          debuggingHint: `Unable to decode auth token: ${s}`
        },
        true
      ), new w("Invalid auth token");
    }
  }
  var $O = Object.defineProperty, UO = Object.getOwnPropertyDescriptor, dd = (s, t, e, r) => {
    for (var n = r > 1 ? undefined : r ? UO(t, e) : t, i = s.length - 1, a; i >= 0; i--)
      (a = s[i]) && (n = (r ? a(t, e, n) : a(n)) || n);
    return r && n && $O(t, e, n), n;
  }, et, lo, uo, $c, Xg, Fh;
  let Ns = (Fh = class {
    constructor(t, e) {
      /**
       * attach the singleton controller to meeting instances
       * +-----------------------------+
       * | ConnectedMeetingsController |
       * +------+--------------+-------+
       *				|							|
       *	 +----v---+			+---v----+
       *	 |meeting1|			|meeting2|
       *	 +--------+			+--------+
       * */
      E(this, $c);
      E(this, et, undefined);
      E(this, lo, undefined);
      E(this, uo, undefined);
      _(this, uo, t), _(this, et, e);
    }
    static init(t) {
      return u(this, null, function* () {
        var m, g, T, y, b;
        _w(), ve.init();
        const e = v4();
        yh.init();
        const { authToken: r, baseURI: n } = t, h = xO(r, n), { meetingId: i } = h, a = na(h, ["meetingId"]);
        window.__zone_symbol__DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION = true;
        const c = Ns.setupContext(
          e,
          t,
          i,
          a
        );
        v.meetingMetadata.roomName = i, v.meetingMetadata.userId = a.participantId, v.meetingMetadata.organizationId = a.orgId, v.init(c, (g = (m = t.modules) == null ? undefined : m.tracing) != null ? g : true), l.info("DyteClient::init::options", {
          dyteClientInitOptions: z(L({}, t), {
            authToken: `${(T = t.authToken) == null ? undefined : T.slice(0, 10)}...
				${(y = t.authToken) == null ? undefined : y.slice(-10)}`
          })
        });
        const d = yield Co.init(c), p = new Ns(c, d);
        return Le(b = p, $c, Xg).call(b, t), p;
      });
    }
    static setupContext(t, e, r, n) {
      var c;
      const i = va.createContext(t, e), a = L(L({}, mw), e == null ? undefined : e.modules);
      return i.setValue("peerId", t), i.setValue("modules", a), i.setValue("sdkName", "web-core"), i.setValue("meetingId", r), i.setValue("apiBase", n.apiBase), i.setValue("baseURI", n.baseURI), i.setValue("userId", n.participantId), i.setValue("organizationId", n.orgId), i.setValue("authToken", e.authToken), i.setValue("overrides", (c = e.overrides) != null ? c : {}), i.setValue("env", fw({ baseURI: n.baseURI })), i.setValue("defaults", e.defaults || { audio: true, video: true }), i.setValue("cachedUserDetails", sr(e.cachedUserDetails)), i.setValue("sdkVersion", "2.2.0"), i;
    }
    join() {
      return u(this, null, function* () {
        const { selfController: t } = o(this, et);
        return t.self.roomJoined ? null : t.joinRoom();
      });
    }
    leave(t) {
      return u(this, null, function* () {
        yh.cleanup();
        const { selfController: e } = o(this, et);
        return e.leaveRoom(t);
      });
    }
    /**
     * The `participants` object consists of 4 maps of participants,
     * `waitlisted`, `joined`, `active`, `pinned`. The maps are indexed by
     * `peerId`s, and the values are the corresponding participant objects.
     */
    get participants() {
      var t;
      return (t = o(this, et).participantController) == null ? undefined : t.participants;
    }
    /**
     * The `self` object can be used to manipulate audio and video settings,
     * and other configurations for the local participant. This exposes methods
     * to enable and disable media tracks, share the user's screen, etc.
     */
    get self() {
      var t;
      return (t = o(this, et).selfController) == null ? undefined : t.self;
    }
    /**
     * The `room` object stores information about the current meeting, such
     * as chat messages, polls, room name, etc.
     */
    get meta() {
      var t;
      return (t = o(this, et).metaController) == null ? undefined : t.meta;
    }
    /**
     * The `ai` object is used to interface with Dyte's AI features.
     * You can obtain the live meeting transcript and use other meeting AI
     * features such as summary, and agenda using this object.
     */
    get ai() {
      var t;
      return (t = o(this, et).metaController) == null ? undefined : t.ai;
    }
    /**
     * The `plugins` object stores information about the plugins available in
     * the current meeting. It exposes methods to activate and deactivate them.
     */
    get plugins() {
      var t;
      return (t = o(this, et).pluginController) == null ? undefined : t.plugins;
    }
    /**
     * The chat object stores the chat messages that were sent in the meeting.
     * This includes text messages, images, and files.
     */
    get chat() {
      var t;
      return (t = o(this, et).chatController) == null ? undefined : t.chat;
    }
    /**
     * The polls object stores the polls that were initiated in the meeting.
     * It exposes methods to create and vote on polls.
     */
    get polls() {
      var t;
      return (t = o(this, et).pollController) == null ? undefined : t.polls;
    }
    /**
     * The connectedMeetings object stores the connected meetings states.
     * It exposes methods to create/read/update/delete methods for connected meetings.
     */
    get connectedMeetings() {
      var t;
      return (t = o(this, lo)) == null ? undefined : t.connectedMeetings;
    }
    /*
     * The recording object stores the recording state of the meeting.
     * It exposes methods to start and stop recording.
     */
    get recording() {
      var t;
      return (t = o(this, et).recordingController) == null ? undefined : t.recording;
    }
    get livestream() {
      var t;
      return (t = o(this, et).livestreamController) == null ? undefined : t.livestream;
    }
    get stage() {
      var t;
      return (t = o(this, et).stageController) == null ? undefined : t.stage;
    }
    get stores() {
      return o(this, et).storesManager;
    }
    /**
     * The __internals__ object exposes the internal tools & utilities such as features and logger
     * so that client can utilise the same to build their own feature based UI.
     * DyteLogger (__internals__.logger) can be used to send logs to Dyte's servers
     *	to inform Dyte of issues, if any, proactively.
     */
    get __internals__() {
      var t;
      return (t = o(this, et).internalsController) == null ? undefined : t.internals;
    }
    /** @deprecated Use `join()` instead */
    joinRoom() {
      return u(this, null, function* () {
        return this.join();
      });
    }
    /** @deprecated Use `leave()` instead */
    leaveRoom(t) {
      return u(this, null, function* () {
        return this.leave(t);
      });
    }
  }, et = new WeakMap(), lo = new WeakMap(), uo = new WeakMap(), $c = new WeakSet(), Xg = function(t) {
    _(this, lo, cd.init(
      o(this, uo),
      this,
      t
    ));
  }, Fh);
  dd([
    vt("0002"),
    $s.executeWithLock({
      methodName: "meeting.join",
      lockName: "DyteClient.join",
      timeout: 3e3
    })
  ], Ns.prototype, "join", 1);
  dd([
    vt("0003")
  ], Ns.prototype, "leave", 1);
  dd([
    vt("0001"),
    $s.executeWithLock({
      methodName: "DyteClient.init",
      lockName: "DyteClient.init",
      timeout: 3e3
    })
  ], Ns, "init", 1);
  Ns = dd([
    vt("0000")
  ], Ns);
  const FO = Ns;

  const NAMESPACE = 'dyte-ui-kit';

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/snabbdom/snabbdom/blob/master/LICENSE
   *
   * Modified for Stencil's renderer and slot projection
   */
  let scopeId;
  let contentRef;
  let hostTagName;
  let useNativeShadowDom = false;
  let checkSlotFallbackVisibility = false;
  let checkSlotRelocate = false;
  let isSvgMode = false;
  let renderingRef = null;
  let queuePending = false;
  const createTime = (fnName, tagName = '') => {
      {
          return () => {
              return;
          };
      }
  };
  const uniqueTime = (key, measureText) => {
      {
          return () => {
              return;
          };
      }
  };
  const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
  const XLINK_NS = 'http://www.w3.org/1999/xlink';
  /**
   * Default style mode id
   */
  /**
   * Reusable empty obj/array
   * Don't add values to these!!
   */
  const EMPTY_OBJ = {};
  const isDef = (v) => v != null;
  const isComplexType = (o) => {
      // https://jsperf.com/typeof-fn-object/5
      o = typeof o;
      return o === 'object' || o === 'function';
  };
  /**
   * Production h() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */
  // const stack: any[] = [];
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
  const h = (nodeName, vnodeData, ...children) => {
      let child = null;
      let key = null;
      let slotName = null;
      let simple = false;
      let lastSimple = false;
      const vNodeChildren = [];
      const walk = (c) => {
          for (let i = 0; i < c.length; i++) {
              child = c[i];
              if (Array.isArray(child)) {
                  walk(child);
              }
              else if (child != null && typeof child !== 'boolean') {
                  if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                      child = String(child);
                  }
                  if (simple && lastSimple) {
                      // If the previous child was simple (string), we merge both
                      vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                  }
                  else {
                      // Append a new vNode, if it's text, we create a text vNode
                      vNodeChildren.push(simple ? newVNode(null, child) : child);
                  }
                  lastSimple = simple;
              }
          }
      };
      walk(children);
      if (vnodeData) {
          // normalize class / classname attributes
          if (vnodeData.key) {
              key = vnodeData.key;
          }
          if (vnodeData.name) {
              slotName = vnodeData.name;
          }
          {
              const classData = vnodeData.className || vnodeData.class;
              if (classData) {
                  vnodeData.class =
                      typeof classData !== 'object'
                          ? classData
                          : Object.keys(classData)
                              .filter((k) => classData[k])
                              .join(' ');
              }
          }
      }
      if (typeof nodeName === 'function') {
          // nodeName is a functional component
          return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
      }
      const vnode = newVNode(nodeName, null);
      vnode.$attrs$ = vnodeData;
      if (vNodeChildren.length > 0) {
          vnode.$children$ = vNodeChildren;
      }
      {
          vnode.$key$ = key;
      }
      {
          vnode.$name$ = slotName;
      }
      return vnode;
  };
  const newVNode = (tag, text) => {
      const vnode = {
          $flags$: 0,
          $tag$: tag,
          $text$: text,
          $elm$: null,
          $children$: null,
      };
      {
          vnode.$attrs$ = null;
      }
      {
          vnode.$key$ = null;
      }
      {
          vnode.$name$ = null;
      }
      return vnode;
  };
  const Host = {};
  const isHost = (node) => node && node.$tag$ === Host;
  const vdomFnUtils = {
      forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
      map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),
  };
  const convertToPublic = (node) => ({
      vattrs: node.$attrs$,
      vchildren: node.$children$,
      vkey: node.$key$,
      vname: node.$name$,
      vtag: node.$tag$,
      vtext: node.$text$,
  });
  const convertToPrivate = (node) => {
      if (typeof node.vtag === 'function') {
          const vnodeData = Object.assign({}, node.vattrs);
          if (node.vkey) {
              vnodeData.key = node.vkey;
          }
          if (node.vname) {
              vnodeData.name = node.vname;
          }
          return h(node.vtag, vnodeData, ...(node.vchildren || []));
      }
      const vnode = newVNode(node.vtag, node.vtext);
      vnode.$attrs$ = node.vattrs;
      vnode.$children$ = node.vchildren;
      vnode.$key$ = node.vkey;
      vnode.$name$ = node.vname;
      return vnode;
  };
  /**
   * Parse a new property value for a given property type.
   *
   * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
   * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
   *   1. `any`, the type given to `propValue` in the function signature
   *   2. the type stored from `propType`.
   *
   * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
   *
   * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
   * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
   * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
   * ```tsx
   * <my-cmp prop-val={0}></my-cmp>
   * ```
   *
   * HTML prop values on the other hand, will always a string
   *
   * @param propValue the new value to coerce to some type
   * @param propType the type of the prop, expressed as a binary number
   * @returns the parsed/coerced value
   */
  const parsePropertyValue = (propValue, propType) => {
      // ensure this value is of the correct prop type
      if (propValue != null && !isComplexType(propValue)) {
          if (propType & 4 /* MEMBER_FLAGS.Boolean */) {
              // per the HTML spec, any string value means it is a boolean true value
              // but we'll cheat here and say that the string "false" is the boolean false
              return propValue === 'false' ? false : propValue === '' || !!propValue;
          }
          if (propType & 2 /* MEMBER_FLAGS.Number */) {
              // force it to be a number
              return parseFloat(propValue);
          }
          if (propType & 1 /* MEMBER_FLAGS.String */) {
              // could have been passed as a number or boolean
              // but we still want it as a string
              return String(propValue);
          }
          // redundant return here for better minification
          return propValue;
      }
      // not sure exactly what type we want
      // so no need to change to a different type
      return propValue;
  };
  const getElement = (ref) => (getHostRef(ref).$hostElement$ );
  const createEvent = (ref, name, flags) => {
      const elm = getElement(ref);
      return {
          emit: (detail) => {
              return emitEvent(elm, name, {
                  bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),
                  composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),
                  cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),
                  detail,
              });
          },
      };
  };
  /**
   * Helper function to create & dispatch a custom Event on a provided target
   * @param elm the target of the Event
   * @param name the name to give the custom Event
   * @param opts options for configuring a custom Event
   * @returns the custom Event
   */
  const emitEvent = (elm, name, opts) => {
      const ev = plt.ce(name, opts);
      elm.dispatchEvent(ev);
      return ev;
  };
  const rootAppliedStyles = /*@__PURE__*/ new WeakMap();
  const registerStyle = (scopeId, cssText, allowCS) => {
      let style = styles.get(scopeId);
      if (supportsConstructableStylesheets && allowCS) {
          style = (style || new CSSStyleSheet());
          if (typeof style === 'string') {
              style = cssText;
          }
          else {
              style.replaceSync(cssText);
          }
      }
      else {
          style = cssText;
      }
      styles.set(scopeId, style);
  };
  const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
      let scopeId = getScopeId(cmpMeta);
      const style = styles.get(scopeId);
      // if an element is NOT connected then getRootNode() will return the wrong root node
      // so the fallback is to always use the document for the root node in those cases
      styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;
      if (style) {
          if (typeof style === 'string') {
              styleContainerNode = styleContainerNode.head || styleContainerNode;
              let appliedStyles = rootAppliedStyles.get(styleContainerNode);
              let styleElm;
              if (!appliedStyles) {
                  rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
              }
              if (!appliedStyles.has(scopeId)) {
                  {
                      {
                          styleElm = doc.createElement('style');
                          styleElm.innerHTML = style;
                      }
                      styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                  }
                  if (appliedStyles) {
                      appliedStyles.add(scopeId);
                  }
              }
          }
          else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
              styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
          }
      }
      return scopeId;
  };
  const attachStyles = (hostRef) => {
      const cmpMeta = hostRef.$cmpMeta$;
      const elm = hostRef.$hostElement$;
      const flags = cmpMeta.$flags$;
      const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
      const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
      if (flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {
          // only required when we're NOT using native shadow dom (slot)
          // or this browser doesn't support native shadow dom
          // and this host element was NOT created with SSR
          // let's pick out the inner content for slot projection
          // create a node to represent where the original
          // content was first placed, which is useful later on
          // DOM WRITE!!
          elm['s-sc'] = scopeId;
          elm.classList.add(scopeId + '-h');
      }
      endAttachStyles();
  };
  const getScopeId = (cmp, mode) => 'sc-' + (cmp.$tagName$);
  /**
   * Production setAccessor() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */
  const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
      if (oldValue !== newValue) {
          let isProp = isMemberInElement(elm, memberName);
          let ln = memberName.toLowerCase();
          if (memberName === 'class') {
              const classList = elm.classList;
              const oldClasses = parseClassList(oldValue);
              const newClasses = parseClassList(newValue);
              classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
              classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
          }
          else if (memberName === 'style') {
              // update style attribute, css properties and values
              {
                  for (const prop in oldValue) {
                      if (!newValue || newValue[prop] == null) {
                          if (prop.includes('-')) {
                              elm.style.removeProperty(prop);
                          }
                          else {
                              elm.style[prop] = '';
                          }
                      }
                  }
              }
              for (const prop in newValue) {
                  if (!oldValue || newValue[prop] !== oldValue[prop]) {
                      if (prop.includes('-')) {
                          elm.style.setProperty(prop, newValue[prop]);
                      }
                      else {
                          elm.style[prop] = newValue[prop];
                      }
                  }
              }
          }
          else if (memberName === 'key')
              ;
          else if (memberName === 'ref') {
              // minifier will clean this up
              if (newValue) {
                  newValue(elm);
              }
          }
          else if ((!isProp ) &&
              memberName[0] === 'o' &&
              memberName[1] === 'n') {
              // Event Handlers
              // so if the member name starts with "on" and the 3rd characters is
              // a capital letter, and it's not already a member on the element,
              // then we're assuming it's an event listener
              if (memberName[2] === '-') {
                  // on- prefixed events
                  // allows to be explicit about the dom event to listen without any magic
                  // under the hood:
                  // <my-cmp on-click> // listens for "click"
                  // <my-cmp on-Click> // listens for "Click"
                  // <my-cmp on-ionChange> // listens for "ionChange"
                  // <my-cmp on-EVENTS> // listens for "EVENTS"
                  memberName = memberName.slice(3);
              }
              else if (isMemberInElement(win, ln)) {
                  // standard event
                  // the JSX attribute could have been "onMouseOver" and the
                  // member name "onmouseover" is on the window's prototype
                  // so let's add the listener "mouseover", which is all lowercased
                  memberName = ln.slice(2);
              }
              else {
                  // custom event
                  // the JSX attribute could have been "onMyCustomEvent"
                  // so let's trim off the "on" prefix and lowercase the first character
                  // and add the listener "myCustomEvent"
                  // except for the first character, we keep the event name case
                  memberName = ln[2] + memberName.slice(3);
              }
              if (oldValue) {
                  plt.rel(elm, memberName, oldValue, false);
              }
              if (newValue) {
                  plt.ael(elm, memberName, newValue, false);
              }
          }
          else {
              // Set property if it exists and it's not a SVG
              const isComplex = isComplexType(newValue);
              if ((isProp || (isComplex && newValue !== null)) && true) {
                  try {
                      if (!elm.tagName.includes('-')) {
                          const n = newValue == null ? '' : newValue;
                          // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                          if (memberName === 'list') {
                              isProp = false;
                          }
                          else if (oldValue == null || elm[memberName] != n) {
                              elm[memberName] = n;
                          }
                      }
                      else {
                          elm[memberName] = newValue;
                      }
                  }
                  catch (e) { }
              }
              /**
               * Need to manually update attribute if:
               * - memberName is not an attribute
               * - if we are rendering the host element in order to reflect attribute
               * - if it's a SVG, since properties might not work in <svg>
               * - if the newValue is null/undefined or 'false'.
               */
              let xlink = false;
              {
                  if (ln !== (ln = ln.replace(/^xlink\:?/, ''))) {
                      memberName = ln;
                      xlink = true;
                  }
              }
              if (newValue == null || newValue === false) {
                  if (newValue !== false || elm.getAttribute(memberName) === '') {
                      if (xlink) {
                          elm.removeAttributeNS(XLINK_NS, memberName);
                      }
                      else {
                          elm.removeAttribute(memberName);
                      }
                  }
              }
              else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {
                  newValue = newValue === true ? '' : newValue;
                  if (xlink) {
                      elm.setAttributeNS(XLINK_NS, memberName, newValue);
                  }
                  else {
                      elm.setAttribute(memberName, newValue);
                  }
              }
          }
      }
  };
  const parseClassListRegex = /\s/;
  const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
  const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
      // if the element passed in is a shadow root, which is a document fragment
      // then we want to be adding attrs/props to the shadow root's "host" element
      // if it's not a shadow root, then we add attrs/props to the same element
      const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host
          ? newVnode.$elm$.host
          : newVnode.$elm$;
      const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
      const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
      {
          // remove attributes no longer present on the vnode by setting them to undefined
          for (memberName in oldVnodeAttrs) {
              if (!(memberName in newVnodeAttrs)) {
                  setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
              }
          }
      }
      // add new & update changed attributes
      for (memberName in newVnodeAttrs) {
          setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
      }
  };
  /**
   * Create a DOM Node corresponding to one of the children of a given VNode.
   *
   * @param oldParentVNode the parent VNode from the previous render
   * @param newParentVNode the parent VNode from the current render
   * @param childIndex the index of the VNode, in the _new_ parent node's
   * children, for which we will create a new DOM node
   * @param parentElm the parent DOM node which our new node will be a child of
   * @returns the newly created node
   */
  const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
      // tslint:disable-next-line: prefer-const
      const newVNode = newParentVNode.$children$[childIndex];
      let i = 0;
      let elm;
      let childNode;
      let oldVNode;
      if (!useNativeShadowDom) {
          // remember for later we need to check to relocate nodes
          checkSlotRelocate = true;
          if (newVNode.$tag$ === 'slot') {
              if (scopeId) {
                  // scoped css needs to add its scoped id to the parent element
                  parentElm.classList.add(scopeId + '-s');
              }
              newVNode.$flags$ |= newVNode.$children$
                  ? // slot element has fallback content
                      2 /* VNODE_FLAGS.isSlotFallback */
                  : // slot element does not have fallback content
                      1 /* VNODE_FLAGS.isSlotReference */;
          }
      }
      if (newVNode.$text$ !== null) {
          // create text node
          elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
      }
      else if (newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {
          // create a slot reference node
          elm = newVNode.$elm$ =
              doc.createTextNode('');
      }
      else {
          // create element
          elm = newVNode.$elm$ = (doc.createElement(newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */
                  ? 'slot-fb'
                  : newVNode.$tag$));
          // add css classes, attrs, props, listeners, etc.
          {
              updateElement(null, newVNode, isSvgMode);
          }
          if (isDef(scopeId) && elm['s-si'] !== scopeId) {
              // if there is a scopeId and this is the initial render
              // then let's add the scopeId as a css class
              elm.classList.add((elm['s-si'] = scopeId));
          }
          if (newVNode.$children$) {
              for (i = 0; i < newVNode.$children$.length; ++i) {
                  // create the node
                  childNode = createElm(oldParentVNode, newVNode, i, elm);
                  // return node could have been null
                  if (childNode) {
                      // append our new node
                      elm.appendChild(childNode);
                  }
              }
          }
      }
      {
          elm['s-hn'] = hostTagName;
          if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {
              // remember the content reference comment
              elm['s-sr'] = true;
              // remember the content reference comment
              elm['s-cr'] = contentRef;
              // remember the slot name, or empty string for default slot
              elm['s-sn'] = newVNode.$name$ || '';
              // check if we've got an old vnode for this slot
              oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
              if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
                  // we've got an old slot vnode and the wrapper is being replaced
                  // so let's move the old slot content back to it's original location
                  putBackInOriginalLocation(oldParentVNode.$elm$, false);
              }
          }
      }
      return elm;
  };
  const putBackInOriginalLocation = (parentElm, recursive) => {
      plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
      const oldSlotChildNodes = parentElm.childNodes;
      for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {
          const childNode = oldSlotChildNodes[i];
          if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
              // // this child node in the old element is from another component
              // // remove this node from the old slot's parent
              // childNode.remove();
              // and relocate it back to it's original location
              parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
              // remove the old original location comment entirely
              // later on the patch function will know what to do
              // and move this to the correct spot in need be
              childNode['s-ol'].remove();
              childNode['s-ol'] = undefined;
              checkSlotRelocate = true;
          }
          if (recursive) {
              putBackInOriginalLocation(childNode, recursive);
          }
      }
      plt.$flags$ &= -2 /* PLATFORM_FLAGS.isTmpDisconnected */;
  };
  const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
      let containerElm = ((parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);
      let childNode;
      if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
          containerElm = containerElm.shadowRoot;
      }
      for (; startIdx <= endIdx; ++startIdx) {
          if (vnodes[startIdx]) {
              childNode = createElm(null, parentVNode, startIdx, parentElm);
              if (childNode) {
                  vnodes[startIdx].$elm$ = childNode;
                  containerElm.insertBefore(childNode, referenceNode(before) );
              }
          }
      }
  };
  const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
      for (; startIdx <= endIdx; ++startIdx) {
          if ((vnode = vnodes[startIdx])) {
              elm = vnode.$elm$;
              callNodeRefs(vnode);
              {
                  // we're removing this element
                  // so it's possible we need to show slot fallback content now
                  checkSlotFallbackVisibility = true;
                  if (elm['s-ol']) {
                      // remove the original location comment
                      elm['s-ol'].remove();
                  }
                  else {
                      // it's possible that child nodes of the node
                      // that's being removed are slot nodes
                      putBackInOriginalLocation(elm, true);
                  }
              }
              // remove the vnode's element from the dom
              elm.remove();
          }
      }
  };
  /**
   * Reconcile the children of a new VNode with the children of an old VNode by
   * traversing the two collections of children, identifying nodes that are
   * conserved or changed, calling out to `patch` to make any necessary
   * updates to the DOM, and rearranging DOM nodes as needed.
   *
   * The algorithm for reconciling children works by analyzing two 'windows' onto
   * the two arrays of children (`oldCh` and `newCh`). We keep track of the
   * 'windows' by storing start and end indices and references to the
   * corresponding array entries. Initially the two 'windows' are basically equal
   * to the entire array, but we progressively narrow the windows until there are
   * no children left to update by doing the following:
   *
   * 1. Skip any `null` entries at the beginning or end of the two arrays, so
   *    that if we have an initial array like the following we'll end up dealing
   *    only with a window bounded by the highlighted elements:
   *
   *    [null, null, VNode1 , ... , VNode2, null, null]
   *                 ^^^^^^         ^^^^^^
   *
   * 2. Check to see if the elements at the head and tail positions are equal
   *    across the windows. This will basically detect elements which haven't
   *    been added, removed, or changed position, i.e. if you had the following
   *    VNode elements (represented as HTML):
   *
   *    oldVNode: `<div><p><span>HEY</span></p></div>`
   *    newVNode: `<div><p><span>THERE</span></p></div>`
   *
   *    Then when comparing the children of the `<div>` tag we check the equality
   *    of the VNodes corresponding to the `<p>` tags and, since they are the
   *    same tag in the same position, we'd be able to avoid completely
   *    re-rendering the subtree under them with a new DOM element and would just
   *    call out to `patch` to handle reconciling their children and so on.
   *
   * 3. Check, for both windows, to see if the element at the beginning of the
   *    window corresponds to the element at the end of the other window. This is
   *    a heuristic which will let us identify _some_ situations in which
   *    elements have changed position, for instance it _should_ detect that the
   *    children nodes themselves have not changed but merely moved in the
   *    following example:
   *
   *    oldVNode: `<div><element-one /><element-two /></div>`
   *    newVNode: `<div><element-two /><element-one /></div>`
   *
   *    If we find cases like this then we also need to move the concrete DOM
   *    elements corresponding to the moved children to write the re-order to the
   *    DOM.
   *
   * 4. Finally, if VNodes have the `key` attribute set on them we check for any
   *    nodes in the old children which have the same key as the first element in
   *    our window on the new children. If we find such a node we handle calling
   *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with
   *    what we find.
   *
   * Finally, once we've narrowed our 'windows' to the point that either of them
   * collapse (i.e. they have length 0) we then handle any remaining VNode
   * insertion or deletion that needs to happen to get a DOM state that correctly
   * reflects the new child VNodes. If, for instance, after our window on the old
   * children has collapsed we still have more nodes on the new children that
   * we haven't dealt with yet then we need to add them, or if the new children
   * collapse but we still have unhandled _old_ children then we need to make
   * sure the corresponding DOM nodes are removed.
   *
   * @param parentElm the node into which the parent VNode is rendered
   * @param oldCh the old children of the parent node
   * @param newVNode the new VNode which will replace the parent
   * @param newCh the new children of the parent node
   */
  const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
      let oldStartIdx = 0;
      let newStartIdx = 0;
      let idxInOld = 0;
      let i = 0;
      let oldEndIdx = oldCh.length - 1;
      let oldStartVnode = oldCh[0];
      let oldEndVnode = oldCh[oldEndIdx];
      let newEndIdx = newCh.length - 1;
      let newStartVnode = newCh[0];
      let newEndVnode = newCh[newEndIdx];
      let node;
      let elmToMove;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
          if (oldStartVnode == null) {
              // VNode might have been moved left
              oldStartVnode = oldCh[++oldStartIdx];
          }
          else if (oldEndVnode == null) {
              oldEndVnode = oldCh[--oldEndIdx];
          }
          else if (newStartVnode == null) {
              newStartVnode = newCh[++newStartIdx];
          }
          else if (newEndVnode == null) {
              newEndVnode = newCh[--newEndIdx];
          }
          else if (isSameVnode(oldStartVnode, newStartVnode)) {
              // if the start nodes are the same then we should patch the new VNode
              // onto the old one, and increment our `newStartIdx` and `oldStartIdx`
              // indices to reflect that. We don't need to move any DOM Nodes around
              // since things are matched up in order.
              patch(oldStartVnode, newStartVnode);
              oldStartVnode = oldCh[++oldStartIdx];
              newStartVnode = newCh[++newStartIdx];
          }
          else if (isSameVnode(oldEndVnode, newEndVnode)) {
              // likewise, if the end nodes are the same we patch new onto old and
              // decrement our end indices, and also likewise in this case we don't
              // need to move any DOM Nodes.
              patch(oldEndVnode, newEndVnode);
              oldEndVnode = oldCh[--oldEndIdx];
              newEndVnode = newCh[--newEndIdx];
          }
          else if (isSameVnode(oldStartVnode, newEndVnode)) {
              // case: "Vnode moved right"
              //
              // We've found that the last node in our window on the new children is
              // the same VNode as the _first_ node in our window on the old children
              // we're dealing with now. Visually, this is the layout of these two
              // nodes:
              //
              // newCh: [..., newStartVnode , ... , newEndVnode , ...]
              //                                    ^^^^^^^^^^^
              // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
              //              ^^^^^^^^^^^^^
              //
              // In this situation we need to patch `newEndVnode` onto `oldStartVnode`
              // and move the DOM element for `oldStartVnode`.
              if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                  putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
              }
              patch(oldStartVnode, newEndVnode);
              // We need to move the element for `oldStartVnode` into a position which
              // will be appropriate for `newEndVnode`. For this we can use
              // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a
              // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for
              // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:
              //
              // <old-start-node />
              // <some-intervening-node />
              // <old-end-node />
              // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here
              // <next-sibling />
              //
              // If instead `oldEndVnode.$elm$` has no sibling then we just want to put
              // the node for `oldStartVnode` at the end of the children of
              // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there
              // aren't any siblings, and passing `null` to `Node.insertBefore` will
              // append it to the children of the parent element.
              parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
              oldStartVnode = oldCh[++oldStartIdx];
              newEndVnode = newCh[--newEndIdx];
          }
          else if (isSameVnode(oldEndVnode, newStartVnode)) {
              // case: "Vnode moved left"
              //
              // We've found that the first node in our window on the new children is
              // the same VNode as the _last_ node in our window on the old children.
              // Visually, this is the layout of these two nodes:
              //
              // newCh: [..., newStartVnode , ... , newEndVnode , ...]
              //              ^^^^^^^^^^^^^
              // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]
              //                                    ^^^^^^^^^^^
              //
              // In this situation we need to patch `newStartVnode` onto `oldEndVnode`
              // (which will handle updating any changed attributes, reconciling their
              // children etc) but we also need to move the DOM node to which
              // `oldEndVnode` corresponds.
              if ((oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {
                  putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
              }
              patch(oldEndVnode, newStartVnode);
              // We've already checked above if `oldStartVnode` and `newStartVnode` are
              // the same node, so since we're here we know that they are not. Thus we
              // can move the element for `oldEndVnode` _before_ the element for
              // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the
              // future.
              parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
              oldEndVnode = oldCh[--oldEndIdx];
              newStartVnode = newCh[++newStartIdx];
          }
          else {
              // Here we do some checks to match up old and new nodes based on the
              // `$key$` attribute, which is set by putting a `key="my-key"` attribute
              // in the JSX for a DOM element in the implementation of a Stencil
              // component.
              //
              // First we check to see if there are any nodes in the array of old
              // children which have the same key as the first node in the new
              // children.
              idxInOld = -1;
              {
                  for (i = oldStartIdx; i <= oldEndIdx; ++i) {
                      if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                          idxInOld = i;
                          break;
                      }
                  }
              }
              if (idxInOld >= 0) {
                  // We found a node in the old children which matches up with the first
                  // node in the new children! So let's deal with that
                  elmToMove = oldCh[idxInOld];
                  if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                      // the tag doesn't match so we'll need a new DOM element
                      node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
                  }
                  else {
                      patch(elmToMove, newStartVnode);
                      // invalidate the matching old node so that we won't try to update it
                      // again later on
                      oldCh[idxInOld] = undefined;
                      node = elmToMove.$elm$;
                  }
                  newStartVnode = newCh[++newStartIdx];
              }
              else {
                  // We either didn't find an element in the old children that matches
                  // the key of the first new child OR the build is not using `key`
                  // attributes at all. In either case we need to create a new element
                  // for the new node.
                  node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
                  newStartVnode = newCh[++newStartIdx];
              }
              if (node) {
                  // if we created a new node then handle inserting it to the DOM
                  {
                      parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                  }
              }
          }
      }
      if (oldStartIdx > oldEndIdx) {
          // we have some more new nodes to add which don't match up with old nodes
          addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
      }
      else if (newStartIdx > newEndIdx) {
          // there are nodes in the `oldCh` array which no longer correspond to nodes
          // in the new array, so lets remove them (which entails cleaning up the
          // relevant DOM nodes)
          removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
  };
  /**
   * Compare two VNodes to determine if they are the same
   *
   * **NB**: This function is an equality _heuristic_ based on the available
   * information set on the two VNodes and can be misleading under certain
   * circumstances. In particular, if the two nodes do not have `key` attrs
   * (available under `$key$` on VNodes) then the function falls back on merely
   * checking that they have the same tag.
   *
   * So, in other words, if `key` attrs are not set on VNodes which may be
   * changing order within a `children` array or something along those lines then
   * we could obtain a false positive and then have to do needless re-rendering.
   *
   * @param leftVNode the first VNode to check
   * @param rightVNode the second VNode to check
   * @returns whether they're equal or not
   */
  const isSameVnode = (leftVNode, rightVNode) => {
      // compare if two vnode to see if they're "technically" the same
      // need to have the same element tag, and same key to be the same
      if (leftVNode.$tag$ === rightVNode.$tag$) {
          if (leftVNode.$tag$ === 'slot') {
              return leftVNode.$name$ === rightVNode.$name$;
          }
          // this will be set if components in the build have `key` attrs set on them
          {
              return leftVNode.$key$ === rightVNode.$key$;
          }
      }
      return false;
  };
  const referenceNode = (node) => {
      // this node was relocated to a new location in the dom
      // because of some other component's slot
      // but we still have an html comment in place of where
      // it's original location was according to it's original vdom
      return (node && node['s-ol']) || node;
  };
  const parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;
  /**
   * Handle reconciling an outdated VNode with a new one which corresponds to
   * it. This function handles flushing updates to the DOM and reconciling the
   * children of the two nodes (if any).
   *
   * @param oldVNode an old VNode whose DOM element and children we want to update
   * @param newVNode a new VNode representing an updated version of the old one
   */
  const patch = (oldVNode, newVNode) => {
      const elm = (newVNode.$elm$ = oldVNode.$elm$);
      const oldChildren = oldVNode.$children$;
      const newChildren = newVNode.$children$;
      const tag = newVNode.$tag$;
      const text = newVNode.$text$;
      let defaultHolder;
      if (text === null) {
          {
              if (tag === 'slot')
                  ;
              else {
                  // either this is the first render of an element OR it's an update
                  // AND we already know it's possible it could have changed
                  // this updates the element's css classes, attrs, props, listeners, etc.
                  updateElement(oldVNode, newVNode, isSvgMode);
              }
          }
          if (oldChildren !== null && newChildren !== null) {
              // looks like there's child vnodes for both the old and new vnodes
              // so we need to call `updateChildren` to reconcile them
              updateChildren(elm, oldChildren, newVNode, newChildren);
          }
          else if (newChildren !== null) {
              // no old child vnodes, but there are new child vnodes to add
              if (oldVNode.$text$ !== null) {
                  // the old vnode was text, so be sure to clear it out
                  elm.textContent = '';
              }
              // add the new vnode children
              addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
          }
          else if (oldChildren !== null) {
              // no new child vnodes, but there are old child vnodes to remove
              removeVnodes(oldChildren, 0, oldChildren.length - 1);
          }
      }
      else if ((defaultHolder = elm['s-cr'])) {
          // this element has slotted content
          defaultHolder.parentNode.textContent = text;
      }
      else if (oldVNode.$text$ !== text) {
          // update the text content for the text only vnode
          // and also only if the text is different than before
          elm.data = text;
      }
  };
  const updateFallbackSlotVisibility = (elm) => {
      // tslint:disable-next-line: prefer-const
      const childNodes = elm.childNodes;
      let childNode;
      let i;
      let ilen;
      let j;
      let slotNameAttr;
      let nodeType;
      for (i = 0, ilen = childNodes.length; i < ilen; i++) {
          childNode = childNodes[i];
          if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
              if (childNode['s-sr']) {
                  // this is a slot fallback node
                  // get the slot name for this slot reference node
                  slotNameAttr = childNode['s-sn'];
                  // by default always show a fallback slot node
                  // then hide it if there are other slots in the light dom
                  childNode.hidden = false;
                  for (j = 0; j < ilen; j++) {
                      nodeType = childNodes[j].nodeType;
                      if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {
                          // this sibling node is from a different component OR is a named fallback slot node
                          if (nodeType === 1 /* NODE_TYPE.ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {
                              childNode.hidden = true;
                              break;
                          }
                      }
                      else {
                          // this is a default fallback slot node
                          // any element or text node (with content)
                          // should hide the default fallback slot node
                          if (nodeType === 1 /* NODE_TYPE.ElementNode */ ||
                              (nodeType === 3 /* NODE_TYPE.TextNode */ && childNodes[j].textContent.trim() !== '')) {
                              childNode.hidden = true;
                              break;
                          }
                      }
                  }
              }
              // keep drilling down
              updateFallbackSlotVisibility(childNode);
          }
      }
  };
  const relocateNodes = [];
  const relocateSlotContent = (elm) => {
      // tslint:disable-next-line: prefer-const
      let childNode;
      let node;
      let hostContentNodes;
      let slotNameAttr;
      let relocateNodeData;
      let j;
      let i = 0;
      const childNodes = elm.childNodes;
      const ilen = childNodes.length;
      for (; i < ilen; i++) {
          childNode = childNodes[i];
          if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {
              // first got the content reference comment node
              // then we got it's parent, which is where all the host content is in now
              hostContentNodes = node.parentNode.childNodes;
              slotNameAttr = childNode['s-sn'];
              for (j = hostContentNodes.length - 1; j >= 0; j--) {
                  node = hostContentNodes[j];
                  if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
                      // let's do some relocating to its new home
                      // but never relocate a content reference node
                      // that is suppose to always represent the original content location
                      if (isNodeLocatedInSlot(node, slotNameAttr)) {
                          // it's possible we've already decided to relocate this node
                          relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                          // made some changes to slots
                          // let's make sure we also double check
                          // fallbacks are correctly hidden or shown
                          checkSlotFallbackVisibility = true;
                          node['s-sn'] = node['s-sn'] || slotNameAttr;
                          if (relocateNodeData) {
                              // previously we never found a slot home for this node
                              // but turns out we did, so let's remember it now
                              relocateNodeData.$slotRefNode$ = childNode;
                          }
                          else {
                              // add to our list of nodes to relocate
                              relocateNodes.push({
                                  $slotRefNode$: childNode,
                                  $nodeToRelocate$: node,
                              });
                          }
                          if (node['s-sr']) {
                              relocateNodes.map((relocateNode) => {
                                  if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                                      relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                                      if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                          relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                      }
                                  }
                              });
                          }
                      }
                      else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
                          // so far this element does not have a slot home, not setting slotRefNode on purpose
                          // if we never find a home for this element then we'll need to hide it
                          relocateNodes.push({
                              $nodeToRelocate$: node,
                          });
                      }
                  }
              }
          }
          if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {
              relocateSlotContent(childNode);
          }
      }
  };
  const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
      if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
          if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {
              return true;
          }
          if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {
              return true;
          }
          return false;
      }
      if (nodeToRelocate['s-sn'] === slotNameAttr) {
          return true;
      }
      return slotNameAttr === '';
  };
  const callNodeRefs = (vNode) => {
      {
          vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
          vNode.$children$ && vNode.$children$.map(callNodeRefs);
      }
  };
  const renderVdom = (hostRef, renderFnResults) => {
      const hostElm = hostRef.$hostElement$;
      const cmpMeta = hostRef.$cmpMeta$;
      const oldVNode = hostRef.$vnode$ || newVNode(null, null);
      const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
      hostTagName = hostElm.tagName;
      if (cmpMeta.$attrsToReflect$) {
          rootVnode.$attrs$ = rootVnode.$attrs$ || {};
          cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));
      }
      rootVnode.$tag$ = null;
      rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;
      hostRef.$vnode$ = rootVnode;
      rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
      {
          scopeId = hostElm['s-sc'];
      }
      {
          contentRef = hostElm['s-cr'];
          useNativeShadowDom = (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;
          // always reset
          checkSlotFallbackVisibility = false;
      }
      // synchronous patch
      patch(oldVNode, rootVnode);
      {
          // while we're moving nodes around existing nodes, temporarily disable
          // the disconnectCallback from working
          plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;
          if (checkSlotRelocate) {
              relocateSlotContent(rootVnode.$elm$);
              let relocateData;
              let nodeToRelocate;
              let orgLocationNode;
              let parentNodeRef;
              let insertBeforeNode;
              let refNode;
              let i = 0;
              for (; i < relocateNodes.length; i++) {
                  relocateData = relocateNodes[i];
                  nodeToRelocate = relocateData.$nodeToRelocate$;
                  if (!nodeToRelocate['s-ol']) {
                      // add a reference node marking this node's original location
                      // keep a reference to this node for later lookups
                      orgLocationNode =
                          doc.createTextNode('');
                      orgLocationNode['s-nr'] = nodeToRelocate;
                      nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);
                  }
              }
              for (i = 0; i < relocateNodes.length; i++) {
                  relocateData = relocateNodes[i];
                  nodeToRelocate = relocateData.$nodeToRelocate$;
                  if (relocateData.$slotRefNode$) {
                      // by default we're just going to insert it directly
                      // after the slot reference node
                      parentNodeRef = relocateData.$slotRefNode$.parentNode;
                      insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                      orgLocationNode = nodeToRelocate['s-ol'];
                      while ((orgLocationNode = orgLocationNode.previousSibling)) {
                          refNode = orgLocationNode['s-nr'];
                          if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                              refNode = refNode.nextSibling;
                              if (!refNode || !refNode['s-nr']) {
                                  insertBeforeNode = refNode;
                                  break;
                              }
                          }
                      }
                      if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||
                          nodeToRelocate.nextSibling !== insertBeforeNode) {
                          // we've checked that it's worth while to relocate
                          // since that the node to relocate
                          // has a different next sibling or parent relocated
                          if (nodeToRelocate !== insertBeforeNode) {
                              if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                                  // probably a component in the index.html that doesn't have it's hostname set
                                  nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
                              }
                              // add it back to the dom but in its new home
                              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                          }
                      }
                  }
                  else {
                      // this node doesn't have a slot home to go to, so let's hide it
                      if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {
                          nodeToRelocate.hidden = true;
                      }
                  }
              }
          }
          if (checkSlotFallbackVisibility) {
              updateFallbackSlotVisibility(rootVnode.$elm$);
          }
          // done moving nodes around
          // allow the disconnect callback to work again
          plt.$flags$ &= -2 /* PLATFORM_FLAGS.isTmpDisconnected */;
          // always reset
          relocateNodes.length = 0;
      }
  };
  const attachToAncestor = (hostRef, ancestorComponent) => {
      if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
          ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
      }
  };
  const scheduleUpdate = (hostRef, isInitialLoad) => {
      {
          hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;
      }
      if (hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {
          hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;
          return;
      }
      attachToAncestor(hostRef, hostRef.$ancestorComponent$);
      // there is no ancestor component or the ancestor component
      // has already fired off its lifecycle update then
      // fire off the initial update
      const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
      return writeTask(dispatch) ;
  };
  const dispatchHooks = (hostRef, isInitialLoad) => {
      const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
      const instance = hostRef.$lazyInstance$ ;
      let promise;
      if (isInitialLoad) {
          {
              hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;
              if (hostRef.$queuedListeners$) {
                  hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
                  hostRef.$queuedListeners$ = null;
              }
          }
          {
              promise = safeCall(instance, 'componentWillLoad');
          }
      }
      else {
          {
              promise = safeCall(instance, 'componentWillUpdate');
          }
      }
      endSchedule();
      return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
  };
  const updateComponent = async (hostRef, instance, isInitialLoad) => {
      // updateComponent
      const elm = hostRef.$hostElement$;
      const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
      const rc = elm['s-rc'];
      if (isInitialLoad) {
          // DOM WRITE!
          attachStyles(hostRef);
      }
      const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
      {
          callRender(hostRef, instance);
      }
      if (rc) {
          // ok, so turns out there are some child host elements
          // waiting on this parent element to load
          // let's fire off all update callbacks waiting
          rc.map((cb) => cb());
          elm['s-rc'] = undefined;
      }
      endRender();
      endUpdate();
      {
          const childrenPromises = elm['s-p'];
          const postUpdate = () => postUpdateComponent(hostRef);
          if (childrenPromises.length === 0) {
              postUpdate();
          }
          else {
              Promise.all(childrenPromises).then(postUpdate);
              hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;
              childrenPromises.length = 0;
          }
      }
  };
  const callRender = (hostRef, instance, elm) => {
      try {
          renderingRef = instance;
          instance = instance.render() ;
          {
              hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;
          }
          {
              hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;
          }
          {
              {
                  // looks like we've got child nodes to render into this host element
                  // or we need to update the css class/attrs on the host element
                  // DOM WRITE!
                  {
                      renderVdom(hostRef, instance);
                  }
              }
          }
      }
      catch (e) {
          consoleError(e, hostRef.$hostElement$);
      }
      renderingRef = null;
      return null;
  };
  const getRenderingRef = () => renderingRef;
  const postUpdateComponent = (hostRef) => {
      const tagName = hostRef.$cmpMeta$.$tagName$;
      const elm = hostRef.$hostElement$;
      const endPostUpdate = createTime('postUpdate', tagName);
      const instance = hostRef.$lazyInstance$ ;
      const ancestorComponent = hostRef.$ancestorComponent$;
      {
          safeCall(instance, 'componentDidRender');
      }
      if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {
          hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;
          {
              // DOM WRITE!
              addHydratedFlag(elm);
          }
          {
              safeCall(instance, 'componentDidLoad');
          }
          endPostUpdate();
          {
              hostRef.$onReadyResolve$(elm);
              if (!ancestorComponent) {
                  appDidLoad();
              }
          }
      }
      else {
          {
              safeCall(instance, 'componentDidUpdate');
          }
          endPostUpdate();
      }
      {
          hostRef.$onInstanceResolve$(elm);
      }
      // load events fire from bottom to top
      // the deepest elements load first then bubbles up
      {
          if (hostRef.$onRenderResolve$) {
              hostRef.$onRenderResolve$();
              hostRef.$onRenderResolve$ = undefined;
          }
          if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {
              nextTick(() => scheduleUpdate(hostRef, false));
          }
          hostRef.$flags$ &= -517;
      }
      // ( •_•)
      // ( •_•)>⌐■-■
      // (⌐■_■)
  };
  const forceUpdate = (ref) => {
      {
          const hostRef = getHostRef(ref);
          const isConnected = hostRef.$hostElement$.isConnected;
          if (isConnected &&
              (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
              scheduleUpdate(hostRef, false);
          }
          // Returns "true" when the forced update was successfully scheduled
          return isConnected;
      }
  };
  const appDidLoad = (who) => {
      // on appload
      // we have finish the first big initial render
      {
          addHydratedFlag(doc.documentElement);
      }
      nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
  };
  const safeCall = (instance, method, arg) => {
      if (instance && instance[method]) {
          try {
              return instance[method](arg);
          }
          catch (e) {
              consoleError(e);
          }
      }
      return undefined;
  };
  const then = (promise, thenFn) => {
      return promise && promise.then ? promise.then(thenFn) : thenFn();
  };
  const addHydratedFlag = (elm) => elm.classList.add('hydrated')
      ;
  const getValue$1 = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
  const setValue = (ref, propName, newVal, cmpMeta) => {
      // check our new property value against our internal value
      const hostRef = getHostRef(ref);
      const elm = hostRef.$hostElement$ ;
      const oldVal = hostRef.$instanceValues$.get(propName);
      const flags = hostRef.$flags$;
      const instance = hostRef.$lazyInstance$ ;
      newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
      // explicitly check for NaN on both sides, as `NaN === NaN` is always false
      const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
      const didValueChange = newVal !== oldVal && !areBothNaN;
      if ((!(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {
          // gadzooks! the property's value has changed!!
          // set our new value!
          hostRef.$instanceValues$.set(propName, newVal);
          if (instance) {
              // get an array of method names of watch functions to call
              if (cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {
                  const watchMethods = cmpMeta.$watchers$[propName];
                  if (watchMethods) {
                      // this instance is watching for when this property changed
                      watchMethods.map((watchMethodName) => {
                          try {
                              // fire off each of the watch methods that are watching this property
                              instance[watchMethodName](newVal, oldVal, propName);
                          }
                          catch (e) {
                              consoleError(e, elm);
                          }
                      });
                  }
              }
              if ((flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {
                  // looks like this value actually changed, so we've got work to do!
                  // but only if we've already rendered, otherwise just chill out
                  // queue that we need to do an update, but don't worry about queuing
                  // up millions cuz this function ensures it only runs once
                  scheduleUpdate(hostRef, false);
              }
          }
      }
  };
  /**
   * Attach a series of runtime constructs to a compiled Stencil component
   * constructor, including getters and setters for the `@Prop` and `@State`
   * decorators, callbacks for when attributes change, and so on.
   *
   * @param Cstr the constructor for a component that we need to process
   * @param cmpMeta metadata collected previously about the component
   * @param flags a number used to store a series of bit flags
   * @returns a reference to the same constructor passed in (but now mutated)
   */
  const proxyComponent = (Cstr, cmpMeta, flags) => {
      if (cmpMeta.$members$) {
          if (Cstr.watchers) {
              cmpMeta.$watchers$ = Cstr.watchers;
          }
          // It's better to have a const than two Object.entries()
          const members = Object.entries(cmpMeta.$members$);
          const prototype = Cstr.prototype;
          members.map(([memberName, [memberFlags]]) => {
              if ((memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||
                      ((flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {
                  // proxyComponent - prop
                  Object.defineProperty(prototype, memberName, {
                      get() {
                          // proxyComponent, get value
                          return getValue$1(this, memberName);
                      },
                      set(newValue) {
                          // proxyComponent, set value
                          setValue(this, memberName, newValue, cmpMeta);
                      },
                      configurable: true,
                      enumerable: true,
                  });
              }
              else if (flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&
                  memberFlags & 64 /* MEMBER_FLAGS.Method */) {
                  // proxyComponent - method
                  Object.defineProperty(prototype, memberName, {
                      value(...args) {
                          const ref = getHostRef(this);
                          return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
                      },
                  });
              }
          });
          if ((flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {
              const attrNameToPropName = new Map();
              prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
                  plt.jmp(() => {
                      const propName = attrNameToPropName.get(attrName);
                      //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
                      //  in the case where an attribute was set inline.
                      //  ```html
                      //    <my-component some-attribute="some-value"></my-component>
                      //  ```
                      //
                      //  There is an edge case where a developer sets the attribute inline on a custom element and then
                      //  programmatically changes it before it has been upgraded as shown below:
                      //
                      //  ```html
                      //    <!-- this component has _not_ been upgraded yet -->
                      //    <my-component id="test" some-attribute="some-value"></my-component>
                      //    <script>
                      //      // grab non-upgraded component
                      //      el = document.querySelector("#test");
                      //      el.someAttribute = "another-value";
                      //      // upgrade component
                      //      customElements.define('my-component', MyComponent);
                      //    </script>
                      //  ```
                      //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
                      //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
                      //  to the value that was set inline i.e. "some-value" from above example. When
                      //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
                      //
                      //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
                      //  by connectedCallback as this attributeChangedCallback will not fire.
                      //
                      //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
                      //
                      //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
                      //  properties here given that this goes against best practices outlined here
                      //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy
                      if (this.hasOwnProperty(propName)) {
                          newValue = this[propName];
                          delete this[propName];
                      }
                      else if (prototype.hasOwnProperty(propName) &&
                          typeof this[propName] === 'number' &&
                          this[propName] == newValue) {
                          // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                          // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                          // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                          return;
                      }
                      this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;
                  });
              };
              // create an array of attributes to observe
              // and also create a map of html attribute name to js property name
              Cstr.observedAttributes = members
                  .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes
                  .map(([propName, m]) => {
                  const attrName = m[1] || propName;
                  attrNameToPropName.set(attrName, propName);
                  if (m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {
                      cmpMeta.$attrsToReflect$.push([propName, attrName]);
                  }
                  return attrName;
              });
          }
      }
      return Cstr;
  };
  const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
      // initializeComponent
      if ((hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {
          {
              // we haven't initialized this element yet
              hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;
              // lazy loaded components
              // request the component's implementation to be
              // wired up with the host element
              Cstr = loadModule(cmpMeta);
              if (Cstr.then) {
                  // Await creates a micro-task avoid if possible
                  const endLoad = uniqueTime();
                  Cstr = await Cstr;
                  endLoad();
              }
              if (!Cstr.isProxied) {
                  // we've never proxied this Constructor before
                  // let's add the getters/setters to its prototype before
                  // the first time we create an instance of the implementation
                  {
                      cmpMeta.$watchers$ = Cstr.watchers;
                  }
                  proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);
                  Cstr.isProxied = true;
              }
              const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
              // ok, time to construct the instance
              // but let's keep track of when we start and stop
              // so that the getters/setters don't incorrectly step on data
              {
                  hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;
              }
              // construct the lazy-loaded component implementation
              // passing the hostRef is very important during
              // construction in order to directly wire together the
              // host element and the lazy-loaded instance
              try {
                  new Cstr(hostRef);
              }
              catch (e) {
                  consoleError(e);
              }
              {
                  hostRef.$flags$ &= -9 /* HOST_FLAGS.isConstructingInstance */;
              }
              {
                  hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;
              }
              endNewInstance();
              fireConnectedCallback(hostRef.$lazyInstance$);
          }
          if (Cstr.style) {
              // this component has styles but we haven't registered them yet
              let style = Cstr.style;
              const scopeId = getScopeId(cmpMeta);
              if (!styles.has(scopeId)) {
                  const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                  registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));
                  endRegisterStyles();
              }
          }
      }
      // we've successfully created a lazy instance
      const ancestorComponent = hostRef.$ancestorComponent$;
      const schedule = () => scheduleUpdate(hostRef, true);
      if (ancestorComponent && ancestorComponent['s-rc']) {
          // this is the initial load and this component it has an ancestor component
          // but the ancestor component has NOT fired its will update lifecycle yet
          // so let's just cool our jets and wait for the ancestor to continue first
          // this will get fired off when the ancestor component
          // finally gets around to rendering its lazy self
          // fire off the initial update
          ancestorComponent['s-rc'].push(schedule);
      }
      else {
          schedule();
      }
  };
  const fireConnectedCallback = (instance) => {
      {
          safeCall(instance, 'connectedCallback');
      }
  };
  const connectedCallback = (elm) => {
      if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
          const hostRef = getHostRef(elm);
          const cmpMeta = hostRef.$cmpMeta$;
          const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
          if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {
              // first time this component has connected
              hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;
              {
                  // initUpdate
                  // if the slot polyfill is required we'll need to put some nodes
                  // in here to act as original content anchors as we move nodes around
                  // host element has been connected to the DOM
                  if ((cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */))) {
                      setContentReference(elm);
                  }
              }
              {
                  // find the first ancestor component (if there is one) and register
                  // this component as one of the actively loading child components for its ancestor
                  let ancestorComponent = elm;
                  while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                      // climb up the ancestors looking for the first
                      // component that hasn't finished its lifecycle update yet
                      if (ancestorComponent['s-p']) {
                          // we found this components first ancestor component
                          // keep a reference to this component's ancestor component
                          attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                          break;
                      }
                  }
              }
              // Lazy properties
              // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
              if (cmpMeta.$members$) {
                  Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                      if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {
                          const value = elm[memberName];
                          delete elm[memberName];
                          elm[memberName] = value;
                      }
                  });
              }
              {
                  initializeComponent(elm, hostRef, cmpMeta);
              }
          }
          else {
              // not the first time this has connected
              // reattach any event listeners to the host
              // since they would have been removed when disconnected
              addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
              // fire off connectedCallback() on component instance
              fireConnectedCallback(hostRef.$lazyInstance$);
          }
          endConnected();
      }
  };
  const setContentReference = (elm) => {
      // only required when we're NOT using native shadow dom (slot)
      // or this browser doesn't support native shadow dom
      // and this host element was NOT created with SSR
      // let's pick out the inner content for slot projection
      // create a node to represent where the original
      // content was first placed, which is useful later on
      const contentRefElm = (elm['s-cr'] = doc.createComment(''));
      contentRefElm['s-cn'] = true;
      elm.insertBefore(contentRefElm, elm.firstChild);
  };
  const disconnectedCallback = (elm) => {
      if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {
          const hostRef = getHostRef(elm);
          const instance = hostRef.$lazyInstance$ ;
          {
              if (hostRef.$rmListeners$) {
                  hostRef.$rmListeners$.map((rmListener) => rmListener());
                  hostRef.$rmListeners$ = undefined;
              }
          }
          {
              safeCall(instance, 'disconnectedCallback');
          }
      }
  };
  const bootstrapLazy = (lazyBundles, options = {}) => {
      const endBootstrap = createTime();
      const cmpTags = [];
      const exclude = options.exclude || [];
      const customElements = win.customElements;
      const head = doc.head;
      const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
      const visibilityStyle = /*@__PURE__*/ doc.createElement('style');
      const deferredConnectedCallbacks = [];
      let appLoadFallback;
      let isBootstrapping = true;
      Object.assign(plt, options);
      plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
      lazyBundles.map((lazyBundle) => {
          lazyBundle[1].map((compactMeta) => {
              const cmpMeta = {
                  $flags$: compactMeta[0],
                  $tagName$: compactMeta[1],
                  $members$: compactMeta[2],
                  $listeners$: compactMeta[3],
              };
              {
                  cmpMeta.$members$ = compactMeta[2];
              }
              {
                  cmpMeta.$listeners$ = compactMeta[3];
              }
              {
                  cmpMeta.$attrsToReflect$ = [];
              }
              {
                  cmpMeta.$watchers$ = {};
              }
              const tagName = cmpMeta.$tagName$;
              const HostElement = class extends HTMLElement {
                  // StencilLazyHost
                  constructor(self) {
                      // @ts-ignore
                      super(self);
                      self = this;
                      registerHost(self, cmpMeta);
                      if (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {
                          // this component is using shadow dom
                          // and this browser supports shadow dom
                          // add the read-only property "shadowRoot" to the host element
                          // adding the shadow root build conditionals to minimize runtime
                          {
                              {
                                  self.attachShadow({ mode: 'open' });
                              }
                          }
                      }
                  }
                  connectedCallback() {
                      if (appLoadFallback) {
                          clearTimeout(appLoadFallback);
                          appLoadFallback = null;
                      }
                      if (isBootstrapping) {
                          // connectedCallback will be processed once all components have been registered
                          deferredConnectedCallbacks.push(this);
                      }
                      else {
                          plt.jmp(() => connectedCallback(this));
                      }
                  }
                  disconnectedCallback() {
                      plt.jmp(() => disconnectedCallback(this));
                  }
                  componentOnReady() {
                      return getHostRef(this).$onReadyPromise$;
                  }
              };
              cmpMeta.$lazyBundleId$ = lazyBundle[0];
              if (!exclude.includes(tagName) && !customElements.get(tagName)) {
                  cmpTags.push(tagName);
                  customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));
              }
          });
      });
      {
          visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
          visibilityStyle.setAttribute('data-styles', '');
          head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
      }
      // Process deferred connectedCallbacks now all components have been registered
      isBootstrapping = false;
      if (deferredConnectedCallbacks.length) {
          deferredConnectedCallbacks.map((host) => host.connectedCallback());
      }
      else {
          {
              plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
          }
      }
      // Fallback appLoad event
      endBootstrap();
  };
  const Fragment = (_, children) => children;
  const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
      if (listeners) {
          listeners.map(([flags, name, method]) => {
              const target = getHostListenerTarget(elm, flags) ;
              const handler = hostListenerProxy(hostRef, method);
              const opts = hostListenerOpts(flags);
              plt.ael(target, name, handler, opts);
              (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
          });
      }
  };
  const hostListenerProxy = (hostRef, methodName) => (ev) => {
      try {
          {
              if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {
                  // instance is ready, let's call it's member method for this event
                  hostRef.$lazyInstance$[methodName](ev);
              }
              else {
                  (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
              }
          }
      }
      catch (e) {
          consoleError(e);
      }
  };
  const getHostListenerTarget = (elm, flags) => {
      if (flags & 8 /* LISTENER_FLAGS.TargetWindow */)
          return win;
      return elm;
  };
  // prettier-ignore
  const hostListenerOpts = (flags) => (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;
  const hostRefs = /*@__PURE__*/ new WeakMap();
  const getHostRef = (ref) => hostRefs.get(ref);
  const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
  const registerHost = (elm, cmpMeta) => {
      const hostRef = {
          $flags$: 0,
          $hostElement$: elm,
          $cmpMeta$: cmpMeta,
          $instanceValues$: new Map(),
      };
      {
          hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));
      }
      {
          hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
          elm['s-p'] = [];
          elm['s-rc'] = [];
      }
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      return hostRefs.set(elm, hostRef);
  };
  const isMemberInElement = (elm, memberName) => memberName in elm;
  const consoleError = (e, el) => (0, console.error)(e, el);
  const cmpModules = /*@__PURE__*/ new Map();
  const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
      // loadModuleImport
      const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
      const bundleId = cmpMeta.$lazyBundleId$;
      const module = cmpModules.get(bundleId) ;
      if (module) {
          return module[exportName];
      }
      
      {
        const processMod = importedModule => {
          cmpModules.set(bundleId, importedModule);
          return importedModule[exportName];
        };
        switch(bundleId) {
          
          case 'dyte-meeting':
            return Promise.resolve().then(function () { return dyteMeeting_entry; }).then(processMod, consoleError);
          case 'dyte-ai':
            return Promise.resolve().then(function () { return dyteAi_entry; }).then(processMod, consoleError);
          case 'dyte-ai-chat':
            return Promise.resolve().then(function () { return dyteAiChat_entry; }).then(processMod, consoleError);
          case 'dyte-ai-home':
            return Promise.resolve().then(function () { return dyteAiHome_entry; }).then(processMod, consoleError);
          case 'dyte-ai-toggle':
            return Promise.resolve().then(function () { return dyteAiToggle_entry; }).then(processMod, consoleError);
          case 'dyte-ai-transcriptions':
            return Promise.resolve().then(function () { return dyteAiTranscriptions_entry; }).then(processMod, consoleError);
          case 'dyte-audio-grid':
            return Promise.resolve().then(function () { return dyteAudioGrid_entry; }).then(processMod, consoleError);
          case 'dyte-audio-tile':
            return Promise.resolve().then(function () { return dyteAudioTile_entry; }).then(processMod, consoleError);
          case 'dyte-breakout-rooms-manager':
            return Promise.resolve().then(function () { return dyteBreakoutRoomsManager_entry; }).then(processMod, consoleError);
          case 'dyte-breakout-rooms-toggle':
            return Promise.resolve().then(function () { return dyteBreakoutRoomsToggle_entry; }).then(processMod, consoleError);
          case 'dyte-broadcast-message-modal':
            return Promise.resolve().then(function () { return dyteBroadcastMessageModal_entry; }).then(processMod, consoleError);
          case 'dyte-camera-toggle':
            return Promise.resolve().then(function () { return dyteCameraToggle_entry; }).then(processMod, consoleError);
          case 'dyte-caption-toggle':
            return Promise.resolve().then(function () { return dyteCaptionToggle_entry; }).then(processMod, consoleError);
          case 'dyte-channel-creator':
            return Promise.resolve().then(function () { return dyteChannelCreator_entry; }).then(processMod, consoleError);
          case 'dyte-channel-selector-ui':
            return Promise.resolve().then(function () { return dyteChannelSelectorUi_entry; }).then(processMod, consoleError);
          case 'dyte-chat':
            return Promise.resolve().then(function () { return dyteChat_entry; }).then(processMod, consoleError);
          case 'dyte-chat-composer-ui':
            return Promise.resolve().then(function () { return dyteChatComposerUi_entry; }).then(processMod, consoleError);
          case 'dyte-chat-selector-ui':
            return Promise.resolve().then(function () { return dyteChatSelectorUi_entry; }).then(processMod, consoleError);
          case 'dyte-chat-toggle':
            return Promise.resolve().then(function () { return dyteChatToggle_entry; }).then(processMod, consoleError);
          case 'dyte-clock':
            return Promise.resolve().then(function () { return dyteClock_entry; }).then(processMod, consoleError);
          case 'dyte-confirmation-modal':
            return Promise.resolve().then(function () { return dyteConfirmationModal_entry; }).then(processMod, consoleError);
          case 'dyte-controlbar':
            return Promise.resolve().then(function () { return dyteControlbar_entry; }).then(processMod, consoleError);
          case 'dyte-debugger':
            return Promise.resolve().then(function () { return dyteDebugger_entry; }).then(processMod, consoleError);
          case 'dyte-debugger-toggle':
            return Promise.resolve().then(function () { return dyteDebuggerToggle_entry; }).then(processMod, consoleError);
          case 'dyte-ended-screen':
            return Promise.resolve().then(function () { return dyteEndedScreen_entry; }).then(processMod, consoleError);
          case 'dyte-file-dropzone':
            return Promise.resolve().then(function () { return dyteFileDropzone_entry; }).then(processMod, consoleError);
          case 'dyte-fullscreen-toggle':
            return Promise.resolve().then(function () { return dyteFullscreenToggle_entry; }).then(processMod, consoleError);
          case 'dyte-grid':
            return Promise.resolve().then(function () { return dyteGrid_entry; }).then(processMod, consoleError);
          case 'dyte-grid-pagination':
            return Promise.resolve().then(function () { return dyteGridPagination_entry; }).then(processMod, consoleError);
          case 'dyte-header':
            return Promise.resolve().then(function () { return dyteHeader_entry; }).then(processMod, consoleError);
          case 'dyte-idle-screen':
            return Promise.resolve().then(function () { return dyteIdleScreen_entry; }).then(processMod, consoleError);
          case 'dyte-image-viewer':
            return Promise.resolve().then(function () { return dyteImageViewer_entry; }).then(processMod, consoleError);
          case 'dyte-information-tooltip':
            return Promise.resolve().then(function () { return dyteInformationTooltip_entry; }).then(processMod, consoleError);
          case 'dyte-leave-button':
            return Promise.resolve().then(function () { return dyteLeaveButton_entry; }).then(processMod, consoleError);
          case 'dyte-leave-meeting':
            return Promise.resolve().then(function () { return dyteLeaveMeeting_entry; }).then(processMod, consoleError);
          case 'dyte-livestream-toggle':
            return Promise.resolve().then(function () { return dyteLivestreamToggle_entry; }).then(processMod, consoleError);
          case 'dyte-meeting-title':
            return Promise.resolve().then(function () { return dyteMeetingTitle_entry; }).then(processMod, consoleError);
          case 'dyte-message-list-view':
            return Promise.resolve().then(function () { return dyteMessageListView_entry; }).then(processMod, consoleError);
          case 'dyte-mic-toggle':
            return Promise.resolve().then(function () { return dyteMicToggle_entry; }).then(processMod, consoleError);
          case 'dyte-mixed-grid':
            return Promise.resolve().then(function () { return dyteMixedGrid_entry; }).then(processMod, consoleError);
          case 'dyte-more-toggle':
            return Promise.resolve().then(function () { return dyteMoreToggle_entry; }).then(processMod, consoleError);
          case 'dyte-mute-all-button':
            return Promise.resolve().then(function () { return dyteMuteAllButton_entry; }).then(processMod, consoleError);
          case 'dyte-mute-all-confirmation':
            return Promise.resolve().then(function () { return dyteMuteAllConfirmation_entry; }).then(processMod, consoleError);
          case 'dyte-network-indicator':
            return Promise.resolve().then(function () { return dyteNetworkIndicator_entry; }).then(processMod, consoleError);
          case 'dyte-participant-count':
            return Promise.resolve().then(function () { return dyteParticipantCount_entry; }).then(processMod, consoleError);
          case 'dyte-participant-setup':
            return Promise.resolve().then(function () { return dyteParticipantSetup_entry; }).then(processMod, consoleError);
          case 'dyte-participants':
            return Promise.resolve().then(function () { return dyteParticipants_entry; }).then(processMod, consoleError);
          case 'dyte-participants-audio':
            return Promise.resolve().then(function () { return dyteParticipantsAudio_entry; }).then(processMod, consoleError);
          case 'dyte-participants-stage-list':
            return Promise.resolve().then(function () { return dyteParticipantsStageList_entry; }).then(processMod, consoleError);
          case 'dyte-participants-stage-queue':
            return Promise.resolve().then(function () { return dyteParticipantsStageQueue_entry; }).then(processMod, consoleError);
          case 'dyte-participants-toggle':
            return Promise.resolve().then(function () { return dyteParticipantsToggle_entry; }).then(processMod, consoleError);
          case 'dyte-participants-viewer-list':
            return Promise.resolve().then(function () { return dyteParticipantsViewerList_entry; }).then(processMod, consoleError);
          case 'dyte-participants-waiting-list':
            return Promise.resolve().then(function () { return dyteParticipantsWaitingList_entry; }).then(processMod, consoleError);
          case 'dyte-permissions-message':
            return Promise.resolve().then(function () { return dytePermissionsMessage_entry; }).then(processMod, consoleError);
          case 'dyte-pip-toggle':
            return Promise.resolve().then(function () { return dytePipToggle_entry; }).then(processMod, consoleError);
          case 'dyte-plugin-main':
            return Promise.resolve().then(function () { return dytePluginMain_entry; }).then(processMod, consoleError);
          case 'dyte-plugins':
            return Promise.resolve().then(function () { return dytePlugins_entry; }).then(processMod, consoleError);
          case 'dyte-plugins-toggle':
            return Promise.resolve().then(function () { return dytePluginsToggle_entry; }).then(processMod, consoleError);
          case 'dyte-polls':
            return Promise.resolve().then(function () { return dytePolls_entry; }).then(processMod, consoleError);
          case 'dyte-polls-toggle':
            return Promise.resolve().then(function () { return dytePollsToggle_entry; }).then(processMod, consoleError);
          case 'dyte-recording-indicator':
            return Promise.resolve().then(function () { return dyteRecordingIndicator_entry; }).then(processMod, consoleError);
          case 'dyte-recording-toggle':
            return Promise.resolve().then(function () { return dyteRecordingToggle_entry; }).then(processMod, consoleError);
          case 'dyte-screen-share-toggle':
            return Promise.resolve().then(function () { return dyteScreenShareToggle_entry; }).then(processMod, consoleError);
          case 'dyte-screenshare-view':
            return Promise.resolve().then(function () { return dyteScreenshareView_entry; }).then(processMod, consoleError);
          case 'dyte-settings':
            return Promise.resolve().then(function () { return dyteSettings_entry; }).then(processMod, consoleError);
          case 'dyte-settings-toggle':
            return Promise.resolve().then(function () { return dyteSettingsToggle_entry; }).then(processMod, consoleError);
          case 'dyte-setup-screen':
            return Promise.resolve().then(function () { return dyteSetupScreen_entry; }).then(processMod, consoleError);
          case 'dyte-sidebar':
            return Promise.resolve().then(function () { return dyteSidebar_entry; }).then(processMod, consoleError);
          case 'dyte-simple-grid':
            return Promise.resolve().then(function () { return dyteSimpleGrid_entry; }).then(processMod, consoleError);
          case 'dyte-spotlight-grid':
            return Promise.resolve().then(function () { return dyteSpotlightGrid_entry; }).then(processMod, consoleError);
          case 'dyte-stage':
            return Promise.resolve().then(function () { return dyteStage_entry; }).then(processMod, consoleError);
          case 'dyte-stage-toggle':
            return Promise.resolve().then(function () { return dyteStageToggle_entry; }).then(processMod, consoleError);
          case 'dyte-text-field':
            return Promise.resolve().then(function () { return dyteTextField_entry; }).then(processMod, consoleError);
          case 'dyte-transcripts':
            return Promise.resolve().then(function () { return dyteTranscripts_entry; }).then(processMod, consoleError);
          case 'dyte-ui-provider':
            return Promise.resolve().then(function () { return dyteUiProvider_entry; }).then(processMod, consoleError);
          case 'dyte-waiting-screen':
            return Promise.resolve().then(function () { return dyteWaitingScreen_entry; }).then(processMod, consoleError);
          case 'dyte-breakout-room-manager_3':
            return Promise.resolve().then(function () { return dyteBreakoutRoomManager_3_entry; }).then(processMod, consoleError);
          case 'dyte-channel-header_8':
            return Promise.resolve().then(function () { return dyteChannelHeader_8_entry; }).then(processMod, consoleError);
          case 'dyte-debugger-audio_4':
            return Promise.resolve().then(function () { return dyteDebuggerAudio_4_entry; }).then(processMod, consoleError);
          case 'dyte-livestream-indicator_3':
            return Promise.resolve().then(function () { return dyteLivestreamIndicator_3_entry; }).then(processMod, consoleError);
          case 'dyte-name-tag':
            return Promise.resolve().then(function () { return dyteNameTag_entry; }).then(processMod, consoleError);
          case 'dyte-participant':
            return Promise.resolve().then(function () { return dyteParticipant_entry; }).then(processMod, consoleError);
          case 'dyte-poll_2':
            return Promise.resolve().then(function () { return dytePoll_2_entry; }).then(processMod, consoleError);
          case 'dyte-settings-audio_2':
            return Promise.resolve().then(function () { return dyteSettingsAudio_2_entry; }).then(processMod, consoleError);
          case 'dyte-tab-bar':
            return Promise.resolve().then(function () { return dyteTabBar_entry; }).then(processMod, consoleError);
          case 'dyte-transcript':
            return Promise.resolve().then(function () { return dyteTranscript_entry; }).then(processMod, consoleError);
          case 'dyte-audio-visualizer_4':
            return Promise.resolve().then(function () { return dyteAudioVisualizer_4_entry; }).then(processMod, consoleError);
          case 'dyte-channel-details':
            return Promise.resolve().then(function () { return dyteChannelDetails_entry; }).then(processMod, consoleError);
          case 'dyte-chat-message_5':
            return Promise.resolve().then(function () { return dyteChatMessage_5_entry; }).then(processMod, consoleError);
          case 'dyte-draft-attachment-view_5':
            return Promise.resolve().then(function () { return dyteDraftAttachmentView_5_entry; }).then(processMod, consoleError);
          case 'dyte-join-stage_2':
            return Promise.resolve().then(function () { return dyteJoinStage_2_entry; }).then(processMod, consoleError);
          case 'dyte-notification':
            return Promise.resolve().then(function () { return dyteNotification_entry; }).then(processMod, consoleError);
          case 'dyte-camera-selector_2':
            return Promise.resolve().then(function () { return dyteCameraSelector_2_entry; }).then(processMod, consoleError);
          case 'dyte-sidebar-ui':
            return Promise.resolve().then(function () { return dyteSidebarUi_entry; }).then(processMod, consoleError);
          case 'dyte-spotlight-indicator':
            return Promise.resolve().then(function () { return dyteSpotlightIndicator_entry; }).then(processMod, consoleError);
          case 'dyte-virtualized-participant-list':
            return Promise.resolve().then(function () { return dyteVirtualizedParticipantList_entry; }).then(processMod, consoleError);
          case 'dyte-file-message-view_4':
            return Promise.resolve().then(function () { return dyteFileMessageView_4_entry; }).then(processMod, consoleError);
          case 'dyte-dialog':
            return Promise.resolve().then(function () { return dyteDialog_entry; }).then(processMod, consoleError);
          case 'dyte-logo':
            return Promise.resolve().then(function () { return dyteLogo_entry; }).then(processMod, consoleError);
          case 'dyte-markdown-view':
            return Promise.resolve().then(function () { return dyteMarkdownView_entry; }).then(processMod, consoleError);
          case 'dyte-menu_3':
            return Promise.resolve().then(function () { return dyteMenu_3_entry; }).then(processMod, consoleError);
          case 'dyte-avatar':
            return Promise.resolve().then(function () { return dyteAvatar_entry; }).then(processMod, consoleError);
          case 'dyte-controlbar-button':
            return Promise.resolve().then(function () { return dyteControlbarButton_entry; }).then(processMod, consoleError);
          case 'dyte-tooltip':
            return Promise.resolve().then(function () { return dyteTooltip_entry; }).then(processMod, consoleError);
          case 'dyte-spinner':
            return Promise.resolve().then(function () { return dyteSpinner_entry; }).then(processMod, consoleError);
          case 'dyte-button':
            return Promise.resolve().then(function () { return dyteButton_entry; }).then(processMod, consoleError);
          case 'dyte-icon':
            return Promise.resolve().then(function () { return dyteIcon_entry; }).then(processMod, consoleError);
        }
      }
      return import(
      /* @vite-ignore */
      /* webpackInclude: /\.entry\.js$/ */
      /* webpackExclude: /\.system\.entry\.js$/ */
      /* webpackMode: "lazy" */
      `./${bundleId}.entry.js${''}`).then((importedModule) => {
          {
              cmpModules.set(bundleId, importedModule);
          }
          return importedModule[exportName];
      }, consoleError);
  };
  const styles = /*@__PURE__*/ new Map();
  const win = typeof window !== 'undefined' ? window : {};
  const doc = win.document || { head: {} };
  const plt = {
      $flags$: 0,
      $resourcesUrl$: '',
      jmp: (h) => h(),
      raf: (h) => requestAnimationFrame(h),
      ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
      rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
      ce: (eventName, opts) => new CustomEvent(eventName, opts),
  };
  const promiseResolve = (v) => Promise.resolve(v);
  const supportsConstructableStylesheets = /*@__PURE__*/ (() => {
          try {
              new CSSStyleSheet();
              return typeof new CSSStyleSheet().replaceSync === 'function';
          }
          catch (e) { }
          return false;
      })()
      ;
  const queueDomReads = [];
  const queueDomWrites = [];
  const queueTask = (queue, write) => (cb) => {
      queue.push(cb);
      if (!queuePending) {
          queuePending = true;
          if (plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {
              nextTick(flush);
          }
          else {
              plt.raf(flush);
          }
      }
  };
  const consume = (queue) => {
      for (let i = 0; i < queue.length; i++) {
          try {
              queue[i](performance.now());
          }
          catch (e) {
              consoleError(e);
          }
      }
      queue.length = 0;
  };
  const flush = () => {
      // always force a bunch of medium callbacks to run, but still have
      // a throttle on how many can run in a certain time
      // DOM READS!!!
      consume(queueDomReads);
      // DOM WRITES!!!
      {
          consume(queueDomWrites);
          if ((queuePending = queueDomReads.length > 0)) {
              // still more to do yet, but we've run out of time
              // let's let this thing cool off and try again in the next tick
              plt.raf(flush);
          }
      }
  };
  const nextTick =  (cb) => promiseResolve().then(cb);
  const writeTask = /*@__PURE__*/ queueTask(queueDomWrites);

  /*
   Stencil Client Patch Esm v2.20.0 | MIT Licensed | https://stenciljs.com
   */
  const patchEsm = () => {
      return promiseResolve();
  };

  const defineCustomElements = (win, options) => {
    if (typeof window === 'undefined') return Promise.resolve();
    return patchEsm().then(() => {
    return bootstrapLazy(JSON.parse("[[\"dyte-chat\",[[1,\"dyte-chat\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"disablePrivateChat\":[4,\"disable-private-chat\"],\"privatePresetFilter\":[16],\"displayFilter\":[16],\"canPinMessages\":[32],\"unreadCountGroups\":[32],\"chatGroups\":[32],\"selectedGroup\":[32],\"now\":[32],\"dropzoneActivated\":[32],\"showLatestMessageButton\":[32],\"canSend\":[32],\"canSendTextMessage\":[32],\"canSendFiles\":[32],\"canPrivateMessage\":[32],\"canSendPrivateTexts\":[32],\"canSendPrivateFiles\":[32],\"emojiPickerEnabled\":[32],\"chatRecipientId\":[32],\"participants\":[32],\"selectedParticipant\":[32],\"channels\":[32],\"selectedChannelId\":[32],\"editingMessage\":[32],\"replyMessage\":[32],\"searchQuery\":[32],\"selectorState\":[32],\"creatingChannel\":[32],\"showPinnedMessages\":[32]},[[8,\"editMessageInit\",\"onEditMessageInit\"],[0,\"switchChannel\",\"channelSwitchListener\"]]]]],[\"dyte-settings\",[[1,\"dyte-settings\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"isMobileMainVisible\":[32],\"networkStatus\":[32],\"canProduceVideo\":[32]}]]],[\"dyte-breakout-rooms-manager\",[[1,\"dyte-breakout-rooms-manager\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"loading\":[32],\"roomConfig\":[32],\"draftState\":[32],\"assigningParticipants\":[32],\"selectedParticipants\":[32],\"ephemeralStatusText\":[32],\"isDragMode\":[32]},[[0,\"participantDelete\",\"onParticipantDelete\"],[0,\"participantsDragging\",\"toggleDragMode\"],[0,\"selectedParticipantsUpdate\",\"updateSelectedParticipants\"],[0,\"allParticipantsToggleUpdate\",\"updateAllParticipants\"]]]]],[\"dyte-participants-viewer-list\",[[1,\"dyte-participants-viewer-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"hideHeader\":[4,\"hide-header\"],\"iconPack\":[16],\"view\":[1],\"search\":[1],\"t\":[16],\"stageViewers\":[32]}]]],[\"dyte-chat-composer-ui\",[[1,\"dyte-chat-composer-ui\",{\"canSendTextMessage\":[4,\"can-send-text-message\"],\"canSendFiles\":[4,\"can-send-files\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"disableEmojiPicker\":[4,\"disable-emoji-picker\"],\"prefill\":[16],\"members\":[16],\"channelId\":[1,\"channel-id\"],\"emojiPickerActive\":[32],\"mentionQuery\":[32],\"focusedMemberIndex\":[32],\"filePreview\":[32]}]]],[\"dyte-debugger\",[[1,\"dyte-debugger\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[32],\"isMobileMainVisible\":[32],\"progress\":[32]},[[0,\"testProgress\",\"progressUpdate\"]]]]],[\"dyte-grid\",[[1,\"dyte-grid\",{\"layout\":[513],\"aspectRatio\":[513,\"aspect-ratio\"],\"meeting\":[16],\"gap\":[514],\"size\":[513],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16],\"overrides\":[8],\"participants\":[32],\"pinnedParticipants\":[32],\"screenShareParticipants\":[32],\"plugins\":[32],\"emptyStage\":[32],\"showLiveStreamPlayer\":[32],\"canCurrentPeerHost\":[32],\"pipSupported\":[32],\"pipEnabled\":[32],\"roomState\":[32]}]]],[\"dyte-setup-screen\",[[1,\"dyte-setup-screen\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"displayName\":[32],\"isJoining\":[32],\"canEditName\":[32],\"canProduceAudio\":[32],\"connectionState\":[32]}]]],[\"dyte-mixed-grid\",[[1,\"dyte-mixed-grid\",{\"layout\":[513],\"participants\":[16],\"pinnedParticipants\":[16],\"screenShareParticipants\":[16],\"plugins\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16],\"activeTab\":[32],\"initialised\":[32]}]]],[\"dyte-participants-stage-queue\",[[1,\"dyte-participants-stage-queue\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"stageRequestedParticipants\":[32]}]]],[\"dyte-participants-waiting-list\",[[1,\"dyte-participants-waiting-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"waitlistedParticipants\":[32]}]]],[\"dyte-polls\",[[1,\"dyte-polls\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"create\":[32],\"polls\":[32],\"permissions\":[32]}]]],[\"dyte-audio-tile\",[[1,\"dyte-audio-tile\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"participant\":[16],\"audioEnabled\":[32],\"volume\":[32]}]]],[\"dyte-camera-toggle\",[[1,\"dyte-camera-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoEnabled\":[32],\"canProduceVideo\":[32],\"cameraPermission\":[32],\"stageStatus\":[32]}]]],[\"dyte-channel-creator\",[[1,\"dyte-channel-creator\",{\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"channelName\":[32],\"searchQuery\":[32],\"step\":[32],\"loading\":[32],\"selectedMemberIds\":[32],\"focusedMemberIndex\":[32],\"showAllMembersList\":[32]}]]],[\"dyte-channel-selector-ui\",[[1,\"dyte-channel-selector-ui\",{\"channels\":[16],\"selectedChannelId\":[1,\"selected-channel-id\"],\"iconPack\":[16],\"t\":[16],\"showRecentMessage\":[4,\"show-recent-message\"],\"isHidden\":[32],\"searchQuery\":[32]}]]],[\"dyte-mic-toggle\",[[1,\"dyte-mic-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"audioEnabled\":[32],\"canProduceAudio\":[32],\"micPermission\":[32],\"stageStatus\":[32]}]]],[\"dyte-mute-all-button\",[[1,\"dyte-mute-all-button\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"canDisable\":[32]}]]],[\"dyte-screen-share-toggle\",[[1,\"dyte-screen-share-toggle\",{\"states\":[16],\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"maxScreenShareCount\":[32],\"screenShareCount\":[32],\"screenShareEnabled\":[32],\"canScreenShare\":[32],\"shareScreenPermission\":[32],\"screenShareState\":[32],\"stageStatus\":[32]}]]],[\"dyte-stage-toggle\",[[1,\"dyte-stage-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"stageStatus\":[32],\"state\":[32]}]]],[\"dyte-ai-toggle\",[[1,\"dyte-ai-toggle\",{\"variant\":[513],\"states\":[16],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"aiActive\":[32]}]]],[\"dyte-breakout-rooms-toggle\",[[1,\"dyte-breakout-rooms-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"canToggle\":[32]}]]],[\"dyte-caption-toggle\",[[1,\"dyte-caption-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"size\":[513],\"t\":[16],\"captionEnabled\":[32]}]]],[\"dyte-chat-toggle\",[[1,\"dyte-chat-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"unreadMessageCount\":[32],\"chatActive\":[32],\"canViewChat\":[32],\"hasNewMessages\":[32]}]]],[\"dyte-debugger-toggle\",[[1,\"dyte-debugger-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"t\":[16],\"iconPack\":[16],\"size\":[513]}]]],[\"dyte-fullscreen-toggle\",[[1,\"dyte-fullscreen-toggle\",{\"states\":[16],\"targetElement\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"fullScreenActive\":[32],\"isFullScreenSupported\":[32]}]]],[\"dyte-grid-pagination\",[[1,\"dyte-grid-pagination\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"variant\":[513],\"iconPack\":[16],\"t\":[16],\"page\":[32],\"pageCount\":[32],\"activeCount\":[32],\"activeComputedCount\":[32],\"showPagination\":[32]}]]],[\"dyte-idle-screen\",[[1,\"dyte-idle-screen\",{\"meeting\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-leave-button\",[[1,\"dyte-leave-button\",{\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-livestream-toggle\",[[1,\"dyte-livestream-toggle\",{\"variant\":[513],\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"livestreamState\":[32]}]]],[\"dyte-more-toggle\",[[1,\"dyte-more-toggle\",{\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-participants\",[[1,\"dyte-participants\",{\"meeting\":[16],\"states\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"defaultParticipantsTabId\":[1,\"default-participants-tab-id\"],\"t\":[16],\"currentParticipantsTabId\":[32],\"tabs\":[32],\"hasRequests\":[32],\"search\":[32]}]]],[\"dyte-participants-audio\",[[1,\"dyte-participants-audio\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"preloadedAudioElem\":[16],\"showPlayDialog\":[32]}]]],[\"dyte-participants-toggle\",[[1,\"dyte-participants-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"participantsActive\":[32],\"waitlistedParticipants\":[32],\"stageRequestedParticipants\":[32],\"badgeCount\":[32],\"canViewParticipants\":[32]}]]],[\"dyte-pip-toggle\",[[1,\"dyte-pip-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"size\":[513],\"t\":[16],\"pipSupported\":[32]}]]],[\"dyte-plugins-toggle\",[[1,\"dyte-plugins-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"pluginsActive\":[32],\"canViewPlugins\":[32]}]]],[\"dyte-polls-toggle\",[[1,\"dyte-polls-toggle\",{\"variant\":[513],\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"pollsActive\":[32],\"unreadPollsCount\":[32],\"canViewPolls\":[32]}]]],[\"dyte-recording-toggle\",[[1,\"dyte-recording-toggle\",{\"variant\":[513],\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"size\":[513],\"disabled\":[4],\"recordingState\":[32],\"canRecord\":[32]}]]],[\"dyte-screenshare-view\",[[1,\"dyte-screenshare-view\",{\"hideFullScreenButton\":[4,\"hide-full-screen-button\"],\"nameTagPosition\":[513,\"name-tag-position\"],\"participant\":[16],\"meeting\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoExpanded\":[32],\"screenShareEnabled\":[32],\"isFullScreen\":[32],\"remoteControlInfo\":[32]}]]],[\"dyte-settings-toggle\",[[1,\"dyte-settings-toggle\",{\"variant\":[513],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-sidebar\",[[1,\"dyte-sidebar\",{\"enabledSections\":[1040],\"defaultSection\":[1,\"default-section\"],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"view\":[513],\"currentTab\":[32],\"isFloating\":[32],\"enablePinning\":[32]}]]],[\"dyte-ai\",[[1,\"dyte-ai\",{\"defaultSection\":[1,\"default-section\"],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"view\":[513],\"tab\":[32],\"newTranscriptionAvailable\":[32],\"newAiMessageAvailable\":[32]}]]],[\"dyte-ai-home\",[[1,\"dyte-ai-home\",{\"meeting\":[16],\"initialMessages\":[16],\"prompt\":[32],\"messages\":[32]}]]],[\"dyte-broadcast-message-modal\",[[1,\"dyte-broadcast-message-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"messagePayload\":[32],\"successMessage\":[32]}]]],[\"dyte-ended-screen\",[[1,\"dyte-ended-screen\",{\"config\":[16],\"size\":[513],\"states\":[16],\"t\":[16],\"iconPack\":[16],\"meeting\":[16],\"icon\":[32],\"message\":[32]}]]],[\"dyte-image-viewer\",[[1,\"dyte-image-viewer\",{\"image\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16]}]]],[\"dyte-message-list-view\",[[0,\"dyte-message-list-view\",{\"messages\":[16],\"renderer\":[16],\"loadMore\":[16],\"visibleItemsCount\":[2,\"visible-items-count\"],\"estimateItemSize\":[2,\"estimate-item-size\"],\"iconPack\":[16],\"range\":[32],\"isFetching\":[32],\"autoScroll\":[32],\"totalHeight\":[32]}]]],[\"dyte-permissions-message\",[[1,\"dyte-permissions-message\",{\"meeting\":[16],\"t\":[16],\"iconPack\":[16],\"states\":[16],\"device\":[32],\"currentStep\":[32],\"svgSteps\":[32]}]]],[\"dyte-plugin-main\",[[1,\"dyte-plugin-main\",{\"meeting\":[16],\"plugin\":[16],\"iconPack\":[16],\"t\":[16],\"canClosePlugin\":[32],\"viewModeEnabled\":[32]}]]],[\"dyte-plugins\",[[1,\"dyte-plugins\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"plugins\":[32],\"canStartPlugins\":[32],\"canClosePlugins\":[32],\"activatedPluginsId\":[32]}]]],[\"dyte-chat-selector-ui\",[[1,\"dyte-chat-selector-ui\",{\"selfUserId\":[1,\"self-user-id\"],\"selectedGroupId\":[1,\"selected-group-id\"],\"unreadCounts\":[16],\"groups\":[16],\"iconPack\":[16],\"t\":[16],\"showParticipantsPanel\":[32],\"query\":[32]}]]],[\"dyte-clock\",[[1,\"dyte-clock\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"startedTime\":[32],\"timeDiff\":[32]}]]],[\"dyte-confirmation-modal\",[[1,\"dyte-confirmation-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-file-dropzone\",[[1,\"dyte-file-dropzone\",{\"hostEl\":[16],\"iconPack\":[16],\"t\":[16],\"dropzoneActivated\":[32]}]]],[\"dyte-information-tooltip\",[[1,\"dyte-information-tooltip\",{\"iconPack\":[16]}]]],[\"dyte-leave-meeting\",[[1,\"dyte-leave-meeting\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"canEndMeeting\":[32]}]]],[\"dyte-meeting-title\",[[1,\"dyte-meeting-title\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-mute-all-confirmation\",[[1,\"dyte-mute-all-confirmation\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"allowUnmute\":[32]}]]],[\"dyte-network-indicator\",[[1,\"dyte-network-indicator\",{\"participant\":[16],\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"isScreenShare\":[4,\"is-screen-share\"],\"score\":[32]}]]],[\"dyte-participant-count\",[[1,\"dyte-participant-count\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"participantCount\":[32],\"isViewer\":[32]}]]],[\"dyte-participants-stage-list\",[[1,\"dyte-participants-stage-list\",{\"meeting\":[16],\"config\":[16],\"size\":[513],\"hideHeader\":[4,\"hide-header\"],\"iconPack\":[16],\"view\":[1],\"t\":[16],\"search\":[1],\"participants\":[32]}]]],[\"dyte-recording-indicator\",[[1,\"dyte-recording-indicator\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"isRecording\":[32]}]]],[\"dyte-transcript\",[[1,\"dyte-transcript\",{\"transcript\":[16],\"t\":[16],\"timeout\":[32]}]]],[\"dyte-transcripts\",[[1,\"dyte-transcripts\",{\"meeting\":[16],\"states\":[16],\"config\":[16],\"t\":[16],\"transcripts\":[32],\"listenerAttached\":[32]}]]],[\"dyte-waiting-screen\",[[1,\"dyte-waiting-screen\",{\"meeting\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-ai-chat\",[[1,\"dyte-ai-chat\",{\"t\":[16]}]]],[\"dyte-ai-transcriptions\",[[1,\"dyte-ai-transcriptions\",{\"t\":[16],\"meeting\":[16],\"initialTranscriptions\":[16],\"participantQuery\":[32],\"isProcessing\":[32],\"captionViewEnabled\":[32],\"transcriptions\":[32]}]]],[\"dyte-audio-grid\",[[1,\"dyte-audio-grid\",{\"meeting\":[16],\"config\":[16],\"states\":[16],\"iconPack\":[16],\"size\":[513],\"t\":[16],\"hideSelf\":[4,\"hide-self\"],\"activeParticipants\":[32],\"onStageParticipants\":[32],\"offStageParticipants\":[32]}]]],[\"dyte-controlbar\",[[1,\"dyte-controlbar\",{\"variant\":[513],\"disableRender\":[4,\"disable-render\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513]}]]],[\"dyte-header\",[[1,\"dyte-header\",{\"variant\":[513],\"disableRender\":[4,\"disable-render\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513]}]]],[\"dyte-meeting\",[[1,\"dyte-meeting\",{\"loadConfigFromPreset\":[4,\"load-config-from-preset\"],\"applyDesignSystem\":[4,\"apply-design-system\"],\"mode\":[513],\"leaveOnUnmount\":[4,\"leave-on-unmount\"],\"meeting\":[16],\"showSetupScreen\":[1028,\"show-setup-screen\"],\"t\":[16],\"config\":[1040],\"iconPackUrl\":[513,\"icon-pack-url\"],\"size\":[1537],\"gridLayout\":[1,\"grid-layout\"],\"states\":[32],\"iconPack\":[32]},[[0,\"dyteStateUpdate\",\"listenState\"]]]]],[\"dyte-participant-setup\",[[1,\"dyte-participant-setup\",{\"nameTagPosition\":[513,\"name-tag-position\"],\"isPreview\":[4,\"is-preview\"],\"participant\":[16],\"states\":[16],\"config\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoState\":[32],\"isPinned\":[32]}]]],[\"dyte-simple-grid\",[[1,\"dyte-simple-grid\",{\"participants\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"dimensions\":[32],\"mediaConnection\":[32]}]]],[\"dyte-spotlight-grid\",[[1,\"dyte-spotlight-grid\",{\"layout\":[513],\"participants\":[16],\"pinnedParticipants\":[16],\"aspectRatio\":[1,\"aspect-ratio\"],\"gap\":[2],\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"iconPack\":[16],\"t\":[16],\"gridSize\":[16]}]]],[\"dyte-stage\",[[1,\"dyte-stage\",{\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-text-field\",[[1,\"dyte-text-field\",{\"type\":[1],\"placeholder\":[1],\"disabled\":[4],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-ui-provider\",[[4,\"dyte-ui-provider\",{\"meeting\":[16],\"size\":[1537],\"config\":[1040],\"t\":[16],\"iconPackUrl\":[513,\"icon-pack-url\"],\"loadConfigFromPreset\":[4,\"load-config-from-preset\"],\"applyDesignSystem\":[4,\"apply-design-system\"],\"joinRoom\":[4,\"join-room\"],\"isReady\":[32],\"iconPack\":[32]}]]],[\"dyte-avatar\",[[1,\"dyte-avatar\",{\"participant\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"imageState\":[32]}]]],[\"dyte-controlbar-button\",[[1,\"dyte-controlbar-button\",{\"variant\":[513],\"showWarning\":[4,\"show-warning\"],\"size\":[513],\"label\":[1],\"icon\":[1],\"isLoading\":[4,\"is-loading\"],\"disabled\":[516],\"iconPack\":[16],\"t\":[16],\"brandIcon\":[516,\"brand-icon\"]}]]],[\"dyte-menu_3\",[[1,\"dyte-menu\",{\"size\":[513],\"placement\":[1],\"offset\":[2],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-menu-item\",{\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-menu-list\",{\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-button\",[[1,\"dyte-button\",{\"size\":[513],\"variant\":[513],\"kind\":[513],\"reverse\":[516],\"disabled\":[516],\"iconPack\":[16],\"t\":[16],\"type\":[513]}]]],[\"dyte-icon\",[[1,\"dyte-icon\",{\"icon\":[1],\"iconPack\":[16],\"variant\":[513],\"t\":[16],\"size\":[513]}]]],[\"dyte-participant\",[[1,\"dyte-participant\",{\"meeting\":[16],\"view\":[1],\"participant\":[16],\"iconPack\":[16],\"t\":[16],\"config\":[16],\"audioEnabled\":[32],\"videoEnabled\":[32],\"isPinned\":[32],\"isOnStage\":[32],\"canDisableParticipantAudio\":[32],\"canDisableParticipantVideo\":[32],\"canKickParticipant\":[32],\"canPinParticipant\":[32],\"canAllowParticipantOnStage\":[32],\"menuOpen\":[32]}]]],[\"dyte-tab-bar\",[[1,\"dyte-tab-bar\",{\"size\":[513],\"meeting\":[16],\"states\":[16],\"config\":[16],\"layout\":[513],\"iconPack\":[16],\"t\":[16],\"activeTab\":[16],\"tabs\":[16]}]]],[\"dyte-name-tag\",[[1,\"dyte-name-tag\",{\"participant\":[16],\"meeting\":[16],\"size\":[513],\"isScreenShare\":[4,\"is-screen-share\"],\"variant\":[513],\"iconPack\":[16],\"t\":[16],\"length\":[32]}]]],[\"dyte-settings-audio_2\",[[1,\"dyte-settings-audio\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-settings-video\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"videoEnabled\":[32]}]]],[\"dyte-poll_2\",[[1,\"dyte-poll-form\",{\"iconPack\":[16],\"t\":[16],\"options\":[32],\"anonymous\":[32],\"hideVotes\":[32],\"error\":[32]}],[1,\"dyte-poll\",{\"poll\":[16],\"self\":[1],\"permissions\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-channel-details\",[[1,\"dyte-channel-details\",{\"channel\":[16],\"t\":[16],\"iconPack\":[16],\"members\":[16]}]]],[\"dyte-notification\",[[1,\"dyte-notification\",{\"notification\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"imageState\":[32]}]]],[\"dyte-sidebar-ui\",[[1,\"dyte-sidebar-ui\",{\"view\":[513],\"tabs\":[16],\"hideHeader\":[4,\"hide-header\"],\"hideCloseAction\":[4,\"hide-close-action\"],\"currentTab\":[1,\"current-tab\"],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-spotlight-indicator\",[[1,\"dyte-spotlight-indicator\",{\"meeting\":[16],\"iconPack\":[16],\"t\":[16],\"size\":[513],\"canSpotlight\":[32],\"isSpotlighted\":[32]}]]],[\"dyte-virtualized-participant-list\",[[0,\"dyte-virtualized-participant-list\",{\"items\":[16],\"renderItem\":[16],\"itemHeight\":[1026,\"item-height\"],\"bufferedItemsCount\":[2,\"buffered-items-count\"],\"emptyListElement\":[16],\"visibleStart\":[32],\"visibleEnd\":[32]}]]],[\"dyte-breakout-room-manager_3\",[[1,\"dyte-breakout-room-manager\",{\"meeting\":[16],\"assigningParticipants\":[4,\"assigning-participants\"],\"mode\":[1],\"states\":[16],\"allowDelete\":[4,\"allow-delete\"],\"iconPack\":[16],\"t\":[16],\"isDragMode\":[4,\"is-drag-mode\"],\"room\":[16],\"defaultExpanded\":[4,\"default-expanded\"],\"editingTitleRoomId\":[32],\"newTitle\":[32],\"showExpandedCard\":[32],\"glowingCard\":[32]}],[1,\"dyte-breakout-room-participants\",{\"meeting\":[16],\"participantIds\":[16],\"iconPack\":[16],\"t\":[16],\"selectedParticipantIds\":[16],\"search\":[32],\"participantsToShow\":[32],\"isDragging\":[32]}],[1,\"dyte-counter\",{\"size\":[513],\"value\":[2],\"minValue\":[2,\"min-value\"],\"iconPack\":[16],\"t\":[16],\"input\":[32]}]]],[\"dyte-livestream-indicator_3\",[[1,\"dyte-livestream-player\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"playbackUrl\":[32],\"isSupported\":[32],\"playerState\":[32],\"livestreamState\":[32],\"playerError\":[32],\"latency\":[32],\"livestreamId\":[32],\"audioPlaybackError\":[32]}],[1,\"dyte-livestream-indicator\",{\"meeting\":[16],\"size\":[513],\"t\":[16],\"iconPack\":[16],\"isLivestreaming\":[32]}],[1,\"dyte-viewer-count\",{\"meeting\":[16],\"variant\":[513],\"iconPack\":[16],\"t\":[16],\"viewerCount\":[32]}]]],[\"dyte-join-stage_2\",[[1,\"dyte-join-stage\",{\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"dataConfig\":[16],\"isLoading\":[32]}],[1,\"dyte-overlay-modal\",{\"meeting\":[16],\"states\":[16],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-dialog\",[[1,\"dyte-dialog\",{\"hideCloseButton\":[4,\"hide-close-button\"],\"disableEscapeKey\":[4,\"disable-escape-key\"],\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"open\":[1540]}]]],[\"dyte-debugger-audio_4\",[[1,\"dyte-debugger-audio\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isNetworkOpen\":[32],\"isDevicesOpen\":[32],\"audioProducerFormattedStats\":[32],\"audioProducerScoreStats\":[32],\"networkBasedMediaHealth\":[32],\"devicesHealth\":[32]}],[1,\"dyte-debugger-screenshare\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isNetworkOpen\":[32],\"isDevicesOpen\":[32],\"videoProducerFormattedStats\":[32],\"videoProducerScoreStats\":[32],\"audioProducerFormattedStats\":[32],\"audioProducerScoreStats\":[32],\"networkBasedMediaHealth\":[32]}],[1,\"dyte-debugger-system\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isBatterySectionOpen\":[32],\"batterySectionHealth\":[32],\"battery\":[32],\"batteryFormattedStats\":[32]}],[1,\"dyte-debugger-video\",{\"meeting\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isNetworkOpen\":[32],\"isDevicesOpen\":[32],\"videoProducerFormattedStats\":[32],\"videoProducerScoreStats\":[32],\"networkBasedMediaHealth\":[32],\"devicesHealth\":[32]}]]],[\"dyte-logo\",[[1,\"dyte-logo\",{\"logoUrl\":[1025,\"logo-url\"],\"config\":[16],\"meeting\":[16],\"t\":[16]}]]],[\"dyte-camera-selector_2\",[[1,\"dyte-participant-tile\",{\"nameTagPosition\":[513,\"name-tag-position\"],\"isPreview\":[4,\"is-preview\"],\"participant\":[16],\"meeting\":[16],\"states\":[16],\"config\":[16],\"variant\":[513],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isPinned\":[32],\"mediaConnectionError\":[32]}],[1,\"dyte-camera-selector\",{\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"variant\":[1],\"t\":[16],\"videoDevices\":[32],\"currentDevice\":[32],\"canProduceVideo\":[32]}]]],[\"dyte-markdown-view\",[[1,\"dyte-markdown-view\",{\"text\":[1],\"maxLength\":[2,\"max-length\"]}]]],[\"dyte-spinner\",[[1,\"dyte-spinner\",{\"iconPack\":[16],\"size\":[513],\"t\":[16]}]]],[\"dyte-draft-attachment-view_5\",[[1,\"dyte-draft-attachment-view\",{\"iconPack\":[16],\"t\":[16],\"attachment\":[16],\"filePreview\":[32]}],[1,\"dyte-emoji-picker-button\",{\"iconPack\":[16],\"t\":[16],\"isActive\":[4,\"is-active\"]}],[1,\"dyte-file-picker-button\",{\"filter\":[1],\"label\":[1],\"icon\":[1],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-text-composer-view\",{\"disabled\":[4],\"placeholder\":[1],\"value\":[1],\"maxLength\":[2,\"max-length\"],\"rateLimitBreached\":[4,\"rate-limit-breached\"],\"keyDownHandler\":[16],\"iconPack\":[16],\"t\":[16],\"maxLengthBreached\":[32],\"setText\":[64]}],[1,\"dyte-emoji-picker\",{\"iconPack\":[16],\"t\":[16],\"emojiList\":[32],\"filterVal\":[32],\"filteredEmojis\":[32]}]]],[\"dyte-chat-message_5\",[[1,\"dyte-chat-message\",{\"message\":[16],\"isContinued\":[4,\"is-continued\"],\"child\":[16],\"isUnread\":[4,\"is-unread\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"isSelf\":[4,\"is-self\"],\"canEdit\":[4,\"can-edit\"],\"canDelete\":[4,\"can-delete\"],\"canReply\":[4,\"can-reply\"],\"canPin\":[4,\"can-pin\"],\"disableControls\":[4,\"disable-controls\"],\"alignRight\":[4,\"align-right\"],\"senderDisplayPicture\":[1,\"sender-display-picture\"],\"hideAvatar\":[4,\"hide-avatar\"],\"leftAlign\":[4,\"left-align\"],\"now\":[32]}],[0,\"dyte-image-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"],\"status\":[32]}],[1,\"dyte-paginated-list\",{\"pageSize\":[2,\"page-size\"],\"pagesAllowed\":[2,\"pages-allowed\"],\"fetchData\":[16],\"createNodes\":[16],\"selectedItemId\":[1,\"selected-item-id\"],\"autoScroll\":[4,\"auto-scroll\"],\"iconPack\":[16],\"t\":[16],\"emptyListLabel\":[1,\"empty-list-label\"],\"isLoading\":[32],\"rerenderBoolean\":[32],\"shouldRenderNewNodes\":[32],\"hasNewNodesToRender\":[32],\"showEmptyListLabel\":[32],\"onNewNode\":[64],\"onNodeDelete\":[64],\"onNodeUpdate\":[64]}],[0,\"dyte-file-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"]}],[0,\"dyte-text-message\",{\"message\":[16],\"now\":[16],\"isContinued\":[516,\"is-continued\"],\"iconPack\":[16],\"t\":[16],\"showBubble\":[4,\"show-bubble\"]}]]],[\"dyte-file-message-view_4\",[[1,\"dyte-message-view\",{\"actions\":[16],\"variant\":[1],\"viewType\":[1,\"view-type\"],\"avatarUrl\":[1,\"avatar-url\"],\"hideAvatar\":[4,\"hide-avatar\"],\"authorName\":[1,\"author-name\"],\"hideAuthorName\":[4,\"hide-author-name\"],\"hideMetadata\":[4,\"hide-metadata\"],\"time\":[16],\"iconPack\":[16]}],[1,\"dyte-image-message-view\",{\"url\":[1],\"iconPack\":[16],\"t\":[16],\"status\":[32]}],[1,\"dyte-file-message-view\",{\"name\":[1],\"size\":[2],\"url\":[1],\"iconPack\":[16],\"t\":[16]}],[0,\"dyte-text-message-view\",{\"text\":[1],\"isMarkdown\":[4,\"is-markdown\"]}]]],[\"dyte-channel-header_8\",[[1,\"dyte-chat-messages-ui\",{\"selectedGroup\":[1,\"selected-group\"],\"messages\":[16],\"selfUserId\":[1,\"self-user-id\"],\"canPinMessages\":[4,\"can-pin-messages\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"now\":[32],\"showLatestMessageButton\":[32]}],[1,\"dyte-chat-messages-ui-paginated\",{\"meeting\":[16],\"selectedChannel\":[16],\"selectedChannelId\":[1,\"selected-channel-id\"],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"leftAlign\":[4,\"left-align\"],\"children\":[32],\"permissionsChanged\":[32]}],[1,\"dyte-chat-search-results\",{\"meeting\":[16],\"query\":[1],\"channelId\":[1,\"channel-id\"],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-chat-composer-view\",{\"canSendTextMessage\":[4,\"can-send-text-message\"],\"canSendFiles\":[4,\"can-send-files\"],\"message\":[1],\"quotedMessage\":[1,\"quoted-message\"],\"storageKey\":[1,\"storage-key\"],\"inputTextPlaceholder\":[1,\"input-text-placeholder\"],\"isEditing\":[4,\"is-editing\"],\"iconPack\":[16],\"t\":[16],\"maxLength\":[2,\"max-length\"],\"disableEmojiPicker\":[4,\"disable-emoji-picker\"],\"rateLimits\":[16],\"fileToUpload\":[32],\"isEmojiPickerOpen\":[32],\"disableSendButton\":[32],\"rateLimitsBreached\":[32]}],[0,\"dyte-channel-header\",{\"meeting\":[16],\"channel\":[16],\"iconPack\":[16],\"t\":[16],\"showBackButton\":[4,\"show-back-button\"],\"showChannelDetailsDialog\":[32],\"showSearchBar\":[32],\"members\":[32]}],[1,\"dyte-channel-selector-view\",{\"channels\":[16],\"selectedChannelId\":[1,\"selected-channel-id\"],\"disableSearch\":[4,\"disable-search\"],\"hideAvatar\":[4,\"hide-avatar\"],\"iconPack\":[16],\"t\":[16],\"viewAs\":[1,\"view-as\"],\"searchQuery\":[32],\"showDropdown\":[32]}],[1,\"dyte-dialog-manager\",{\"meeting\":[16],\"config\":[16],\"states\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16]}],[1,\"dyte-notifications\",{\"meeting\":[16],\"states\":[16],\"config\":[16],\"t\":[16],\"size\":[513],\"iconPack\":[16],\"notifications\":[32]},[[8,\"dyteAPIError\",\"apiErrorListener\"],[8,\"dyteSendNotification\",\"sendNotificationListener\"]]]]],[\"dyte-audio-visualizer_4\",[[1,\"dyte-audio-visualizer\",{\"variant\":[513],\"participant\":[16],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"hideMuted\":[4,\"hide-muted\"],\"isScreenShare\":[4,\"is-screen-share\"],\"audioEnabled\":[32],\"volume\":[32]}],[1,\"dyte-speaker-selector\",{\"meeting\":[16],\"states\":[16],\"variant\":[1],\"size\":[513],\"iconPack\":[16],\"t\":[16],\"speakerDevices\":[32],\"currentDevices\":[32]}],[1,\"dyte-microphone-selector\",{\"meeting\":[16],\"size\":[513],\"iconPack\":[16],\"variant\":[1],\"t\":[16],\"audioinputDevices\":[32],\"canProduceAudio\":[32],\"currentDevices\":[32]}],[1,\"dyte-switch\",{\"checked\":[1028],\"readonly\":[4],\"disabled\":[516],\"iconPack\":[16],\"t\":[16]}]]],[\"dyte-tooltip\",[[1,\"dyte-tooltip\",{\"label\":[1],\"variant\":[513],\"disabled\":[516],\"open\":[516],\"kind\":[513],\"size\":[513],\"placement\":[1],\"delay\":[2],\"iconPack\":[16],\"t\":[16],\"isInFocus\":[32]}]]]]"), options);
    });
  };

  /**
   * The default UI Config
   */
  const defaultConfig = {
    designTokens: {
      spacingBase: 4,
      googleFont: 'Inter',
    },
    styles: {
      // 'dyte-meeting': {
      // NOTE(vaibhavshn): required for mobile devices with static positioning
      // not required for fixed position
      // height: '-webkit-fill-available',
      // },
      'dyte-header': {
        display: 'grid',
        height: '48px',
        gridTemplateColumns: 'repeat(3, 1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
      },
      'dyte-header.sm': {
        display: 'grid',
        gridArea: 'header',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
      },
      'div#header-left': {
        display: 'flex',
        alignItems: 'center',
        height: '48px',
        wordBreak: 'break-all',
      },
      'dyte-logo': {
        height: '26px',
      },
      'div#header-center': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        wordBreak: 'break-all',
      },
      'div#header-right': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-end',
      },
      'dyte-stage': {
        display: 'flex',
        flex: '1',
      },
      'dyte-grid': {
        flex: '1',
        height: 'auto',
      },
      'dyte-controlbar': {
        display: 'grid',
        gridTemplateColumns: 'repeat(3,1fr)',
        gridTemplateRows: '1fr',
        alignItems: 'center',
        padding: '8px',
      },
      'dyte-controlbar.sm': {
        display: 'flex',
        position: 'relative',
        backgroundColor: 'rgb(var(--dyte-colors-background-1000, 0 0 0))',
      },
      'dyte-controlbar.md': {
        display: 'flex',
        position: 'relative',
        backgroundColor: 'rgb(var(--dyte-colors-background-1000, 0 0 0))',
      },
      'div#controlbar-left': {
        display: 'flex',
        alignItems: 'center',
      },
      'div#controlbar-center': {
        display: 'flex',
        alignItems: 'center',
        position: 'relative',
        overflow: 'visible',
        justifyContent: 'center',
      },
      'div#controlbar-mobile': {
        display: 'flex',
        flex: '1',
        alignItems: 'center',
        justifyContent: 'center',
      },
      'div#controlbar-right': {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'flex-end',
      },
      'dyte-settings': {
        width: '720px',
        height: '480px',
      },
      'dyte-debugger': {
        width: '720px',
        height: '480px',
      },
      'dyte-breakout-rooms-manager': {
        minHeight: '400px',
        minWidth: '500px',
        maxWidth: '80%',
        maxHeight: '480px',
      },
      'div#setupcontrols-media': {
        position: 'absolute',
        bottom: '8px',
        right: '8px',
        display: 'flex',
        gap: '4px',
      },
      'div#setupcontrols-settings': {
        position: 'absolute',
        top: '8px',
        right: '8px',
        display: 'flex',
        flexDirection: 'column',
        gap: '6px',
      },
      'dyte-meeting-title.sm': {
        marginLeft: '0',
      },
      'dyte-clock': {
        marginRight: '0',
      },
    },
    root: {
      'dyte-meeting': {
        // if using key value pair, provide the key in `state`
        // else provide array of states in `states`
        state: 'meeting',
        states: ['activeSidebar', 'activeAI'],
      },
      'dyte-meeting[meeting=waiting]': ['dyte-waiting-screen'],
      'dyte-meeting[meeting=idle]': ['dyte-idle-screen'],
      'dyte-meeting[meeting=setup]': ['dyte-setup-screen', 'dyte-dialog-manager'],
      'dyte-meeting[meeting=joined]': [
        'dyte-header',
        'dyte-stage',
        'dyte-controlbar',
        'dyte-participants-audio',
        'dyte-dialog-manager',
      ],
      'dyte-meeting[meeting=joined].activeSidebar.sm': {
        add: [['dyte-sidebar', { view: 'full-screen' }]],
      },
      'dyte-meeting[meeting=joined].activeSidebar.md': {
        add: [['dyte-sidebar', { view: 'full-screen' }]],
      },
      'dyte-meeting[meeting=joined].activeAI.sm': {
        add: [['dyte-ai', { view: 'full-screen' }]],
      },
      'dyte-meeting[meeting=joined].activeAI.md': {
        add: [['dyte-ai', { view: 'full-screen' }]],
      },
      'dyte-meeting[meeting=ended]': ['dyte-ended-screen'],
      'dyte-header': ['div#header-left', 'div#header-center', 'div#header-right'],
      'dyte-header.sm': { remove: ['div#header-center'] },
      'div#header-left': ['dyte-logo', 'dyte-recording-indicator', 'dyte-livestream-indicator'],
      'div#header-center': ['dyte-meeting-title'],
      'div#header-right': [
        'dyte-grid-pagination',
        'dyte-clock',
        'dyte-participant-count',
        'dyte-viewer-count',
      ],
      'div#header-left.sm': [
        'dyte-meeting-title',
        'dyte-recording-indicator',
        'dyte-livestream-indicator',
      ],
      'dyte-stage': {
        states: ['activeSidebar', 'activeAI'],
        children: ['dyte-grid', 'dyte-notifications', 'dyte-transcripts'],
      },
      'dyte-stage.activeSidebar': {
        add: [['dyte-sidebar', { view: 'sidebar' }]],
      },
      // hide sidebar for smaller screens
      'dyte-stage.activeSidebar.sm': { remove: ['dyte-sidebar'] },
      'dyte-stage.activeAI': {
        add: [['dyte-ai', { view: 'sidebar' }]],
      },
      // hide sidebar for smaller screens
      'dyte-stage.activeAI.sm': { remove: ['dyte-ai'] },
      'dyte-grid': {
        states: ['activeScreenShare', 'activePlugin', 'activeSpotlight'],
        children: ['dyte-simple-grid'],
      },
      'dyte-grid.activeSpotlight': ['dyte-spotlight-grid'],
      'dyte-grid.activeScreenShare': ['dyte-mixed-grid'],
      'dyte-grid.activePlugin': ['dyte-mixed-grid'],
      'dyte-grid.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'],
      'dyte-grid.activePlugin.activeSpotlight': ['dyte-mixed-grid'],
      'dyte-grid.activePlugin.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'],
      'dyte-mixed-grid': {
        states: ['activeSpotlight'],
        children: ['dyte-simple-grid'],
      },
      'dyte-mixed-grid.activeSpotlight': ['dyte-spotlight-grid'],
      'dyte-participant-tile': {
        state: 'meeting',
        children: ['dyte-name-tag', 'dyte-avatar', 'dyte-network-indicator'],
      },
      'dyte-participant-setup': ['dyte-avatar', 'div#setupcontrols-media'],
      'dyte-participant-tile[meeting=setup]': [
        'dyte-avatar',
        'div#setupcontrols-settings',
        'div#setupcontrols-media',
      ],
      'div#setupcontrols-media': [
        ['dyte-mic-toggle', { size: 'sm' }],
        ['dyte-camera-toggle', { size: 'sm' }],
      ],
      'div#setupcontrols-settings': [['dyte-settings-toggle', { size: 'sm' }]],
      'dyte-screenshare-view': {
        children: ['dyte-name-tag', 'dyte-network-indicator'],
      },
      'dyte-name-tag': [['dyte-audio-visualizer', { slot: 'start' }]],
      'dyte-controlbar': {
        states: ['activeMoreMenu'],
        props: {
          variant: 'solid',
        },
        children: ['div#controlbar-left', 'div#controlbar-center', 'div#controlbar-right'],
      },
      'dyte-more-toggle': {
        states: ['activeMoreMenu'],
        children: [],
      },
      'dyte-controlbar.sm': ['div#controlbar-mobile'],
      'dyte-controlbar.md': ['div#controlbar-mobile'],
      'dyte-more-toggle.activeMoreMenu': [
        ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-caption-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-recording-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-debugger-toggle', { variant: 'horizontal' }],
      ],
      'dyte-more-toggle.activeMoreMenu.sm': [
        ['dyte-chat-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-participants-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-polls-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-plugins-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-screen-share-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-caption-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-settings-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-ai-toggle', { variant: 'horizontal' }],
        ['dyte-debugger-toggle', { variant: 'horizontal' }],
      ],
      'dyte-more-toggle.activeMoreMenu.md': [
        ['dyte-chat-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-participants-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-polls-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-plugins-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-fullscreen-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-screen-share-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-pip-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-caption-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-mute-all-button', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-breakout-rooms-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-settings-toggle', { variant: 'horizontal', slot: 'more-elements' }],
        ['dyte-ai-toggle', { variant: 'horizontal' }],
        ['dyte-debugger-toggle', { variant: 'horizontal' }],
      ],
      'div#controlbar-mobile': [
        'dyte-mic-toggle',
        'dyte-camera-toggle',
        'dyte-webinar-stage-toggle',
        'dyte-stage-toggle',
        'dyte-leave-button',
        'dyte-more-toggle',
      ],
      'div#controlbar-left': [
        'dyte-settings-toggle',
        'dyte-screen-share-toggle',
        'dyte-livestream-toggle',
      ],
      'div#controlbar-center': [
        'dyte-mic-toggle',
        'dyte-camera-toggle',
        'dyte-webinar-stage-toggle',
        'dyte-stage-toggle',
        'dyte-more-toggle',
        'dyte-leave-button',
      ],
      'div#controlbar-right': [
        'dyte-chat-toggle',
        'dyte-polls-toggle',
        'dyte-participants-toggle',
        'dyte-plugins-toggle',
        'dyte-ai-toggle',
      ],
    },
    config: {
      notification_sounds: {
        participant_left: false,
      },
      participant_joined_sound_notification_limit: 10,
      participant_chat_message_sound_notification_limit: 10,
      videoFit: 'cover',
    },
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal$1 = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;

  /** Used for built-in method references. */
  var objectProto$1$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$1$3.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1$1 = objectProto$1$3.toString;

  /** Built-in value references. */
  var symToStringTag$1$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$8.call(value, symToStringTag$1$1),
        tag = value[symToStringTag$1$1];

    try {
      value[symToStringTag$1$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1$1] = tag;
      } else {
        delete value[symToStringTag$1$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$2 = objectProto$9.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString$2.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag$1 = '[object Null]',
      undefinedTag$1 = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$2 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$1(value) {
    if (value == null) {
      return value === undefined ? undefinedTag$1 : nullTag$1;
    }
    return (symToStringTag$2 && symToStringTag$2 in Object(value))
      ? getRawTag$1(value)
      : objectToString$1(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$1(value) {
    return value != null && typeof value == 'object';
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject$1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$1(value);
    return tag == funcTag$1 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype,
      objectProto$7 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$2.call(hasOwnProperty$6).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? undefined : result;
    }
    return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$1 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /** Built-in value references. */
  var Uint8Array$1 = root$1.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /** Used for built-in method references. */
  var objectProto$4$1 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4$1;

    return value === proto;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike$1(value) && baseGetTag$1(value) == argsTag$1;
  }

  /** Used for built-in method references. */
  var objectProto$3$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3$1 = objectProto$3$1.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$3$1.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike$1(value) && hasOwnProperty$3$1.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer = moduleExports$1 ? root$1.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$2 = '[object Function]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$3 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      weakMapTag$2 = '[object WeakMap]';

  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
  typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
  typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
  typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
  typedArrayTags[uint32Tag$2] = true;
  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$1] =
  typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] =
  typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] =
  typedArrayTags[errorTag$1] = typedArrayTags[funcTag$2] =
  typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] =
  typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$2] =
  typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] =
  typedArrayTags[weakMapTag$2] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike$1(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag$1(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal$1.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$2$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2$1 = objectProto$2$1.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$2$1.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /** Used for built-in method references. */
  var objectProto$1$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1$1 = objectProto$1$2.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$1$1.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject$1(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$7.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * Can view the livestream
   */
  const isLiveStreamViewer = (meeting) => {
    if (!showLivestream(meeting))
      return false;
    return meeting.meta.viewType === 'LIVESTREAM' && meeting.stage.status !== 'ON_STAGE';
  };
  /**
   * Can start/stop the livestream
   */
  const isLiveStreamHost = (meeting) => {
    var _a;
    if (!showLivestream(meeting))
      return false;
    return meeting.meta.viewType === 'LIVESTREAM' && ((_a = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _a === undefined ? undefined : _a.permissions.canLivestream);
  };
  const showLivestream = (meeting) => {
    return meeting === null || meeting === undefined ? undefined : meeting.livestream;
  };
  var PlayerState;
  (function (PlayerState) {
    PlayerState["BUFFERING"] = "Buffering";
    PlayerState["ENDED"] = "Ended";
    PlayerState["IDLE"] = "Idle";
    PlayerState["PLAYING"] = "Playing";
    PlayerState["READY"] = "Ready";
  })(PlayerState || (PlayerState = {}));
  var PlayerEventType;
  (function (PlayerEventType) {
    PlayerEventType["INITIALIZED"] = "PlayerInitialized";
    PlayerEventType["QUALITY_CHANGED"] = "PlayerQualityChanged";
    PlayerEventType["DURATION_CHANGED"] = "PlayerDurationChanged";
    PlayerEventType["VOLUME_CHANGED"] = "PlayerVolumeChanged";
    PlayerEventType["MUTED_CHANGED"] = "PlayerMutedChanged";
    PlayerEventType["PLAYBACK_RATE_CHANGED"] = "PlayerPlaybackRateChanged";
    PlayerEventType["REBUFFERING"] = "PlayerRebuffering";
    PlayerEventType["AUDIO_BLOCKED"] = "PlayerAudioBlocked";
    PlayerEventType["PLAYBACK_BLOCKED"] = "PlayerPlaybackBlocked";
    PlayerEventType["ERROR"] = "PlayerError";
    PlayerEventType["RECOVERABLE_ERROR"] = "PlayerRecoverableError";
    PlayerEventType["ANALYTICS_EVENT"] = "PlayerAnalyticsEvent";
    PlayerEventType["TIME_UPDATE"] = "PlayerTimeUpdate";
    PlayerEventType["BUFFER_UPDATE"] = "PlayerBufferUpdate";
    PlayerEventType["SEEK_COMPLETED"] = "PlayerSeekCompleted";
    PlayerEventType["SESSION_DATA"] = "PlayerSessionData";
    PlayerEventType["STATE_CHANGED"] = "PlayerStateChanged";
    PlayerEventType["WORKER_ERROR"] = "PlayerWorkerError";
    PlayerEventType["METADATA"] = "PlayerMetadata";
    PlayerEventType["TEXT_CUE"] = "PlayerTextCue";
    PlayerEventType["TEXT_METADATA_CUE"] = "PlayerTextMetadataCue";
    PlayerEventType["AD_CUE"] = "PlayerAdCue";
    PlayerEventType["STREAM_SOURCE_CUE"] = "PlayerStreamSourceCue";
    PlayerEventType["NETWORK_UNAVAILABLE"] = "PlayerNetworkUnavailable";
    PlayerEventType["SEGMENT_DISCONTINUITY"] = "PlayerSegmentDiscontinuity";
    PlayerEventType["SEGMENT_METADATA"] = "PlayerSegmentMetadata";
    PlayerEventType["PLAYER_METADATA"] = "PlayerMetadata";
  })(PlayerEventType || (PlayerEventType = {}));

  const FlagsmithFeatureFlags = {
    PLAY_PARTICIPANT_TILE_VIDEO_ON_PAUSE: 'play_participant_tile_video_on_pause',
    DISABLE_EMOJI_PICKER: 'disable_emoji_picker',
    FEAT_PAGINATED_CHAT: 'feat_paginated_chat',
    LOG_PLAYING_FAILURES: 'log_playing_failures',
    FEAT_CHANNEL_CHAT: 'feat_channel_chat',
    DISABLE_KICKING: 'disable_kicking',
    ADMIN_CANTREMOVE_ADMIN: 'admin_cantremove_admin',
    CANTINVITE_VIEWER: 'cantinvite_viewer',
    PINNED_MESSAGES: 'pinned_msgs',
  };
  const isBreakoutRoomsEnabled = (meeting) => meeting.connectedMeetings.supportsConnectedMeetings;
  const usePaginatedChat = (meeting) => {
    var _a;
    return (meeting === null || meeting === undefined ? undefined : meeting.meta.viewType) === 'CHAT' ||
      showLivestream(meeting) ||
      ((_a = meeting === null || meeting === undefined ? undefined : meeting.__internals__) === null || _a === undefined ? undefined : _a.features.hasFeature('feat_paginated_chat'));
  };
  const disableSettingSinkId = (meeting) => {
    var _a, _b;
    return ((_a = meeting === null || meeting === undefined ? undefined : meeting.__internals__) === null || _a === undefined ? undefined : _a.browserSpecs.isFirefox()) &&
      ((_b = meeting === null || meeting === undefined ? undefined : meeting.__internals__) === null || _b === undefined ? undefined : _b.features.hasFeature('disable_firefox_setting_sink_id'));
  };

  let roomCount = 0;
  function getNextRoomNumber() {
    return ++roomCount;
  }
  function resetRoomCount() {
    roomCount = 0;
  }
  const TEMP_ROOM_PREFIX = 'temp-';
  function createDraftRoom() {
    return {
      id: `${TEMP_ROOM_PREFIX}${Math.random().toString(36)}`,
      title: `Room ${getNextRoomNumber()}`,
      participants: [],
    };
  }
  function isDraftRoom(roomId) {
    return roomId.includes(TEMP_ROOM_PREFIX);
  }
  function splitCollection(collection, parts) {
    const length = collection.length;
    const size = Math.ceil(length / parts);
    const result = new Array(parts);
    let start = 0;
    for (let i = 0; i < parts; i++) {
      result[i] = collection.slice(start, start + size);
      start += size;
    }
    return result.filter((res) => res.length);
  }
  function participantIdentifier(participant) {
    var _a;
    return (_a = participant.customParticipantId) !== null && _a !== undefined ? _a : participant.clientSpecificId;
  }
  function getAllConnectedParticipants(meeting) {
    // TODO: remove this once we start getting display pics from socket
    const map = new Map();
    [meeting.self, ...meeting.participants.joined.toArray()].map((participant) => {
      map.set(participantIdentifier(participant), participant.picture);
    });
    return [meeting.connectedMeetings.parentMeeting, ...meeting.connectedMeetings.meetings]
      .flatMap((meeting) => meeting.participants)
      .map((connectedPeer) => {
      return {
        id: connectedPeer.id,
        customParticipantId: participantIdentifier(connectedPeer),
        displayName: connectedPeer.displayName,
        displayPictureUrl: connectedPeer.displayPictureUrl !== ''
          ? connectedPeer.displayPictureUrl
          : map.get(participantIdentifier(connectedPeer)),
      };
    });
  }
  const canToggleBreakout = (meeting) => {
    if (!isBreakoutRoomsEnabled(meeting))
      return false;
    const permissions = meeting.self.permissions.connectedMeetings;
    // for host - always show toggle
    if (permissions.canAlterConnectedMeetings)
      return true;
    // for participants - show only when breakout is active
    if (permissions.canSwitchConnectedMeetings || permissions.canSwitchToParentMeeting) {
      return meeting.connectedMeetings.isActive;
    }
    return false;
  };

  const spacingScale = [
  	0,
  	0.5,
  	1,
  	1.5,
  	2,
  	3,
  	4,
  	5,
  	6,
  	7,
  	8,
  	9,
  	10,
  	12,
  	14,
  	16,
  	20,
  	24,
  	28,
  	32,
  	36,
  	40,
  	44,
  	48,
  	52,
  	56,
  	60,
  	64,
  	72,
  	80,
  	96
  ];

  const THEMES = {
    darkest: {
      background: {
        1000: '#080808',
        900: '#1A1A1A',
        800: '#1E1E1E',
        700: '#2C2C2C',
        600: '#393939',
      },
      text: '#FFFFFF',
    },
    dark: {
      background: {
        1000: '#252525',
        900: '#2F2F2F',
        800: '#323232',
        700: '#3E3E3E',
        600: '#4A4A4A',
      },
      text: '#F5F5F5',
      'video-bg': '#1C1C1C',
    },
    light: {
      background: {
        1000: '#FFFFFF',
        900: '#F5F5F5',
        800: '#EBEBEB',
        700: '#E0E0E0',
        600: '#D6D6D6',
      },
      text: '#111111',
      'text-on-brand': '#ffffff',
      'video-bg': '#DADADA',
    },
  };

  const BORDER_WIDTHS = {
    none: {
      none: 0,
      sm: 0,
      md: 0,
      lg: 0,
    },
    thin: {
      none: 0,
      sm: 1,
      md: 2,
      lg: 4,
    },
    fat: {
      none: 0,
      sm: 2,
      md: 4,
      lg: 8,
    },
  };
  const BORDER_RADII = {
    sharp: {
      none: 0,
      sm: 0,
      md: 0,
      lg: 0,
    },
    rounded: {
      none: 0,
      sm: 4,
      md: 8,
      lg: 12,
    },
    'extra-rounded': {
      none: 0,
      sm: 8,
      md: 16,
      lg: 24,
    },
    circular: {
      none: 9999,
      sm: 9999,
      md: 9999,
      lg: 9999,
    },
  };

  function hexToRGB(h) {
    h = h.trim();
    let r = '0', g = '0', b = '0';
    if (h.length == 4) {
      r = '0x' + h[1] + h[1];
      g = '0x' + h[2] + h[2];
      b = '0x' + h[3] + h[3];
    }
    else if (h.length > 6) {
      r = '0x' + h[1] + h[2];
      g = '0x' + h[3] + h[4];
      b = '0x' + h[5] + h[6];
    }
    return [+r, +g, +b];
  }
  const isValidHexColor = (color) => {
    return typeof color === 'string' && color.length === 7 && color.startsWith('#');
  };

  const DEFAULT_CSS_TOKEN_PREFIX = '--dyte-';
  function getToken(token, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX) {
    return tokenPrefix + token;
  }
  const provideGoogleFont = (fontFamily) => {
    const weights = [400, 500, 700];
    const links = [];
    if (document.querySelector('link[data-dyte-font]') == null) {
      /**
       * Adds the following preconnect link tags for faster google font loading
       * <link rel="preconnect" href="https://fonts.googleapis.com">
       * <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
       */
      const p1 = document.createElement('link');
      p1.rel = 'preconnect';
      p1.setAttribute('data-dyte-font', 'true');
      p1.href = 'https://fonts.googleapis.com';
      const p2 = p1.cloneNode(true);
      p2.href = 'https://fonts.gstatic.com';
      p2.crossOrigin = '';
      links.push(p1, p2);
    }
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.setAttribute('data-dyte-font', fontFamily);
    link.href = encodeURI(`https://fonts.googleapis.com/css2?family=${fontFamily}:wght@${weights.join(';')}&display=swap`);
    links.push(link);
    document.head.append(...links);
  };
  const provideSpacing = (el, spacingBase, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX) => {
    spacingScale.forEach((space) => {
      el.style.setProperty(getToken(`space-${space}`, tokenPrefix), `${space * spacingBase}px`);
    });
  };
  const provideBorderWidth = (el, borderWidth, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX) => {
    if (borderWidth in BORDER_WIDTHS) {
      const widths = BORDER_WIDTHS[borderWidth];
      Object.keys(widths).forEach((type) => {
        el.style.setProperty(getToken(`border-width-${type}`, tokenPrefix), `${widths[type]}px`);
      });
    }
  };
  const provideBorderRadius = (el, borderRadius, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX) => {
    if (borderRadius in BORDER_RADII) {
      const radii = BORDER_RADII[borderRadius];
      Object.keys(radii).forEach((type) => {
        el.style.setProperty(getToken(`border-radius-${type}`, tokenPrefix), `${radii[type]}px`);
      });
    }
  };
  const provideColors = (el, colors, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX) => {
    Object.keys(colors).forEach((color) => {
      const colorValue = colors[color];
      if (typeof colorValue === 'string') {
        if (color === 'text' || color === 'text-on-brand') {
          const rgb = hexToRGB(colorValue).join(' ');
          el.style.setProperty(getToken(`colors-${color}-1000`, tokenPrefix), `${rgb}`);
          el.style.setProperty(getToken(`colors-${color}-900`, tokenPrefix), `${rgb} / 0.88`);
          el.style.setProperty(getToken(`colors-${color}-800`, tokenPrefix), `${rgb} / 0.76`);
          el.style.setProperty(getToken(`colors-${color}-700`, tokenPrefix), `${rgb} / 0.64`);
          el.style.setProperty(getToken(`colors-${color}-600`, tokenPrefix), `${rgb} / 0.52`);
        }
        else {
          const rgb = hexToRGB(colorValue).join(' ');
          el.style.setProperty(getToken(`colors-${color}`, tokenPrefix), rgb);
        }
      }
      else if (typeof colorValue === 'object') {
        Object.keys(colorValue).forEach((shade) => {
          const shadeValue = colorValue[shade];
          const rgb = hexToRGB(shadeValue).join(' ');
          el.style.setProperty(getToken(`colors-${color}-${shade}`, tokenPrefix), rgb);
        });
      }
    });
  };
  /**
   * Provides the design system new tokens to consume values from for styling the Dyte UI Kit's UI.
   * @param el The element/node you want to _provide_ Dyte's design system.
   * @param tokens The design tokens you want to updated.
   */
  const provideDyteDesignSystem = (el, { spacingBase, borderRadius, borderWidth, colors, fontFamily, googleFont, theme, tokenPrefix = DEFAULT_CSS_TOKEN_PREFIX, }) => {
    if (typeof el !== 'object') {
      throw new Error('[dyte-ui-kit] (provideDyteDesignSystem): Passed element is not a valid HTML Element');
    }
    if (typeof googleFont === 'string') {
      provideGoogleFont(googleFont);
      el.style.setProperty(getToken('font-family', tokenPrefix), googleFont);
    }
    if (typeof fontFamily === 'string') {
      el.style.setProperty(getToken('font-family', tokenPrefix), fontFamily);
    }
    if (typeof spacingBase === 'number') {
      provideSpacing(el, spacingBase, tokenPrefix);
    }
    if (typeof borderWidth === 'string') {
      provideBorderWidth(el, borderWidth, tokenPrefix);
    }
    if (typeof borderRadius === 'string') {
      provideBorderRadius(el, borderRadius, tokenPrefix);
    }
    if (typeof theme === 'string') {
      const colors = THEMES[theme];
      if (colors != null)
        provideColors(el, colors, tokenPrefix);
    }
    if (typeof colors === 'object') {
      provideColors(el, colors, tokenPrefix);
    }
  };

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike$1(value) && isArrayLike(value);
  }

  /** `Object#toString` result references. */
  var objectTag$2 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$4 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag$2) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$3.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray(srcValue),
          isBuff = !isArr && isBuffer(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        }
        else if (!isObject$1(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack);
      if (isObject$1(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$2 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax$2(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax$2(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString);

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + '');
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject$1(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  /**
   * Extend the default UI Config with your own
   * @param config Your extended UI Config
   * @returns New extended UI Config object
   */
  const extendConfig = (config, baseConfig = defaultConfig) => {
    let newConfig = Object.assign({}, baseConfig);
    merge(newConfig, config);
    return newConfig;
  };
  /**
   * Generates a config with older theme value.
   * @param oldConfig Theme object
   * @param toExtend UI Config object to extend the generated config
   * @param options Options for toggling components
   * @returns
   */
  const generateConfig = (oldConfig, meeting, toExtend = {}, options = { grid_pagination: true, settings_toggle: true }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    const data = { showSetupScreen: true };
    let logo;
    let meetingElements = ['dyte-stage'];
    let headerChildren = {}, controlBarChildren = {};
    const showSettingsToggle = (options === null || options === undefined ? undefined : options.settings_toggle) !== false;
    const showGridPagination = (options === null || options === undefined ? undefined : options.grid_pagination) !== false;
    if ((_a = oldConfig.controlBar) === null || _a === undefined ? undefined : _a.isEnabled) {
      meetingElements.push('dyte-controlbar');
      const { elements } = oldConfig.controlBar;
      const leftElements = [
        ...(elements.fullscreen ? ['dyte-fullscreen-toggle'] : []),
        ...(showSettingsToggle ? ['dyte-settings-toggle'] : []),
      ];
      const rightElements = [];
      const moreElements = [];
      if (((_b = meeting.participants.pip) === null || _b === undefined ? undefined : _b.isSupported()) &&
        ((_d = (_c = meeting.self) === null || _c === undefined ? undefined : _c.config) === null || _d === undefined ? undefined : _d.pipMode) &&
        ((_e = meeting.self.config) === null || _e === undefined ? undefined : _e.viewType) !== 'LIVESTREAM') {
        moreElements.push('dyte-pip-toggle');
      }
      if (meeting === null || meeting === undefined ? undefined : meeting.self.permissions.canDisableParticipantAudio) {
        moreElements.push('dyte-mute-all-button');
      }
      if (canToggleBreakout(meeting)) {
        moreElements.push('dyte-breakout-rooms-toggle');
      }
      if ((_f = meeting.self) === null || _f === undefined ? undefined : _f.permissions.canRecord) {
        moreElements.push('dyte-recording-toggle');
      }
      if ((_g = meeting.self.permissions.transcriptionEnabled) !== null && _g !== undefined ? _g : false) {
        moreElements.push('dyte-caption-toggle');
      }
      if (navigator.product !== 'ReactNative')
        moreElements.push('dyte-debugger-toggle');
      if (isLiveStreamHost(meeting)) {
        leftElements.push('dyte-livestream-toggle');
      }
      if (elements.screenshare) {
        leftElements.push('dyte-screen-share-toggle');
      }
      if (elements.chat) {
        rightElements.push('dyte-chat-toggle');
      }
      if (elements.polls) {
        rightElements.push('dyte-polls-toggle');
      }
      if (elements.participants) {
        rightElements.push('dyte-participants-toggle');
      }
      if (elements.plugins) {
        rightElements.push('dyte-plugins-toggle');
      }
      rightElements.push('dyte-ai-toggle');
      // NOTE(ishita1805): No condition as permission check happens within component
      const centerElements = [
        'dyte-mic-toggle',
        'dyte-camera-toggle',
        'dyte-stage-toggle',
        'dyte-leave-button',
      ];
      if (moreElements.length > 0)
        centerElements.push('dyte-more-toggle');
      const allSideElements = leftElements.concat(rightElements).concat(moreElements);
      let hasMobileDrawer = false;
      if (allSideElements.length > 0) {
        hasMobileDrawer = true;
      }
      controlBarChildren = {
        'dyte-controlbar': {
          states: ['activeMoreMenu'],
          children: ['div#controlbar-left', 'div#controlbar-center', 'div#controlbar-right'],
        },
        'div#controlbar-left': leftElements,
        'div#controlbar-center': centerElements,
        'div#controlbar-right': rightElements,
        'dyte-more-toggle': {
          states: ['activeMoreMenu'],
          children: [],
        },
        'dyte-more-toggle.activeMoreMenu': moreElements.map((el) => [
          el,
          { variant: 'horizontal', slot: 'more-elements' },
        ]),
        'dyte-controlbar.sm': ['div#controlbar-mobile'],
        'dyte-controlbar.md': ['div#controlbar-mobile'],
        'dyte-more-toggle.activeMoreMenu.md': allSideElements.map((el) => [
          el,
          { variant: 'horizontal', slot: 'more-elements' },
        ]),
        'dyte-more-toggle.activeMoreMenu.sm': allSideElements.map((el) => [
          el,
          { variant: 'horizontal', slot: 'more-elements' },
        ]),
        'div#controlbar-mobile': [
          'dyte-mic-toggle',
          'dyte-camera-toggle',
          'dyte-stage-toggle',
          ...[hasMobileDrawer && 'dyte-more-toggle'],
          'dyte-leave-button',
        ],
      };
    }
    if ((_h = oldConfig.header) === null || _h === undefined ? undefined : _h.isEnabled) {
      meetingElements.unshift('dyte-header');
      const { elements } = oldConfig.header;
      let leftElements = ['dyte-recording-indicator', 'dyte-livestream-indicator'], centerElements = [], rightElements = [];
      if (showGridPagination) {
        rightElements.push('dyte-grid-pagination');
      }
      if (elements.title) {
        centerElements.push('dyte-meeting-title');
      }
      if (typeof elements.logo === 'string' && elements.logo.length > 0) {
        logo = elements.logo;
        leftElements.unshift('dyte-logo');
      }
      if (elements.participantCount) {
        rightElements.push('dyte-participant-count', 'dyte-viewer-count');
      }
      if (elements.timer) {
        rightElements.push('dyte-clock');
      }
      headerChildren = {
        'dyte-header': ['div#header-left', 'div#header-center', 'div#header-right'],
        'dyte-header.sm': { remove: ['div#header-center'] },
        'div#header-left': leftElements,
        'div#header-center': centerElements,
        'div#header-right': rightElements,
        'div#header-left.sm': {
          remove: ['dyte-logo'],
          prepend: ['dyte-meeting-title'],
        },
      };
    }
    meetingElements.push('dyte-participants-audio', 'dyte-dialog-manager');
    let designTokens = {
      logo,
    };
    designTokens = oldConfig.designTokens;
    if (isValidHexColor((_k = (_j = oldConfig === null || oldConfig === undefined ? undefined : oldConfig.designTokens) === null || _j === undefined ? undefined : _j.colors) === null || _k === undefined ? undefined : _k.textOnBrand)) {
      designTokens.colors['text-on-brand'] = (_m = (_l = oldConfig === null || oldConfig === undefined ? undefined : oldConfig.designTokens) === null || _l === undefined ? undefined : _l.colors) === null || _m === undefined ? undefined : _m.textOnBrand;
    }
    if (isValidHexColor((_p = (_o = oldConfig === null || oldConfig === undefined ? undefined : oldConfig.designTokens) === null || _o === undefined ? undefined : _o.colors) === null || _p === undefined ? undefined : _p.videoBg)) {
      designTokens.colors['video-bg'] = (_r = (_q = oldConfig === null || oldConfig === undefined ? undefined : oldConfig.designTokens) === null || _q === undefined ? undefined : _q.colors) === null || _r === undefined ? undefined : _r.videoBg;
    }
    let config = {
      designTokens,
      styles: {
        'dyte-header': {
          display: 'grid',
          height: '48px',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gridTemplateRows: '1fr',
          alignItems: 'center',
        },
        'dyte-header.sm': {
          display: 'grid',
          gridArea: 'header',
          gridTemplateColumns: 'repeat(2, 1fr)',
          gridTemplateRows: '1fr',
          alignItems: 'center',
        },
        'div#header-left': {
          display: 'flex',
          alignItems: 'center',
          height: '48px',
          wordBreak: 'break-all',
        },
        'dyte-logo': {
          height: '26px',
        },
        'div#header-center': {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          wordBreak: 'break-all',
        },
        'div#header-right': {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'flex-end',
        },
        'dyte-stage': {
          display: 'flex',
          flex: '1',
        },
        'dyte-grid': {
          flex: '1',
          height: 'auto',
        },
        'dyte-controlbar': {
          display: 'grid',
          gridTemplateColumns: 'repeat(3,1fr)',
          gridTemplateRows: '1fr',
          alignItems: 'center',
          padding: '8px',
        },
        'dyte-controlbar.sm': {
          display: 'flex',
          position: 'relative',
          backgroundColor: 'var(--dyte-colors-background-1000, #000)',
        },
        'dyte-controlbar.md': {
          display: 'flex',
          position: 'relative',
          backgroundColor: 'var(--dyte-colors-background-1000, #000)',
        },
        'div#controlbar-left': {
          display: 'flex',
          alignItems: 'center',
        },
        'div#controlbar-center': {
          display: 'flex',
          alignItems: 'center',
          position: 'relative',
          overflow: 'visible',
          justifyContent: 'center',
        },
        'div#controlbar-mobile': {
          display: 'flex',
          flex: '1',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: '10000',
        },
        'div#controlbar-right': {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'flex-end',
        },
        'dyte-settings': {
          width: '720px',
          height: '480px',
        },
        'dyte-debugger': {
          width: '720px',
          height: '480px',
        },
        'div#setupcontrols-indicator': {
          position: 'absolute',
          bottom: '12px',
          left: '12px',
          display: 'flex',
          gap: '6px',
          background: 'rgb(var(--dyte-colors-background-800, 0 0 0))',
          borderRadius: '100%',
        },
        'div#setupcontrols-media': {
          position: 'absolute',
          bottom: '8px',
          right: '8px',
          display: 'flex',
          gap: '6px',
        },
        'div#setupcontrols-settings': {
          position: 'absolute',
          top: '8px',
          right: '8px',
          display: 'flex',
          flexDirection: 'column',
          gap: '6px',
        },
        'dyte-meeting-title.sm': {
          marginLeft: '0',
        },
        'dyte-clock': {
          marginRight: '0',
        },
      },
      root: Object.assign(Object.assign(Object.assign({ 'dyte-meeting': {
          // if using key value pair, provide the key in `state`
          // else provide array of states in `states`
          state: 'meeting',
          states: ['activeSidebar', 'activeAI'],
        }, 'dyte-meeting[meeting=idle]': ['dyte-idle-screen'], 'dyte-meeting[meeting=waiting]': ['dyte-waiting-screen'], 'dyte-meeting[meeting=setup]': ['dyte-setup-screen', 'dyte-dialog-manager'], 'dyte-meeting[meeting=joined]': meetingElements, 'dyte-meeting[meeting=joined].activeSidebar.sm': {
          add: [['dyte-sidebar', { view: 'full-screen' }]],
        }, 'dyte-meeting[meeting=joined].activeSidebar.md': {
          add: [['dyte-sidebar', { view: 'full-screen' }]],
        }, 'dyte-meeting[meeting=joined].activeAI.sm': {
          add: [['dyte-ai', { view: 'full-screen' }]],
        }, 'dyte-meeting[meeting=joined].activeAI.md': {
          add: [['dyte-ai', { view: 'full-screen' }]],
        }, 'dyte-meeting[meeting=ended]': ['dyte-ended-screen'] }, headerChildren), controlBarChildren), { 'dyte-stage': {
          states: ['activeSidebar', 'activeAI'],
          children: ['dyte-grid', 'dyte-notifications', 'dyte-transcripts'],
        }, 'dyte-stage.activeSidebar': {
          add: [['dyte-sidebar', { view: 'sidebar' }]],
        }, 
        // hide sidebar for smaller screens
        'dyte-stage.activeSidebar.sm': { remove: ['dyte-sidebar'] }, 'dyte-stage.activeAI': {
          add: [['dyte-ai', { view: 'sidebar' }]],
        }, 
        // hide sidebar for smaller screens
        'dyte-stage.activeAI.sm': { remove: ['dyte-ai'] }, 'dyte-grid': {
          states: ['activeScreenShare', 'activePlugin', 'activeSpotlight'],
          state: 'viewType',
          children: ['dyte-simple-grid'],
        }, 'dyte-grid[viewType=AUDIO_ROOM]': ['dyte-audio-grid'], 'dyte-grid[viewType=AUDIO_ROOM].activePlugin': ['dyte-mixed-grid'], 'dyte-grid[viewType=AUDIO_ROOM].activeScreenshare': ['dyte-mixed-grid'], 'dyte-grid[viewType=AUDIO_ROOM].activeScreenShare.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid[viewType=AUDIO_ROOM].activePlugin.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid[viewType=AUDIO_ROOM].activePlugin.activeScreenShare.activeSpotlight': [
          'dyte-mixed-grid',
        ], 'dyte-grid.activeSpotlight': ['dyte-spotlight-grid'], 'dyte-grid.activeScreenShare': ['dyte-mixed-grid'], 'dyte-grid.activePlugin': ['dyte-mixed-grid'], 'dyte-grid.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid.activePlugin.activeSpotlight': ['dyte-mixed-grid'], 'dyte-grid.activePlugin.activeScreenShare.activeSpotlight': ['dyte-mixed-grid'], 'dyte-mixed-grid': {
          states: ['activeSpotlight'],
          state: 'viewType',
          children: ['dyte-simple-grid'],
        }, 'dyte-mixed-grid[viewType=AUDIO_ROOM]': ['dyte-audio-grid'], 'dyte-mixed-grid.activeSpotlight': ['dyte-spotlight-grid'], 'dyte-participant-tile': {
          state: 'meeting',
          children: ['dyte-name-tag', 'dyte-avatar', 'dyte-network-indicator'],
        }, 'dyte-participant-setup': ['dyte-avatar', 'div#setupcontrols-media'], 'dyte-participant-tile[meeting=setup]': [
          'dyte-avatar',
          'div#setupcontrols-indicator',
          'div#setupcontrols-media',
          ...(showSettingsToggle ? ['div#setupcontrols-settings'] : []),
        ], 'div#setupcontrols-indicator': [
          ['dyte-audio-visualizer', { slot: 'start', hideMuted: true }],
        ], 'div#setupcontrols-media': [
          ['dyte-mic-toggle', { size: 'sm' }],
          ['dyte-camera-toggle', { size: 'sm' }],
        ], 'div#setupcontrols-settings': [
          ['dyte-settings-toggle', { size: 'sm' }],
          ['dyte-debugger-toggle', { size: 'sm' }],
        ], 'dyte-screenshare-view': ['dyte-name-tag', 'dyte-network-indicator'], 'dyte-name-tag': [['dyte-audio-visualizer', { slot: 'start' }]] }),
      config: {
        notification_sounds: {
          participant_left: false,
        },
        participant_joined_sound_notification_limit: 3,
        participant_chat_message_sound_notification_limit: 10,
        videoFit: 'cover',
      },
    };
    config = extendConfig(toExtend, config);
    data.showSetupScreen = (_t = (_s = oldConfig.setupScreen) === null || _s === undefined ? undefined : _s.isEnabled) !== null && _t !== undefined ? _t : true;
    return { config, data };
  };

  /**
   * Default Icon Pack for UI Kit
   */
  const defaultIconPack = {
    people: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 13.999 13 14a2 2 0 0 1 1.995 1.85L15 16v1.5C14.999 21 11.284 22 8.5 22c-2.722 0-6.335-.956-6.495-4.27L2 17.5v-1.501c0-1.054.816-1.918 1.85-1.995L4 14ZM15.22 14H20c1.054 0 1.918.816 1.994 1.85L22 16v1c-.001 3.062-2.858 4-5 4a7.16 7.16 0 0 1-2.14-.322c.336-.386.607-.827.802-1.327A6.19 6.19 0 0 0 17 19.5l.267-.006c.985-.043 3.086-.363 3.226-2.289L20.5 17v-1a.501.501 0 0 0-.41-.492L20 15.5h-4.051a2.957 2.957 0 0 0-.595-1.34L15.22 14H20h-4.78ZM4 15.499l-.1.01a.51.51 0 0 0-.254.136.506.506 0 0 0-.136.253l-.01.101V17.5c0 1.009.45 1.722 1.417 2.242.826.445 2.003.714 3.266.753l.317.005.317-.005c1.263-.039 2.439-.308 3.266-.753.906-.488 1.359-1.145 1.412-2.057l.005-.186V16a.501.501 0 0 0-.41-.492L13 15.5l-9-.001ZM8.5 3a4.5 4.5 0 1 1 0 9 4.5 4.5 0 0 1 0-9Zm9 2a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7Zm-9-.5c-1.654 0-3 1.346-3 3s1.346 3 3 3 3-1.346 3-3-1.346-3-3-3Zm9 2c-1.103 0-2 .897-2 2s.897 2 2 2 2-.897 2-2-.897-2-2-2Z" fill="currentColor"/></svg>',
    people_checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 29 29"><path fill="currentColor" d="M14.58 15.333H2.833a2.667 2.667 0 0 0-2.666 2.666v2l.006.307c.214 4.419 5.031 5.693 8.66 5.693 1.374 0 2.92-.182 4.32-.649a8.53 8.53 0 0 1-.717-1.87c-.93.298-2.027.478-3.18.513l-.423.006-.422-.006c-1.684-.052-3.254-.411-4.355-1.004-1.29-.694-1.89-1.644-1.89-2.99v-2.001l.014-.135a.675.675 0 0 1 .181-.337.68.68 0 0 1 .338-.181l.134-.014h10.31a8.71 8.71 0 0 1 1.436-1.998h.001Zm.253-8.667a6 6 0 1 0-12 0 6 6 0 0 0 12 0Zm-10 0c0-2.205 1.795-4 4-4 2.206 0 4 1.795 4 4s-1.794 4-4 4c-2.205 0-4-1.795-4-4ZM25.5 7.999a4.667 4.667 0 1 0-9.333 0A4.667 4.667 0 0 0 25.5 8Zm-7.333 0a2.67 2.67 0 0 1 2.666-2.666A2.67 2.67 0 0 1 23.5 7.999a2.67 2.67 0 0 1-2.667 2.667 2.67 2.67 0 0 1-2.666-2.667Zm10 13.334a7.333 7.333 0 1 1-14.667 0 7.333 7.333 0 0 1 14.667 0Zm-2.862-3.139a.666.666 0 0 0-.944 0l-4.86 4.863-2.196-2.196a.667.667 0 1 0-.944.944l2.667 2.666a.666.666 0 0 0 .944 0l5.333-5.333a.666.666 0 0 0 0-.944Z"/></svg>',
    chat: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10a9.96 9.96 0 0 1-4.587-1.112l-3.826 1.067a1.25 1.25 0 0 1-1.54-1.54l1.068-3.823A9.96 9.96 0 0 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5A8.5 8.5 0 0 0 3.5 12c0 1.47.373 2.883 1.073 4.137l.15.27-1.112 3.984 3.987-1.112.27.15A8.5 8.5 0 1 0 12 3.5ZM8.75 13h4.498a.75.75 0 0 1 .102 1.493l-.102.007H8.75a.75.75 0 0 1-.102-1.493L8.75 13h4.498H8.75Zm0-3.5h6.505a.75.75 0 0 1 .101 1.493l-.101.007H8.75a.75.75 0 0 1-.102-1.493L8.75 9.5h6.505H8.75Z" fill="currentColor"/></svg>',
    poll: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.752 2a2.752 2.752 0 0 1 2.752 2.751V19.25a2.752 2.752 0 1 1-5.504 0V4.75A2.752 2.752 0 0 1 11.752 2Zm7 5a2.752 2.752 0 0 1 2.752 2.751v9.499a2.752 2.752 0 1 1-5.504 0V9.75A2.752 2.752 0 0 1 18.752 7Zm-14 5a2.752 2.752 0 0 1 2.752 2.751v4.499a2.752 2.752 0 0 1-5.504 0V14.75A2.752 2.752 0 0 1 4.752 12Zm7-8.5c-.692 0-1.252.56-1.252 1.251V19.25a1.252 1.252 0 0 0 2.504 0V4.75c0-.691-.56-1.251-1.252-1.251Zm7 5c-.691 0-1.252.56-1.252 1.251v9.499a1.252 1.252 0 0 0 2.504 0V9.75c0-.691-.56-1.251-1.252-1.251Zm-14 5c-.692 0-1.252.56-1.252 1.251v4.499a1.252 1.252 0 1 0 2.504 0V14.75c0-.691-.56-1.252-1.252-1.252Z" fill="currentColor"/></svg>',
    participants: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.754 10c.966 0 1.75.784 1.75 1.75v4.749a4.501 4.501 0 0 1-9.002 0V11.75c0-.966.783-1.75 1.75-1.75h5.502Zm0 1.5H9.252a.25.25 0 0 0-.25.25v4.749a3.001 3.001 0 0 0 6.002 0V11.75a.25.25 0 0 0-.25-.25ZM3.75 10h3.381a2.738 2.738 0 0 0-.618 1.5H3.75a.25.25 0 0 0-.25.25v3.249a2.501 2.501 0 0 0 3.082 2.433c.085.504.24.985.453 1.432A4.001 4.001 0 0 1 2 14.999V11.75c0-.966.784-1.75 1.75-1.75Zm13.125 0h3.375c.966 0 1.75.784 1.75 1.75V15a4 4 0 0 1-5.03 3.866c.214-.448.369-.929.455-1.433A2.5 2.5 0 0 0 20.5 15v-3.25a.25.25 0 0 0-.25-.25h-2.757a2.738 2.738 0 0 0-.618-1.5ZM12 3a3 3 0 1 1 0 6 3 3 0 0 1 0-6Zm6.5 1a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Zm-13 0a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Zm6.5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm6.5 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-13 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z" fill="currentColor"/></svg>',
    rocket: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><path d="M9.35 20.45 14.65 22.7Q15.55 20.9 16.575 19.15Q17.6 17.4 18.75 15.8L14.8 15Q14.8 15 14.8 15Q14.8 15 14.8 15ZM17.05 24.5 23.7 31.15Q26.55 29.85 29.05 28.2Q31.55 26.55 33.1 25Q37.15 20.95 39.05 16.7Q40.95 12.45 41.1 7.1Q35.75 7.25 31.5 9.15Q27.25 11.05 23.2 15.1Q21.65 16.65 20 19.15Q18.35 21.65 17.05 24.5ZM28.5 19.7Q27.5 18.7 27.5 17.225Q27.5 15.75 28.5 14.75Q29.5 13.75 30.975 13.75Q32.45 13.75 33.45 14.75Q34.45 15.75 34.45 17.225Q34.45 18.7 33.45 19.7Q32.45 20.7 30.975 20.7Q29.5 20.7 28.5 19.7ZM27.75 38.85 33.2 33.4Q33.2 33.4 33.2 33.4Q33.2 33.4 33.2 33.4L32.4 29.45Q30.8 30.6 29.05 31.625Q27.3 32.65 25.5 33.55ZM44.05 4.15Q44.5 10.95 42.35 16.55Q40.2 22.15 35.25 27.1Q35.2 27.15 35.15 27.2Q35.1 27.25 35.05 27.3L36.15 32.8Q36.3 33.55 36.075 34.25Q35.85 34.95 35.3 35.5L26.75 44.1L22.5 34.2L14 25.7L4.1 21.45L12.7 12.9Q13.25 12.35 13.95 12.125Q14.65 11.9 15.4 12.05L20.9 13.15Q20.95 13.1 21 13.075Q21.05 13.05 21.1 13Q26.05 8.05 31.65 5.875Q37.25 3.7 44.05 4.15ZM7.45 31.75Q9.2 30 11.725 29.975Q14.25 29.95 16 31.7Q17.75 33.45 17.725 35.975Q17.7 38.5 15.95 40.25Q14.65 41.55 11.925 42.4Q9.2 43.25 3.75 44Q4.5 38.55 5.325 35.8Q6.15 33.05 7.45 31.75ZM9.55 33.9Q8.85 34.65 8.3 36.25Q7.75 37.85 7.35 40.35Q9.85 39.95 11.45 39.4Q13.05 38.85 13.8 38.15Q14.75 37.3 14.775 36.025Q14.8 34.75 13.9 33.8Q12.95 32.9 11.675 32.925Q10.4 32.95 9.55 33.9Z" fill="currentColor" /></svg>',
    call_end: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.903 13.202-.191.816a2.75 2.75 0 0 1-2.955 2.107l-1.755-.178A2.75 2.75 0 0 1 14.6 13.83l-.389-1.686a.25.25 0 0 0-.113-.157c-.321-.197-1.034-.32-2.098-.32-.786 0-1.386.067-1.786.189-.14.043-.238.085-.301.116l-.09.048-.015.04-.409 1.77A2.75 2.75 0 0 1 7 15.948l-1.746.177A2.75 2.75 0 0 1 2.3 14.03l-.196-.817a3.75 3.75 0 0 1 1.13-3.651C5.134 7.839 8.064 7 12 7c3.943 0 6.875.842 8.776 2.57a3.75 3.75 0 0 1 1.172 3.41l-.045.222Zm-1.426-.514a2.25 2.25 0 0 0-.71-2.009C18.184 9.241 15.602 8.5 12 8.5c-3.598 0-6.177.739-7.76 2.172a2.25 2.25 0 0 0-.677 2.19l.196.818a1.25 1.25 0 0 0 1.342.953l1.746-.178a1.25 1.25 0 0 0 1.09-.962l.423-1.82.043-.136c.376-.998 1.591-1.37 3.597-1.37 1.318 0 2.265.164 2.88.54.401.245.687.642.793 1.1l.389 1.685c.12.522.56.909 1.092.963l1.754.178a1.25 1.25 0 0 0 1.343-.958l.192-.816.034-.171Z" fill="currentColor"/></svg>',
    share: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 2.498a3.502 3.502 0 1 1-2.597 5.851l-4.558 2.604a3.5 3.5 0 0 1 0 2.093l4.557 2.606a3.502 3.502 0 1 1-.745 1.302L9.1 14.347a3.502 3.502 0 1 1 0-4.698l4.557-2.604A3.502 3.502 0 0 1 17 2.498Zm0 13.5a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Zm-10.498-6a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Zm10.498-6a2.002 2.002 0 1 0 0 4.004 2.002 2.002 0 0 0 0-4.004Z" fill="currentColor"/></svg>',
    mic_on: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.25 11a.75.75 0 0 1 .743.648l.007.102v.5a6.75 6.75 0 0 1-6.249 6.732l-.001 2.268a.75.75 0 0 1-1.493.102l-.007-.102v-2.268a6.75 6.75 0 0 1-6.246-6.496L5 12.25v-.5a.75.75 0 0 1 1.493-.102l.007.102v.5a5.25 5.25 0 0 0 5.034 5.246l.216.004h.5a5.25 5.25 0 0 0 5.246-5.034l.004-.216v-.5a.75.75 0 0 1 .75-.75ZM12 2a4 4 0 0 1 4 4v6a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4Zm0 1.5A2.5 2.5 0 0 0 9.5 6v6a2.5 2.5 0 0 0 5 0V6A2.5 2.5 0 0 0 12 3.5Z" fill="currentColor"/></svg>',
    mic_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06L8 9.06V12a4 4 0 0 0 6.248 3.309l1.146 1.146A5.227 5.227 0 0 1 12.25 17.5h-.5l-.216-.004A5.25 5.25 0 0 1 6.5 12.25v-.5l-.007-.102A.75.75 0 0 0 5 11.75v.5l.004.236a6.75 6.75 0 0 0 6.246 6.496v2.268l.007.102a.75.75 0 0 0 1.493-.102l.001-2.268a6.718 6.718 0 0 0 3.712-1.458l4.256 4.256a.75.75 0 0 0 1.061-1.06L3.28 2.22Zm9.876 11.997A2.5 2.5 0 0 1 9.5 12v-1.44l3.656 3.657ZM14.5 6v5.318l1.43 1.43c.046-.242.07-.492.07-.748V6a4 4 0 0 0-7.862-1.044L9.5 6.318V6a2.5 2.5 0 0 1 5 0ZM17.196 14.014l1.146 1.146A6.725 6.725 0 0 0 19 12.25v-.5l-.007-.102a.75.75 0 0 0-1.493.102v.5l-.004.216a5.233 5.233 0 0 1-.3 1.548Z" fill="currentColor"/></svg>',
    video_on: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13.75 4.5A3.25 3.25 0 0 1 17 7.75v.173l3.864-2.318A.75.75 0 0 1 22 6.248V17.75a.75.75 0 0 1-1.136.643L17 16.075v.175a3.25 3.25 0 0 1-3.25 3.25h-8.5A3.25 3.25 0 0 1 2 16.25v-8.5A3.25 3.25 0 0 1 5.25 4.5h8.5Zm0 1.5h-8.5A1.75 1.75 0 0 0 3.5 7.75v8.5c0 .966.784 1.75 1.75 1.75h8.5a1.75 1.75 0 0 0 1.75-1.75v-8.5A1.75 1.75 0 0 0 13.75 6Zm6.75 1.573L17 9.674v4.651l3.5 2.1V7.573Z" fill="currentColor"/></svg>',
    video_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06l1.567 1.567A3.25 3.25 0 0 0 2 7.75v8.5a3.25 3.25 0 0 0 3.25 3.25h8.5a3.25 3.25 0 0 0 2.903-1.786l4.066 4.067a.75.75 0 0 0 1.061-1.061L3.28 2.22Zm12.196 14.317A1.75 1.75 0 0 1 13.75 18h-8.5a1.75 1.75 0 0 1-1.75-1.75v-8.5c0-.869.633-1.59 1.463-1.727l10.514 10.514ZM15.5 12.318V7.75A1.75 1.75 0 0 0 13.75 6H9.182l-1.5-1.5h6.068A3.25 3.25 0 0 1 17 7.75v.173l3.864-2.318A.75.75 0 0 1 22 6.248V17.75c0 .301-.17.543-.403.665L20.5 17.318V7.573L17 9.674v4.144l-1.5-1.5Z" fill="currentColor"/></svg>',
    share_screen_start: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 6.25A2.25 2.25 0 0 1 4.25 4h15.5A2.25 2.25 0 0 1 22 6.25v11.5A2.25 2.25 0 0 1 19.75 20H4.25A2.25 2.25 0 0 1 2 17.75V6.25Zm2.25-.75a.75.75 0 0 0-.75.75v11.5c0 .414.336.75.75.75h15.5a.75.75 0 0 0 .75-.75V6.25a.75.75 0 0 0-.75-.75H4.25Z"/><path d="M12 7.245a.75.75 0 0 1 .53.22l3.255 3.255a.75.75 0 1 1-1.06 1.06L12.75 9.806v6.447a.75.75 0 0 1-1.5 0V9.808L9.28 11.78a.75.75 0 1 1-1.06-1.06l3.25-3.254a.75.75 0 0 1 .53-.22Z"/></svg>',
    share_screen_stop: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 6.25A2.25 2.25 0 0 1 4.25 4h15.5A2.25 2.25 0 0 1 22 6.25v11.5A2.25 2.25 0 0 1 19.75 20H4.25A2.25 2.25 0 0 1 2 17.75V6.25Zm2.25-.75a.75.75 0 0 0-.75.75v11.5c0 .414.336.75.75.75h15.5a.75.75 0 0 0 .75-.75V6.25a.75.75 0 0 0-.75-.75H4.25Z"/><path d="M8.22 8.215a.75.75 0 0 1 1.06 0l2.72 2.72 2.725-2.716a.75.75 0 0 1 1.06 1.062l-2.724 2.715 2.724 2.724a.75.75 0 1 1-1.06 1.06L12 13.057 9.28 15.78a.75.75 0 0 1-1.06-1.06l2.72-2.724-2.72-2.72a.75.75 0 0 1 0-1.06Z"/></svg>',
    share_screen_person: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2 7.25A3.25 3.25 0 0 1 5.25 4h13.5A3.25 3.25 0 0 1 22 7.25V13h-.258a3.74 3.74 0 0 0-1.242-2.545V7.25a1.75 1.75 0 0 0-1.75-1.75H5.25A1.75 1.75 0 0 0 3.5 7.25v9.5c0 .966.784 1.75 1.75 1.75H12v.5c0 .34.04.674.118 1H5.25A3.25 3.25 0 0 1 2 16.75v-9.5ZM21.5 17a1.5 1.5 0 0 1 1.5 1.5v.5c0 1.971-1.86 4-5 4-3.14 0-5-2.029-5-4v-.5a1.5 1.5 0 0 1 1.5-1.5h7ZM18 10.5a2.75 2.75 0 1 1 0 5.5 2.75 2.75 0 0 1 0-5.5Z" fill="currentColor"/></svg>',
    clock: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.523 0 10 4.478 10 10s-4.477 10-10 10S2 17.522 2 12 6.477 2 12 2Zm0 1.667c-4.595 0-8.333 3.738-8.333 8.333 0 4.595 3.738 8.333 8.333 8.333 4.595 0 8.333-3.738 8.333-8.333 0-4.595-3.738-8.333-8.333-8.333ZM11.25 6a.75.75 0 0 1 .743.648L12 6.75V12h3.25a.75.75 0 0 1 .102 1.493l-.102.007h-4a.75.75 0 0 1-.743-.648l-.007-.102v-6a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
    dismiss: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m4.397 4.554.073-.084a.75.75 0 0 1 .976-.073l.084.073L12 10.939l6.47-6.47a.75.75 0 1 1 1.06 1.061L13.061 12l6.47 6.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L12 13.061l-6.47 6.47a.75.75 0 0 1-1.06-1.061L10.939 12l-6.47-6.47a.75.75 0 0 1-.072-.976l.073-.084-.073.084Z" fill="currentColor"/></svg>',
    send: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.694 12 2.299 3.272c-.236-.607.356-1.188.942-.982l.093.04 18 9a.75.75 0 0 1 .097 1.283l-.097.058-18 9a.75.75 0 0 1-1.065-.847l.03-.096L5.694 12 2.299 3.272 5.694 12ZM4.402 4.54l2.61 6.71h6.627a.75.75 0 0 1 .743.648l.007.102a.75.75 0 0 1-.649.743l-.101.007H7.01l-2.609 6.71L19.322 12 4.401 4.54Z" fill="currentColor"/></svg>',
    search: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 2.75a7.25 7.25 0 0 1 5.63 11.819l4.9 4.9a.75.75 0 0 1-.976 1.134l-.084-.073-4.901-4.9A7.25 7.25 0 1 1 10 2.75Zm0 1.5a5.75 5.75 0 1 0 0 11.5 5.75 5.75 0 0 0 0-11.5Z" fill="currentColor"/</svg>',
    more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7.75a1.75 1.75 0 1 1 0-3.5 1.75 1.75 0 0 1 0 3.5ZM12 13.75a1.75 1.75 0 1 1 0-3.5 1.75 1.75 0 0 1 0 3.5ZM10.25 18a1.75 1.75 0 1 0 3.5 0 1.75 1.75 0 0 0-3.5 0Z" fill="currentColor"/></svg>',
    chevron_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.22 8.47a.75.75 0 0 1 1.06 0L12 15.19l6.72-6.72a.75.75 0 1 1 1.06 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L4.22 9.53a.75.75 0 0 1 0-1.06Z" fill="currentColor"/></svg>',
    chevron_up: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.22 15.53a.75.75 0 0 0 1.06 0L12 8.81l6.72 6.72a.75.75 0 1 0 1.06-1.06l-7.25-7.25a.75.75 0 0 0-1.06 0l-7.25 7.25a.75.75 0 0 0 0 1.06Z" fill="currentColor"/></svg>',
    chevron_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.53 4.22a.75.75 0 0 1 0 1.06L8.81 12l6.72 6.72a.75.75 0 1 1-1.06 1.06l-7.25-7.25a.75.75 0 0 1 0-1.06l7.25-7.25a.75.75 0 0 1 1.06 0Z" fill="currentColor"/></svg>',
    chevron_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.47 4.22a.75.75 0 0 0 0 1.06L15.19 12l-6.72 6.72a.75.75 0 1 0 1.06 1.06l7.25-7.25a.75.75 0 0 0 0-1.06L9.53 4.22a.75.75 0 0 0-1.06 0Z" fill="currentColor"/></svg>',
    settings: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12.012 2.25c.734.008 1.465.093 2.182.253a.75.75 0 0 1 .582.649l.17 1.527a1.384 1.384 0 0 0 1.927 1.116l1.401-.615a.75.75 0 0 1 .85.174 9.792 9.792 0 0 1 2.204 3.792.75.75 0 0 1-.271.825l-1.242.916a1.381 1.381 0 0 0 0 2.226l1.243.915a.75.75 0 0 1 .272.826 9.797 9.797 0 0 1-2.204 3.792.75.75 0 0 1-.848.175l-1.407-.617a1.38 1.38 0 0 0-1.926 1.114l-.169 1.526a.75.75 0 0 1-.572.647 9.518 9.518 0 0 1-4.406 0 .75.75 0 0 1-.572-.647l-.168-1.524a1.382 1.382 0 0 0-1.926-1.11l-1.406.616a.75.75 0 0 1-.849-.175 9.798 9.798 0 0 1-2.204-3.796.75.75 0 0 1 .272-.826l1.243-.916a1.38 1.38 0 0 0 0-2.226l-1.243-.914a.75.75 0 0 1-.271-.826 9.793 9.793 0 0 1 2.204-3.792.75.75 0 0 1 .85-.174l1.4.615a1.387 1.387 0 0 0 1.93-1.118l.17-1.526a.75.75 0 0 1 .583-.65c.717-.159 1.45-.243 2.201-.252Zm0 1.5a9.135 9.135 0 0 0-1.354.117l-.109.977A2.886 2.886 0 0 1 6.525 7.17l-.898-.394a8.293 8.293 0 0 0-1.348 2.317l.798.587a2.881 2.881 0 0 1 0 4.643l-.799.588c.32.842.776 1.626 1.348 2.322l.905-.397a2.882 2.882 0 0 1 4.017 2.318l.11.984c.889.15 1.798.15 2.687 0l.11-.984a2.881 2.881 0 0 1 4.018-2.322l.905.396a8.296 8.296 0 0 0 1.347-2.318l-.798-.588a2.881 2.881 0 0 1 0-4.643l.796-.587a8.293 8.293 0 0 0-1.348-2.317l-.896.393a2.884 2.884 0 0 1-4.023-2.324l-.11-.976a8.988 8.988 0 0 0-1.333-.117ZM12 8.25a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Zm0 1.5a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z" fill="currentColor"/></svg>',
    wifi: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.745 10.75a8.291 8.291 0 0 1 1.492 2.07.75.75 0 1 1-1.335.683 6.798 6.798 0 0 0-1.218-1.692 6.562 6.562 0 0 0-10.493 1.673.75.75 0 1 1-1.339-.677 8.062 8.062 0 0 1 12.893-2.057Zm-2.102 3.07c.448.447.816.997 1.072 1.582a.75.75 0 1 1-1.373.602 3.72 3.72 0 0 0-.76-1.124 3.592 3.592 0 0 0-5.08 0c-.31.31-.562.689-.746 1.11a.75.75 0 1 1-1.375-.6 5.11 5.11 0 0 1 1.061-1.57 5.092 5.092 0 0 1 7.201 0Zm4.805-5.541c.51.509.99 1.09 1.409 1.697a.75.75 0 0 1-1.235.852 10.822 10.822 0 0 0-1.234-1.489c-4.08-4.08-10.695-4.08-14.776 0-.421.422-.84.934-1.222 1.484a.75.75 0 0 1-1.232-.855c.43-.62.905-1.2 1.394-1.69 4.666-4.665 12.23-4.665 16.896 0Zm-7.387 8.16a1.5 1.5 0 1 1-2.122 2.122 1.5 1.5 0 0 1 2.122-2.122Z" fill="currentColor"/></svg>',
    speaker: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15 4.25c0-1.079-1.274-1.65-2.08-.934L8.427 7.309a.75.75 0 0 1-.498.19H4.25A2.25 2.25 0 0 0 2 9.749v4.497a2.25 2.25 0 0 0 2.25 2.25h3.68a.75.75 0 0 1 .498.19l4.491 3.994c.806.716 2.081.144 2.081-.934V4.25ZM9.425 8.43 13.5 4.807v14.382l-4.075-3.624a2.25 2.25 0 0 0-1.495-.569H4.25a.75.75 0 0 1-.75-.75V9.75a.75.75 0 0 1 .75-.75h3.68a2.25 2.25 0 0 0 1.495-.569ZM18.992 5.897a.75.75 0 0 1 1.049.157A9.959 9.959 0 0 1 22 12a9.96 9.96 0 0 1-1.96 5.946.75.75 0 0 1-1.205-.892A8.459 8.459 0 0 0 20.5 12a8.459 8.459 0 0 0-1.665-5.054.75.75 0 0 1 .157-1.049Z" /><path d="M17.143 8.37a.75.75 0 0 1 1.017.302c.536.99.84 2.125.84 3.328a6.973 6.973 0 0 1-.84 3.328.75.75 0 0 1-1.32-.714c.42-.777.66-1.666.66-2.614s-.24-1.837-.66-2.614a.75.75 0 0 1 .303-1.017Z"/></svg>',
    speaker_off: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06L6.438 7.5H4.25A2.25 2.25 0 0 0 2 9.749v4.497a2.25 2.25 0 0 0 2.25 2.25h3.68a.75.75 0 0 1 .498.19l4.491 3.994c.806.716 2.081.144 2.081-.934V16.06l5.72 5.72a.75.75 0 0 0 1.06-1.061L3.28 2.22ZM13.5 14.56v4.629l-4.075-3.624a2.25 2.25 0 0 0-1.495-.569H4.25a.75.75 0 0 1-.75-.75V9.75a.75.75 0 0 1 .75-.75h3.688L13.5 14.56ZM13.5 4.807v5.511l1.5 1.5V4.25c0-1.079-1.274-1.65-2.08-.934l-3.4 3.022 1.063 1.063L13.5 4.807ZM17.141 13.96l1.138 1.137A6.974 6.974 0 0 0 19 12a6.973 6.973 0 0 0-.84-3.328.75.75 0 0 0-1.32.714c.42.777.66 1.666.66 2.614 0 .691-.127 1.351-.359 1.96ZM19.388 16.206l1.093 1.094A9.955 9.955 0 0 0 22 12a9.959 9.959 0 0 0-1.96-5.946.75.75 0 0 0-1.205.892A8.46 8.46 0 0 1 20.5 12a8.458 8.458 0 0 1-1.112 4.206Z"/></svg>',
    download: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.25 20.5a.75.75 0 1 1 0 1.5l-13 .004a.75.75 0 1 1 0-1.5l13-.004ZM11.648 2.012l.102-.007a.75.75 0 0 1 .743.648l.007.102-.001 13.685 3.722-3.72a.75.75 0 0 1 .976-.073l.085.073a.75.75 0 0 1 .072.976l-.073.084-4.997 4.997a.75.75 0 0 1-.976.073l-.085-.073-5.003-4.996a.75.75 0 0 1 .976-1.134l.084.072 3.719 3.714L11 2.755a.75.75 0 0 1 .648-.743l.102-.007-.102.007Z" fill="currentColor"/></svg>',
    full_screen_maximize: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4.5 5.75c0-.69.56-1.25 1.25-1.25h2a.75.75 0 0 0 0-1.5h-2A2.75 2.75 0 0 0 3 5.75v2a.75.75 0 0 0 1.5 0v-2ZM4.5 18.25c0 .69.56 1.25 1.25 1.25h2a.75.75 0 0 1 0 1.5h-2A2.75 2.75 0 0 1 3 18.25v-2a.75.75 0 0 1 1.5 0v2ZM18.25 4.5c.69 0 1.25.56 1.25 1.25v2a.75.75 0 0 0 1.5 0v-2A2.75 2.75 0 0 0 18.25 3h-2a.75.75 0 0 0 0 1.5h2ZM19.5 18.25c0 .69-.56 1.25-1.25 1.25h-2a.75.75 0 0 0 0 1.5h2A2.75 2.75 0 0 0 21 18.25v-2a.75.75 0 0 0-1.5 0v2Z" fill="currentColor"/></svg>',
    full_screen_minimize: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.5 3.75a.75.75 0 0 0-1.5 0v2.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 0 0 1.5h2.5A2.25 2.25 0 0 0 8.5 6.25v-2.5ZM8.5 20.25a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 1 0-1.5h2.5a2.25 2.25 0 0 1 2.25 2.25v2.5ZM16.25 3a.75.75 0 0 0-.75.75v2.5a2.25 2.25 0 0 0 2.25 2.25h2.5a.75.75 0 0 0 0-1.5h-2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 0-.75-.75ZM15.5 20.25a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 0 0-1.5h-2.5a2.25 2.25 0 0 0-2.25 2.25v2.5Z" fill="currentColor"/></svg>',
    copy: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5.503 4.627 5.5 6.75v10.504a3.25 3.25 0 0 0 3.25 3.25h8.616a2.251 2.251 0 0 1-2.122 1.5H8.75A4.75 4.75 0 0 1 4 17.254V6.75c0-.98.627-1.815 1.503-2.123ZM17.75 2A2.25 2.25 0 0 1 20 4.25v13a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-13A2.25 2.25 0 0 1 8.75 2h9Zm0 1.5h-9a.75.75 0 0 0-.75.75v13c0 .414.336.75.75.75h9a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75Z" fill="currentColor"/></svg>',
    attach: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.772 3.743a6 6 0 0 1 8.66 8.302l-.19.197-8.8 8.798-.036.03a3.723 3.723 0 0 1-5.489-4.973.764.764 0 0 1 .085-.13l.054-.06.086-.088.142-.148.002.003 7.436-7.454a.75.75 0 0 1 .977-.074l.084.073a.75.75 0 0 1 .074.976l-.073.084-7.594 7.613a2.23 2.23 0 0 0 3.174 3.106l8.832-8.83A4.502 4.502 0 0 0 13 4.644l-.168.16-.013.014-9.536 9.536a.75.75 0 0 1-1.133-.977l.072-.084 9.549-9.55h.002Z" fill="currentColor"/></svg>',
    image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116 5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" fill="currentColor"/></svg>',
    emoji_multiple: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.5 2a6.503 6.503 0 0 1 6.312 4.943c-.515.01-1.02.068-1.506.171a5 5 0 1 0-6.191 6.191 8.053 8.053 0 0 0-.172 1.507A6.5 6.5 0 0 1 8.5 2Zm.16 8.006c.355-.451.759-.864 1.202-1.23a3.5 3.5 0 0 0-4.022.95.75.75 0 1 0 1.14.974 2 2 0 0 1 1.68-.694ZM7.5 6.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm4 0a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm1 8a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm5.458 2.042a.75.75 0 0 1 .082 1.058 4 4 0 0 1-6.075.005.75.75 0 0 1 1.138-.977 2.499 2.499 0 0 0 3.797-.003.75.75 0 0 1 1.058-.083ZM17.5 14.5a1 1 0 1 0 0-2 1 1 0 0 0 0 2ZM15 22a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0-1.5a5.5 5.5 0 1 1 0-11 5.5 5.5 0 0 1 0 11Z" fill="currentColor"/></svg>',
    image_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 1 0-1.06 1.06l1.263 1.264A3.235 3.235 0 0 0 3 6.25v11.5A3.25 3.25 0 0 0 6.25 21h11.5c.626 0 1.21-.177 1.706-.483l1.263 1.264a.75.75 0 0 0 1.061-1.061L3.28 2.22Zm8.788 10.909 6.206 6.206.056.066a1.746 1.746 0 0 1-.58.099H6.25c-.204 0-.4-.035-.582-.099l5.807-5.686.593-.586Zm-.95-.95a2.245 2.245 0 0 0-.692.464l-5.823 5.7a1.747 1.747 0 0 1-.103-.593V6.25c0-.206.036-.404.101-.588l6.518 6.518ZM19.5 16.318V6.25a1.75 1.75 0 0 0-1.75-1.75H7.682L6.182 3H17.75A3.25 3.25 0 0 1 21 6.25v11.568l-1.5-1.5Z" fill="currentColor"/><path d="M15.252 6.5a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" fill="currentColor"/></svg>',
    disconnected: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l3.364 3.365a11.99 11.99 0 0 0-2.033 1.634c-.49.489-.964 1.069-1.394 1.689a.75.75 0 1 0 1.233.855c.381-.55.8-1.062 1.222-1.484a10.468 10.468 0 0 1 2.063-1.604l1.591 1.592a8.062 8.062 0 0 0-1.923 1.424c-.61.61-1.109 1.3-1.491 2.056a.75.75 0 1 0 1.338.677 6.51 6.51 0 0 1 1.214-1.673 6.546 6.546 0 0 1 1.984-1.362l1.93 1.93a5.07 5.07 0 0 0-2.876 1.44 5.11 5.11 0 0 0-1.061 1.57.75.75 0 0 0 1.374.602c.185-.422.437-.8.747-1.111a3.59 3.59 0 0 1 3.36-.958l7.858 7.858a.75.75 0 0 0 1.06-1.06L3.28 2.22Zm8.304 6.182 1.584 1.584a6.532 6.532 0 0 1 3.516 1.825 6.798 6.798 0 0 1 1.217 1.692.75.75 0 1 0 1.336-.683 8.292 8.292 0 0 0-1.492-2.07 8.042 8.042 0 0 0-6.16-2.348ZM8.487 5.305 9.713 6.53a10.44 10.44 0 0 1 10.908 4.297.75.75 0 1 0 1.235-.852 11.946 11.946 0 0 0-13.369-4.67Zm4.573 11.134a1.5 1.5 0 1 1-2.121 2.122 1.5 1.5 0 0 1 2.121-2.122Z" fill="currentColor"/></svg>',
    wand: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m13.314 7.565-.136.126-10.48 10.488a2.27 2.27 0 0 0 3.211 3.208L16.388 10.9a2.251 2.251 0 0 0-.001-3.182l-.157-.146a2.25 2.25 0 0 0-2.916-.007Zm-.848 2.961 1.088 1.088-8.706 8.713a.77.77 0 1 1-1.089-1.088l8.707-8.713Zm4.386 4.48L16.75 15a.75.75 0 0 0-.743.648L16 15.75v.75h-.75a.75.75 0 0 0-.743.648l-.007.102c0 .38.282.694.648.743l.102.007H16v.75c0 .38.282.694.648.743l.102.007a.75.75 0 0 0 .743-.648l.007-.102V18h.75a.75.75 0 0 0 .743-.648L19 17.25a.75.75 0 0 0-.648-.743l-.102-.007h-.75v-.75a.75.75 0 0 0-.648-.743L16.75 15l.102.007Zm-1.553-6.254.027.027a.751.751 0 0 1 0 1.061l-.711.713-1.089-1.089.73-.73a.75.75 0 0 1 1.043.018ZM6.852 5.007 6.75 5a.75.75 0 0 0-.743.648L6 5.75v.75h-.75a.75.75 0 0 0-.743.648L4.5 7.25c0 .38.282.693.648.743L5.25 8H6v.75c0 .38.282.693.648.743l.102.007a.75.75 0 0 0 .743-.648L7.5 8.75V8h.75a.75.75 0 0 0 .743-.648L9 7.25a.75.75 0 0 0-.648-.743L8.25 6.5H7.5v-.75a.75.75 0 0 0-.648-.743L6.75 5l.102.007Zm12-2L18.75 3a.75.75 0 0 0-.743.648L18 3.75v.75h-.75a.75.75 0 0 0-.743.648l-.007.102c0 .38.282.693.648.743L17.25 6H18v.75c0 .38.282.693.648.743l.102.007a.75.75 0 0 0 .743-.648l.007-.102V6h.75a.75.75 0 0 0 .743-.648L21 5.25a.75.75 0 0 0-.648-.743L20.25 4.5h-.75v-.75a.75.75 0 0 0-.648-.743L18.75 3l.102.007Z" fill="currentColor"/></svg>',
    recording: '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z"/><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2ZM3.5 12a8.5 8.5 0 1 1 17 0 8.5 8.5 0 0 1-17 0Z"/></svg>',
    subtract: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.755 12.5h16.492a.75.75 0 0 0 0-1.5H3.755a.75.75 0 0 0 0 1.5Z" fill="currentColor"/></svg>',
    stop_recording: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 3.5C9.74566 3.5 7.58365 4.39553 5.98959 5.98959C4.39553 7.58365 3.5 9.74566 3.5 12C3.5 14.2543 4.39553 16.4163 5.98959 18.0104C7.58365 19.6045 9.74566 20.5 12 20.5C14.2543 20.5 16.4163 19.6045 18.0104 18.0104C19.6045 16.4163 20.5 14.2543 20.5 12C20.5 9.74566 19.6045 7.58365 18.0104 5.98959C16.4163 4.39553 14.2543 3.5 12 3.5ZM2 12C2 6.477 6.477 2 12 2C17.523 2 22 6.477 22 12C22 17.523 17.523 22 12 22C6.477 22 2 17.523 2 12ZM8 9.5C8 9.10218 8.15804 8.72064 8.43934 8.43934C8.72064 8.15804 9.10218 8 9.5 8H14.5C14.8978 8 15.2794 8.15804 15.5607 8.43934C15.842 8.72064 16 9.10218 16 9.5V14.5C16 14.8978 15.842 15.2794 15.5607 15.5607C15.2794 15.842 14.8978 16 14.5 16H9.5C9.10218 16 8.72064 15.842 8.43934 15.5607C8.15804 15.2794 8 14.8978 8 14.5V9.5Z" fill="currentColor"/></svg>',
    warning: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.91 2.782a2.25 2.25 0 0 1 2.975.74l.083.138 7.759 14.009a2.25 2.25 0 0 1-1.814 3.334l-.154.006H4.243a2.25 2.25 0 0 1-2.041-3.197l.072-.143L10.031 3.66a2.25 2.25 0 0 1 .878-.878Zm9.505 15.613-7.76-14.008a.75.75 0 0 0-1.254-.088l-.057.088-7.757 14.008a.75.75 0 0 0 .561 1.108l.095.006h15.516a.75.75 0 0 0 .696-1.028l-.04-.086-7.76-14.008 7.76 14.008ZM12 16.002a.999.999 0 1 1 0 1.997.999.999 0 0 1 0-1.997ZM11.995 8.5a.75.75 0 0 1 .744.647l.007.102.004 4.502a.75.75 0 0 1-1.494.103l-.006-.102-.004-4.502a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
    pin: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.242 2.932 4.826 4.826a2.75 2.75 0 0 1-.715 4.404l-4.87 2.435a.75.75 0 0 0-.374.426l-1.44 4.166a1.25 1.25 0 0 1-2.065.476L8.5 16.561 4.06 21H3v-1.06l4.44-4.44-3.105-3.104a1.25 1.25 0 0 1 .476-2.066l4.166-1.44a.75.75 0 0 0 .426-.373l2.435-4.87a2.75 2.75 0 0 1 4.405-.715Zm3.766 5.886-4.826-4.826a1.25 1.25 0 0 0-2.002.325l-2.435 4.871a2.25 2.25 0 0 1-1.278 1.12l-3.789 1.31 6.705 6.704 1.308-3.789a2.25 2.25 0 0 1 1.12-1.277l4.872-2.436a1.25 1.25 0 0 0 .325-2.002Z" fill="currentColor"/></svg>',
    pin_off: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l5.905 5.905L4.81 10.33a1.25 1.25 0 0 0-.476 2.065L7.439 15.5 3 19.94V21h1.06l4.44-4.44 3.105 3.105a1.25 1.25 0 0 0 2.065-.476l1.145-3.313 5.905 5.904a.75.75 0 0 0 1.06-1.06L3.28 2.22Zm10.355 12.476-1.252 3.626-6.705-6.705 3.626-1.252 4.331 4.331Zm6.048-3.876-3.787 1.894 1.118 1.118 3.34-1.67a2.75 2.75 0 0 0 .714-4.404l-4.825-4.826a2.75 2.75 0 0 0-4.405.715l-1.67 3.34 1.118 1.117 1.894-3.787a1.25 1.25 0 0 1 2.002-.325l4.826 4.826a1.25 1.25 0 0 1-.325 2.002Z" fill="currentColor"/></svg>',
    spinner: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="10" stroke-width="2" stroke="currentColor" stroke-opacity="0.2" vector-effect="non-scaling-stroke"/><path d="M22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7362 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" vector-effect="non-scaling-stroke"/></svg>',
    breakout_rooms: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.5 3a2.25 2.25 0 0 1 2.25 2.25v6h6A2.25 2.25 0 0 1 21 13.5v5.25A2.25 2.25 0 0 1 18.75 21H5.25A2.25 2.25 0 0 1 3 18.75V5.25A2.25 2.25 0 0 1 5.25 3h5.25Zm.75 9.75H4.5v6c0 .414.336.75.75.75h5.999l.001-6.75Zm7.5 0h-6.001v6.75h6.001a.75.75 0 0 0 .75-.75V13.5a.75.75 0 0 0-.75-.75ZM10.5 4.5H5.25a.75.75 0 0 0-.75.75v6h6.75v-6a.75.75 0 0 0-.75-.75Zm7.398-2.493L18 2a.75.75 0 0 1 .743.648l.007.102v2.5h2.5a.75.75 0 0 1 .743.648L22 6a.75.75 0 0 1-.648.743l-.102.007h-2.5v2.5a.75.75 0 0 1-.648.743L18 10a.75.75 0 0 1-.743-.648l-.007-.102v-2.5h-2.5a.75.75 0 0 1-.743-.648L14 6a.75.75 0 0 1 .648-.743l.102-.007h2.5v-2.5a.75.75 0 0 1 .648-.743Z" fill="currentColor"/></svg>',
    add: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M11.75 3a.75.75 0 0 1 .743.648l.007.102.001 7.25h7.253a.75.75 0 0 1 .102 1.493l-.102.007h-7.253l.002 7.25a.75.75 0 0 1-1.493.101l-.007-.102-.002-7.249H3.752a.75.75 0 0 1-.102-1.493L3.752 11h7.25L11 3.75a.75.75 0 0 1 .75-.75Z" fill="currentColor"/></svg>',
    shuffle: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M14.0058 8.11111H18.7947L16.9613 9.94444C16.9095 9.99587 16.8684 10.057 16.8402 10.1243C16.812 10.1917 16.7974 10.2639 16.7971 10.3369C16.7966 10.4843 16.8547 10.6259 16.9586 10.7306C17.01 10.7823 17.0711 10.8235 17.1385 10.8517C17.2058 10.8799 17.278 10.8945 17.351 10.8947C17.4985 10.8953 17.64 10.8372 17.7447 10.7333L20.8891 7.59999L20.4947 7.20555L17.7447 4.46111C17.64 4.35723 17.4985 4.29917 17.351 4.29969C17.2036 4.30021 17.0624 4.35927 16.9586 4.46388C16.8547 4.5685 16.7966 4.71009 16.7971 4.85751C16.7977 5.00494 16.8567 5.14612 16.9613 5.24999L18.728 6.99999H13.6669C13.5699 7.00058 13.4748 7.02653 13.391 7.07526C13.3072 7.12399 13.2376 7.19381 13.1891 7.27777L11.7224 9.82777L12.3669 10.9389L14.0058 8.11111Z" fill="currentColor"/><path d="M8.15022 15.9278H3.66688C3.51954 15.9278 3.37823 15.9863 3.27405 16.0905C3.16986 16.1947 3.11133 16.336 3.11133 16.4833C3.11133 16.6307 3.16986 16.772 3.27405 16.8762C3.37823 16.9804 3.51954 17.0389 3.66688 17.0389H8.47244C8.56939 17.0383 8.6645 17.0124 8.74832 16.9636C8.83214 16.9149 8.90174 16.8451 8.95022 16.7611L10.4335 14.2222L9.77799 13.1111L8.15022 15.9278Z"/><path d="M17.7447 13.2056C17.64 13.1017 17.4985 13.0436 17.351 13.0441C17.2036 13.0447 17.0624 13.1037 16.9586 13.2083C16.8547 13.3129 16.7966 13.4545 16.7971 13.602C16.7977 13.7494 16.8567 13.8906 16.9613 13.9944L18.9058 15.9389H14.0058L8.95022 7.29444C8.90174 7.21047 8.83214 7.14066 8.74832 7.09193C8.6645 7.04319 8.56939 7.01725 8.47244 7.01666H3.66688C3.51954 7.01666 3.37823 7.07519 3.27405 7.17938C3.16986 7.28357 3.11133 7.42487 3.11133 7.57222C3.11133 7.71956 3.16986 7.86087 3.27405 7.96505C3.37823 8.06924 3.51954 8.12777 3.66688 8.12777H8.15022L13.2058 16.7667C13.2542 16.8506 13.3239 16.9204 13.4077 16.9692C13.4915 17.0179 13.5866 17.0439 13.6836 17.0444H18.6113L16.9447 18.7111C16.8929 18.7625 16.8517 18.8237 16.8235 18.891C16.7954 18.9584 16.7807 19.0306 16.7805 19.1036C16.7802 19.1766 16.7943 19.2489 16.822 19.3165C16.8497 19.384 16.8905 19.4454 16.9419 19.4972C16.9933 19.549 17.0545 19.5902 17.1218 19.6184C17.1891 19.6465 17.2614 19.6612 17.3344 19.6614C17.4074 19.6617 17.4797 19.6476 17.5472 19.6199C17.6148 19.5922 17.6762 19.5514 17.728 19.5L20.478 16.7556L20.8724 16.3611L17.7447 13.2056Z"/></svg>',
    edit: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21.03 2.97a3.578 3.578 0 0 1 0 5.06L9.062 20a2.25 2.25 0 0 1-.999.58l-5.116 1.395a.75.75 0 0 1-.92-.921l1.395-5.116a2.25 2.25 0 0 1 .58-.999L15.97 2.97a3.578 3.578 0 0 1 5.06 0ZM15 6.06 5.062 16a.75.75 0 0 0-.193.333l-1.05 3.85 3.85-1.05A.75.75 0 0 0 8 18.938L17.94 9 15 6.06Zm2.03-2.03-.97.97L19 7.94l.97-.97a2.079 2.079 0 0 0-2.94-2.94Z" fill="currentColor"/></svg>',
    delete: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.75a3.25 3.25 0 0 1 3.245 3.066L15.25 5h5.25a.75.75 0 0 1 .102 1.493L20.5 6.5h-.796l-1.28 13.02a2.75 2.75 0 0 1-2.561 2.474l-.176.006H8.313a2.75 2.75 0 0 1-2.714-2.307l-.023-.174L4.295 6.5H3.5a.75.75 0 0 1-.743-.648L2.75 5.75a.75.75 0 0 1 .648-.743L3.5 5h5.25A3.25 3.25 0 0 1 12 1.75Zm6.197 4.75H5.802l1.267 12.872a1.25 1.25 0 0 0 1.117 1.122l.127.006h7.374c.6 0 1.109-.425 1.225-1.002l.02-.126L18.196 6.5ZM13.75 9.25a.75.75 0 0 1 .743.648L14.5 10v7a.75.75 0 0 1-1.493.102L13 17v-7a.75.75 0 0 1 .75-.75Zm-3.5 0a.75.75 0 0 1 .743.648L11 10v7a.75.75 0 0 1-1.493.102L9.5 17v-7a.75.75 0 0 1 .75-.75Zm1.75-6a1.75 1.75 0 0 0-1.744 1.606L10.25 5h3.5A1.75 1.75 0 0 0 12 3.25Z" fill="currentColor"/></svg>',
    back: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4.75 2a.75.75 0 0 1 .743.648l.007.102v5.69l4.574-4.56a6.41 6.41 0 0 1 8.879-.179l.186.18a6.41 6.41 0 0 1 0 9.063l-8.846 8.84a.75.75 0 0 1-1.06-1.062l8.845-8.838a4.91 4.91 0 0 0-6.766-7.112l-.178.17L6.562 9.5h5.688a.75.75 0 0 1 .743.648l.007.102a.75.75 0 0 1-.648.743L12.25 11h-7.5a.75.75 0 0 1-.743-.648L4 10.25v-7.5A.75.75 0 0 1 4.75 2Z" fill="currentColor"/></svg>',
    save: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.75A2.75 2.75 0 0 1 5.75 3h9.964a3.25 3.25 0 0 1 2.299.952l2.035 2.035c.61.61.952 1.437.952 2.299v9.964A2.75 2.75 0 0 1 18.25 21H5.75A2.75 2.75 0 0 1 3 18.25V5.75ZM5.75 4.5c-.69 0-1.25.56-1.25 1.25v12.5c0 .69.56 1.25 1.25 1.25H6v-5.25A2.25 2.25 0 0 1 8.25 12h7.5A2.25 2.25 0 0 1 18 14.25v5.25h.25c.69 0 1.25-.56 1.25-1.25V8.286c0-.465-.184-.91-.513-1.238l-2.035-2.035a1.75 1.75 0 0 0-.952-.49V7.25a2.25 2.25 0 0 1-2.25 2.25h-4.5A2.25 2.25 0 0 1 7 7.25V4.5H5.75Zm10.75 15v-5.25a.75.75 0 0 0-.75-.75h-7.5a.75.75 0 0 0-.75.75v5.25h9Zm-8-15v2.75c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75V4.5h-6Z" fill="currentColor"/></svg>',
    web: '<svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.999c5.524 0 10.002 4.478 10.002 10.002 0 5.523-4.478 10.001-10.002 10.001-5.524 0-10.002-4.478-10.002-10.001C1.998 6.477 6.476 1.999 12 1.999ZM14.939 16.5H9.06c.652 2.414 1.786 4.002 2.939 4.002s2.287-1.588 2.939-4.002Zm-7.43 0H4.785a8.532 8.532 0 0 0 4.094 3.411c-.522-.82-.953-1.846-1.27-3.015l-.102-.395Zm11.705 0h-2.722c-.324 1.335-.792 2.5-1.373 3.411a8.528 8.528 0 0 0 3.91-3.127l.185-.283ZM7.094 10H3.735l-.005.017a8.525 8.525 0 0 0-.233 1.984c0 1.056.193 2.067.545 3h3.173a20.847 20.847 0 0 1-.123-5Zm8.303 0H8.603a18.966 18.966 0 0 0 .135 5h6.524a18.974 18.974 0 0 0 .135-5Zm4.868 0h-3.358c.062.647.095 1.317.095 2a20.3 20.3 0 0 1-.218 3h3.173a8.482 8.482 0 0 0 .544-3c0-.689-.082-1.36-.236-2ZM8.88 4.09l-.023.008A8.531 8.531 0 0 0 4.25 8.5h3.048c.314-1.752.86-3.278 1.583-4.41ZM12 3.499l-.116.005C10.62 3.62 9.396 5.622 8.83 8.5h6.342c-.566-2.87-1.783-4.869-3.045-4.995L12 3.5Zm3.12.59.107.175c.669 1.112 1.177 2.572 1.475 4.237h3.048a8.533 8.533 0 0 0-4.339-4.29l-.291-.121Z" fill="currentColor"/></svg>',
    checkmark: '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="m18 6.7-8.48 8.48-3.54-3.54a.996.996 0 1 0-1.41 1.41l4.24 4.24c.39.39 1.02.39 1.41 0l9.18-9.18a.999.999 0 0 0-.01-1.42c-.37-.38-1-.38-1.39.01z"/></svg>',
    spotlight: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.745 4C20.3417 4 20.914 4.23705 21.336 4.65901C21.7579 5.08097 21.995 5.65326 21.995 6.25V12.805C21.5485 12.3774 21.0434 12.0154 20.495 11.73V6.25C20.495 6.05109 20.416 5.86032 20.2753 5.71967C20.1347 5.57902 19.9439 5.5 19.745 5.5H4.25C4.05109 5.5 3.86032 5.57902 3.71967 5.71967C3.57902 5.86032 3.5 6.05109 3.5 6.25V17.755C3.5 18.169 3.836 18.505 4.25 18.505L6.999 18.504L7 15.75C7.00002 15.3108 7.16517 14.8877 7.46268 14.5646C7.76019 14.2415 8.1683 14.0421 8.606 14.006L8.75 14H12.022C11.7223 14.4675 11.484 14.9716 11.313 15.5H8.75C8.69368 15.5001 8.63904 15.5192 8.59493 15.5542C8.55083 15.5893 8.51984 15.6382 8.507 15.693L8.5 15.75L8.499 18.504H11.077C11.1569 19.0193 11.2989 19.5229 11.5 20.004H4.25C3.65344 20.004 3.08129 19.7671 2.65936 19.3453C2.23744 18.9236 2.00027 18.3516 2 17.755V6.25C2 5.65326 2.23705 5.08097 2.65901 4.65901C3.08097 4.23705 3.65326 4 4.25 4H19.745Z"/><path d="M12 7C12.7956 7 13.5587 7.31607 14.1213 7.87868C14.6839 8.44129 15 9.20435 15 10C15 10.7956 14.6839 11.5587 14.1213 12.1213C13.5587 12.6839 12.7956 13 12 13C11.2044 13 10.4413 12.6839 9.87868 12.1213C9.31607 11.5587 9 10.7956 9 10C9 9.20435 9.31607 8.44129 9.87868 7.87868C10.4413 7.31607 11.2044 7 12 7ZM12 8.5C11.6022 8.5 11.2206 8.65804 10.9393 8.93934C10.658 9.22064 10.5 9.60218 10.5 10C10.5 10.3978 10.658 10.7794 10.9393 11.0607C11.2206 11.342 11.6022 11.5 12 11.5C12.3978 11.5 12.7794 11.342 13.0607 11.0607C13.342 10.7794 13.5 10.3978 13.5 10C13.5 9.60218 13.342 9.22064 13.0607 8.93934C12.7794 8.65804 12.3978 8.5 12 8.5Z"/><path d="M23 17.5C23 18.9587 22.4205 20.3576 21.3891 21.3891C20.3576 22.4205 18.9587 23 17.5 23C16.0413 23 14.6424 22.4205 13.6109 21.3891C12.5795 20.3576 12 18.9587 12 17.5C12 16.0413 12.5795 14.6424 13.6109 13.6109C14.6424 12.5795 16.0413 12 17.5 12C18.9587 12 20.3576 12.5795 21.3891 13.6109C22.4205 14.6424 23 16.0413 23 17.5ZM18.055 14.42C18.0207 14.2993 17.9479 14.193 17.8478 14.1174C17.7476 14.0417 17.6255 14.0008 17.5 14.0008C17.3745 14.0008 17.2524 14.0417 17.1522 14.1174C17.0521 14.193 16.9793 14.2993 16.945 14.42L16.388 16.208H14.585C14.019 16.208 13.785 16.962 14.242 17.308L15.7 18.413L15.143 20.2C14.968 20.761 15.584 21.228 16.042 20.881L17.5 19.777L18.958 20.881C19.416 21.228 20.032 20.761 19.857 20.201L19.3 18.413L20.758 17.309C21.216 16.962 20.981 16.208 20.415 16.208H18.612L18.055 14.421V14.42Z"/></svg>',
    join_stage: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path d="M17.5 22C14.4618 22 12 19.5376 12 16.5C12 13.4623 14.4618 11 17.5 11C20.5371 11 23 13.4624 23 16.5C23 19.5376 20.5371 22 17.5 22ZM17.0704 18.992L17.1167 19.0322C17.1868 19.0841 17.2716 19.1125 17.3588 19.1132C17.4461 19.1139 17.5314 19.0869 17.6023 19.036L17.654 18.992L17.6936 18.9458C17.7455 18.8757 17.7739 18.7909 17.7746 18.7037C17.7753 18.6164 17.7483 18.5311 17.6975 18.4602L17.6535 18.4085L16.158 16.9125H19.8375L19.8936 16.9092C19.9829 16.8969 20.0657 16.8558 20.1293 16.792C20.193 16.7282 20.234 16.6454 20.2462 16.5561L20.25 16.5005L20.2462 16.4444C20.2339 16.3553 20.1928 16.2725 20.1292 16.2089C20.0655 16.1452 19.9828 16.1041 19.8936 16.0919L19.8375 16.088H16.158L17.654 14.592L17.6941 14.5453C17.7537 14.4659 17.7827 14.3676 17.7756 14.2686C17.7686 14.1695 17.726 14.0763 17.6558 14.0061C17.5856 13.9359 17.4924 13.8934 17.3934 13.8863C17.2943 13.8793 17.1961 13.9082 17.1167 13.9678L17.071 14.0079L14.8699 16.2079L14.8303 16.2547C14.7784 16.3247 14.75 16.4094 14.7493 16.4965C14.7485 16.5837 14.7753 16.6688 14.8259 16.7398L14.8699 16.7915L17.0704 18.992Z"/><path d="M2.80546 3.80546C2.28973 4.32118 2 5.02065 2 5.75V16.25C2 16.6111 2.07113 16.9687 2.20933 17.3024C2.34753 17.636 2.5501 17.9392 2.80546 18.1945C3.06082 18.4499 3.36398 18.6525 3.69762 18.7907C4.03127 18.9289 4.38886 19 4.75 19H11.498C11.3 18.526 11.157 18.023 11.076 17.5H9.002V14.75C9.002 14.6837 9.02834 14.6201 9.07522 14.5732C9.12211 14.5263 9.1857 14.5 9.252 14.5H11.3135C11.4858 13.9665 11.7253 13.4632 12.0218 13H9.252C8.285 13 7.502 13.784 7.502 14.75V16H7.5V17.5H4.75C4.06 17.5 3.5 16.94 3.5 16.25V5.75C3.5 5.06 4.06 4.5 4.75 4.5H19.25C19.94 4.5 20.5 5.06 20.5 5.75V10.732C20.6457 10.808 20.7884 10.8895 20.9277 10.9762C20.9687 11.0017 21.0093 11.0276 21.0497 11.054C21.3899 11.2762 21.708 11.5294 22 11.8096V5.75C22 5.02065 21.7103 4.32118 21.1945 3.80546C20.6788 3.28973 19.9793 3 19.25 3H4.75C4.02065 3 3.32118 3.28973 2.80546 3.80546Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.4181 10.7757C14.7938 10.264 15 9.64262 15 9C15 8.20435 14.6839 7.44129 14.1213 6.87868C13.5587 6.31607 12.7956 6 12 6C11.2044 6 10.4413 6.31607 9.87868 6.87868C9.31607 7.44129 9 8.20435 9 9C9 9.79565 9.31607 10.5587 9.87868 11.1213C10.4413 11.6839 11.2044 12 12 12C12.333 12 12.6602 11.9446 12.9695 11.839C13.3992 11.4213 13.8864 11.0625 14.4181 10.7757ZM10.9393 7.93934C11.2206 7.65804 11.6022 7.5 12 7.5C12.3978 7.5 12.7794 7.65804 13.0607 7.93934C13.342 8.22064 13.5 8.60218 13.5 9C13.5 9.39782 13.342 9.77936 13.0607 10.0607C12.7794 10.342 12.3978 10.5 12 10.5C11.6022 10.5 11.2206 10.342 10.9393 10.0607C10.658 9.77936 10.5 9.39782 10.5 9C10.5 8.60218 10.658 8.22064 10.9393 7.93934Z"></svg>',
    leave_stage: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M2.80546 3.80546C2.28973 4.32118 2 5.02065 2 5.75V16.25C2 16.6111 2.07113 16.9687 2.20933 17.3024C2.34753 17.636 2.5501 17.9392 2.80546 18.1945C3.06082 18.4499 3.36398 18.6525 3.69762 18.7907C4.03127 18.9289 4.38886 19 4.75 19H11.498C11.3 18.526 11.157 18.023 11.076 17.5H9.002V14.75C9.002 14.6837 9.02834 14.6201 9.07522 14.5732C9.12211 14.5263 9.1857 14.5 9.252 14.5H11.3135C11.4858 13.9665 11.7253 13.4632 12.0218 13H9.252C8.285 13 7.502 13.784 7.502 14.75V16H7.5V17.5H4.75C4.06 17.5 3.5 16.94 3.5 16.25V5.75C3.5 5.06 4.06 4.5 4.75 4.5H19.25C19.94 4.5 20.5 5.06 20.5 5.75V10.732C20.6457 10.808 20.7884 10.8895 20.9277 10.9762C20.9687 11.0017 21.0093 11.0276 21.0497 11.054C21.3899 11.2762 21.708 11.5294 22 11.8096V5.75C22 5.02065 21.7103 4.32118 21.1945 3.80546C20.6788 3.28973 19.9793 3 19.25 3H4.75C4.02065 3 3.32118 3.28973 2.80546 3.80546Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M14.4181 10.7757C14.7938 10.264 15 9.64262 15 9C15 8.20435 14.6839 7.44129 14.1213 6.87868C13.5587 6.31607 12.7956 6 12 6C11.2044 6 10.4413 6.31607 9.87868 6.87868C9.31607 7.44129 9 8.20435 9 9C9 9.79565 9.31607 10.5587 9.87868 11.1213C10.4413 11.6839 11.2044 12 12 12C12.333 12 12.6602 11.9446 12.9695 11.839C13.3992 11.4213 13.8864 11.0625 14.4181 10.7757ZM10.9393 7.93934C11.2206 7.65804 11.6022 7.5 12 7.5C12.3978 7.5 12.7794 7.65804 13.0607 7.93934C13.342 8.22064 13.5 8.60218 13.5 9C13.5 9.39782 13.342 9.77936 13.0607 10.0607C12.7794 10.342 12.3978 10.5 12 10.5C11.6022 10.5 11.2206 10.342 10.9393 10.0607C10.658 9.77936 10.5 9.39782 10.5 9C10.5 8.60218 10.658 8.22064 10.9393 7.93934Z"/><path d="M17.5 11C20.5382 11 23 13.4624 23 16.5C23 19.5377 20.5382 22 17.5 22C14.4629 22 12 19.5377 12 16.5C12 13.4624 14.4629 11 17.5 11V11ZM17.9296 14.0079L17.8833 13.9678C17.8132 13.9159 17.7284 13.8875 17.6412 13.8868C17.5539 13.8861 17.4686 13.9131 17.3977 13.964L17.346 14.0079L17.3064 14.0542C17.2545 14.1243 17.2261 14.2091 17.2254 14.2963C17.2247 14.3836 17.2517 14.4689 17.3026 14.5398L17.3465 14.5915L18.842 16.0875H15.1625L15.1064 16.0908C15.0171 16.1031 14.9343 16.1442 14.8707 16.208C14.807 16.2718 14.766 16.3546 14.7539 16.4439L14.75 16.4995L14.7539 16.5556C14.7661 16.6447 14.8072 16.7275 14.8708 16.7911C14.9345 16.8548 15.0172 16.8959 15.1064 16.9081L15.1625 16.912H18.842L17.346 18.408L17.3059 18.4547C17.2463 18.5341 17.2173 18.6324 17.2244 18.7314C17.2314 18.8305 17.274 18.9237 17.3442 18.9939C17.4144 19.0641 17.5076 19.1066 17.6066 19.1137C17.7057 19.1207 17.8039 19.0918 17.8833 19.0322L17.929 18.9921L20.1301 16.7921L20.1697 16.7453C20.2216 16.6753 20.25 16.5906 20.2507 16.5035C20.2515 16.4163 20.2247 16.3312 20.1741 16.2602L20.1301 16.2085L17.9301 14.0079L17.8833 13.9678L17.9296 14.0079V14.0079Z"/></svg>',
    pip_off: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.8666 12.3058C11.0731 12.3058 11.2404 12.1385 11.2404 11.932V8.56753C11.2404 8.36107 11.0731 8.1937 10.8666 8.1937C10.6601 8.1937 10.4928 8.36107 10.4928 8.56753V11.0295L6.45393 6.99066C6.30794 6.84467 6.07124 6.84467 5.92525 6.99066C5.77926 7.13665 5.77926 7.37335 5.92525 7.51934L9.9641 11.5582L7.50212 11.5582C7.29566 11.5582 7.12829 11.7256 7.12829 11.932C7.12829 12.1385 7.29566 12.3058 7.50212 12.3058L10.8666 12.3058ZM5.73832 19.8879C3.6737 19.8879 2 18.2141 2 16.1495V7.73832C2 5.6737 3.6737 4 5.73832 4H18.2617C20.3263 4 22 5.6737 22 7.73832L22 13.0269C22 12.2687 21.6002 11.6038 21 11.2316C20.8468 11.1366 20.6806 11.0607 20.5047 11.0071V7.73832C20.5047 6.49955 19.5005 5.49533 18.2617 5.49533H5.73832C4.49955 5.49533 3.49533 6.49955 3.49533 7.73832V16.1495C3.49533 17.3883 4.49955 18.3925 5.73832 18.3925H10.7971C10.8506 18.5685 10.9266 18.7347 11.0216 18.8879C11.3938 19.4881 12.0587 19.8879 12.8169 19.8879H5.73832Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19.7265 12.5H13.3911C12.899 12.5 12.5 12.899 12.5 13.3911V17.6462C12.5 18.1384 12.899 18.5374 13.3911 18.5374H19.7265C20.2187 18.5374 20.6176 18.1384 20.6176 17.6462V13.3911C20.6176 12.899 20.2187 12.5 19.7265 12.5ZM13.3911 11.5C12.3467 11.5 11.5 12.3467 11.5 13.3911V17.6462C11.5 18.6907 12.3467 19.5374 13.3911 19.5374H19.7265C20.771 19.5374 21.6176 18.6907 21.6176 17.6462V13.3911C21.6176 12.3467 20.771 11.5 19.7265 11.5H13.3911Z"/></svg>',
    pip_on: '<svg viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.73832 19.8879C3.6737 19.8879 2 18.2141 2 16.1495V7.73832C2 5.6737 3.6737 4 5.73832 4H18.2617C20.3263 4 22 5.6737 22 7.73832L22 13.0269C22 12.2687 21.6002 11.6038 21 11.2316C20.8468 11.1366 20.6806 11.0607 20.5047 11.0071V7.73832C20.5047 6.49955 19.5005 5.49533 18.2617 5.49533H5.73832C4.49955 5.49533 3.49533 6.49955 3.49533 7.73832V16.1495C3.49533 17.3883 4.49955 18.3925 5.73832 18.3925H10.7971C10.8506 18.5685 10.9266 18.7347 11.0216 18.8879C11.3938 19.4881 12.0587 19.8879 12.8169 19.8879H5.73832Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19.7265 12.5H13.3911C12.899 12.5 12.5 12.899 12.5 13.3911V17.6462C12.5 18.1384 12.899 18.5374 13.3911 18.5374H19.7265C20.2187 18.5374 20.6176 18.1384 20.6176 17.6462V13.3911C20.6176 12.899 20.2187 12.5 19.7265 12.5ZM13.3911 11.5C12.3467 11.5 11.5 12.3467 11.5 13.3911V17.6462C11.5 18.6907 12.3467 19.5374 13.3911 19.5374H19.7265C20.771 19.5374 21.6176 18.6907 21.6176 17.6462V13.3911C21.6176 12.3467 20.771 11.5 19.7265 11.5H13.3911Z"/><path d="M6.18951 6.88123C5.98304 6.88123 5.81567 7.0486 5.81567 7.25506V10.6195C5.81567 10.826 5.98304 10.9934 6.18951 10.9934C6.39597 10.9934 6.56334 10.826 6.56334 10.6195V8.15757L10.6022 12.1964C10.7482 12.3424 10.9849 12.3424 11.1309 12.1964C11.2769 12.0504 11.2769 11.8137 11.1309 11.6677L7.09202 7.62889L9.55399 7.62889C9.76045 7.62889 9.92782 7.46152 9.92782 7.25506C9.92782 7.0486 9.76045 6.88123 9.55399 6.88123L6.18951 6.88123Z"/></svg>',
    signal_1: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3z"></path></svg>',
    signal_2: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7z"></path></svg>',
    signal_3: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2z"></path></svg>',
    signal_4: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2zm4-3h2v14h-2z"></path></svg>',
    signal_5: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 16h2v5H3zm4-3h2v8H7zm4-3h2v11h-2zm4-3h2v14h-2zm4-3h2v17h-2z"></path></svg>',
    start_livestream: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M6.343 4.938a1 1 0 0 1 0 1.415a8.003 8.003 0 0 0 0 11.317a1 1 0 1 1-1.415 1.414c-3.906-3.906-3.906-10.24 0-14.146a1 1 0 0 1 1.415 0Zm12.731 0c3.906 3.907 3.906 10.24 0 14.146a1 1 0 0 1-1.414-1.414a8.003 8.003 0 0 0 0-11.317a1 1 0 0 1 1.414-1.415ZM9.31 7.812a1 1 0 0 1 0 1.414a3.92 3.92 0 0 0 0 5.544a1 1 0 1 1-1.414 1.414a5.92 5.92 0 0 1 0-8.372a1 1 0 0 1 1.414 0Zm6.959 0a5.92 5.92 0 0 1 0 8.372a1 1 0 0 1-1.415-1.414a3.92 3.92 0 0 0 0-5.544a1 1 0 0 1 1.415-1.414Zm-4.187 2.77a1.5 1.5 0 1 1 0 3a1.5 1.5 0 0 1 0-3Z"/></svg>',
    stop_livestream: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill="currentColor" d="M2.854 2.146a.5.5 0 1 0-.708.708l1.811 1.81A8.218 8.218 0 0 0 2 10a8.228 8.228 0 0 0 2.604 6.015a.725.725 0 0 0 1.01-.025c.316-.316.277-.819-.027-1.11A6.73 6.73 0 0 1 3.5 10c0-1.62.57-3.107 1.522-4.27l.712.71A5.726 5.726 0 0 0 4.5 10c0 1.691.73 3.213 1.893 4.264a.713.713 0 0 0 .983-.037c.328-.328.267-.844-.041-1.134A4.238 4.238 0 0 1 6 10c0-.93.298-1.789.804-2.489l1.842 1.842a1.5 1.5 0 0 0 2 2l6.5 6.5a.5.5 0 0 0 .708-.707l-1.811-1.81l-1.065-1.066l-.712-.71l-1.07-1.072l-1.842-1.841l-2-2L7.4 6.693l-.942-.942l-.82-.82l-.944-.944l-1.841-1.842Zm13.794 12.38A8.212 8.212 0 0 0 18 10c0-2.283-.928-4.35-2.426-5.843a.726.726 0 0 0-1.027.01c-.31.31-.28.8.01 1.095A6.727 6.727 0 0 1 16.5 10a6.718 6.718 0 0 1-.94 3.438l1.088 1.089Zm-1.822-1.822A5.73 5.73 0 0 0 15.5 10a5.733 5.733 0 0 0-1.706-4.087a.714.714 0 0 0-1.008.016c-.319.318-.272.816.014 1.111A4.235 4.235 0 0 1 14 10c0 .557-.107 1.09-.302 1.577l1.128 1.127Z"/></svg>',
    viewers: '<svg fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 9.005a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5ZM12 5.5c4.613 0 8.596 3.15 9.701 7.564a.75.75 0 1 1-1.455.365 8.503 8.503 0 0 0-16.493.004.75.75 0 0 1-1.455-.363A10.003 10.003 0 0 1 12 5.5Z" fill="currentColor"/></svg>',
    debug: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m10.05 15.42 6.256-8.476a.694.694 0 0 1 1.235.57l-.03.098-3.87 9.8a2.07 2.07 0 1 1-3.737-1.766l.069-.115.076-.11 6.257-8.477-6.257 8.476Zm2.05-4.549-1.226 1.66a3.32 3.32 0 0 0-2.29 3.024.75.75 0 0 1-1.5-.063A4.819 4.819 0 0 1 9.14 11.74c.9-.631 1.942-.911 2.961-.87Zm4.167 2.752c.28.586.436 1.22.463 1.866a.75.75 0 0 1-1.376.444l.913-2.31Zm-2.233-5.37-.969 1.311a6.22 6.22 0 0 0-4.736 1.02 6.208 6.208 0 0 0-2.419 3.39.75.75 0 0 1-1.442-.412 7.708 7.708 0 0 1 3-4.207 7.724 7.724 0 0 1 6.566-1.102Zm3.51 2.138c.25.267.486.556.702.865a7.727 7.727 0 0 1 1.097 2.288.75.75 0 0 1-1.44.417 6.23 6.23 0 0 0-.885-1.845l-.102-.138.627-1.587ZM15.98 5.852l-.088.054c-.123.082-.236.18-.337.295l-.096.12-.54.732a9.138 9.138 0 0 0-8.261 1.146A9.103 9.103 0 0 0 3.38 12.37a.75.75 0 1 1-1.398-.543A10.603 10.603 0 0 1 5.799 6.97 10.642 10.642 0 0 1 15.98 5.852Zm2.629 1.562a10.646 10.646 0 0 1 2.022 2.171c.49.702.892 1.451 1.199 2.235a.75.75 0 1 1-1.397.547 9.188 9.188 0 0 0-2.327-3.405l.381-.964c.076-.19.115-.388.122-.584Z" fill="currentColor"/></svg>',
    info: '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 1.999c5.524 0 10.002 4.478 10.002 10.002 0 5.523-4.478 10.001-10.002 10.001-5.524 0-10.002-4.478-10.002-10.001C1.998 6.477 6.476 1.999 12 1.999Zm0 1.5a8.502 8.502 0 1 0 0 17.003A8.502 8.502 0 0 0 12 3.5Zm-.004 7a.75.75 0 0 1 .744.648l.007.102.003 5.502a.75.75 0 0 1-1.493.102l-.007-.101-.003-5.502a.75.75 0 0 1 .75-.75ZM12 7.003a.999.999 0 1 1 0 1.997.999.999 0 0 1 0-1.997Z" fill="currentColor"/></svg>',
    devices: '<svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Zm5.5-8.5V9a5.5 5.5 0 1 0-11 0v1H9a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H6.5v.25a2.25 2.25 0 0 0 2.096 2.245l.154.005h1.128a2.251 2.251 0 1 1 0 1.5H8.75a3.75 3.75 0 0 1-3.745-3.55L5 16.25V9a7 7 0 0 1 14 0v5a2 2 0 0 1-1.85 1.995L17 16h-2a1 1 0 0 1-.993-.883L14 15v-4a1 1 0 0 1 .883-.993L15 10h2.5Zm-9 1.5h-2v3h2v-3Zm9 0h-2v3H17a.5.5 0 0 0 .492-.41L17.5 14v-2.5Z" fill="currentColor"/></svg>',
    horizontal_dots: '<svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0ZM14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0ZM18 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill="currentColor"/></svg>',
    ai_sparkle: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 49 48" fill="none"><path fill="#F13E1B" d="m30.023 15.96.07.016a1.362 1.362 0 0 1 .657 2.068c-.163.23-.392.403-.658.497l-3.444 1.118a7.095 7.095 0 0 0-4.495 4.492l-1.12 3.442a1.357 1.357 0 0 1-1.267.907h-.016a1.361 1.361 0 0 1-1.283-.907l-1.12-3.442a7.091 7.091 0 0 0-4.495-4.509l-3.444-1.119a1.36 1.36 0 0 1 0-2.564l3.444-1.118a7.097 7.097 0 0 0 4.427-4.492l1.119-3.442a1.36 1.36 0 0 1 2.566 0l1.12 3.442a7.09 7.09 0 0 0 4.495 4.492l3.444 1.118Zm9.195 16.007-2.755-.894a5.678 5.678 0 0 1-3.596-3.594l-.896-2.753a1.087 1.087 0 0 0-2.053 0l-.895 2.753a5.672 5.672 0 0 1-3.541 3.594l-2.756.894a1.088 1.088 0 0 0 0 2.052l2.756.895a5.675 5.675 0 0 1 3.596 3.607l.896 2.753a1.088 1.088 0 0 0 2.052 0l.896-2.753a5.672 5.672 0 0 1 3.596-3.594l2.756-.894a1.088 1.088 0 0 0 0-2.052l-.056-.014Z"/><path fill="#2160FD" d="m39.218 31.967-2.755-.894a5.677 5.677 0 0 1-3.596-3.594l-.896-2.753a1.087 1.087 0 0 0-2.053 0l-.895 2.753a5.672 5.672 0 0 1-3.541 3.594l-2.756.894a1.088 1.088 0 0 0 0 2.052l2.756.895a5.675 5.675 0 0 1 3.596 3.607l.896 2.753a1.088 1.088 0 0 0 2.052 0l.896-2.753a5.672 5.672 0 0 1 3.596-3.594l2.756-.894a1.088 1.088 0 0 0 0-2.052l-.056-.014Z"/></svg>',
    meeting_ai: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" fill="none"><path fill="#F13E1B" d="M9.111 12.888a4.98 4.98 0 0 0-1.075-.8l-.04.048a4.651 4.651 0 0 0-.903-.424l-2.446-.8a.963.963 0 0 1-.467-.356.953.953 0 0 1 0-1.116.955.955 0 0 1 .467-.352l2.446-.8A5.088 5.088 0 0 0 9.04 7.06a5.048 5.048 0 0 0 1.2-1.904l.02-.064.799-2.444A.97.97 0 0 1 11.969 2a.97.97 0 0 1 .91.648l.8 2.444a5.147 5.147 0 0 0 1.219 1.976 5.042 5.042 0 0 0 1.974 1.2l2.45.8h.048c.188.067.351.19.468.352.115.164.176.36.175.56.001.2-.06.396-.175.56a1 1 0 0 1-.468.352l-2.446.8a5.067 5.067 0 0 0-1.978 1.2 5.096 5.096 0 0 0-1.199 1.976l-.8 2.448-.023.06a1.02 1.02 0 0 1-.184.284.967.967 0 0 1-.703.3 1 1 0 0 1-.927-.644l-.8-2.448a5.11 5.11 0 0 0-.799-1.508 5.16 5.16 0 0 0-.4-.472Zm10.434 5.396a.492.492 0 0 1 .176-.236.473.473 0 0 1 .1-.048.466.466 0 0 1 .168-.04c.1 0 .197.031.28.088l.091.072a.456.456 0 0 1 .096.164l.4 1.224c.124.372.332.71.607.988.278.276.616.484.987.608l1.223.4h.028l.084.04a.536.536 0 0 1 .148.136c.056.082.087.18.088.28a.484.484 0 0 1-.32.456l-1.227.4a2.528 2.528 0 0 0-1.595 1.6l-.399 1.224a.46.46 0 0 1-.176.232.464.464 0 0 1-.28.088.475.475 0 0 1-.455-.32l-.4-1.224a2.507 2.507 0 0 0-.611-.992 2.487 2.487 0 0 0-.987-.612l-1.223-.4a.48.48 0 0 1 0-.908l1.223-.4c.367-.128.7-.337.975-.612.137-.142.257-.3.36-.468.1-.162.18-.335.24-.516l.399-1.224Z"/><path fill="currentColor" d="M19.545 18.284a.492.492 0 0 1 .176-.236.469.469 0 0 1 .1-.048.466.466 0 0 1 .168-.04c.1 0 .197.031.28.088l.091.072a.456.456 0 0 1 .096.164l.4 1.224c.124.372.332.71.607.988.279.276.616.484.988.608l1.222.4h.028l.084.04a.534.534 0 0 1 .148.136c.057.082.087.18.088.28a.484.484 0 0 1-.32.456l-1.227.4a2.528 2.528 0 0 0-1.595 1.6l-.399 1.224a.46.46 0 0 1-.175.232.464.464 0 0 1-.28.088.475.475 0 0 1-.456-.32l-.4-1.224a2.509 2.509 0 0 0-.61-.992 2.487 2.487 0 0 0-.988-.612l-1.223-.4a.48.48 0 0 1 0-.908l1.223-.4c.367-.128.7-.337.975-.612a2.7 2.7 0 0 0 .36-.468c.1-.162.18-.335.24-.516l.4-1.224Z"/></svg>',
    create_channel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"><path fill="currentColor" d="M2 14.75A3.25 3.25 0 0 0 5.25 18H6v2.75a1.25 1.25 0 0 0 1.999 1l2.125-1.59.396-1.583c.071-.286.177-.56.312-.82L7.5 20.252 7.499 16.5H5.25a1.75 1.75 0 0 1-1.75-1.75v-8.5c0-.966.784-1.75 1.75-1.75h13.5c.966 0 1.75.784 1.75 1.75v3.845a3.27 3.27 0 0 1 1.5.83V6.25A3.25 3.25 0 0 0 18.75 3H5.25A3.25 3.25 0 0 0 2 6.25v8.5Z"/><path fill="currentColor" d="m18.098 11.67-5.902 5.902a2.684 2.684 0 0 0-.707 1.247l-.458 1.831a1.087 1.087 0 0 0 1.319 1.318l1.83-.457a2.685 2.685 0 0 0 1.248-.707l5.902-5.902a2.285 2.285 0 1 0-3.232-3.232Z"/></svg>',
    create_channel_illustration: '<svg width="503" height="362" viewBox="0 0 503 362" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M93.3477 192.893C93.3477 190.684 95.1385 188.893 97.3477 188.893H476C478.209 188.893 480 190.684 480 192.893V311.824C480 314.033 478.209 315.824 476 315.824H469.354C467.145 315.824 465.354 317.615 465.354 319.824V339.364C465.354 342.928 461.045 344.712 458.525 342.193L433.328 316.996C432.578 316.245 431.561 315.824 430.5 315.824H97.3477C95.1385 315.824 93.3477 314.033 93.3477 311.824V192.893Z" fill="#282828"/> <path d="M306.606 230.9H136.121C134.648 230.9 133.453 232.095 133.453 233.568C133.453 235.041 134.648 236.236 136.121 236.236H306.606C308.079 236.236 309.274 235.041 309.274 233.568C309.274 232.095 308.079 230.9 306.606 230.9Z" fill="#2160FD"/> <path d="M437.226 249.358H136.121C134.648 249.358 133.453 250.553 133.453 252.026C133.453 253.499 134.648 254.694 136.121 254.694H437.226C438.7 254.694 439.894 253.499 439.894 252.026C439.894 250.553 438.7 249.358 437.226 249.358Z" fill="#5C5C5C"/> <path d="M436.926 267.816H136.121C134.648 267.816 133.453 269.011 133.453 270.484C133.453 271.957 134.648 273.152 136.121 273.152H436.926C438.4 273.152 439.594 271.957 439.594 270.484C439.594 269.011 438.399 267.816 436.926 267.816Z" fill="#5C5C5C"/> <path d="M411.652 23C411.652 20.7909 409.861 19 407.652 19H29C26.7909 19 25 20.7909 25 23V141.931C25 144.14 26.7909 145.931 29 145.931H35.646C37.8551 145.931 39.646 147.722 39.646 149.931V169.472C39.646 173.036 43.9546 174.82 46.4745 172.3L71.6714 147.103C72.4216 146.352 73.439 145.931 74.4999 145.931H407.652C409.861 145.931 411.652 144.14 411.652 141.931V23Z" fill="#282828"/> <path d="M241.188 61.9839H70.703C69.2296 61.9839 68.0352 63.1783 68.0352 64.6517C68.0352 66.1252 69.2296 67.3196 70.703 67.3196H241.188C242.662 67.3196 243.856 66.1252 243.856 64.6517C243.856 63.1783 242.662 61.9839 241.188 61.9839Z" fill="#2160FD"/> <path d="M371.808 80.4419H70.703C69.2296 80.4419 68.0352 81.6363 68.0352 83.1098C68.0352 84.5832 69.2296 85.7776 70.703 85.7776H371.808C373.282 85.7776 374.476 84.5832 374.476 83.1098C374.476 81.6363 373.282 80.4419 371.808 80.4419Z" fill="#5C5C5C"/> <path d="M371.508 98.8999H70.703C69.2296 98.8999 68.0352 100.094 68.0352 101.568C68.0352 103.041 69.2296 104.236 70.703 104.236H371.508C372.982 104.236 374.176 103.041 374.176 101.568C374.176 100.094 372.982 98.8999 371.508 98.8999Z" fill="#5C5C5C"/> </svg>',
    captionsOn: '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.75 4A3.25 3.25 0 0 1 22 7.25v9.505a3.25 3.25 0 0 1-3.25 3.25H5.25A3.25 3.25 0 0 1 2 16.755V7.25a3.25 3.25 0 0 1 3.066-3.245L5.25 4h13.5Zm0 1.5H5.25l-.144.006A1.75 1.75 0 0 0 3.5 7.25v9.505c0 .966.784 1.75 1.75 1.75h13.5a1.75 1.75 0 0 0 1.75-1.75V7.25a1.75 1.75 0 0 0-1.75-1.75ZM5.5 12c0-3.146 2.713-4.775 5.122-3.401A.75.75 0 0 1 9.878 9.9C8.481 9.104 7 9.994 7 12c0 2.005 1.484 2.896 2.88 2.103a.75.75 0 0 1 .74 1.304C8.216 16.775 5.5 15.143 5.5 12Zm7.5 0c0-3.146 2.713-4.775 5.122-3.401a.75.75 0 0 1-.744 1.302C15.981 9.104 14.5 9.994 14.5 12c0 2.005 1.484 2.896 2.88 2.103a.75.75 0 0 1 .74 1.304C15.716 16.775 13 15.143 13 12Z" fill="currentColor"/></svg>',
    captionsOff: '<svg width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l1.25 1.25A3.247 3.247 0 0 0 2 7.25v9.505a3.25 3.25 0 0 0 3.25 3.25h13.5c.063 0 .126-.002.188-.006l1.781 1.781a.75.75 0 0 0 1.061-1.06L3.28 2.22Zm14.164 16.284H5.25a1.75 1.75 0 0 1-1.75-1.75V7.25c0-.727.443-1.35 1.074-1.615l2.828 2.828C6.292 9.043 5.5 10.3 5.5 12c0 3.143 2.715 4.775 5.12 3.406a.75.75 0 0 0-.74-1.303C8.483 14.896 7 14.005 7 12c0-1.37.69-2.22 1.573-2.366l8.87 8.87Zm2.986-1.256c.045-.157.07-.322.07-.494V7.25a1.75 1.75 0 0 0-1.75-1.75H8.682L7.182 4H18.75A3.25 3.25 0 0 1 22 7.25v9.505c0 .593-.159 1.148-.436 1.627l-1.134-1.134Zm-5.877-5.877-1.197-1.197c.813-1.888 2.882-2.65 4.766-1.575a.75.75 0 0 1-.744 1.302c-1.241-.708-2.549-.085-2.825 1.47Z" fill="currentColor"/></svg>',
  };

  const getIconPack = async (url) => {
    // check for both null/undefined
    if (url == null) {
      return defaultIconPack;
    }
    try {
      const res = await fetch(url);
      if (!res.ok) {
        return defaultIconPack;
      }
      // merge defaultIconPack with the received iconPack so as to
      // fill the missing icons with default ones
      return Object.assign({}, defaultIconPack, await res.json());
    }
    catch (_) {
      return defaultIconPack;
    }
  };

  const sm = 640;
  const md = 768;
  const lg = 1080;
  const xl = 2160;
  const breakpoints = {
  	sm: sm,
  	md: md,
  	lg: lg,
  	xl: xl
  };

  /**
   * Get the screen breakpoint from a given width
   * @param width The width of the container
   * @returns The screen breakpoint value
   */
  const getSize = (width) => {
    if (width >= breakpoints.lg)
      return 'lg';
    else if (width >= breakpoints.md)
      return 'md';
    else
      return 'sm';
  };

  /**
   * Default language dictionary
   */
  const defaultLanguage = {
    about_call: 'About Call',
    screen: 'Screen',
    camera: 'Camera',
    leave: 'Leave',
    dismiss: 'Dismiss',
    logo: 'Logo',
    page: 'Page',
    more: 'More',
    'page.prev': 'Previous Page',
    'page.next': 'Next Page',
    layout: 'Layout',
    'layout.auto': 'Auto Layout',
    settings: 'Settings',
    file: 'File',
    image: 'Image',
    connection: 'Connection',
    leave_confirmation: 'Are you sure you want to leave the call?',
    cancel: 'Cancel',
    yes: 'Yes',
    '(you)': '(you)',
    you: 'You',
    everyone: 'Everyone',
    to: 'To',
    mute: 'Mute',
    kick: 'Kick',
    pin: 'Pin',
    pinned: 'Pinned',
    accept: 'Accept',
    unpin: 'Unpin',
    pip_on: 'Show PiP',
    pip_off: 'Hide PiP',
    viewers: 'Viewers',
    join: 'Join',
    joined: 'Joined',
    create: 'Create',
    close: 'Close',
    ask: 'Ask',
    type: 'Type',
    activate: 'Activate',
    requests: 'Requests',
    mic_off: 'Mic Off',
    disable_mic: 'Disable Mic',
    mic_on: 'Mic On',
    enable_mic: 'Enable Mic',
    audio: 'Audio',
    test: 'Test',
    mute_all: 'Mute all',
    'mute_all.description': 'Everyone in the meeting will be muted.',
    'mute_all.header': 'Are you sure?',
    'mute_all.allow_unmute': 'Allow others to unmute',
    video_off: 'Video Off',
    disable_video: 'Disable Video',
    video_on: 'Video On',
    enable_video: 'Enable Video',
    video: 'Video',
    offline: "You're offline",
    'offline.description': 'Please ensure that you are connected to the internet.',
    disconnected: "You haven't joined the meeting.",
    failed: "You've been disconnected",
    'failed.description': 'We could not connect you back to the meeting room. Please try rejoining the meeting.',
    'disconnected.description': 'Please join the meeting in order to see and interact with other participants.',
    participants: 'Participants',
    'participants.errors.empty_results': "Couldn't find a participant with the specified name or ID.",
    'participants.empty_list': 'It looks like nobody is here.',
    'participants.no_pending_requests': 'There are no pending requests.',
    'participants.turn_off_video': 'Turn off video',
    polls: 'Polls',
    'polls.by': 'Poll by',
    'polls.question': 'Poll Question',
    'polls.question.placeholder': 'What is your poll for?',
    'polls.answers': 'Answers',
    'polls.option': 'Add an option.',
    'polls.option.placeholder': 'Enter an option',
    'polls.results.anon': 'Anonymous',
    'polls.results.hide': 'Hide results before voting',
    'polls.create': 'Create Poll',
    'polls.cancel': 'Cancel Poll Creation',
    'polls.empty': 'No polls available',
    'polls.errors.question_required': 'Question is required.',
    'polls.errors.empty_option': 'Empty options not allowed.',
    screenshare: 'Screen Share',
    'screenshare.min_preview': 'Minimize Preview',
    'screenshare.max_preview': 'Expand Preview',
    'screenshare.shared': 'Your screen is being shared.',
    'screenshare.start': 'Share Screen',
    'screenshare.stop': 'Stop Sharing',
    'screenshare.error.unknown': 'An error occured while starting screenshare.',
    'screenshare.error.max_count': 'Maximum screen share limit reached.',
    plugins: 'Plugins',
    perm_denied: 'Permission denied by browser.',
    'perm_denied.audio': 'Mic Permission denied by browser',
    'perm_denied.video': 'Camera Permission denied by browser',
    'perm_denied.screenshare': 'Screenshare Permission denied by browser',
    'perm_denied.audio.chrome.message': `In the top navigation bar, click on the icon left to the URL and ensure  'Microphone' permission is checked`,
    'perm_denied.video.chrome.message': `In the top navigation bar, click on the icon left to the URL and ensure  'Camera' permission is checked`,
    'perm_denied.screenshare.chrome.message': `Under Chrome settings, navigate to 'Privacy and Security > Site Settings > Permissions'. Select 'Screenshare', provide permission and reload this application.`,
    'perm_denied.audio.safari.message': `Under Safari settings, navigate to 'Websites > Microphone', provide permission and reload this application.`,
    'perm_denied.video.safari.message': `Under Safari settings, navigate to 'Websites > Camera', provide permission and reload this application.`,
    'perm_denied.screenshare.safari.message': `Under Safari settings, navigate to 'Websites > Screenshare', provide permission and reload this application.`,
    'perm_denied.audio.edge.message': `Under Edge settings, navigate to 'Site Permissions > Microphone', provide permission and reload this application.`,
    'perm_denied.video.edge.message': `Under Edge settings, navigate to 'Site Permissions > Camera', provide permission and reload this application.`,
    'perm_denied.screenshare.edge.message': `Under Edge settings, navigate to 'Site Permissions > Screenshare', provide permission and reload this application.`,
    'perm_denied.audio.microsoft edge.message': `Under Edge settings, navigate to 'Site Permissions > Microphone', provide permission and reload this application.`,
    'perm_denied.video.microsoft edge.message': `Under Edge settings, navigate to 'Site Permissions > Camera', provide permission and reload this application.`,
    'perm_denied.screenshare.microsoft edge.message': `Under Edge settings, navigate to 'Site Permissions > Screenshare', provide permission and reload this application.`,
    'perm_denied.audio.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Microphone', provide permission and reload this application.`,
    'perm_denied.video.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Camera', provide permission and reload this application.`,
    'perm_denied.screenshare.firefox.message': `Under Firefox settings, navigate to 'Privacy and Security > Permissions > Screenshare', provide permission and reload this application.`,
    'perm_denied.audio.others.message': `From your browser settings, enable 'Microphone' permissions and reload this application.`,
    'perm_denied.video.others.message': `From your browser settings, enable 'Camera' permissions and reload this application.`,
    'perm_denied.screenshare.others.message': `From your browser settings, enable 'Screenshare' permissions and reload this application.`,
    perm_sys_denied: 'Permission denied by system',
    'perm_sys_denied.audio': 'Mic permission denied by system',
    'perm_sys_denied.video': 'Camera permission denied by system',
    'perm_sys_denied.screenshare': 'Screenshare permission denied by system',
    'perm_sys_denied.audio.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Microphone'. Allow access to your browser and reload this application.`,
    'perm_sys_denied.video.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Camera'. Allow access to your browser and reload this application.`,
    'perm_sys_denied.screenshare.macos.message': `Open Apple Menu, Navigate to 'System Settings > Privacy & Security > Screenshare'. Allow access to your browser and reload this application.`,
    'perm_sys_denied.audio.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Microphone', allow access to your browser and reload this application.`,
    'perm_sys_denied.video.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Camera', allow access to your browser and reload this application.`,
    'perm_sys_denied.screenshare.ios.message': `On your iPhone, navigate to 'Settings > Privacy > Screenshare', allow access to your browser and reload this application.`,
    'perm_sys_denied.audio.windows.message': `Go to windows settings, select 'Settings > Privacy > Microphone'. Allow permissions to your browser and reload this application.`,
    'perm_sys_denied.video.windows.message': `Go to windows settings, select 'Settings > Privacy > Camera'. Allow permissions to your browser and reload this application.`,
    'perm_sys_denied.screenshare.windows.message': `Go to windows settings, select 'Settings > Privacy > Screenshare'. Allow permissions to your browser and reload this application.`,
    'perm_sys_denied.audio.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Microphone permissions and reload this application.`,
    'perm_sys_denied.video.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Camera permissions and reload this application.`,
    'perm_sys_denied.screenshare.android.message': `On you device, navigate to 'Settings > Apps'. Select your browser, allow Screenshare permissions and reload this application.`,
    'perm_sys_denied.audio.others.message': `Navigate to your system settings. Allow 'Microphone' permissions for your browser and reload this application.`,
    'perm_sys_denied.video.others.message': `Navigate to your system settings. Allow 'Camera' permissions for your browser and reload this application.`,
    'perm_sys_denied.screenshare.others.message': `Navigate to your system settings. Allow 'Screenshare' permissions for your browser and reload this application.`,
    perm_could_not_start: `Could not capture device.`,
    'perm_could_not_start.audio': `Unable to start your Microphone`,
    'perm_could_not_start.video': `Unable to start your Camera`,
    'perm_could_not_start.screenshare': `Unable to start your Screenshare`,
    'perm_could_not_start.audio.message': `Looks like the system could not capture your microphone. Please restart your device or upgrade your browser to fix this.`,
    'perm_could_not_start.video.message': `Looks like the system could not capture your camera. Please restart your device or upgrade your browser to fix this.`,
    'perm_could_not_start.screenshare.message': `Looks like the system could not capture your screenshare. Please restart your device or upgrade your browser to fix this.`,
    full_screen: 'Full Screen',
    'full_screen.exit': 'Exit Full Screen',
    'waitlist.header_title': 'Waiting',
    'waitlist.body_text': 'You are in the waiting room, the host will let you in soon.',
    'waitlist.deny_request': 'Deny request',
    'waitlist.accept_request': 'Accept request',
    'waitlist.accept_all': 'Accept all',
    'stage_request.header_title': 'Join Stage Requests',
    'stage_request.deny_request': 'Deny request',
    'stage_request.accept_request': 'Accept request',
    'stage_request.accept_all': 'Accept all',
    'stage_request.deny_all': 'Deny all',
    'stage_request.approval_pending': 'Pending',
    'stage_request.denied': 'Denied',
    'stage_request.request': 'Join stage',
    'stage_request.requested': 'Requested',
    'stage_request.cancel_request': 'Cancel request',
    'stage_request.leave_stage': 'Leave stage',
    'stage_request.request_tip': 'Request to join the discussion',
    'stage_request.leave_tip': 'Leave the stage',
    'stage_request.pending_tip': 'Request pending',
    'stage_request.denied_tip': 'Rejected request',
    'stage.empty_host': 'The stage is empty',
    'stage.empty_host_summary': 'You are off stage. You can manage stage request from the participants tab.',
    'stage.empty_viewer': 'There is no one on stage',
    'stage.remove_from_stage': 'Remove from stage',
    'stage.invited_notification': 'has been invited to join stage.',
    'stage.add_to_stage': 'Invite to stage',
    'stage.join_title': 'Join Stage',
    'stage.join_summary': 'You are about to join the stage, your video & audio as shown above will be visible to all participants.',
    'stage.join_cancel': 'Cancel',
    'stage.join_confirm': 'Join',
    'setup_screen.join_in_as': 'Join in as',
    'setup_screen.joining_as': 'Joining as',
    'setup_screen.your_name': 'Your name',
    'stage.reconnecting': 'Reconnecting...',
    'recording.label': 'REC',
    'recording.indicator': 'This meeting is being recorded.',
    'recording.started': 'This meeting is being recorded.',
    'recording.stopped': 'Recording for this meeting has been stopped.',
    'recording.paused': 'Recording for this meeting has been paused.',
    'recording.error.start': 'Error while starting recording.',
    'recording.error.stop': 'Error while stopping recording',
    'recording.error.resume': 'Error while resuming recording',
    'recording.start': 'Start Recording',
    'recording.stop': 'Stop Recording',
    'recording.resume': 'Resume Recording',
    'recording.starting': 'Starting',
    'recording.stopping': 'Stopping',
    'recording.loading': 'Loading',
    'recording.idle': 'Record',
    audio_playback: 'Play Audio',
    'audio_playback.title': 'Allow Audio Playback',
    'audio_playback.description': 'In order to play audio properly on your device, click the button below.',
    breakout_rooms: 'Breakout Rooms',
    'breakout_rooms.room_config_header': 'Create Breakout',
    'breakout_rooms.join_breakout_header': 'Join Breakout',
    'breakout_rooms.empty': 'Nobody here yet.',
    'breakout_rooms.delete': 'Delete Room',
    'breakout_rooms.switch': 'Switch',
    'breakout_rooms.main_room': 'Main Room',
    'breakout_rooms.shuffle_participants': 'Shuffle Participants',
    'breakout_rooms.deselect': 'Deselect',
    'breakout_rooms.selected': 'selected',
    'breakout_rooms.num_of_rooms': 'No. of Rooms',
    'breakout_rooms.approx': 'Approx.',
    'breakout_rooms.participants_per_room': 'participants/room',
    'breakout_rooms.division_text': 'when equally divided.',
    'breakout_rooms.start_breakout': 'Start Breakout',
    'breakout_rooms.close_breakout': 'Close Breakout',
    'breakout_rooms.update_breakout': 'Update Breakout',
    'breakout_rooms.discard_changes': 'Discard Changes',
    'breakout_rooms.room': 'Room',
    'breakout_rooms.rooms': 'Rooms',
    'breakout_rooms.room_name': 'Room Name',
    'breakout_rooms.edit_room_name': 'Edit Room Name',
    'breakout_rooms.save_room_name': 'Save Room Name',
    'breakout_rooms.add_room': 'Add',
    'breakout_rooms.add_room_brief': 'Add Room',
    'breakout_rooms.select_all': 'Select all',
    'breakout_rooms.unassign_all': 'Unassign all',
    'breakout_rooms.assign': 'Assign',
    'breakout_rooms.assign_participants': 'Assign Participants',
    'breakout_rooms.none_assigned': 'No participants assigned yet',
    'breakout_rooms.drag_drop_participants': 'Drag and drop participants',
    'breakout_rooms.click_drop_participants': 'Click here to assign',
    'breakout_rooms.status.assign_multiple': 'Assign multiple participants at once by clicking and selecting them',
    'breakout_rooms.status.select_room': 'Select a room to assign',
    'breakout_rooms.ephemeral_status.participants_assigned': 'Participants assigned',
    'breakout_rooms.ephemeral_status.participants_assigned_randomly': 'Participants assigned randomly',
    'breakout_rooms.ephemeral_status.changes_discarded': 'Changes discarded',
    'breakout_rooms.confirm_modal.start_breakout.header': 'Start breakout rooms?',
    'breakout_rooms.confirm_modal.start_breakout.content': 'Once started, all participants will be moved to their assigned rooms.',
    'breakout_rooms.confirm_modal.start_breakout.cancelText': 'No, go back',
    'breakout_rooms.confirm_modal.start_breakout.ctaText': 'Yes, start',
    'breakout_rooms.confirm_modal.close_breakout.header': 'Close breakout rooms?',
    'breakout_rooms.confirm_modal.close_breakout.content': 'All breakout rooms will be closed & participants will be moved back to the main room.',
    'breakout_rooms.confirm_modal.close_breakout.ctaText': 'Yes, close breakout',
    'breakout_rooms.move_reason.started_msg': 'Starting breakout rooms...',
    'breakout_rooms.move_reason.started_desc': 'You are being moved to your assigned room',
    'breakout_rooms.move_reason.closed_msg': 'Closing Breakout rooms...',
    'breakout_rooms.move_reason.closed_desc': 'You are being moved back to the main room',
    'breakout_rooms.move_reason.switch_room': 'Joining Breakout Room...',
    'breakout_rooms.move_reason.switch_main_room': 'Joining Main Room...',
    'breakout_rooms.all_assigned': 'All participants have been assigned',
    'breakout_rooms.empty_main_room': 'No more participants in the main room.',
    'breakout_rooms.leave_confirmation': 'Are you sure you want to leave the call? You are in a breakout room, you can join the main room too.',
    'breakout_rooms.leave_confirmation.main_room_btn': 'Go back to main room',
    ai: 'AI',
    'ai.meeting_ai': 'MeetingAI',
    'ai.home': 'Home',
    'ai.transcriptions': 'Transcriptions',
    'ai.personal': 'Personal',
    'ai.caption_view': 'Caption View',
    'ai.chat.tooltip': 'This conversation will just be visible to you and not to others in the call.',
    'ai.chat.summerise': 'Hey AI, summarise this call',
    'ai.chat.agenda': "Hey AI, what is today's agenda?",
    search: 'Search',
    'search.could_not_find': "Couldn't find a participant with the specified name or ID.",
    'search.empty': 'It looks like nobody is here.',
    end: 'End Meeting',
    'end.all': 'End meeting for all',
    ended: 'The meeting ended.',
    'ended.rejected': 'Your request to join the meeting was denied.',
    'ended.left': 'You left the meeting.',
    'ended.kicked': 'You were removed from the meeting.',
    'ended.disconnected': 'The call ended because the connection was lost.',
    'ended.network': 'Please check your internet connection and try again.',
    network: 'Network',
    'network.reconnecting': 'Connection lost. Trying to reconnect.',
    'network.delay_extended': 'Taking too long to reconnect. Please check your network connection.',
    'network.disconnected': 'Could not reconnect. Please leave the meeting and try refreshing the window.',
    'network.leaving': 'Automatically leaving the meeting in 10 seconds.',
    'network.restored': 'Connection restored',
    'network.delay': 'Taking too long to reconnect.',
    'network.lost': 'Connection lost',
    'network.lost_extended': 'Connection lost. Please check your network connection.',
    livestream: 'Livestream',
    'livestream.indicator': 'This meeting is being livestreamed.',
    'livestream.skip': 'Skip to Live',
    'livestream.idle': 'Waiting to go live.',
    'livestream.starting': 'Livestream is starting...',
    'livestream.stopping': 'Livestream is stopping...',
    'livestream.error.not_supported': 'Player not supported.',
    'livestream.error.not_found': 'Playback URL not found.',
    'livestream.error.unknown': 'An unknown error occured.',
    'livestream.error.sync': 'Could not sync livestream please try again later.',
    'livestream.error.start': 'Error while starting livestream.',
    'livestream.error.stop': 'Error while stopping livestream.',
    'livestream.go_live': 'Go Live',
    'livestream.end_live': 'End Live',
    'livestream.error': 'Error',
    'cta.help': 'Need help on how to do this?',
    'cta.continue': 'Ignore',
    'cta.reload': 'Reload',
    'cta.confirmation': 'Are you sure?',
    'cta.system_settings': 'Open Settings',
    'remote_access.empty': 'There are no remote requests, yet.',
    'remote_access.requests': 'The following people have requested remote control to your screen share.',
    'remote_access.allow': 'Please select whom you want to give access to.',
    'remote_access.grant': 'Grant acess',
    'remote_access.indicator': 'Any plugin or screenshare you switch to will sync the change across the meeting',
    chat: 'Chat',
    'chat.new': 'New',
    'chat.max_limit_warning': 'Max Character Limit',
    'chat.rate_limit_error': 'Please wait before you can send another message',
    'chat.new_channel': 'Create new channel',
    'chat.channel_name': 'Enter channel name',
    'chat.member_name': 'Enter member name',
    'chat.add_members': 'Add members',
    'chat.delete_msg': 'Delete',
    'chat.edit_msg': 'Edit',
    'chat.send_msg': 'Send message',
    'chat.send_attachment': 'Drop files/images to send',
    'chat.send_img': 'Send an image',
    'chat.send_file': 'Send a file',
    'chat.send_emoji': 'Send an emoji',
    'chat.update_msg': 'Update message',
    'chat.channel_members': 'Channel Members',
    'chat.img.loading': 'Loading image',
    'chat.error.img_not_found': 'Image not found',
    'chat.error.empty_results': "Couldn't find a member with the specified name.",
    'chat.img.shared_by': 'Shared by',
    'chat.reply': 'Reply',
    'chat.message_placeholder': 'Message..',
    'chat.click_to_send': 'Click to send as message',
    'chat.search_msgs': 'Search messages',
    'chat.search_conversations': 'Search conversations',
    'chat.start_conversation': 'Start a conversation..',
    'chat.empty_search': 'No messages found',
    'chat.empty_channel': 'Send a message to get started',
    'chat.cancel_upload': 'Cancel upload',
    'chat.view_chats': 'View chats',
    'chat.everyone': 'everyone',
    'chat.pinned_msgs': 'Pinned messages',
    'chat.toggle_pinned_msgs': 'Toggle pinned messages',
    'date.today': 'Today',
    'date.yesteday': 'Yesterday',
    'date.sunday': 'Sunday',
    'date.monday': 'Monday',
    'date.tuesday': 'Tuesday',
    'date.wednesday': 'Wednesday',
    'date.thursday': 'Thursday',
    'date.friday': 'Friday',
    'date.saturday': 'Saturday',
    'list.empty': 'No items found',
    'grid.listening': 'Listening',
    'transcript.off': 'Turn off Transcripts',
    'transcript.on': 'Turn on Transcripts',
    'settings.notification_sound': 'Notification sound',
    'settings.microphone_input': 'Microphone',
    'settings.speaker_output': 'Speaker',
    'settings.mirror_video': 'Mirror my Video',
    'settings.camera_off': 'Camera is off',
    'dialog.close': 'Close dialog',
    'notifications.joined': 'just joined',
    'notifications.left': 'left',
    'notifications.requesting_to_join_meeting': 'is requesting to join the meeting',
    'notifications.requested_to_join_stage': 'has requested to join stage',
    'notifications.joined_stage': 'has joined stage',
    'notifications.request_to_join_accepted': 'Request to join accepted',
    'notifications.request_to_join_rejected': 'Request to join rejected',
    'notifications.accept': 'Accept',
    'notifications.new_poll_created_by': 'New poll created by',
    'notifications.connected_to': 'Connected to',
    'notifications.plugin_switched_to': 'Plugin switched to',
    'notifications.remote_control_requested': 'has requested for remote control',
    'notifications.remote_control_request_sent': 'Sent remote control request to',
    'notifications.remote_control_request_accepted': 'has granted remote control',
    'notifications.remote_control_granted': 'Granted remote control to',
    'notifications.remote_control_terminated': 'Existing remote control has been terminated',
    'debugger.troubleshooting.label': 'Troubleshooting',
    'debugger.quality.good': 'Good',
    'debugger.quality.average': 'Average',
    'debugger.quality.poor': 'Poor',
    'debugger.stats.bitrate.label': 'Bitrate',
    'debugger.stats.bitrate.description': 'Data transmitted per second, affects quality and file size.',
    'debugger.stats.packet_loss.label': 'Packet Loss',
    'debugger.stats.packet_loss.description': 'Amount of data lost during transfer',
    'debugger.stats.jitter.label': 'Jitter',
    'debugger.stats.jitter.description': 'Variance or fluctuation in latency',
    'debugger.stats.cpu_limitations.label': 'CPU Limitations',
    'debugger.stats.cpu_limitations.description': 'CPU limitations can impact WebRTC call quality and performance.',
    'debugger.stats.bandwidth_limitations.label': 'Bandwidth Limitations',
    'debugger.stats.bandwidth_limitations.description': 'Slow internet speeds can degrade video quality.',
    'debugger.audio.label': 'Audio',
    'debugger.audio.troubleshooting.label': 'Audio Troubleshooting',
    'debugger.audio.messages.generating_report': 'Generating report. Please wait for a few seconds.',
    'debugger.audio.messages.enable_media': 'Please enable mic to see the report.',
    'debugger.audio.sections.network_media': 'Network & Media',
    'debugger.video.label': 'Video',
    'debugger.video.troubleshooting.label': 'Video Troubleshooting',
    'debugger.video.messages.generating_report': 'Generating report. Please wait for a few seconds.',
    'debugger.video.messages.enable_media': 'Please enable camera to see the report.',
    'debugger.video.sections.network_media': 'Network & Media',
    'debugger.screenshare.label': 'Screenshare',
    'debugger.screenshare.troubleshooting.label': 'Screenshare Troubleshooting',
    'debugger.screenshare.sections.network_media': 'Network & Media',
    'debugger.screenshare.messages.generating_report': 'Generating report. Please wait for a few seconds.',
    'debugger.screenshare.messages.enable_media': 'Please share screen to see the report.',
    'debugger.system.label': 'System',
    'debugger.system.troubleshooting.label': 'System Troubleshooting',
    'debugger.system.sections.battery': 'Battery',
    'debugger.system.battery.level.label': 'Battery Level',
    'debugger.system.battery.level.description': 'A low battery charge may result in reduced performance.',
    'debugger.system.battery.charging.label': 'Battery Charging Status',
    'debugger.system.battery.charging.description': 'A device running on power performs optimally.',
    'debugger.system.battery.charging.is_charging': 'Charging',
    'debugger.system.battery.charging.is_not_charging': 'Not charging',
  };

  /**
   * Creates an i18n instance from a language dictionary/object.
   * @param lang The language dictionary
   * @returns A function which handles i18n
   */
  const useLanguage = (lang = defaultLanguage) => {
    const locale = Object.assign({}, defaultLanguage, lang);
    return (key) => {
      var _a;
      return (_a = locale[key]) !== null && _a !== undefined ? _a : key;
    };
  };

  /**
   * Computes selectors and returns them based on their priority.
   */
  const computeSelectors = ({ element, size, states = {}, config = {}, }) => {
    let selectors = [];
    const data = config === null || config === undefined ? undefined : config.root[element];
    const add = (selector) => {
      selectors.push(selector);
      if (typeof size === 'string') {
        selectors.push(`${selector}.${size}`);
      }
    };
    add(element);
    if (typeof data === 'object' && !Array.isArray(data) && data !== null) {
      // check if the data variable is an object, strictly and not an array or just null
      const { state, states: elementStates } = data;
      let selector = element;
      let activeStates = [];
      if (Array.isArray(elementStates)) {
        activeStates = elementStates.filter((state) => states[state]);
        activeStates.sort();
        for (const state of activeStates) {
          add(`${selector}.${state}`);
        }
        if (activeStates.length > 1) {
          const booleanStateSelector = [selector, ...activeStates].join('.');
          add(booleanStateSelector);
        }
      }
      if (typeof state === 'string') {
        // dyte-meeting[meeting=joined]
        const keyValueSelector = `${element}[${state}=${states[state]}]`;
        add(keyValueSelector);
        for (const state of activeStates) {
          add(`${keyValueSelector}.${state}`);
        }
        if (activeStates.length > 1) {
          const withBooleanStateSelector = [keyValueSelector, ...activeStates].join('.');
          add(withBooleanStateSelector);
        }
      }
    }
    return selectors;
  };
  /**
   * Returns the computed styles - styles obtained from combining styles from all computed selectors
   * on the basis of their priorities.
   */
  const getComputedStyles = ({ selectors, styles }) => {
    if (!Array.isArray(selectors) || styles == null)
      return {};
    const computedStyles = {};
    for (const selector of selectors) {
      const style = styles[selector];
      if (style != null) {
        Object.assign(computedStyles, style);
      }
    }
    return computedStyles;
  };
  /**
   * Returns the computed children which are to be rendered inside an element
   */
  const getComputedChildren = ({ selectors, root }) => {
    if (!root || !Array.isArray(selectors))
      return [];
    let children = [];
    for (const selector of selectors) {
      const el = root[selector];
      if (Array.isArray(el)) {
        children = [...el];
      }
      else if (el) {
        if (el.children) {
          children = [...el.children];
        }
        if (Array.isArray(el.remove)) {
          for (const toRemove of el.remove) {
            children = children.filter((child) => {
              if (typeof child === 'string') {
                return child !== toRemove;
              }
              else if (Array.isArray(child)) {
                return child[0] !== toRemove;
              }
              return true;
            });
          }
        }
        if (el.addBefore) {
          for (const [beforeEl, toAdd] of Object.entries(el.addBefore)) {
            const idx = children.findIndex((child) => {
              if (typeof child === 'string') {
                return child === beforeEl;
              }
              else if (Array.isArray(child)) {
                return child[0] === beforeEl;
              }
              return false;
            });
            if (idx >= 0) {
              children.splice(idx, 0, ...toAdd);
            }
          }
        }
        if (Array.isArray(el.add)) {
          children = children.concat(el.add);
        }
        if (Array.isArray(el.prepend)) {
          children = el.prepend.concat(children);
        }
      }
    }
    return children;
  };

  /**
   * Renders the children of an element.
   */
  const RenderChildren = ({ elements, defaults, props = {}, deepProps = false, elementProps = {}, }) => {
    if (!Array.isArray(elements) || elements.length === 0)
      return null;
    return elements.map((element) => {
      return (h(Render, { element: element, defaults: defaults, props: props, childProps: deepProps && props, elementProps: elementProps }));
    });
  };
  const lenChildren = ({ element, defaults, props = {}, elementProps = {} }) => {
    var _a;
    const { config, size, states } = defaults;
    let Tag, configProps = {}, configChildren = [];
    if (Array.isArray(element)) {
      // get props if element is passed in array form:
      // ['dyte-participant-tile', { variant: 'gradient' }]
      [Tag, configProps, ...configChildren] = element;
    }
    else {
      Tag = element;
    }
    const elemData = (_a = config === null || config === undefined ? undefined : config.root) === null || _a === undefined ? undefined : _a[Tag];
    if (elemData != null && 'props' in elemData) {
      props = Object.assign(Object.assign({}, elemData['props']), props);
    }
    props = Object.assign(Object.assign({}, props), configProps);
    if (Tag in elementProps) {
      props = Object.assign(Object.assign({}, props), elementProps[Tag]);
    }
    const selectors = computeSelectors({ element: Tag, size, states, config });
    const computedChildren = getComputedChildren({ selectors, root: config.root });
    return computedChildren.length;
  };
  /**
   * Renders an element from UI Config
   */
  const Render = ({ element, defaults, childProps = {}, props = {}, onlyChildren = false, asHost = false, deepProps = false, elementProps = {}, }, children) => {
    var _a;
    const { config, size, states } = defaults;
    let Tag, configProps = {}, configChildren = [];
    if (Array.isArray(element)) {
      // get props if element is passed in array form:
      // ['dyte-participant-tile', { variant: 'gradient' }]
      [Tag, configProps, ...configChildren] = element;
    }
    else {
      Tag = element;
    }
    const elemData = (_a = config === null || config === undefined ? undefined : config.root) === null || _a === undefined ? undefined : _a[Tag];
    if (elemData != null && 'props' in elemData) {
      props = Object.assign(Object.assign({}, elemData['props']), props);
    }
    props = Object.assign(Object.assign({}, props), configProps);
    if (Tag in elementProps) {
      props = Object.assign(Object.assign({}, props), elementProps[Tag]);
    }
    const selectors = computeSelectors({ element: Tag, size, states, config });
    const computedChildren = getComputedChildren({ selectors, root: config.root });
    if (onlyChildren) {
      return (h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }));
    }
    const styles = getComputedStyles({ selectors, styles: config.styles });
    if (asHost) {
      return (h(Host, Object.assign({}, defaults, { style: styles }, props),
        h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
        children,
        configChildren.map((child) => {
          if (Array.isArray(child)) {
            const [Tag, props] = child;
            return h(Tag, Object.assign({}, defaults, props));
          }
          return child;
        })));
    }
    if (['dyte-header', 'dyte-controlbar'].includes(Tag)) {
      props['disableRender'] = true;
    }
    if (Tag.startsWith('dyte-')) {
      return (h(Tag, Object.assign({}, defaults, { style: styles }, props),
        h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
        children,
        configChildren.map((child) => {
          if (Array.isArray(child)) {
            const [Tag, props] = child;
            return h(Tag, Object.assign({}, defaults, props));
          }
          return child;
        })));
    }
    else {
      const [HTMLTag, id] = Tag.split('#');
      return (h(HTMLTag, Object.assign({ id: id, style: styles }, props),
        h(RenderChildren, { elements: computedChildren, defaults: defaults, props: childProps, deepProps: deepProps, elementProps: elementProps }),
        children,
        configChildren.map((child) => {
          if (Array.isArray(child)) {
            const [Tag, props] = child;
            return h(Tag, Object.assign({}, defaults, props));
          }
          return child;
        })));
    }
  };

  const handler = {
    get: (target, name, receiver) => (...args) => {
      try {
        return Reflect.get(target, name, receiver).apply(target, args);
      }
      catch (_a) {
        return null;
      }
    },
  };
  let gracefulStorage;
  try {
    gracefulStorage = new Proxy(localStorage, handler);
  }
  catch (_a) {
    gracefulStorage = new Proxy({}, handler);
  }
  const gracefulStorage$1 = gracefulStorage;

  const KEY = 'dyte-prefs';
  const setPreference = (key, value) => {
    const data = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
    data[key] = JSON.stringify(value);
    gracefulStorage$1.setItem('dyte-prefs', JSON.stringify(data));
  };
  const getPreference = (key) => {
    const data = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
    return data[key];
  };
  const getUserPreferences = () => {
    const prefs = JSON.parse(gracefulStorage$1.getItem(KEY) || '{}');
    const mirrorVideo = prefs['mirror-video'] ? prefs['mirror-video'] === 'true' : true;
    const muteNotificationSounds = prefs['mute-notification-sounds']
      ? prefs['mute-notification-sounds'] === 'true'
      : false;
    return { mirrorVideo, muteNotificationSounds };
  };
  const chatUnreadTimestamps = {};

  const appendToMap = (map, propName, value) => {
      const items = map.get(propName);
      if (!items) {
          map.set(propName, [value]);
      }
      else if (!items.includes(value)) {
          items.push(value);
      }
  };
  const debounce$2 = (fn, ms) => {
      let timeoutId;
      return (...args) => {
          if (timeoutId) {
              clearTimeout(timeoutId);
          }
          timeoutId = setTimeout(() => {
              timeoutId = 0;
              fn(...args);
          }, ms);
      };
  };

  /**
   * Check if a possible element isConnected.
   * The property might not be there, so we check for it.
   *
   * We want it to return true if isConnected is not a property,
   * otherwise we would remove these elements and would not update.
   *
   * Better leak in Edge than to be useless.
   */
  const isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;
  const cleanupElements = debounce$2((map) => {
      for (let key of map.keys()) {
          map.set(key, map.get(key).filter(isConnected));
      }
  }, 2000);
  const stencilSubscription = () => {
      if (typeof getRenderingRef !== 'function') {
          // If we are not in a stencil project, we do nothing.
          // This function is not really exported by @stencil/core.
          return {};
      }
      const elmsToUpdate = new Map();
      return {
          dispose: () => elmsToUpdate.clear(),
          get: (propName) => {
              const elm = getRenderingRef();
              if (elm) {
                  appendToMap(elmsToUpdate, propName, elm);
              }
          },
          set: (propName) => {
              const elements = elmsToUpdate.get(propName);
              if (elements) {
                  elmsToUpdate.set(propName, elements.filter(forceUpdate));
              }
              cleanupElements(elmsToUpdate);
          },
          reset: () => {
              elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));
              cleanupElements(elmsToUpdate);
          },
      };
  };

  const unwrap = (val) => (typeof val === 'function' ? val() : val);
  const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
      const unwrappedState = unwrap(defaultState);
      let states = new Map(Object.entries(unwrappedState !== null && unwrappedState !== undefined ? unwrappedState : {}));
      const handlers = {
          dispose: [],
          get: [],
          set: [],
          reset: [],
      };
      const reset = () => {
          var _a;
          // When resetting the state, the default state may be a function - unwrap it to invoke it.
          // otherwise, the state won't be properly reset
          states = new Map(Object.entries((_a = unwrap(defaultState)) !== null && _a !== undefined ? _a : {}));
          handlers.reset.forEach((cb) => cb());
      };
      const dispose = () => {
          // Call first dispose as resetting the state would
          // cause less updates ;)
          handlers.dispose.forEach((cb) => cb());
          reset();
      };
      const get = (propName) => {
          handlers.get.forEach((cb) => cb(propName));
          return states.get(propName);
      };
      const set = (propName, value) => {
          const oldValue = states.get(propName);
          if (shouldUpdate(value, oldValue, propName)) {
              states.set(propName, value);
              handlers.set.forEach((cb) => cb(propName, value, oldValue));
          }
      };
      const state = (typeof Proxy === 'undefined'
          ? {}
          : new Proxy(unwrappedState, {
              get(_, propName) {
                  return get(propName);
              },
              ownKeys(_) {
                  return Array.from(states.keys());
              },
              getOwnPropertyDescriptor() {
                  return {
                      enumerable: true,
                      configurable: true,
                  };
              },
              has(_, propName) {
                  return states.has(propName);
              },
              set(_, propName, value) {
                  set(propName, value);
                  return true;
              },
          }));
      const on = (eventName, callback) => {
          handlers[eventName].push(callback);
          return () => {
              removeFromArray(handlers[eventName], callback);
          };
      };
      const onChange = (propName, cb) => {
          const unSet = on('set', (key, newValue) => {
              if (key === propName) {
                  cb(newValue);
              }
          });
          // We need to unwrap the defaultState because it might be a function.
          // Otherwise we might not be sending the right reset value.
          const unReset = on('reset', () => cb(unwrap(defaultState)[propName]));
          return () => {
              unSet();
              unReset();
          };
      };
      const use = (...subscriptions) => {
          const unsubs = subscriptions.reduce((unsubs, subscription) => {
              if (subscription.set) {
                  unsubs.push(on('set', subscription.set));
              }
              if (subscription.get) {
                  unsubs.push(on('get', subscription.get));
              }
              if (subscription.reset) {
                  unsubs.push(on('reset', subscription.reset));
              }
              if (subscription.dispose) {
                  unsubs.push(on('dispose', subscription.dispose));
              }
              return unsubs;
          }, []);
          return () => unsubs.forEach((unsub) => unsub());
      };
      const forceUpdate = (key) => {
          const oldValue = states.get(key);
          handlers.set.forEach((cb) => cb(key, oldValue, oldValue));
      };
      return {
          state,
          get,
          set,
          on,
          onChange,
          use,
          dispose,
          reset,
          forceUpdate,
      };
  };
  const removeFromArray = (array, item) => {
      const index = array.indexOf(item);
      if (index >= 0) {
          array[index] = array[array.length - 1];
          array.length--;
      }
  };

  const createStore = (defaultState, shouldUpdate) => {
      const map = createObservableMap(defaultState, shouldUpdate);
      map.use(stencilSubscription());
      return map;
  };

  const { state, onChange } = createStore({
    prefs: getUserPreferences(),
  });

  var __classPrivateFieldSet = function (receiver, state, value, kind, f) {
    if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (state.set(receiver, value)), value;
  };
  var __classPrivateFieldGet = function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __rest = function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  };
  var _BreakoutRoomsManager_instances, _BreakoutRoomsManager_hasLocalChanges, _BreakoutRoomsManager_state, _BreakoutRoomsManager_participantsNewMeetingMap, _BreakoutRoomsManager_participantsOldMeetingMap, _BreakoutRoomsManager_meetingParticipantsMap, _BreakoutRoomsManager_allParticipantsMap, _BreakoutRoomsManager_allMeetingsMap, _BreakoutRoomsManager_meetingsToUpdate, _BreakoutRoomsManager_meetingsToDelete, _BreakoutRoomsManager_init, _BreakoutRoomsManager_addNewMeetingToState, _BreakoutRoomsManager_addNewParticipantToState, _BreakoutRoomsManager_replaceDraftMeetingIds, _BreakoutRoomsManager_getMeetingParticipants;
  class BreakoutRoomsManager {
    constructor() {
      _BreakoutRoomsManager_instances.add(this);
      _BreakoutRoomsManager_hasLocalChanges.set(this, false);
      _BreakoutRoomsManager_state.set(this, undefined);
      _BreakoutRoomsManager_participantsNewMeetingMap.set(this, undefined);
      _BreakoutRoomsManager_participantsOldMeetingMap.set(this, undefined);
      _BreakoutRoomsManager_meetingParticipantsMap.set(this, undefined);
      _BreakoutRoomsManager_allParticipantsMap.set(this, undefined);
      _BreakoutRoomsManager_allMeetingsMap.set(this, undefined);
      _BreakoutRoomsManager_meetingsToUpdate.set(this, undefined);
      _BreakoutRoomsManager_meetingsToDelete.set(this, undefined);
    }
    get hasLocalChanges() {
      return __classPrivateFieldGet(this, _BreakoutRoomsManager_hasLocalChanges, "f");
    }
    get currentState() {
      let parentMeeting;
      let meetings = [];
      Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").keys()).forEach((meetingId) => {
        const meeting = __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").get(meetingId);
        if (meeting.isParent) {
          parentMeeting = Object.assign(Object.assign({}, meeting), { participants: __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_getMeetingParticipants).call(this, meetingId) });
        }
        else {
          meetings.push(Object.assign(Object.assign({}, meeting), { participants: __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_getMeetingParticipants).call(this, meetingId) }));
        }
      });
      return {
        parentMeeting,
        meetings,
      };
    }
    get allConnectedMeetings() {
      return this.currentState.meetings.sort((a, b) => a.title.localeCompare(b.title));
    }
    get allParticipants() {
      return Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_allParticipantsMap, "f").values());
    }
    get unassignedParticipants() {
      return __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_getMeetingParticipants).call(this, __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.id);
    }
    /**
     * get participants of a meeting
     */
    getParticipantsForMeeting(meetingId) {
      return __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_getMeetingParticipants).call(this, meetingId);
    }
    /**
     * add a new connected meeting
     */
    addNewMeeting() {
      __classPrivateFieldSet(this, _BreakoutRoomsManager_hasLocalChanges, true);
      const _a = createDraftRoom(), meeting = __rest(_a, ["participants"]);
      __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_addNewMeetingToState).call(this, Object.assign(Object.assign({}, meeting), { isParent: false }));
      return meeting;
    }
    /**
     * add multiple new connected meetings
     */
    addNewMeetings(count) {
      return Array.from({ length: count }).map(() => this.addNewMeeting());
    }
    /**
     * update a meeting's title
     */
    updateMeetingTitle(meetingId, newTitle) {
      __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").get(meetingId).title = newTitle;
      if (!isDraftRoom(meetingId)) {
        __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingsToUpdate, "f").add(meetingId);
      }
    }
    /**
     * deleteMeeting
     */
    deleteMeeting(meetingId) {
      __classPrivateFieldSet(this, _BreakoutRoomsManager_hasLocalChanges, true);
      const meeting = __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").get(meetingId);
      const participants = __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_getMeetingParticipants).call(this, meeting.id).map(participantIdentifier);
      this.assignParticipantsToMeeting(participants, __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.id);
      __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").delete(meeting.id);
      __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").delete(meeting.id);
      if (!isDraftRoom(meeting.id)) {
        __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingsToDelete, "f").add(meeting.id);
      }
    }
    /**
     * assign participants to a meeting
     */
    assignParticipantsToMeeting(customParticipantIds, destinationMeetingId) {
      __classPrivateFieldSet(this, _BreakoutRoomsManager_hasLocalChanges, true);
      customParticipantIds.forEach((participantId) => {
        const currentMeetingId = __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").get(participantId);
        __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").get(currentMeetingId).delete(participantId);
        __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").get(destinationMeetingId).add(participantId);
        __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").set(participantId, destinationMeetingId);
      });
      return this.currentState;
    }
    /**
     * assign participants randomly
     */
    assignParticipantsRandomly() {
      const splits = splitCollection(this.unassignedParticipants, this.allConnectedMeetings.length);
      this.allConnectedMeetings.forEach((meeting, index) => {
        const toAssign = splits[index];
        if (toAssign && toAssign.length !== 0) {
          this.assignParticipantsToMeeting(toAssign.map((participant) => participant.customParticipantId), meeting.id);
        }
      });
      return this.currentState;
    }
    /**
     * unassign participants
     */
    unassignParticipants(customParticipantIds) {
      const destinationMeetingId = __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.id;
      return this.assignParticipantsToMeeting(customParticipantIds, destinationMeetingId);
    }
    /**
     * unassign all participants
     */
    unassignAllParticipants() {
      const destinationMeetingId = __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.id;
      const customParticipantIds = this.allParticipants.map(participantIdentifier);
      return this.assignParticipantsToMeeting(customParticipantIds, destinationMeetingId);
    }
    /**
     * update current state
     */
    updateCurrentState(state) {
      if (!__classPrivateFieldGet(this, _BreakoutRoomsManager_hasLocalChanges, "f")) {
        __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_init).call(this, state);
      }
      [state.parentMeeting, ...state.meetings].forEach((meeting, index) => {
        const draftMeeting = Object.assign(Object.assign({}, meeting), { isParent: index === 0 });
        __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_addNewMeetingToState).call(this, draftMeeting);
        meeting.participants.forEach((participant) => {
          __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_addNewParticipantToState).call(this, participant, draftMeeting);
        });
      });
    }
    get meetingsToCreate() {
      return this.allConnectedMeetings
        .filter((meeting) => isDraftRoom(meeting.id))
        .map(({ id, title }) => ({ id, title }));
    }
    get meetingsToUpdate() {
      return this.allConnectedMeetings
        .filter((meeting) => __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingsToUpdate, "f").has(meeting.id))
        .map(({ id, title }) => ({ id, title }));
    }
    get meetingsToDelete() {
      return Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_meetingsToDelete, "f"));
    }
    get participantsToMove() {
      // gather participants
      const moveMap = new Map();
      Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").keys()).forEach((participantId) => {
        const sourceMeetingId = __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsOldMeetingMap, "f").get(participantId);
        const destinationMeetingId = __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").get(participantId);
        if (sourceMeetingId === destinationMeetingId)
          return;
        const key = `${sourceMeetingId}__${destinationMeetingId}`;
        if (!moveMap.has(key)) {
          moveMap.set(key, []);
        }
        const participantDetails = __classPrivateFieldGet(this, _BreakoutRoomsManager_allParticipantsMap, "f").get(participantId);
        moveMap.get(key).push(participantDetails.id);
      });
      return Array.from(moveMap.keys()).map((key) => {
        const [sourceMeetingId, destinationMeetingId] = key.split('__');
        return {
          sourceMeetingId,
          destinationMeetingId,
          participantIds: moveMap.get(key),
        };
      });
    }
    async applyChanges(meeting) {
      // create new rooms
      const createMeetingsPromise = this.meetingsToCreate.length !== 0
        ? meeting.connectedMeetings.createMeetings(this.meetingsToCreate)
        : Promise.resolve([]);
      // update old rooms titles
      const updateMeetingsPromise = this.meetingsToUpdate.length !== 0
        ? meeting.connectedMeetings.updateMeetings(this.meetingsToUpdate)
        : Promise.resolve();
      const [createMeetingsResponse] = await Promise.all([
        createMeetingsPromise,
        updateMeetingsPromise,
      ]);
      // replace temporary ids
      if (createMeetingsResponse) {
        createMeetingsResponse.forEach((meeting) => {
          this.meetingsToCreate.forEach((draftMeeting) => {
            if (draftMeeting.title === meeting.title) {
              __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_replaceDraftMeetingIds).call(this, __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").get(draftMeeting.id), meeting.id);
            }
          });
        });
      }
      // move participants (no async)
      if (this.participantsToMove.length !== 0) {
        this.participantsToMove.forEach(({ sourceMeetingId, destinationMeetingId, participantIds }) => {
          meeting.connectedMeetings.moveParticipants(sourceMeetingId, destinationMeetingId, participantIds);
        });
      }
      // delete rooms
      if (this.meetingsToDelete.length !== 0) {
        meeting.connectedMeetings.deleteMeetings(this.meetingsToDelete);
      }
    }
    /**
     * discard local changes
     */
    discardChanges() {
      __classPrivateFieldSet(this, _BreakoutRoomsManager_hasLocalChanges, false);
      this.updateCurrentState(__classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f"));
      return this.currentState;
    }
  }
  _BreakoutRoomsManager_hasLocalChanges = new WeakMap(), _BreakoutRoomsManager_state = new WeakMap(), _BreakoutRoomsManager_participantsNewMeetingMap = new WeakMap(), _BreakoutRoomsManager_participantsOldMeetingMap = new WeakMap(), _BreakoutRoomsManager_meetingParticipantsMap = new WeakMap(), _BreakoutRoomsManager_allParticipantsMap = new WeakMap(), _BreakoutRoomsManager_allMeetingsMap = new WeakMap(), _BreakoutRoomsManager_meetingsToUpdate = new WeakMap(), _BreakoutRoomsManager_meetingsToDelete = new WeakMap(), _BreakoutRoomsManager_instances = new WeakSet(), _BreakoutRoomsManager_init = function _BreakoutRoomsManager_init(state) {
    __classPrivateFieldSet(this, _BreakoutRoomsManager_state, state);
    __classPrivateFieldSet(this, _BreakoutRoomsManager_allMeetingsMap, new Map());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_allParticipantsMap, new Map());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_meetingsToUpdate, new Set());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_meetingsToDelete, new Set());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_meetingParticipantsMap, new Map());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_participantsNewMeetingMap, new Map());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_participantsOldMeetingMap, new Map());
    __classPrivateFieldSet(this, _BreakoutRoomsManager_participantsOldMeetingMap, new Map());
    __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.participants.forEach((participant) => {
      __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsOldMeetingMap, "f").set(participantIdentifier(participant), __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").parentMeeting.id);
    });
    __classPrivateFieldGet(this, _BreakoutRoomsManager_state, "f").meetings.forEach((meeting) => {
      meeting.participants.forEach((participant) => {
        __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsOldMeetingMap, "f").set(participantIdentifier(participant), meeting.id);
      });
    });
  }, _BreakoutRoomsManager_addNewMeetingToState = function _BreakoutRoomsManager_addNewMeetingToState(meeting) {
    if (!__classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").has(meeting.id)) {
      __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").set(meeting.id, meeting);
      __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").set(meeting.id, new Set());
    }
  }, _BreakoutRoomsManager_addNewParticipantToState = function _BreakoutRoomsManager_addNewParticipantToState(participant, meeting) {
    if (__classPrivateFieldGet(this, _BreakoutRoomsManager_allParticipantsMap, "f").has(participantIdentifier(participant))) {
      return;
    }
    __classPrivateFieldGet(this, _BreakoutRoomsManager_allParticipantsMap, "f").set(participantIdentifier(participant), participant);
    __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").set(participantIdentifier(participant), meeting.id);
    __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").get(meeting.id).add(participantIdentifier(participant));
  }, _BreakoutRoomsManager_replaceDraftMeetingIds = function _BreakoutRoomsManager_replaceDraftMeetingIds(draftMeeting, realId) {
    const draftId = draftMeeting.id;
    __classPrivateFieldGet(this, _BreakoutRoomsManager_instances, "m", _BreakoutRoomsManager_addNewMeetingToState).call(this, Object.assign(Object.assign({}, draftMeeting), { id: realId }));
    __classPrivateFieldGet(this, _BreakoutRoomsManager_allMeetingsMap, "f").delete(draftId);
    const participantSet = __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").get(draftId);
    __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").set(realId, participantSet);
    __classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").delete(draftId);
    Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").keys()).forEach((participantId) => {
      if (__classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").get(participantId) === draftId) {
        __classPrivateFieldGet(this, _BreakoutRoomsManager_participantsNewMeetingMap, "f").set(participantId, realId);
      }
    });
  }, _BreakoutRoomsManager_getMeetingParticipants = function _BreakoutRoomsManager_getMeetingParticipants(meetingId) {
    const participantIds = Array.from(__classPrivateFieldGet(this, _BreakoutRoomsManager_meetingParticipantsMap, "f").get(meetingId));
    return participantIds.map((id) => __classPrivateFieldGet(this, _BreakoutRoomsManager_allParticipantsMap, "f").get(id));
  };

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
      if (typeof Map !== 'undefined') {
          return Map;
      }
      /**
       * Returns index in provided array that matches the specified key.
       *
       * @param {Array<Array>} arr
       * @param {*} key
       * @returns {number}
       */
      function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
              if (entry[0] === key) {
                  result = index;
                  return true;
              }
              return false;
          });
          return result;
      }
      return /** @class */ (function () {
          function class_1() {
              this.__entries__ = [];
          }
          Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function () {
                  return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
          });
          /**
           * @param {*} key
           * @returns {*}
           */
          class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
          };
          /**
           * @param {*} key
           * @param {*} value
           * @returns {void}
           */
          class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);
              if (~index) {
                  this.__entries__[index][1] = value;
              }
              else {
                  this.__entries__.push([key, value]);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);
              if (~index) {
                  entries.splice(index, 1);
              }
          };
          /**
           * @param {*} key
           * @returns {void}
           */
          class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
          };
          /**
           * @returns {void}
           */
          class_1.prototype.clear = function () {
              this.__entries__.splice(0);
          };
          /**
           * @param {Function} callback
           * @param {*} [ctx=null]
           * @returns {void}
           */
          class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === undefined) { ctx = null; }
              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                  var entry = _a[_i];
                  callback.call(ctx, entry[1], entry[0]);
              }
          };
          return class_1;
      }());
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
      if (typeof global !== 'undefined' && global.Math === Math) {
          return global;
      }
      if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
      }
      if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
      }
      // eslint-disable-next-line no-new-func
      return Function('return this')();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
      if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
      }
      return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle (callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      /**
       * Invokes the original callback function and schedules new invocation if
       * the "proxy" was called during current request.
       *
       * @returns {void}
       */
      function resolvePending() {
          if (leadingCall) {
              leadingCall = false;
              callback();
          }
          if (trailingCall) {
              proxy();
          }
      }
      /**
       * Callback invoked after the specified delay. It will further postpone
       * invocation of the original function delegating it to the
       * requestAnimationFrame.
       *
       * @returns {void}
       */
      function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
      }
      /**
       * Schedules invocation of the original function.
       *
       * @returns {void}
       */
      function proxy() {
          var timeStamp = Date.now();
          if (leadingCall) {
              // Reject immediately following calls.
              if (timeStamp - lastCallTime < trailingTimeout) {
                  return;
              }
              // Schedule new call to be in invoked when the pending one is resolved.
              // This is important for "transitions" which never actually start
              // immediately so there is a chance that we might miss one if change
              // happens amids the pending invocation.
              trailingCall = true;
          }
          else {
              leadingCall = true;
              trailingCall = false;
              setTimeout(timeoutCallback, delay);
          }
          lastCallTime = timeStamp;
      }
      return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== 'undefined';
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserverController.
       *
       * @private
       */
      function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */
          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */
          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */
          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      /**
       * Adds observer to observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be added.
       * @returns {void}
       */
      ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
              this.observers_.push(observer);
          }
          // Add listeners if they haven't been added yet.
          if (!this.connected_) {
              this.connect_();
          }
      };
      /**
       * Removes observer from observers list.
       *
       * @param {ResizeObserverSPI} observer - Observer to be removed.
       * @returns {void}
       */
      ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer);
          // Remove observer if it's present in registry.
          if (~index) {
              observers.splice(index, 1);
          }
          // Remove listeners if controller has no connected observers.
          if (!observers.length && this.connected_) {
              this.disconnect_();
          }
      };
      /**
       * Invokes the update of observers. It will continue running updates insofar
       * it detects changes.
       *
       * @returns {void}
       */
      ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_();
          // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.
          if (changesDetected) {
              this.refresh();
          }
      };
      /**
       * Updates every observer from observers list and notifies them of queued
       * entries.
       *
       * @private
       * @returns {boolean} Returns "true" if any observer has detected changes in
       *      dimensions of it's elements.
       */
      ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
              return observer.gatherActive(), observer.hasActive();
          });
          // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.
          activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
          return activeObservers.length > 0;
      };
      /**
       * Initializes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser || this.connected_) {
              return;
          }
          // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.
          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);
          if (mutationObserverSupported) {
              this.mutationsObserver_ = new MutationObserver(this.refresh);
              this.mutationsObserver_.observe(document, {
                  attributes: true,
                  childList: true,
                  characterData: true,
                  subtree: true
              });
          }
          else {
              document.addEventListener('DOMSubtreeModified', this.refresh);
              this.mutationEventsAdded_ = true;
          }
          this.connected_ = true;
      };
      /**
       * Removes DOM listeners.
       *
       * @private
       * @returns {void}
       */
      ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser || !this.connected_) {
              return;
          }
          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);
          if (this.mutationsObserver_) {
              this.mutationsObserver_.disconnect();
          }
          if (this.mutationEventsAdded_) {
              document.removeEventListener('DOMSubtreeModified', this.refresh);
          }
          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
      };
      /**
       * "Transitionend" event handler.
       *
       * @private
       * @param {TransitionEvent} event
       * @returns {void}
       */
      ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName, propertyName = _b === undefined ? '' : _b;
          // Detect whether transition may affect dimensions of an element.
          var isReflowProperty = transitionKeys.some(function (key) {
              return !!~propertyName.indexOf(key);
          });
          if (isReflowProperty) {
              this.refresh();
          }
      };
      /**
       * Returns instance of the ResizeObserverController.
       *
       * @returns {ResizeObserverController}
       */
      ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
              this.instance_ = new ResizeObserverController();
          }
          return this.instance_;
      };
      /**
       * Holds reference to the controller's instance.
       *
       * @private {ResizeObserverController}
       */
      ResizeObserverController.instance_ = null;
      return ResizeObserverController;
  }());

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = (function (target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
              value: props[key],
              enumerable: false,
              writable: false,
              configurable: true
          });
      }
      return target;
  });

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = (function (target) {
      // Assume that the element is an instance of Node, which means that it
      // has the "ownerDocument" property from which we can retrieve a
      // corresponding global object.
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      // Return the local global object if it's not possible extract one from
      // provided element.
      return ownerGlobal || global$1;
  });

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
      return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize(styles) {
      var positions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
      }
      return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
      }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
      var positions = ['top', 'right', 'bottom', 'left'];
      var paddings = {};
      for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
      }
      return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
      var bbox = target.getBBox();
      return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
      // Client width & height properties can't be
      // used exclusively as they provide rounded values.
      var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
      // By this condition we can catch all non-replaced inline, hidden and
      // detached elements. Though elements with width & height properties less
      // than 0.5 will be discarded as well.
      //
      // Without it we would need to implement separate methods for each of
      // those cases and it's not possible to perform a precise and performance
      // effective test for hidden elements. E.g. even jQuery's ':visible' filter
      // gives wrong results for elements with width & height less than 0.5.
      if (!clientWidth && !clientHeight) {
          return emptyRect;
      }
      var styles = getWindowOf(target).getComputedStyle(target);
      var paddings = getPaddings(styles);
      var horizPad = paddings.left + paddings.right;
      var vertPad = paddings.top + paddings.bottom;
      // Computed styles of width & height are being used because they are the
      // only dimensions available to JS that contain non-rounded values. It could
      // be possible to utilize the getBoundingClientRect if only it's data wasn't
      // affected by CSS transformations let alone paddings, borders and scroll bars.
      var width = toFloat(styles.width), height = toFloat(styles.height);
      // Width & height include paddings and borders when the 'border-box' box
      // model is applied (except for IE).
      if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
              width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }
          if (Math.round(height + vertPad) !== clientHeight) {
              height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
      }
      // Following steps can't be applied to the document's root element as its
      // client[Width/Height] properties represent viewport area of the window.
      // Besides, it's as well not necessary as the <html> itself neither has
      // rendered scroll bars nor it can be clipped.
      if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight;
          // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.
          if (Math.abs(vertScrollbar) !== 1) {
              width -= vertScrollbar;
          }
          if (Math.abs(horizScrollbar) !== 1) {
              height -= horizScrollbar;
          }
      }
      return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
      // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
      // interface.
      if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
      }
      // If it's so, then check that element is at least an instance of the
      // SVGElement and that it has the "getBBox" method.
      // eslint-disable-next-line no-extra-parens
      return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
          typeof target.getBBox === 'function'); };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
      return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
      if (!isBrowser) {
          return emptyRect;
      }
      if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
      }
      return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
      var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
      // If DOMRectReadOnly is available use it as a prototype for the rectangle.
      var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
      var rect = Object.create(Constr.prototype);
      // Rectangle's properties are not writable and non-enumerable.
      defineConfigurable(rect, {
          x: x, y: y, width: width, height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
      });
      return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
      return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObservation.
       *
       * @param {Element} target - Element to be observed.
       */
      function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */
          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */
          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
      }
      /**
       * Updates content rectangle and tells whether it's width or height properties
       * have changed since the last broadcast.
       *
       * @returns {boolean}
       */
      ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return (rect.width !== this.broadcastWidth ||
              rect.height !== this.broadcastHeight);
      };
      /**
       * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
       * from the corresponding properties of the last observed content rectangle.
       *
       * @returns {DOMRectInit} Last observed content rectangle.
       */
      ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
      };
      return ResizeObservation;
  }());

  var ResizeObserverEntry = /** @class */ (function () {
      /**
       * Creates an instance of ResizeObserverEntry.
       *
       * @param {Element} target - Element that is being observed.
       * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
       */
      function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit);
          // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.
          defineConfigurable(this, { target: target, contentRect: contentRect });
      }
      return ResizeObserverEntry;
  }());

  var ResizeObserverSPI = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback function that is invoked
       *      when one of the observed elements changes it's content dimensions.
       * @param {ResizeObserverController} controller - Controller instance which
       *      is responsible for the updates of observer.
       * @param {ResizeObserver} callbackCtx - Reference to the public
       *      ResizeObserver instance which will be passed to callback function.
       */
      function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */
          this.observations_ = new MapShim();
          if (typeof callback !== 'function') {
              throw new TypeError('The callback provided as parameter 1 is not a function.');
          }
          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
      }
      /**
       * Starts observing provided element.
       *
       * @param {Element} target - Element to be observed.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is already being observed.
          if (observations.has(target)) {
              return;
          }
          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this);
          // Force the update of observations.
          this.controller_.refresh();
      };
      /**
       * Stops observing provided element.
       *
       * @param {Element} target - Element to stop observing.
       * @returns {void}
       */
      ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          // Do nothing if current environment doesn't have the Element interface.
          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
              return;
          }
          if (!(target instanceof getWindowOf(target).Element)) {
              throw new TypeError('parameter 1 is not of type "Element".');
          }
          var observations = this.observations_;
          // Do nothing if element is not being observed.
          if (!observations.has(target)) {
              return;
          }
          observations.delete(target);
          if (!observations.size) {
              this.controller_.removeObserver(this);
          }
      };
      /**
       * Stops observing all elements.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
      };
      /**
       * Collects observation instances the associated element of which has changed
       * it's content rectangle.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;
          this.clearActive();
          this.observations_.forEach(function (observation) {
              if (observation.isActive()) {
                  _this.activeObservations_.push(observation);
              }
          });
      };
      /**
       * Invokes initial callback function with a list of ResizeObserverEntry
       * instances collected from active resize observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
              return;
          }
          var ctx = this.callbackCtx_;
          // Create ResizeObserverEntry instance for every active observation.
          var entries = this.activeObservations_.map(function (observation) {
              return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
      };
      /**
       * Clears the collection of active observations.
       *
       * @returns {void}
       */
      ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
      };
      /**
       * Tells whether observer has active observations.
       *
       * @returns {boolean}
       */
      ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI;
  }());

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver$1 = /** @class */ (function () {
      /**
       * Creates a new instance of ResizeObserver.
       *
       * @param {ResizeObserverCallback} callback - Callback that is invoked when
       *      dimensions of the observed elements change.
       */
      function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
              throw new TypeError('Cannot call a class as a function.');
          }
          if (!arguments.length) {
              throw new TypeError('1 argument required, but only 0 present.');
          }
          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
      }
      return ResizeObserver;
  }());
  // Expose public methods of ResizeObserver.
  [
      'observe',
      'unobserve',
      'disconnect'
  ].forEach(function (method) {
      ResizeObserver$1.prototype[method] = function () {
          var _a;
          return (_a = observers.get(this))[method].apply(_a, arguments);
      };
  });

  var index = (function () {
      // Export existing implementation if available.
      if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
      }
      return ResizeObserver$1;
  })();

  const dyteMeetingCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));overflow:hidden;position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);height:100%;width:100%}:host([mode='fill']){position:relative}";

  const DyteMeeting = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.roomJoinedListener = () => {
        this.setStates({ meeting: 'joined' });
        state.meeting = 'joined';
      };
      this.waitlistedListener = () => {
        this.setStates({ meeting: 'waiting' });
        state.meeting = 'waiting';
      };
      this.roomLeftListener = ({ state: state$1 }) => {
        // Let socketConnectionUpdate listener handle this case.
        if (state$1 === 'disconnected' || state$1 === 'failed')
          return;
        this.setStates({ meeting: 'ended', roomLeftState: state$1 });
        state.meeting = 'ended';
        state.roomLeftState = state$1;
      };
      this.mediaPermissionUpdateListener = ({ kind, message }) => {
        if (['audio', 'video'].includes(kind)) {
          console.log(message, state.activeDebugger);
          if ((message === 'DENIED' || message === 'SYSTEM_DENIED') &&
            state.activeDebugger !== true) {
            const permissionModalSettings = {
              enabled: true,
              kind,
            };
            this.setStates({ activePermissionsMessage: permissionModalSettings });
            state.activePermissionsMessage = permissionModalSettings;
          }
        }
      };
      this.socketConnectionUpdateListener = ({ state }) => {
        if (state === 'failed') {
          setTimeout(() => {
            this.meeting.leave('disconnected');
          }, this.leaveRoomTimer);
        }
      };
      this.loadConfigFromPreset = false;
      this.applyDesignSystem = false;
      this.mode = 'fixed';
      this.leaveOnUnmount = false;
      this.meeting = undefined;
      this.showSetupScreen = undefined;
      this.t = useLanguage();
      this.config = defaultConfig;
      this.iconPackUrl = undefined;
      this.size = undefined;
      this.gridLayout = 'row';
      this.states = {
        meeting: 'idle',
        prefs: getUserPreferences(),
      };
      this.iconPack = defaultIconPack;
    }
    connectedCallback() {
      var _a;
      this.leaveRoomTimer = 10000;
      this.loadConfigFromPreset = true;
      this.applyDesignSystem = true;
      this.resizeObserver = new index(() => this.handleResize());
      this.resizeObserver.observe(this.host);
      if (this.applyDesignSystem &&
        ((_a = this.config) === null || _a === undefined ? undefined : _a.designTokens) != null &&
        typeof document !== 'undefined') {
        provideDyteDesignSystem(document.documentElement, this.config.designTokens);
      }
      this.meetingChanged(this.meeting);
      this.iconPackUrlChanged(this.iconPackUrl);
    }
    clearListeners(meeting) {
      if (meeting == undefined)
        return;
      meeting.self.removeListener('roomLeft', this.roomLeftListener);
      meeting.self.removeListener('roomJoined', this.roomJoinedListener);
      meeting.self.removeListener('waitlisted', this.waitlistedListener);
      meeting.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      meeting.meta.removeListener('socketConnectionUpdate', this.socketConnectionUpdateListener);
    }
    disconnectedCallback() {
      var _a;
      if (this.leaveOnUnmount) {
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.leaveRoom();
      }
      this.resizeObserver.disconnect();
      this.clearListeners(this.meeting);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting == null)
        return;
      this.setStates({ viewType: meeting.meta.viewType });
      if (this.loadConfigFromPreset && meeting.self.config != null) {
        const theme = meeting.self.config;
        const { config, data } = generateConfig(theme, meeting);
        if (this.config === defaultConfig) {
          // only override the config if the object is same as defaultConfig
          // which means it's a different object passed via prop
          this.config = config;
        }
        if (this.showSetupScreen == null) {
          // only override this value if the prop isn't passed
          this.showSetupScreen = data.showSetupScreen;
        }
        if (meeting.connectedMeetings.supportsConnectedMeetings &&
          ((_a = state.activeBreakoutRoomsManager) === null || _a === undefined ? undefined : _a.destinationMeetingId)) {
          this.showSetupScreen = false;
        }
      }
      if (this.applyDesignSystem &&
        ((_b = this.config) === null || _b === undefined ? undefined : _b.designTokens) != null &&
        typeof document !== 'undefined') {
        provideDyteDesignSystem(document.documentElement, this.config.designTokens);
      }
      meeting.self.addListener('roomJoined', this.roomJoinedListener);
      meeting.self.addListener('waitlisted', this.waitlistedListener);
      meeting.self.addListener('roomLeft', this.roomLeftListener);
      meeting.self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      meeting.meta.addListener('socketConnectionUpdate', this.socketConnectionUpdateListener);
      if (meeting.connectedMeetings.supportsConnectedMeetings) {
        meeting.connectedMeetings.once('changingMeeting', this.handleChangingMeeting);
      }
      if (meeting.self.roomJoined) {
        this.states = Object.assign(Object.assign({}, this.states), { meeting: 'joined' });
        state.meeting = 'joined';
      }
      else {
        if (this.showSetupScreen) {
          this.states = Object.assign(Object.assign({}, this.states), { meeting: 'setup' });
          state.meeting = 'setup';
        }
        else {
          // join directly to the meeting
          meeting.joinRoom();
        }
      }
    }
    async iconPackUrlChanged(url) {
      this.iconPack = await getIconPack(url);
    }
    listenState(e) {
      e.stopPropagation();
      this.setStates(e.detail);
    }
    handleChangingMeeting(destinationMeetingId) {
      state.activeBreakoutRoomsManager = Object.assign(Object.assign({}, state.activeBreakoutRoomsManager), { destinationMeetingId });
    }
    handleResize() {
      this.size = getSize(this.host.clientWidth);
    }
    setStates(states) {
      const newStates = Object.assign({}, this.states);
      merge(newStates, states);
      this.states = newStates;
    }
    render() {
      var _a, _b;
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        states: this.states || state,
        config: this.config,
        iconPack: this.iconPack,
        t: this.t,
      };
      const elementProps = {
        'dyte-grid': {
          layout: this.gridLayout,
        },
      };
      if (((_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.viewType) === 'CHAT')
        return h(Render, { element: "dyte-chat", defaults: defaults });
      return h(Render, { element: "dyte-meeting", defaults: defaults, asHost: true, elementProps: elementProps });
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "iconPackUrl": ["iconPackUrlChanged"]
    }; }
  };
  DyteMeeting.style = dyteMeetingCss;

  var dyteMeeting_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_meeting: DyteMeeting
  });

  const dyteAiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;box-sizing:border-box;display:flex;width:100%;max-width:var(--dyte-space-80, 320px);flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden}.close{position:absolute;top:var(--dyte-space-3, 12px);left:var(--dyte-space-3, 12px)}.title{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-2, 8px);-webkit-user-select:none;-moz-user-select:none;user-select:none;padding:var(--dyte-space-0, 0px);text-align:center;font-size:16px;font-weight:400}#mobile-header{margin-top:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-evenly;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}#mobile-header dyte-button{border-bottom:var(--dyte-border-width-md, 2px) solid transparent;position:relative;border-radius:var(--dyte-border-radius-none, 0)}#mobile-header dyte-button:hover{background-color:transparent}#mobile-header dyte-button.active{border-color:rgb(var(--dyte-colors-brand-400, 53 110 253))}#mobile-header dyte-button .dot{font-size:48px;position:absolute;top:-26px;right:calc(var(--dyte-space-1, 4px) * -1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}dyte-ai-home,dyte-ai-transcriptions,dyte-ai-chat{flex:1}:host([view='sidebar']){margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}:host([view='full-screen']){position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:50;max-width:100%;border:none}";

  const DyteAi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.close = () => {
        this.stateUpdate.emit({ activeAI: false });
        state.activeAI = false;
      };
      this.transcriptionHandler = () => {
        if (this.tab !== 'transcriptions') {
          this.newTranscriptionAvailable = true;
        }
      };
      this.defaultSection = 'home';
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
      this.view = 'sidebar';
      this.tab = this.defaultSection;
      this.newTranscriptionAvailable = false;
      this.newAiMessageAvailable = false;
    }
    connectedCallback() {
      var _a, _b;
      this.viewChanged(this.view);
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.on('transcript', this.transcriptionHandler);
    }
    disconnectedCallback() {
      var _a, _b;
      this.keydownListener && document.removeEventListener('keydown', this.keydownListener);
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.off('transcript', this.transcriptionHandler);
    }
    viewChanged(view) {
      if (view === 'full-screen') {
        this.keydownListener = (e) => {
          if (e.key === 'Escape') {
            this.close();
          }
        };
        document.addEventListener('keydown', this.keydownListener);
      }
    }
    tabChanged(tab) {
      if (tab === 'transcriptions' && this.newTranscriptionAvailable) {
        this.newTranscriptionAvailable = false;
      }
      if (tab === 'home' && this.newAiMessageAvailable) {
        this.newAiMessageAvailable = false;
      }
    }
    viewSection(section) {
      this.tab = section;
      state.activeSidebar = true;
    }
    // private aiMessageHandler = () => {
    //   if (this.tab !== 'home') {
    //     this.newAiMessageAvailable = true;
    //   }
    // };
    render() {
      var _a, _b, _c;
      if (!((_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions).transcriptionEnabled ||
        !((_c = this.states) === null || _c === undefined ? undefined : _c.activeAI)) {
        return null;
      }
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states || state,
        size: this.size,
        t: this.t,
        iconPack: this.iconPack,
      };
      // const aiClient = this.middlewares.speech;
      return (h(Host, null, h("h3", { class: "title" }, this.t('ai')), h("div", { id: "mobile-header" }, h("dyte-button", { variant: "ghost", class: { active: this.tab === 'home' }, onClick: () => this.viewSection('home'), iconPack: this.iconPack, t: this.t }, this.t('ai.home'), this.newAiMessageAvailable && h("span", { class: "dot" }, ".")), h("dyte-button", { variant: "ghost", class: { active: this.tab === 'transcriptions' }, onClick: () => this.viewSection('transcriptions'), iconPack: this.iconPack, t: this.t }, this.t('ai.transcriptions'), this.newTranscriptionAvailable && h("span", { class: "dot" }, "."))), h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: this.close, "aria-label": this.t('close'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t })), this.tab === 'home' && (h(Render, { element: "dyte-ai-home", defaults: defaults, props: {
          // aiClient: aiClient,
          // initialMessages: aiClient.aiMesssages,
          meeting: this.meeting,
        } })), this.tab === 'transcriptions' && (h(Render, { element: "dyte-ai-transcriptions", defaults: defaults })), this.tab === 'personal' && h(Render, { element: "dyte-ai-chat", defaults: defaults })));
    }
    static get watchers() { return {
      "view": ["viewChanged"],
      "tab": ["tabChanged"]
    }; }
  };
  DyteAi.style = dyteAiCss;

  var dyteAi_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ai: DyteAi
  });

  const dyteAiChatCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column}.private-message{text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));margin-top:var(--dyte-space-8, 32px);margin-bottom:var(--dyte-space-8, 32px);margin-left:var(--dyte-space-10, 40px);margin-right:var(--dyte-space-10, 40px)}.hint-message{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;flex:1 1 0%;font-size:14px;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}i{font-weight:500;font-style:italic;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}";

  const DyteAiChat = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("p", { class: "private-message" }, this.t('ai.chat.tooltip')), h("div", { class: "hint-message" }, h("p", null, this.t('ask'), " ", h("i", null, "\"", this.t('ai.chat.summerise'), "\""), h("br", null), " or ", h("br", null), this.t('type'), " ", h("i", null, "\"", this.t('ai.chat.agenda'), "\"")))));
    }
  };
  DyteAiChat.style = dyteAiChatCss;

  var dyteAiChat_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ai_chat: DyteAiChat
  });

  const differenceInMinutes = (oldDate, newDate) => {
    // difference in milliseconds
    const diff = newDate.getTime() - oldDate.getTime();
    return Math.round(Math.abs(diff / 1000 / 60));
  };
  const elapsedDuration = (oldDate, newDate) => {
    const minutes = differenceInMinutes(oldDate, newDate);
    if (minutes < 2) {
      return 'just now';
    }
    if (minutes < 60) {
      return `${minutes}m ago`;
    }
    const hours = Math.round(minutes / 60);
    if (minutes < 90) {
      return `about ${hours}h ago`;
    }
    if (hours < 24) {
      return `${hours}h ago`;
    }
    const days = Math.round(hours / 24);
    if (days < 7) {
      return `${days}d ago`;
    }
    const weeks = Math.round(days / 7);
    return `${weeks}w ago`;
  };
  const formatDateTime = (date) => {
    return date.toDateString() + ' ' + date.toLocaleTimeString();
  };

  /**
   * Shorten a string upto a maximum length of characters and add `...` as suffix if it exceeds the maximum length
   * @param str The The string you want to shorten
   * @param maxLength Maximum length of character
   * @returns Formatted shortedned string
   */
  const shorten = (str, maxLength = 20) => {
    if (str == null)
      return '';
    if (str.length > maxLength) {
      return `${str.substring(0, maxLength)}...`;
    }
    return str;
  };
  /**
   * Checks if a given string consists of only emojis.
   *
   * However this classifies a string with numbers as emoji as well.
   * Which works in our favour for now in chat as it enlarges messages with just numbers.
   * @param str String on which to perform the check on
   * @returns A Boolean value which indicates if string consists of only emojis
   */
  const hasOnlyEmojis = (str) => {
    const num = /^\d+$/;
    const re = /^\p{Emoji}+$/u;
    return re.test(str) && !num.test(str);
  };
  const sanitizeLink = (link) => {
    // TODO: needs more work
    if (link === null || link === undefined ? undefined : link.trim().toLowerCase().startsWith('javascript:')) {
      return 'https://dyte.io';
    }
    return link;
  };
  /**
   * Formats a given name and returns **Participant** for unnamed participants.
   * @param name Name of participant
   * @returns Name to use in the UI
   */
  const formatName = (name) => {
    name = name === null || name === undefined ? undefined : name.trim();
    if (name === '')
      return 'Participant';
    return name;
  };
  const whiteSpace = new RegExp(/[^\u00BF-\u1FFF\u2C00-\uD7FF\w\s]/, 'g');
  const space = new RegExp(/\s+/);
  function getInitials(name, maxInitials = 2) {
    // removes any character that is not a letter, number or whitespace
    const cleanedName = name.replace(whiteSpace, '');
    const words = cleanedName.trim().split(space).slice(0, maxInitials);
    return words
      .map((word) => word.charAt(0))
      .join('')
      .toUpperCase();
  }

  const ChatHead = ({ name, time, now }) => {
    return (h("div", { class: "head" },
      h("div", { class: "name" }, shorten(formatName(name), 20)),
      h("div", { class: "time", title: formatDateTime(time) }, elapsedDuration(time, now))));
  };

  /**
   * Scroll to bottom of an element.
   *
   * Works in all browsers - just that in Safari, the smooth scrolling doesn't work.
   * @param el The bottom of which element you want to scroll down to
   */
  const smoothScrollToBottom = (el, smooth = true) => {
    if (el == null)
      return;
    el.scrollTo({ top: el.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
  };

  const dyteAiHomeCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.head{display:flex;align-items:center}.head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}*{box-sizing:border-box;border-width:0;border-style:solid}:host{display:flex;flex-direction:column}.public-message{text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));margin-top:var(--dyte-space-8, 32px);margin-bottom:var(--dyte-space-8, 32px);margin-left:var(--dyte-space-10, 40px);margin-right:var(--dyte-space-10, 40px)}.content{box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-3, 12px);flex:1 0 0px;overflow-y:scroll;}.subtitle{margin-top:var(--dyte-space-1, 4px);font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.hint-message{display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;flex:1 1 0%;font-size:14px;line-height:1.5;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}i{font-weight:500;font-style:italic;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.actions{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);display:flex;align-items:center;justify-content:space-between;font-size:12px}.actions div{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.actions button{display:inline-flex;cursor:pointer;border-radius:var(--dyte-border-radius-md, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.5);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.prompt{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.prompt input{height:var(--dyte-space-12, 48px);width:100%;resize:none;background-color:transparent;padding:var(--dyte-space-4, 16px);font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px}.message .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);white-space:pre-wrap;font-size:14px}.message .loader{display:flex;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);font-size:12px}.message{margin-bottom:var(--dyte-space-3, 12px)}.message:last-child{margin-bottom:var(--dyte-space-0, 0px)}.prompt-text{margin-top:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-1, 4px);border-left-width:var(--dyte-border-width-sm, 1px);border-left-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}";

  const DyteAiHome = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.handleSubmit = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.messages = [
          ...this.messages,
          {
            action: 'Prompt',
            participantName: this.meeting.self.name,
            createdAt: new Date(),
            prompt: this.prompt,
            loading: true,
          },
        ];
        // this.middlewares?.speech?.sendMessageToChatGPT({ action: 'default', message: this.prompt });
        this.prompt = '';
      };
      this.handleSummarise = () => {
        // this.middlewares?.speech?.sendMessageToChatGPT({ action: 'summarization' });
      };
      this.handleAgenda = () => {
        // this.middlewares?.speech?.sendMessageToChatGPT({ action: 'agenda generation' });
      };
      this.handleMoM = () => {
        // this.middlewares?.speech?.sendMessageToChatGPT({ action: 'action items generation' });
      };
      this.prompt = '';
      this.messages = [];
      this.meeting = undefined;
      this.initialMessages = undefined;
    }
    // private handleChatGPTReply(data: AIMessage) {
    //   const existingMessage = this.messages.find((message) =>
    //     data.action === 'default'
    //       ? message.id === data.id
    //       : message.id === data.id || message.action === this.mapMessageAction(data.action)
    //   );
    //
    //   if (
    //     existingMessage &&
    //     (existingMessage.loading || existingMessage.action !== this.mapMessageAction('default'))
    //   ) {
    //     this.messages = [
    //       ...this.messages.map((message) =>
    //         message.id === data.id || message.action === this.mapMessageAction(data.action)
    //           ? { ...data, action: this.mapMessageAction(data.action) }
    //           : message
    //       ),
    //     ];
    //   } else {
    //     this.messages = [...this.messages, { ...data, action: this.mapMessageAction(data.action) }];
    //   }
    // }
    connectedCallback() {
      if (this.initialMessages) {
        this.messages = this.initialMessages.map((message) => (Object.assign(Object.assign({}, message), { action: this.mapMessageAction(message.action) })));
      }
      // this.middlewares?.speech?.on('chatGPTReply', (data) => this.handleChatGPTReply(data));
    }
    disconnectedCallback() {
      // this.middlewares?.speech?.off('chatGPTReply', (data) => this.handleChatGPTReply(data));
    }
    messagesUpdated() {
      // NOTE: I don't know why initially contentContainer ref is not set, That's
      // why this setTimeout. We can figure a better approach for this
      setTimeout(() => {
        smoothScrollToBottom(this.contentContainer, false);
      }, 100);
    }
    mapMessageAction(action) {
      switch (action) {
        case 'default':
          return 'Prompt';
        case 'summarization':
          return 'Summary';
        case 'agenda generation':
          return 'Agenda';
        case 'action items generation':
          return 'Action items';
      }
    }
    render() {
      return (h(Host, null, h("div", { class: "content scrollbar", ref: (el) => (this.contentContainer = el) }, h("p", { class: "public-message" }, "This conversation will be visible to everyone on the call."), !this.messages.length && (h("div", { class: "hint-message" }, h("p", null, "Ask ", h("i", null, "\"Hey AI, summarise this call\""), h("br", null), " or ", h("br", null), "Type ", h("i", null, "\"Hey AI, what is today's agenda?\"")))), this.messages.length > 0 && (h("div", { class: "" }, this.messages.map((message) => (h("div", { class: "message" }, h(ChatHead, { name: message.action, time: new Date(message.createdAt), now: new Date() }), h("p", { class: "subtitle" }, "Triggered by ", message.participantName), message.prompt && h("div", { class: "prompt-text" }, message.prompt), message.loading ? (h("div", { class: "loader" }, h("dyte-spinner", { size: "sm" }), "\u00A0\u00A0Generating...")) : (h("div", { class: "body" }, message.response)))))))), h("div", { class: "actions" }, h("span", null, "Quick actions:"), h("div", null, h("button", { onClick: this.handleSummarise }, "Summarise"), h("button", { onClick: this.handleAgenda }, "Agenda"), h("button", { onClick: this.handleMoM }, "MoM"))), h("form", { class: "prompt", onSubmit: this.handleSubmit }, h("input", { value: this.prompt, onInput: (e) => {
          this.prompt = e.target.value;
        }, placeholder: "Type your prompt..." }))));
    }
    static get watchers() { return {
      "messages": ["messagesUpdated"]
    }; }
  };
  DyteAiHome.style = dyteAiHomeCss;

  var dyteAiHome_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ai_home: DyteAiHome
  });

  const dyteAiToggleCss = ":host{display:block}";

  const DyteAiToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.variant = 'button';
      this.states = undefined;
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.aiActive = false;
    }
    statesChanged(s) {
      const states = s || state;
      this.aiActive = states.activeAI;
    }
    toggleAI() {
      const states = this.states || state;
      this.aiActive = !(states === null || states === undefined ? undefined : states.activeAI);
      this.stateUpdate.emit({
        activeAI: this.aiActive,
        activeMoreMenu: false,
        activeSidebar: false,
      });
      state.activeAI = this.aiActive;
      state.activeMoreMenu = false;
      state.activeSidebar = false;
    }
    render() {
      var _a, _b;
      const text = this.t('ai.meeting_ai');
      if (!((_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions).transcriptionEnabled) {
        return null;
      }
      return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.aiActive }, onClick: () => this.toggleAI(), icon: this.iconPack.meeting_ai, label: text, variant: this.variant, brandIcon: true })));
    }
    static get watchers() { return {
      "states": ["statesChanged"]
    }; }
  };
  DyteAiToggle.style = dyteAiToggleCss;

  var dyteAiToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ai_toggle: DyteAiToggle
  });

  /* Built-in method references that are verified to be native. */
  var WeakMap$1 = getNative(root$1, 'WeakMap');

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$1.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */
  var objectProto$1$1 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$1$1.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /* Built-in method references that are verified to be native. */
  var DataView$1 = getNative(root$1, 'DataView');

  /* Built-in method references that are verified to be native. */
  var Promise$1 = getNative(root$1, 'Promise');

  /* Built-in method references that are verified to be native. */
  var Set$1 = getNative(root$1, 'Set');

  /** `Object#toString` result references. */
  var mapTag$3 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$3 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$2 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView$1),
      mapCtorString = toSource(Map$1),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set$1),
      weakMapCtorString = toSource(WeakMap$1);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag$1;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2) ||
      (Map$1 && getTag(new Map$1) != mapTag$3) ||
      (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
      (Set$1 && getTag(new Set$1) != setTag$3) ||
      (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
    getTag = function(value) {
      var result = baseGetTag$1(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$2;
          case mapCtorString: return mapTag$3;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$3;
          case weakMapCtorString: return weakMapTag$1;
        }
      }
      return result;
    };
  }

  const getTag$1 = getTag;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty$2.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = cloneArrayBuffer(dataView.buffer) ;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$1 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$1:
        return cloneDataView(object);

      case float32Tag$1: case float64Tag$1:
      case int8Tag$1: case int16Tag$1: case int32Tag$1:
      case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor;

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return cloneRegExp(object);

      case setTag$2:
        return new Ctor;

      case symbolTag$1$1:
        return cloneSymbol(object);
    }
  }

  /** `Object#toString` result references. */
  var mapTag$1 = '[object Map]';

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike$1(value) && getTag$1(value) == mapTag$1;
  }

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap;

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /** `Object#toString` result references. */
  var setTag$1 = '[object Set]';

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike$1(value) && getTag$1(value) == setTag$1;
  }

  /* Node.js helper references. */
  var nodeIsSet = nodeUtil && nodeUtil.isSet;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG$1 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag$2 = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag$2] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG$1;
    if (result !== undefined) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
    } else {
      var tag = getTag$1(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = (isFunc) ? {} : initCloneObject(value);
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = (getAllKeys)
      ;

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_SYMBOLS_FLAG = 4;

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  function clone(obj) {
    if (structuredClone) {
      return structuredClone(obj);
    }
    return cloneDeep(obj);
  }

  const dyteAiTranscriptionsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.head{display:flex;align-items:center}.head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}*{box-sizing:border-box;border-width:0;border-style:solid}:host{width:100%;display:flex;flex-direction:column}.processing{display:flex;flex:1 1 0%;flex-direction:column;align-items:center;justify-content:center}.content{box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-3, 12px);flex:1 0 0px;overflow-y:scroll}.started-message{margin-top:var(--dyte-space-5, 20px);margin-bottom:var(--dyte-space-5, 20px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.search-bar{height:var(--dyte-space-14, 56px);width:100%;border-bottom-width:var(--dyte-border-width-sm, 1px);--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));padding:var(--dyte-space-3, 12px)}input{height:100%;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-size:14px;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.caption-view{height:var(--dyte-space-12, 48px);width:100%;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));display:flex;align-items:center;justify-content:space-between;font-size:14px}.message .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);font-size:14px;word-break:break-word}.message{margin-bottom:var(--dyte-space-3, 12px)}.message:last-child{margin-bottom:var(--dyte-space-0, 0px)}";

  const DyteAiTranscriptions = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.autoScrollEnabled = true;
      this.onScroll = (e) => {
        const { scrollTop, clientHeight, scrollHeight } = e.target;
        const fromTop = scrollTop + clientHeight;
        if (fromTop + 10 >= scrollHeight) {
          // at bottom
          this.autoScrollEnabled = true;
        }
        else {
          // not at bottom
          this.autoScrollEnabled = false;
        }
      };
      this.onTranscriptHandler = (data) => {
        this.transcriptions = this.transcriptionsReducer(this.transcriptions, data);
      };
      this.participantQuery = '';
      this.isProcessing = false;
      this.captionViewEnabled = false;
      this.t = useLanguage();
      this.meeting = undefined;
      this.transcriptions = [];
      this.initialTranscriptions = undefined;
    }
    // private transcriptionHandler(data: Transcript) {
    //   this.transcriptions = [...this.transcriptions, data];
    // }
    transcriptionsReducer(acc, t) {
      if (!acc.length || acc[acc.length - 1].peerId !== t.peerId) {
        return acc.concat(t);
      }
      const lastElement = acc[acc.length - 1];
      if (lastElement.id === t.id) {
        lastElement.transcript = t.transcript;
        acc.pop();
        return acc.concat(lastElement);
      }
      return acc.concat(t);
    }
    connectedCallback() {
      if (!this.meeting)
        return;
      this.meetingChanged(this.meeting);
    }
    componentDidLoad() {
      var _a;
      (_a = this.contentContainer) === null || _a === undefined ? undefined : _a.addEventListener('scroll', this.onScroll);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.ai) === null || _b === undefined ? undefined : _b.off('transcript', this.onTranscriptHandler);
      (_c = this.contentContainer) === null || _c === undefined ? undefined : _c.removeEventListener('scroll', this.onScroll);
    }
    meetingChanged(meeting) {
      var _a, _b;
      this.transcriptions = clone((_a = meeting === null || meeting === undefined ? undefined : meeting.ai) === null || _a === undefined ? undefined : _a.transcripts);
      this.transcriptions = this.transcriptions.reduce(this.transcriptionsReducer, []);
      (_b = meeting === null || meeting === undefined ? undefined : meeting.ai) === null || _b === undefined ? undefined : _b.on('transcript', this.onTranscriptHandler);
    }
    transcriptionsChanged() {
      if (this.autoScrollEnabled) {
        setTimeout(() => {
          smoothScrollToBottom(this.contentContainer, false);
        }, 100);
      }
    }
    renderTranscripts() {
      const transcripts = this.transcriptions.filter((t) => this.participantQuery
        ? t.name.toLowerCase().includes(this.participantQuery.toLowerCase())
        : true);
      const renderedTranscripts = [];
      transcripts.forEach((transcript) => {
        const t = {
          name: transcript.name,
          date: transcript.date,
          peerId: transcript.peerId,
          transcript: transcript.transcript,
        };
        if (!renderedTranscripts.length) {
          renderedTranscripts.push(t);
          return;
        }
        const lastTranscript = renderedTranscripts[renderedTranscripts.length - 1];
        if (transcript.peerId !== lastTranscript.peerId) {
          renderedTranscripts.push(t);
          return;
        }
        lastTranscript.transcript += ' ' + transcript.transcript;
      });
      return renderedTranscripts.map((transcription) => {
        return (h("div", { class: "message" }, h(ChatHead, { name: transcription.name, time: new Date(transcription.date), now: new Date() }), h("div", { class: "body" }, transcription.transcript)));
      });
    }
    render() {
      return (h(Host, null, h("div", { class: "search-bar" }, h("input", { type: "text", placeholder: "Search Participant", value: this.participantQuery, onInput: (e) => (this.participantQuery = e.target.value) })), this.isProcessing && (h("div", { class: "processing" }, h("p", null, "Processing audio...."))), !this.isProcessing && (h("div", { class: "content scrollbar", ref: (el) => (this.contentContainer = el) }, h("div", { class: "started-message" }, "Transcription started"), this.renderTranscripts())), this.captionViewEnabled && h("dyte-ai-caption", null)));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "transcriptions": ["transcriptionsChanged"]
    }; }
  };
  DyteAiTranscriptions.style = dyteAiTranscriptionsCss;

  var dyteAiTranscriptions_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ai_transcriptions: DyteAiTranscriptions
  });

  const dyteAudioGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;height:100%;width:100%;box-sizing:border-box}.content{position:relative;display:flex;height:100%;width:100%;flex-direction:column;overflow-y:auto}.waitlist-area{display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.listening-title{text-align:center;margin-top:var(--dyte-space-5, 20px);margin-bottom:var(--dyte-space-4, 16px)}.waitlist-grid{flex:1 1 0%}.grid{box-sizing:border-box;flex:1 1 0%;gap:var(--dyte-space-6, 24px);display:flex;align-content:center;justify-content:center;flex-wrap:wrap}:host([size='md']) .grid{gap:var(--dyte-space-4, 16px)}:host([size='sm']) .grid{gap:var(--dyte-space-3, 12px)}dyte-audio-tile{aspect-ratio:1 / 1;flex:none;width:calc(20%);max-width:var(--dyte-space-48, 192px);transition:all 0.3s}dyte-audio-tile[size='md']{width:100%;max-width:var(--dyte-space-36, 144px)}dyte-audio-tile[size='sm']{width:100%;max-width:var(--dyte-space-24, 96px)}";

  const DyteAudioGrid = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onParticipantListUpdate = () => {
        if (!this.meeting) {
          return;
        }
        let activeParticipants = this.meeting.participants.active.toArray();
        if (!this.hideSelf) {
          activeParticipants = [...activeParticipants, this.meeting.self];
        }
        let onStageParticipants = this.meeting.participants.joined
          .toArray()
          .filter((p) => !activeParticipants.some((a) => a.id === p.id));
        this.activeParticipants = activeParticipants;
        this.onStageParticipants = onStageParticipants;
      };
      this.meeting = undefined;
      this.config = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.size = undefined;
      this.t = useLanguage();
      this.hideSelf = false;
      this.activeParticipants = [];
      this.onStageParticipants = [];
      this.offStageParticipants = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    meetingChanged(meeting) {
      if (!meeting || meeting.self.config.viewType !== 'AUDIO_ROOM') {
        return;
      }
      this.onParticipantListUpdate();
      // listeners
      meeting.participants.active.addListener('participantJoined', this.onParticipantListUpdate);
      meeting.participants.active.addListener('participantLeft', this.onParticipantListUpdate);
      meeting.participants.joined.addListener('participantJoined', this.onParticipantListUpdate);
      meeting.participants.joined.addListener('participantLeft', this.onParticipantListUpdate);
    }
    disconnectedCallback() {
      this.resizeObserver.disconnect();
      this.resizeObserver = undefined;
      this.meeting.participants.active.removeListener('participantJoined', this.onParticipantListUpdate);
      this.meeting.participants.active.removeListener('participantLeft', this.onParticipantListUpdate);
      this.meeting.participants.joined.removeListener('participantJoined', this.onParticipantListUpdate);
      this.meeting.participants.joined.removeListener('participantLeft', this.onParticipantListUpdate);
    }
    renderGrid(participants = []) {
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        config: this.config,
        t: this.t,
        iconPack: this.iconPack,
        states: this.states,
      };
      return participants.map((participant) => {
        return (h(Render, { element: "dyte-audio-tile", defaults: defaults, props: {
            key: participant.id,
            participant,
          }, childProps: {
            participant,
          }, deepProps: true }));
      });
    }
    render() {
      const onStage = this.activeParticipants.concat(this.onStageParticipants);
      return (h(Host, null, h("div", { class: "content scrollbar" }, h("div", { class: "stage grid" }, this.renderGrid(onStage)), this.offStageParticipants.length > 0 && (h("div", { class: "waitlist-area" }, h("div", { class: "listening-title" }, this.offStageParticipants.length, " ", this.t('grid.listening')), h("div", { class: "waitlist-grid grid" }, this.renderGrid(this.offStageParticipants))))), h("slot", null)));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteAudioGrid.style = dyteAudioGridCss;

  var dyteAudioGrid_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_audio_grid: DyteAudioGrid
  });

  /*
  WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based
  on @visionmedia's Emitter from UI Kit.

  Why? I wanted it standalone.

  I also wanted support for wildcard emitters like this:

  emitter.on('*', function (eventName, other, event, payloads) {

  });

  emitter.on('somenamespace*', function (eventName, payloads) {

  });

  Please note that callbacks triggered by wildcard registered events also get
  the event name as the first argument.
  */

  var wildemitter = WildEmitter;

  function WildEmitter() { }

  WildEmitter.mixin = function (constructor) {
      var prototype = constructor.prototype || constructor;

      prototype.isWildEmitter= true;

      // Listen on the given `event` with `fn`. Store a group name if present.
      prototype.on = function (event, groupName, fn) {
          this.callbacks = this.callbacks || {};
          var hasGroup = (arguments.length === 3),
              group = hasGroup ? arguments[1] : undefined,
              func = hasGroup ? arguments[2] : arguments[1];
          func._groupName = group;
          (this.callbacks[event] = this.callbacks[event] || []).push(func);
          return this;
      };

      // Adds an `event` listener that will be invoked a single
      // time then automatically removed.
      prototype.once = function (event, groupName, fn) {
          var self = this,
              hasGroup = (arguments.length === 3),
              group = hasGroup ? arguments[1] : undefined,
              func = hasGroup ? arguments[2] : arguments[1];
          function on() {
              self.off(event, on);
              func.apply(this, arguments);
          }
          this.on(event, group, on);
          return this;
      };

      // Unbinds an entire group
      prototype.releaseGroup = function (groupName) {
          this.callbacks = this.callbacks || {};
          var item, i, len, handlers;
          for (item in this.callbacks) {
              handlers = this.callbacks[item];
              for (i = 0, len = handlers.length; i < len; i++) {
                  if (handlers[i]._groupName === groupName) {
                      //console.log('removing');
                      // remove it and shorten the array we're looping through
                      handlers.splice(i, 1);
                      i--;
                      len--;
                  }
              }
          }
          return this;
      };

      // Remove the given callback for `event` or all
      // registered callbacks.
      prototype.off = function (event, fn) {
          this.callbacks = this.callbacks || {};
          var callbacks = this.callbacks[event],
              i;

          if (!callbacks) return this;

          // remove all handlers
          if (arguments.length === 1) {
              delete this.callbacks[event];
              return this;
          }

          // remove specific handler
          i = callbacks.indexOf(fn);
          if (i !== -1) {
              callbacks.splice(i, 1);
              if (callbacks.length === 0) {
                  delete this.callbacks[event];
              }
          }
          return this;
      };

      /// Emit `event` with the given args.
      // also calls any `*` handlers
      prototype.emit = function (event) {
          this.callbacks = this.callbacks || {};
          var args = [].slice.call(arguments, 1),
              callbacks = this.callbacks[event],
              specialCallbacks = this.getWildcardCallbacks(event),
              i,
              len,
              listeners;

          if (callbacks) {
              listeners = callbacks.slice();
              for (i = 0, len = listeners.length; i < len; ++i) {
                  if (!listeners[i]) {
                      break;
                  }
                  listeners[i].apply(this, args);
              }
          }

          if (specialCallbacks) {
              len = specialCallbacks.length;
              listeners = specialCallbacks.slice();
              for (i = 0, len = listeners.length; i < len; ++i) {
                  if (!listeners[i]) {
                      break;
                  }
                  listeners[i].apply(this, [event].concat(args));
              }
          }

          return this;
      };

      // Helper for for finding special wildcard event handlers that match the event
      prototype.getWildcardCallbacks = function (eventName) {
          this.callbacks = this.callbacks || {};
          var item,
              split,
              result = [];

          for (item in this.callbacks) {
              split = item.split('*');
              if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
                  result = result.concat(this.callbacks[item]);
              }
          }
          return result;
      };

  };

  WildEmitter.mixin(WildEmitter);

  function getMaxVolume (analyser, fftBins) {
    var maxVolume = -Infinity;
    analyser.getFloatFrequencyData(fftBins);

    for(var i=4, ii=fftBins.length; i < ii; i++) {
      if (fftBins[i] > maxVolume && fftBins[i] < 0) {
        maxVolume = fftBins[i];
      }
    }
    return maxVolume;
  }


  var audioContextType;
  if (typeof window !== 'undefined') {
    audioContextType = window.AudioContext || window.webkitAudioContext;
  }
  // use a single audio context due to hardware limits
  var audioContext = null;
  var hark = function(stream, options) {
    var harker = new wildemitter();

    // make it not break in non-supported browsers
    if (!audioContextType) return harker;

    //Config
    var options = options || {},
        smoothing = (options.smoothing || 0.1),
        interval = (options.interval || 50),
        threshold = options.threshold,
        play = options.play,
        history = options.history || 10,
        running = true;

    // Ensure that just a single AudioContext is internally created
    audioContext = options.audioContext || audioContext || new audioContextType();

    var sourceNode, fftBins, analyser;

    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = smoothing;
    fftBins = new Float32Array(analyser.frequencyBinCount);

    if (stream.jquery) stream = stream[0];
    if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {
      //Audio Tag
      sourceNode = audioContext.createMediaElementSource(stream);
      if (typeof play === 'undefined') play = true;
      threshold = threshold || -50;
    } else {
      //WebRTC Stream
      sourceNode = audioContext.createMediaStreamSource(stream);
      threshold = threshold || -50;
    }

    sourceNode.connect(analyser);
    if (play) analyser.connect(audioContext.destination);

    harker.speaking = false;

    harker.suspend = function() {
      return audioContext.suspend();
    };
    harker.resume = function() {
      return audioContext.resume();
    };
    Object.defineProperty(harker, 'state', { get: function() {
      return audioContext.state;
    }});
    audioContext.onstatechange = function() {
      harker.emit('state_change', audioContext.state);
    };

    harker.setThreshold = function(t) {
      threshold = t;
    };

    harker.setInterval = function(i) {
      interval = i;
    };

    harker.stop = function() {
      running = false;
      harker.emit('volume_change', -100, threshold);
      if (harker.speaking) {
        harker.speaking = false;
        harker.emit('stopped_speaking');
      }
      analyser.disconnect();
      sourceNode.disconnect();
    };
    harker.speakingHistory = [];
    for (var i = 0; i < history; i++) {
        harker.speakingHistory.push(0);
    }

    // Poll the analyser node to determine if speaking
    // and emit events if changed
    var looper = function() {
      setTimeout(function() {

        //check if stop has been called
        if(!running) {
          return;
        }

        var currentVolume = getMaxVolume(analyser, fftBins);

        harker.emit('volume_change', currentVolume, threshold);

        var history = 0;
        if (currentVolume > threshold && !harker.speaking) {
          // trigger quickly, short history
          for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {
            history += harker.speakingHistory[i];
          }
          if (history >= 2) {
            harker.speaking = true;
            harker.emit('speaking');
          }
        } else if (currentVolume < threshold && harker.speaking) {
          for (var i = 0; i < harker.speakingHistory.length; i++) {
            history += harker.speakingHistory[i];
          }
          if (history == 0) {
            harker.speaking = false;
            harker.emit('stopped_speaking');
          }
        }
        harker.speakingHistory.shift();
        harker.speakingHistory.push(0 + (currentVolume > threshold));

        looper();
      }, interval);
    };
    looper();

    return harker;
  };

  const dyteAudioTileCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:flex;flex-direction:column}.avatar-ctr{box-sizing:border-box;width:100%;flex:1 1 0%;padding:var(--dyte-space-1\\.5, 6px);border:2px solid transparent;border-radius:calc(var(--dyte-border-radius-xl, 40px) + var(--dyte-space-1\\.5, 6px))}.avatar-ctr.speaking{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));transition-property:box-shadow;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.bar-0{box-shadow:none}.bar-1{box-shadow:0 0 4px rgb(var(--dyte-colors-brand-500, 33 96 253))}.bar-2{box-shadow:0 0 8px rgb(var(--dyte-colors-brand-500, 33 96 253))}.bar-3{box-shadow:0 0 16px 1px rgb(var(--dyte-colors-brand-500, 33 96 253))}.bar-4{box-shadow:0 0 20px 3px rgb(var(--dyte-colors-brand-500, 33 96 253))}.bar-5{box-shadow:0 0 24px 6px rgb(var(--dyte-colors-brand-500, 33 96 253))}dyte-avatar{aspect-ratio:1 / 1;height:100%;width:100%;position:relative;border-radius:var(--dyte-border-radius-xl, 40px)}dyte-name-tag{display:block;height:var(--dyte-space-10, 40px);width:100%;text-align:center;line-height:2.5rem}:host([size='sm']) .avatar-ctr{border-radius:calc(var(--dyte-border-radius-lg, 12px) + var(--dyte-space-1\\.5, 6px))}:host([size='sm']) dyte-name-tag{height:var(--dyte-space-7, 28px);line-height:1.75rem}:host([size='sm']) dyte-avatar{border-radius:var(--dyte-border-radius-lg, 12px)}.mic-icon{position:absolute;bottom:calc(var(--dyte-space-1, 4px) * -1);right:calc(var(--dyte-space-1, 4px) * -1);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.mic-icon dyte-icon{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}:host([size='sm']) .mic-icon dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([size='md']) .mic-icon dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}";

  const DyteAudioTile = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onAudioUpdate = ({ audioEnabled, audioTrack, }) => {
        if (!this.participant)
          return;
        if (audioEnabled && audioTrack) {
          const stream = new MediaStream();
          stream.addTrack(audioTrack);
          this.calcVolume(stream);
          this.audioEnabled = true;
        }
        else {
          this.volume = 0;
          this.audioEnabled = false;
        }
      };
      this.meeting = undefined;
      this.config = undefined;
      this.size = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.participant = undefined;
      this.audioEnabled = false;
      this.volume = 0;
    }
    connectedCallback() {
      this.participantChanged(this.participant);
    }
    disconnectedCallback() {
      var _a, _b;
      (_a = this.hark) === null || _a === undefined ? undefined : _a.stop();
      (_b = this.participant) === null || _b === undefined ? undefined : _b.removeListener('audioUpdate', this.onAudioUpdate);
    }
    participantChanged(participant) {
      if (!participant) {
        return;
      }
      this.audioEnabled = participant.audioEnabled;
      participant.addListener('audioUpdate', this.onAudioUpdate);
    }
    /**
     * Determines the volume from a given MediaStream and updates the components state
     * @param stream A MediaStream with AudioTrack(s) added
     */
    calcVolume(stream) {
      this.hark = hark(stream, {
        play: false,
        interval: 1000 / 10,
      });
      this.hark.on('volume_change', (dBs) => {
        const prevVolume = this.volume;
        // The exact formula to convert from dBs (-100..0) to linear (0..1) is:
        //   Math.pow(10, dBs / 20)
        // However it does not produce a visually useful output, so let exagerate
        // it a bit. Also, let convert it from 0..1 to 0..10 and avoid value 1 to
        // minimize component renderings.
        // if dBs is -Inifnity, set vol to 0
        let audioVol = Math.round(10 ** (dBs / 115) * 10);
        if (audioVol < 3)
          audioVol = 0;
        let volume = Math.round((prevVolume * 2 + audioVol) / 3);
        if (prevVolume !== volume) {
          this.volume = volume;
        }
      });
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        config: this.config,
        states: this.states,
        iconPack: this.iconPack,
        t: this.t,
      };
      let shadowClass = 'bar-0';
      if (this.volume > 5) {
        shadowClass = 'bar-5';
      }
      else if (this.volume < 0) {
        shadowClass = 'bar-0';
      }
      else {
        shadowClass = 'bar-' + this.volume;
      }
      return (h(Host, null, h("div", { class: { 'avatar-ctr': true, speaking: this.audioEnabled, [shadowClass]: true } }, h("dyte-avatar", { participant: this.participant, size: this.size }, !this.audioEnabled && (h("div", { class: "mic-icon" }, h("dyte-icon", { icon: defaultIconPack.mic_off }))))), h("dyte-name-tag", Object.assign({ variant: "text", participant: this.participant }, defaults)), h("slot", null)));
    }
    static get watchers() { return {
      "participant": ["participantChanged"]
    }; }
  };
  DyteAudioTile.style = dyteAudioTileCss;

  var dyteAudioTile_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_audio_tile: DyteAudioTile
  });

  const dyteBreakoutRoomsManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.color-brand{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.color-danger{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.loading-content{height:var(--dyte-space-60, 240px);width:var(--dyte-space-96, 384px);padding:var(--dyte-space-9, 36px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;align-items:center;justify-content:center}.room-config{overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-96, 384px);padding-left:var(--dyte-space-9, 36px);padding-right:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-10, 40px);padding-bottom:var(--dyte-space-10, 40px)}header{margin-bottom:var(--dyte-space-8, 32px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);font-size:24px;font-weight:600}header dyte-icon{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}.create-room{margin-bottom:var(--dyte-space-4, 16px);display:flex;align-items:center;gap:var(--dyte-space-3, 12px);width:100%}.create-room p{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-1, 4px);font-size:16px}.distribution-hint{margin-bottom:var(--dyte-space-8, 32px);font-size:14px;font-weight:400;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.distribution-hint em{font-style:normal;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}footer{display:flex;flex-direction:row;vertical-align:middle;justify-content:center}footer dyte-button{width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}label{margin-bottom:var(--dyte-space-3, 12px);font-weight:400;color:rgb(var(--dyte-colors-text-1000, 255 255 255));opacity:0.4}.participant-config-wrapper{width:850px;height:595px;max-width:100%;max-height:100%;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));display:flex;flex-direction:column}.participant-config-actions{display:flex;justify-content:space-between;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-5, 20px);padding-bottom:var(--dyte-space-5, 20px);border-bottom-right-radius:var(--dyte-border-radius-md, 8px);border-bottom-left-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.participant-config{display:flex;flex-grow:1;flex-direction:row;overflow:hidden}aside{box-sizing:border-box;display:flex;width:var(--dyte-space-96, 384px);flex-grow:1;flex-direction:column;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-4, 16px);border-right-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-right-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity))}aside header{margin-bottom:var(--dyte-space-4, 16px);width:100%;padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px);padding-top:var(--dyte-space-8, 32px);font-size:20px;font-weight:500;line-height:2rem}.shuffle-button{display:flex;flex-direction:row;align-items:center}.shuffle-button dyte-icon{height:var(--dyte-space-8, 32px)}.participants-assign-actions{display:flex;flex-direction:row;align-items:center;justify-content:space-between;font-size:14px;padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-2, 8px);margin-left:calc(var(--dyte-space-8, 32px) * -1);margin-right:calc(var(--dyte-space-4, 16px) * -1);padding-top:var(--dyte-space-0\\.5, 2px);padding-bottom:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.participants-assign-actions .deselect-button{height:var(--dyte-space-6, 24px)}.participants-assign-actions .deselect-button:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.assign-rooms{padding:var(--dyte-space-8, 32px);display:flex;width:100%;flex-direction:column}.assign-rooms .disabled{opacity:0.2}.assign-rooms .back{display:flex;cursor:pointer;flex-direction:row;align-items:center;justify-content:flex-start;padding:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-0, 0px);font-size:14px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.assign-rooms .back dyte-icon{height:var(--dyte-space-5, 20px)}.assign-rooms .row{display:flex;flex-direction:row;align-items:center;justify-content:flex-start;gap:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}.assign-rooms .row-header{margin:var(--dyte-space-0, 0px);font-size:16px;line-height:2rem}.assign-rooms .cta-buttons{display:flex;align-items:center;justify-content:flex-start;gap:var(--dyte-space-2, 8px)}.assign-rooms .cta-buttons dyte-button div{display:flex;flex-direction:row;align-items:center}.assign-rooms .cta-buttons dyte-button div dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.rooms{margin-bottom:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-1, 4px);display:flex;flex-grow:1;flex-direction:column;gap:var(--dyte-space-2, 8px);overflow-y:auto;max-height:500px}.rooms::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px)}.rooms::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.rooms::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.breakout-actions{display:flex;flex-direction:row;align-items:center;justify-content:flex-end;gap:var(--dyte-space-2, 8px)}.breakout-actions .start-breakout-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.breakout-actions .close-breakout-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}.breakout-actions .update-breakout-button{background-color:transparent;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity));border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}.status-bar{display:flex;align-items:center;font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));width:var(--dyte-space-80, 320px)}.ephemeral-status{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.ephemeral-status dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.room-switcher-container{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));width:468px;padding:var(--dyte-space-8, 32px)}.add-room-jumbo-btn div{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.add-room-jumbo-btn div dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}.br-primary-btn:not([disabled]){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-primary-btn:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}.br-secondary-btn:not([disabled]){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-secondary-btn:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

  const MIN_ROOMS = 1;
  const DyteBreakoutRoomsManager = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.permissionsUpdateListener = () => {
        this.permissions = this.meeting.self.permissions.connectedMeetings;
      };
      this.updateLocalState = (payload) => {
        this.stateManager.updateCurrentState(payload);
        this.draftState = this.stateManager.currentState;
        if (this.meeting.connectedMeetings.isActive) {
          this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { mode: 'edit' });
        }
        if (this.roomConfig.mode === 'create' && !this.meeting.connectedMeetings.isActive) {
          resetRoomCount();
        }
        if (['edit', 'view'].includes(this.roomConfig.mode)) {
          this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { rooms: payload.meetings.length, step: 'participants-config' });
          this.selectedParticipants = [];
        }
      };
      this.onAddNewRoom = () => {
        this.stateManager.addNewMeeting();
        this.draftState = this.stateManager.currentState;
        this.selectorRef.scrollTo({ top: this.selectorRef.scrollHeight, behavior: 'smooth' });
      };
      this.onRoomUpdate = (event) => {
        const { detail } = event;
        this.stateManager.updateMeetingTitle(detail.id, detail.title);
        this.draftState = this.stateManager.currentState;
      };
      this.onRoomDelete = (id) => {
        const toDelete = this.stateManager.allConnectedMeetings.find((meeting) => meeting.id === id);
        if (toDelete) {
          this.stateManager.deleteMeeting(id);
          this.draftState = this.stateManager.currentState;
        }
      };
      this.unassignParticipant = (id) => {
        this.stateManager.unassignParticipants([id]);
        this.draftState = this.stateManager.currentState;
      };
      this.onUnassignAll = () => {
        this.stateManager.unassignAllParticipants();
        this.draftState = this.stateManager.currentState;
      };
      this.assignParticipantsToRoom = (destinationMeetingId) => {
        if (this.selectedParticipants.length === 0 || this.assigningParticipants == false)
          return;
        this.stateManager.assignParticipantsToMeeting(this.selectedParticipants, destinationMeetingId);
        this.draftState = this.stateManager.currentState;
        this.selectedParticipants = [];
        this.assigningParticipants = false;
        this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.participants_assigned'));
      };
      this.handleClose = (stateUpdate, store) => {
        stateUpdate.emit({
          activeBreakoutRoomsManager: {
            active: true,
          },
        });
        store.activeBreakoutRoomsManager = {
          active: true,
        };
      };
      this.enableConfirmationModal = (modalType = 'start-breakout') => {
        let activeConfirmationModal = {
          active: true,
          header: 'breakout_rooms.confirm_modal.start_breakout.header',
          content: 'breakout_rooms.confirm_modal.start_breakout.content',
          variant: 'primary',
          cancelText: 'breakout_rooms.confirm_modal.start_breakout.cancelText',
          ctaText: 'breakout_rooms.confirm_modal.start_breakout.ctaText',
          onClick: () => this.applyChanges(),
          onClose: this.handleClose,
        };
        if (modalType === 'close-breakout') {
          activeConfirmationModal = {
            active: true,
            header: 'breakout_rooms.confirm_modal.close_breakout.header',
            content: 'breakout_rooms.confirm_modal.close_breakout.content',
            variant: 'danger',
            cancelText: 'cancel',
            ctaText: 'breakout_rooms.confirm_modal.close_breakout.ctaText',
            onClick: () => this.closeBreakout(),
            onClose: this.handleClose,
          };
        }
        this.stateUpdate.emit({
          activeBreakoutRoomsManager: { active: false },
          activeConfirmationModal,
        });
        state.activeBreakoutRoomsManager = { active: false };
        state.activeConfirmationModal = activeConfirmationModal;
      };
      this.close = () => {
        var _a;
        this.stateManager.discardChanges();
        (_a = this.stateUpdate) === null || _a === undefined ? undefined : _a.emit({
          activeBreakoutRoomsManager: {
            active: false,
          },
        });
        state.activeBreakoutRoomsManager = { active: false };
      };
      this.applyChanges = async () => {
        this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { applyingChanges: true });
        await this.stateManager.applyChanges(this.meeting);
        this.close();
        this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { applyingChanges: false });
      };
      this.loading = false;
      this.roomConfig = {
        rooms: 2,
        step: 'room-config',
        mode: 'create',
        applyingChanges: false,
      };
      this.draftState = undefined;
      this.assigningParticipants = false;
      this.selectedParticipants = [];
      this.ephemeralStatusText = '';
      this.isDragMode = false;
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    onSelectedParticipantsChanged(participants) {
      if (participants.length > 0)
        this.assigningParticipants = true;
      else
        this.assigningParticipants = false;
    }
    connectedCallback() {
      this.permissionsUpdateListener();
      this.meeting.connectedMeetings.on('stateUpdate', this.updateLocalState);
      this.meeting.connectedMeetings.on('changingMeeting', this.close);
      this.meeting.self.permissions.on('permissionsUpdate', this.permissionsUpdateListener);
      this.stateManager = new BreakoutRoomsManager();
      this.fetchRoomState();
    }
    disconnectedCallback() {
      this.meeting.connectedMeetings.off('stateUpdate', this.updateLocalState);
      this.meeting.connectedMeetings.off('changingMeeting', this.close);
      this.meeting.self.permissions.off('permissionsUpdate', this.permissionsUpdateListener);
    }
    async fetchRoomState() {
      this.loading = true;
      await this.meeting.connectedMeetings.getConnectedMeetings();
      this.loading = false;
    }
    setEphemeralStatus(text) {
      this.ephemeralStatusText = text;
      setTimeout(() => {
        this.ephemeralStatusText = '';
      }, 3000);
    }
    onCreateRooms() {
      this.selectedParticipants = [];
      this.stateManager.addNewMeetings(this.roomConfig.rooms);
      this.draftState = this.stateManager.currentState;
      // move to next step -> participants-config
      this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { step: 'participants-config' });
    }
    onParticipantDelete(event) {
      const { detail } = event;
      const id = participantIdentifier(detail);
      if (id == null)
        return;
      this.unassignParticipant(id);
    }
    toggleDragMode(e) {
      this.isDragMode = e.detail;
    }
    assignParticipantsRandomly() {
      if (this.stateManager.unassignedParticipants.length === 0)
        return;
      this.stateManager.assignParticipantsRandomly();
      this.draftState = this.stateManager.currentState;
      this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.participants_assigned_randomly'));
    }
    async joinRoom(destinationMeetingId) {
      const participantId = participantIdentifier(this.meeting.self);
      this.stateManager.assignParticipantsToMeeting([participantId], destinationMeetingId);
      await this.applyChanges();
    }
    async closeBreakout() {
      this.stateManager.allConnectedMeetings.forEach((meeting) => this.stateManager.deleteMeeting(meeting.id));
      await this.applyChanges();
    }
    updateSelectedParticipants(e) {
      this.selectedParticipants = e.detail;
    }
    updateAllParticipants(e) {
      this.selectedParticipants = e.detail;
    }
    getStatusText() {
      if (this.ephemeralStatusText !== '')
        return this.ephemeralStatusText;
      let statusText = '';
      if (this.roomConfig.mode === 'create') {
        statusText = this.t('breakout_rooms.status.assign_multiple');
        if (this.selectedParticipants.length !== 0) {
          statusText = this.t('breakout_rooms.status.select_room');
        }
      }
      return statusText;
    }
    getApproxDistribution() {
      const num = this.stateManager.unassignedParticipants.length / (this.roomConfig.rooms || MIN_ROOMS);
      return Math.max(MIN_ROOMS, Math.round(num));
    }
    deselectAll() {
      this.selectedParticipants = [];
    }
    async discardChanges() {
      this.stateManager.discardChanges();
      await this.fetchRoomState();
      this.setEphemeralStatus(this.t('breakout_rooms.ephemeral_status.changes_discarded'));
    }
    shouldShowOnlyRoomSwitcher() {
      return this.permissions.canAlterConnectedMeetings === false;
    }
    getPermittedRooms() {
      if (this.permissions.canAlterConnectedMeetings || this.permissions.canSwitchConnectedMeetings) {
        return this.stateManager.allConnectedMeetings;
      }
      return this.stateManager.allConnectedMeetings.filter((cMeeting) => cMeeting.id === this.meeting.meta.meetingId);
    }
    renderMainRoomMaybe() {
      if (!(this.meeting.connectedMeetings.isActive && this.permissions.canSwitchToParentMeeting)) {
        return null;
      }
      return (h("dyte-breakout-room-manager", { key: this.stateManager.currentState.parentMeeting['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, meeting: this.meeting, mode: this.roomConfig.mode, onParticipantsAdd: () => this.assignParticipantsToRoom(this.stateManager.currentState.parentMeeting['id']), onRoomJoin: () => this.joinRoom(this.stateManager.currentState.parentMeeting['id']), onUpdate: this.onRoomUpdate, states: this.states, room: Object.assign({}, this.stateManager.currentState.parentMeeting), iconPack: this.iconPack, t: this.t }));
    }
    renderRoomSwitcher() {
      return (h(Host, null, h("div", { class: "room-switcher-container" }, h("header", null, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("span", null, this.t('breakout_rooms.join_breakout_header'))), h("div", { class: "rooms", ref: (el) => (this.selectorRef = el) }, this.renderMainRoomMaybe(), this.getPermittedRooms().map((room, idx) => {
        return (h("dyte-breakout-room-manager", { key: room['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, defaultExpanded: idx === 0, meeting: this.meeting, mode: this.roomConfig.mode, onDelete: () => this.onRoomDelete(room['id']), onParticipantsAdd: () => this.assignParticipantsToRoom(room['id']), onRoomJoin: () => this.joinRoom(room['id']), states: this.states, room: Object.assign({}, room), iconPack: this.iconPack, t: this.t, allowDelete: false }));
      })))));
    }
    renderLoading() {
      return (h(Host, null, h("div", { class: "loading-content" }, h("dyte-spinner", { size: "xl" }))));
    }
    renderRoomConfig() {
      return (h(Host, null, h("div", { class: "room-config" }, h("header", null, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("span", null, this.t('breakout_rooms.room_config_header'))), h("div", { class: "create-room" }, h("p", null, this.t('breakout_rooms.num_of_rooms')), h("dyte-counter", { value: this.roomConfig.rooms, minValue: MIN_ROOMS, iconPack: this.iconPack, t: this.t, onValueChange: (val) => {
          this.roomConfig = Object.assign(Object.assign({}, this.roomConfig), { rooms: Math.max(+val.detail, MIN_ROOMS) });
        } })), h("span", { class: "distribution-hint" }, `${this.t('breakout_rooms.approx')}${' '}`, ' ', h("em", null, this.getApproxDistribution(), " ", this.t('breakout_rooms.participants_per_room')), ' ', this.t('breakout_rooms.division_text')), h("footer", null, h("dyte-button", { kind: "button", iconPack: this.iconPack, t: this.t, size: "lg", title: this.t('create'), disabled: this.roomConfig.rooms === 0, onClick: () => this.onCreateRooms() }, this.t('create'))))));
    }
    render() {
      if (this.loading) {
        return this.renderLoading();
      }
      if (this.shouldShowOnlyRoomSwitcher()) {
        return this.renderRoomSwitcher();
      }
      if (this.roomConfig.step === 'room-config') {
        return this.renderRoomConfig();
      }
      // participant config
      return (h(Host, null, h("div", { class: "participant-config-wrapper" }, h("div", { class: "participant-config" }, h("aside", { part: "menu" }, h("header", null, this.t('breakout_rooms.assign_participants')), h("dyte-breakout-room-participants", { meeting: this.meeting, iconPack: this.iconPack, t: this.t, participantIds: this.stateManager.unassignedParticipants.map(participantIdentifier), selectedParticipantIds: this.selectedParticipants }, h("dyte-tooltip", { label: this.t('breakout_rooms.shuffle_participants'), iconPack: this.iconPack, t: this.t, slot: "shuffle-button" }, h("dyte-button", { disabled: this.roomConfig.mode === 'edit' ||
          this.stateManager.unassignedParticipants.length === 0, iconPack: this.iconPack, t: this.t, kind: "button", variant: "secondary", size: "md", onClick: () => this.assignParticipantsRandomly(), class: "shuffle-button br-primary-btn" }, h("dyte-icon", { icon: this.iconPack.shuffle, iconPack: this.iconPack, t: this.t })))), this.selectedParticipants.length !== 0 && (h("div", { class: "participants-assign-actions" }, h("span", null, `${this.selectedParticipants.length} ${this.t('breakout_rooms.selected')}`), h("dyte-button", { disabled: this.roomConfig.mode === 'edit', iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", size: "md", onClick: () => this.deselectAll(), class: "deselect-button color-danger" }, this.t('breakout_rooms.deselect'))))), h("div", { class: "assign-rooms" }, h("div", { class: "row" }, h("p", { class: "row-header" }, this.t('breakout_rooms.rooms'), " (", this.stateManager.allConnectedMeetings.length, ")"), !this.assigningParticipants && (h("div", { class: "cta-buttons" }, h("dyte-button", { kind: "button", variant: "secondary", iconPack: this.iconPack, t: this.t, class: "br-primary-btn" }, h("div", { onClick: this.onAddNewRoom }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }), this.t('breakout_rooms.add_room'))), this.stateManager.allConnectedMeetings.flatMap((m) => m.participants)
        .length !== 0 && (h("dyte-button", { kind: "button", variant: "ghost", onClick: this.onUnassignAll, iconPack: this.iconPack, t: this.t }, this.t('breakout_rooms.unassign_all')))))), h("div", { class: "rooms", ref: (el) => (this.selectorRef = el) }, this.renderMainRoomMaybe(), this.getPermittedRooms().map((room, idx) => {
        return (h("dyte-breakout-room-manager", { key: room['id'], assigningParticipants: this.assigningParticipants, isDragMode: this.isDragMode, defaultExpanded: idx === 0, meeting: this.meeting, mode: this.roomConfig.mode, onDelete: () => this.onRoomDelete(room['id']), onParticipantsAdd: () => this.assignParticipantsToRoom(room['id']), onRoomJoin: () => this.joinRoom(room['id']), onUpdate: this.onRoomUpdate, states: this.states, room: Object.assign({}, room), iconPack: this.iconPack, t: this.t, allowDelete: this.stateManager.allConnectedMeetings.length > MIN_ROOMS }));
      }), h("dyte-button", { kind: "button", variant: "secondary", iconPack: this.iconPack, t: this.t, onClick: this.onAddNewRoom, class: "add-room-jumbo-btn br-secondary-btn" }, h("div", null, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }), h("span", null, this.t('breakout_rooms.add_room_brief'))))))), h("div", { class: "participant-config-actions" }, h("div", { class: { 'status-bar': true, 'ephemeral-status': this.ephemeralStatusText !== '' } }, this.ephemeralStatusText !== '' && (h("dyte-icon", { icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t })), this.getStatusText()), h("div", { class: "breakout-actions" }, this.roomConfig.mode === 'create' && this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "start-breakout-button", onClick: () => this.enableConfirmationModal('start-breakout') }, this.t('breakout_rooms.start_breakout'))), this.roomConfig.mode === 'edit' &&
        this.stateManager.hasLocalChanges &&
        this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "color-danger", variant: "ghost", onClick: () => this.discardChanges() }, this.t('breakout_rooms.discard_changes'))), this.roomConfig.mode === 'edit' &&
        this.stateManager.hasLocalChanges &&
        this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "update-breakout-button", onClick: this.applyChanges }, this.t('breakout_rooms.update_breakout'))), this.roomConfig.mode === 'edit' &&
        !this.stateManager.hasLocalChanges &&
        this.permissions.canAlterConnectedMeetings && (h("dyte-button", { size: "md", iconPack: this.iconPack, t: this.t, class: "close-breakout-button", onClick: () => this.enableConfirmationModal('close-breakout') }, this.t('breakout_rooms.close_breakout'))))))));
    }
    static get watchers() { return {
      "selectedParticipants": ["onSelectedParticipantsChanged"]
    }; }
  };
  DyteBreakoutRoomsManager.style = dyteBreakoutRoomsManagerCss;

  var dyteBreakoutRoomsManager_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_breakout_rooms_manager: DyteBreakoutRoomsManager
  });

  const dyteBreakoutRoomsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteBreakoutRoomsToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.permissionsUpdateListener = () => {
        this.canToggle = canToggleBreakout(this.meeting);
      };
      this.breakoutRoomToggle = () => {
        var _a, _b, _c;
        const mode = this.meeting.connectedMeetings.isActive ? 'view' : 'create';
        this.stateUpdate.emit({
          activeBreakoutRoomsManager: {
            active: !((_b = (_a = this.states) === null || _a === undefined ? undefined : _a.activeBreakoutRoomsManager) === null || _b === undefined ? undefined : _b.active),
            mode,
          },
        });
        state.activeBreakoutRoomsManager = {
          active: !((_c = state.activeBreakoutRoomsManager) === null || _c === undefined ? undefined : _c.active),
          mode,
        };
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.canToggle = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions) === null || _c === undefined ? undefined : _c.off('permissionsUpdate', this.permissionsUpdateListener);
    }
    meetingChanged(meeting) {
      if (!meeting)
        return;
      this.canToggle = canToggleBreakout(meeting);
      meeting.self.permissions.on('permissionsUpdate', this.permissionsUpdateListener);
    }
    render() {
      if (!this.canToggle)
        return;
      return (h(Host, { title: this.t('breakout_rooms') }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.breakoutRoomToggle, icon: this.iconPack.breakout_rooms, label: this.t('breakout_rooms'), variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteBreakoutRoomsToggle.style = dyteBreakoutRoomsToggleCss;

  var dyteBreakoutRoomsToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_breakout_rooms_toggle: DyteBreakoutRoomsToggle
  });

  const dyteBroadcastMessageModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);padding:var(--dyte-space-4, 16px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));width:400px;max-width:80%}.content-col{display:flex;width:100%;flex-direction:column}h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-2, 8px)}.content-row{display:flex;width:100%;flex-direction:row}.content-row dyte-button{margin-top:var(--dyte-space-4, 16px);width:100%}textarea{margin-top:var(--dyte-space-3, 12px);resize:none;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;font-family:var(--dyte-font-family, sans-serif);outline:2px solid transparent;outline-offset:2px;height:var(--dyte-space-16, 64px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}textarea::-moz-placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}textarea::placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}select{border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);outline:2px solid transparent;outline-offset:2px;border-right-width:var(--dyte-border-width-md, 2px);border-style:solid;border-color:transparent;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}p{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-2, 8px);width:100%;text-align:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));display:flex;flex-direction:row;align-items:center;justify-content:center}p dyte-icon{margin-left:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px)}";

  const DyteBroadcastMessageModal = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.messagePayload = {
        to: 'Everyone',
        message: '',
      };
      this.successMessage = false;
    }
    close() {
      var _a;
      (_a = this.stateUpdate) === null || _a === undefined ? undefined : _a.emit({ activeBroadcastMessageModal: false });
      state.activeBroadcastMessageModal = false;
    }
    sendMessage() {
      // TODO:(ishita1805) Send this.messagePayload to webcore.
      this.successMessage = true;
      setTimeout(() => {
        this.close();
      }, 2000);
    }
    render() {
      return (h(Host, null, h("div", { class: "content-col" }, h("h2", null, "Broadcast message to"), h("select", { onChange: (e) => {
          this.messagePayload = Object.assign(Object.assign({}, this.messagePayload), { to: e.target.value });
        } }, h("option", null, "Everyone"), h("option", null, "List of rooms")), h("textarea", { placeholder: "Type message here...", onInput: (e) => {
          this.messagePayload = Object.assign(Object.assign({}, this.messagePayload), { message: e.target.value });
        } }), this.successMessage ? (h("p", null, "Message sent to ", this.messagePayload.to, h("dyte-icon", { icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t }))) : (h("div", { class: "content-row" }, h("dyte-button", { onClick: () => this.close(), variant: "secondary", iconPack: this.iconPack, t: this.t }, "Cancel"), "\u2002", h("dyte-button", { variant: "primary", onClick: () => this.sendMessage(), iconPack: this.iconPack, t: this.t }, "Send"))))));
    }
  };
  DyteBroadcastMessageModal.style = dyteBroadcastMessageModalCss;

  var dyteBroadcastMessageModal_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_broadcast_message_modal: DyteBroadcastMessageModal
  });

  const dyteCameraToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteCameraToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.videoUpdateListener = ({ videoEnabled }) => {
        this.videoEnabled = videoEnabled;
      };
      this.stageStatusListener = () => {
        this.stageStatus = this.meeting.stage.status;
        this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
      };
      this.mediaPermissionUpdateListener = ({ kind, message }) => {
        if (kind === 'video') {
          this.cameraPermission = message;
        }
      };
      this.meetingPermissionsUpdateListener = (patch) => {
        var _a;
        if ((_a = patch === null || patch === undefined ? undefined : patch.media) === null || _a === undefined ? undefined : _a.video) {
          this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
        }
      };
      this.toggleCamera = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.__internals__.logger.info('dyteCameraToggle::toggleCamera', {
          media: {
            video: {
              enabled: Boolean((_c = (_b = this.meeting) === null || _b === undefined ? undefined : _b.self) === null || _c === undefined ? undefined : _c.videoEnabled),
              permission: this.cameraPermission,
              canProduce: (_f = (_e = (_d = this.meeting) === null || _d === undefined ? undefined : _d.self) === null || _e === undefined ? undefined : _e.permissions) === null || _f === undefined ? undefined : _f.canProduceVideo,
            },
          },
          webinar: {
            stageStatus: (_g = this.meeting) === null || _g === undefined ? undefined : _g.stage.status,
          },
          livestream: {
            stageStatus: (_j = (_h = this.meeting) === null || _h === undefined ? undefined : _h.stage) === null || _j === undefined ? undefined : _j.status,
          },
          moduleExists: {
            self: Boolean((_k = this.meeting) === null || _k === undefined ? undefined : _k.self),
          },
        });
        if (this.hasPermissionError()) {
          const permissionModalSettings = {
            enabled: true,
            kind: 'video',
          };
          this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
          state.activePermissionsMessage = permissionModalSettings;
          return false;
        }
        const self = (_l = this.meeting) === null || _l === undefined ? undefined : _l.self;
        if (self == null || !this.canProduceVideo) {
          return;
        }
        if (self.videoEnabled) {
          self.disableVideo();
        }
        else {
          self.enableVideo();
        }
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.videoEnabled = false;
      this.canProduceVideo = false;
      this.cameraPermission = 'NOT_REQUESTED';
      this.stageStatus = 'OFF_STAGE';
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f, _g;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.removeListener('videoUpdate', this.videoUpdateListener);
      (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.stage) === null || _d === undefined ? undefined : _d.removeListener('stageStatusUpdate', this.stageStatusListener);
      (_g = (_f = (_e = this.meeting) === null || _e === undefined ? undefined : _e.self) === null || _f === undefined ? undefined : _f.permissions) === null || _g === undefined ? undefined : _g.removeListener('permissionsUpdate', this.meetingPermissionsUpdateListener);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting != null) {
        const { self, stage } = meeting;
        this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
        this.cameraPermission = self.mediaPermissions.video || 'NOT_REQUESTED';
        this.videoEnabled = self.videoEnabled;
        this.stageStatus = meeting.stage.status;
        self.addListener('videoUpdate', this.videoUpdateListener);
        self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
        stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStatusListener);
        (_b = (_a = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _a === undefined ? undefined : _a.permissions) === null || _b === undefined ? undefined : _b.addListener('permissionsUpdate', this.meetingPermissionsUpdateListener);
      }
    }
    hasPermissionError() {
      return this.cameraPermission === 'DENIED' || this.cameraPermission === 'SYSTEM_DENIED';
    }
    getState() {
      let tooltipLabel = '';
      let label = '';
      let icon = '';
      let classList = {};
      let hasError = this.hasPermissionError();
      let couldNotStart = this.cameraPermission === 'COULD_NOT_START';
      if (this.videoEnabled && !hasError) {
        label = this.t('video_on');
        icon = this.iconPack.video_on;
      }
      else {
        label = this.t('video_off');
        icon = this.iconPack.video_off;
        classList['red-icon'] = true;
      }
      if (couldNotStart) {
        tooltipLabel = this.t('perm_could_not_start.video');
      }
      else if (this.cameraPermission === 'SYSTEM_DENIED') {
        tooltipLabel = this.t('perm_sys_denied.video');
      }
      else if (this.cameraPermission === 'DENIED') {
        tooltipLabel = this.t('perm_denied.video');
      }
      else {
        tooltipLabel = this.videoEnabled ? this.t('disable_video') : this.t('enable_video');
      }
      return {
        tooltipLabel,
        label,
        icon,
        classList,
        showWarning: hasError || couldNotStart,
        disable: hasError,
      };
    }
    render() {
      var _a;
      if (!this.canProduceVideo ||
        ((_a = this.meeting) === null || _a === undefined ? undefined : _a.meta.viewType) === 'AUDIO_ROOM' ||
        ['OFF_STAGE', 'REQUESTED_TO_JOIN_STAGE'].includes(this.stageStatus)) {
        return null;
      }
      const { tooltipLabel, label, icon, classList, showWarning, disable } = this.getState();
      return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: tooltipLabel, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: classList, variant: this.variant, label: label, icon: icon, onClick: this.toggleCamera, showWarning: showWarning, disabled: disable }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteCameraToggle.style = dyteCameraToggleCss;

  var dyteCameraToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_camera_toggle: DyteCameraToggle
  });

  const dyteCaptionToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteCaptionToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.permissionsUpdateListener = () => {
        var _a;
        this.captionEnabled =
          (_a = this.meeting.self.permissions.transcriptionEnabled) !== null && _a !== undefined ? _a : false;
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.size = undefined;
      this.t = useLanguage();
      this.captionEnabled = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    meetingChanged(meeting) {
      if (meeting === null)
        return;
      this.permissionsUpdateListener();
      this.meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    toggleCaptions() {
      this.stateUpdate.emit({ activeCaptions: !state.activeCaptions });
      state.activeCaptions = !state.activeCaptions;
      this.stateUpdate.emit({ activeMoreMenu: false });
      state.activeMoreMenu = false;
    }
    render() {
      if (!this.captionEnabled)
        return null;
      const captionsEnabled = this.states.activeCaptions;
      return (h(Host, { tabIndex: 0, role: "log", "aria-label": `Picture-in-Picture mode` }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleCaptions(), icon: captionsEnabled ? this.iconPack.captionsOff : this.iconPack.captionsOn, label: captionsEnabled ? this.t('transcript.off') : this.t('transcript.on'), variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteCaptionToggle.style = dyteCaptionToggleCss;

  var dyteCaptionToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_caption_toggle: DyteCaptionToggle
  });

  const dyteChannelCreatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-96, 384px);padding-left:var(--dyte-space-9, 36px);padding-right:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-10, 40px);padding-bottom:var(--dyte-space-10, 40px)}header{margin-bottom:var(--dyte-space-8, 32px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);font-size:24px;font-weight:600}.channel-name-input{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-3, 12px);font-size:16px;-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:1.25;outline:2px solid transparent;outline-offset:2px}.channel-name-input:focus{outline-width:2px;outline-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}footer{margin-top:var(--dyte-space-5, 20px);display:flex;justify-content:flex-end}.member{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding:var(--dyte-space-2, 8px)}.member dyte-avatar{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.input-container{position:relative;-webkit-appearance:none;-moz-appearance:none;appearance:none;line-height:1.25;outline:2px solid transparent;outline-offset:2px;outline-width:2px;outline-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5);border-radius:var(--dyte-border-radius-sm, 4px)}.input-container .members{margin:var(--dyte-space-0, 0px);max-height:var(--dyte-space-28, 112px);border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);list-style-type:none;display:flex;flex-wrap:wrap;gap:var(--dyte-space-1, 4px);cursor:text;font-size:16px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));overflow-y:auto;min-height:var(--dyte-space-7, 28px)}.input-container .pill{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.input-container .pill dyte-avatar{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.input-container .pill span{max-width:var(--dyte-space-32, 128px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.input-container .pill dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);cursor:pointer}.input-container input{width:var(--dyte-space-24, 96px);border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-1, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;font-size:16px;line-height:1.25rem}.input-container input.wide-input{width:100%}.search-results{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-1, 4px);max-height:var(--dyte-space-28, 112px);width:100%;padding:var(--dyte-space-0, 0px);position:absolute;list-style-type:none;overflow-y:auto;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-md, 8px);--tw-border-spacing-x:var(--dyte-space-2, 8px);--tw-border-spacing-y:var(--dyte-space-2, 8px);border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-style:solid;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.search-results .member{cursor:pointer}.search-results .member dyte-avatar{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.search-results .member:hover,.search-results .member.selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}";

  const DyteChannelCreator = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.switchChannel = createEvent(this, "switchChannel", 7);
      this.allMembers = new Map();
      this.inputTextRef = null;
      this.searchInputTextRef = null;
      this.focusOnSearch = (selectText = false) => {
        this.focusedMemberIndex = -1;
        writeTask(() => {
          var _a, _b;
          (_a = this.searchInputTextRef) === null || _a === undefined ? undefined : _a.focus();
          if (selectText)
            (_b = this.searchInputTextRef) === null || _b === undefined ? undefined : _b.select();
        });
      };
      this.onClickHandler = async () => {
        if (this.channelName.length === 0)
          return;
        if (this.step === 1) {
          const members = this.meeting.participants.all.toArray();
          const selfId = this.meeting.self.userId;
          const nonSelfMembers = members.filter((member) => member.userId !== selfId);
          nonSelfMembers.forEach((member) => this.allMembers.set(member.userId, member));
          this.step = 2;
          this.focusOnSearch();
          return;
        }
        // step 2 - add members and create channel
        await this.createChannel();
      };
      this.createChannel = async () => {
        const members = Array.from(this.selectedMemberIds);
        const newChannel = await this.meeting.chat.createChannel(this.channelName, members, {
          displayPictureUrl: '',
          visibility: 'public',
          isDirectMessage: false,
        });
        this.switchChannel.emit(newChannel.id);
        this.stateUpdate.emit({ activeChannelCreator: false });
        state.activeChannelCreator = false;
      };
      this.onMemberAdd = (id) => {
        this.showAllMembersList = false;
        this.selectedMemberIds.add(id);
        this.searchQuery = '';
        this.focusOnSearch();
      };
      this.keyDownHandler = (e, filteredMembers) => {
        if (e.key === 'ArrowDown') {
          this.focusedMemberIndex = Math.min(this.focusedMemberIndex + 1, filteredMembers.length - 1);
        }
        else if (e.key === 'ArrowUp') {
          if (this.focusedMemberIndex === -1)
            return;
          if (this.focusedMemberIndex === 0) {
            this.focusOnSearch(true);
            return;
          }
          this.focusedMemberIndex = Math.max(this.focusedMemberIndex - 1, 0);
        }
        else if (e.key === 'Enter') {
          this.onMemberAdd(filteredMembers[this.focusedMemberIndex].userId);
        }
        else if (e.key === 'Backspace') {
          if (this.searchQuery.length !== 0)
            return;
          if (this.selectedMemberIds.size === 0)
            return;
          const lastMemberId = Array.from(this.selectedMemberIds.values()).at(-1);
          this.selectedMemberIds.delete(lastMemberId);
          forceUpdate(this.$el);
        }
      };
      this.renderMemberSelector = () => {
        const filteredMembers = Array.from(this.allMembers.values()).filter((member) => !this.selectedMemberIds.has(member.userId) &&
          member.name.toLowerCase().includes(this.searchQuery.toLowerCase()));
        const selectedMembers = Array.from(this.selectedMemberIds.values()).map((id) => this.allMembers.get(id));
        const disableInput = this.selectedMemberIds.size === this.allMembers.size;
        return (h("div", { class: "input-container" }, h("ul", { class: "members scrollbar", onClick: () => {
            var _a;
            (_a = this.searchInputTextRef) === null || _a === undefined ? undefined : _a.focus();
          } }, selectedMembers.map((member) => (h("li", { class: "pill" }, h("dyte-avatar", { participant: {
            name: member.name,
            picture: member.picture,
          }, size: "sm" }), h("span", null, member.name), h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t, onClick: () => {
            this.selectedMemberIds.delete(member.userId);
            forceUpdate(this.$el);
            this.focusOnSearch();
          } })))), !disableInput && (h("input", { type: "text", ref: (el) => (this.searchInputTextRef = el), value: this.searchQuery, placeholder: this.selectedMemberIds.size === 0 ? this.t('chat.member_name') : '', class: {
            'wide-input': this.selectedMemberIds.size === 0,
          }, onInput: (e) => {
            this.searchQuery = e.target.value.trim();
          }, onClick: () => {
            this.showAllMembersList = !this.showAllMembersList;
          }, onKeyDown: (e) => this.keyDownHandler(e, filteredMembers) }))), (this.searchQuery.length !== 0 || this.showAllMembersList) && (h("ul", { class: "search-results" }, filteredMembers.map((member, index) => (h("li", { class: { member: true, selected: index === this.focusedMemberIndex }, onClick: () => this.onMemberAdd(member.userId), ref: ($li) => {
            if (index === this.focusedMemberIndex) {
              writeTask(() => {
                if ($li)
                  $li.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
              });
            }
          } }, h("dyte-avatar", { participant: {
            name: member.name,
            picture: member.picture,
          }, size: "sm" }), h("span", null, member.name)))), filteredMembers.length === 0 && (h("li", { class: "member" }, h("span", null, this.t('chat.error.empty_results'))))))));
      };
      this.meeting = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.channelName = '';
      this.searchQuery = '';
      this.step = 1;
      this.loading = false;
      this.selectedMemberIds = new Set();
      this.focusedMemberIndex = -1;
      this.showAllMembersList = false;
    }
    componentDidLoad() {
      var _a;
      (_a = this.inputTextRef) === null || _a === undefined ? undefined : _a.focus();
    }
    render() {
      return (h(Host, null, h("header", null, this.step === 1 ? this.t('chat.new_channel') : this.t('chat.add_members')), this.step === 1 && (h("input", { class: "channel-name-input", type: "text", placeholder: this.t('chat.channel_name'), ref: (el) => (this.inputTextRef = el), onInput: (e) => {
          this.channelName = e.target.value.trim();
        } })), this.step === 2 && this.renderMemberSelector(), h("footer", null, h("dyte-button", { kind: "button", iconPack: this.iconPack, t: this.t, size: "lg", disabled: this.channelName.length === 0, onClick: this.onClickHandler }, this.step === 1 ? this.t('chat.add_members') : this.t('create')))));
    }
    get $el() { return getElement(this); }
  };
  DyteChannelCreator.style = dyteChannelCreatorCss;

  var dyteChannelCreator_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_channel_creator: DyteChannelCreator
  });

  const parseMessageForTarget = (message) => {
    let parsedMessage = null;
    try {
      const parsed = JSON.parse(message.message);
      const { target, message: m } = parsed;
      if (target === undefined || m === undefined) {
        parsedMessage = message;
      }
      else {
        parsedMessage = Object.assign(Object.assign({}, message), { targetUserIds: target, message: m });
      }
    }
    catch (error) {
      parsedMessage = message;
    }
    return parsedMessage;
  };
  function alphabeticalSorter(a, b) {
    return a.localeCompare(b);
  }
  /**
   * Generate a unique chat group key used in `<dyte-chat-messages-ui />`
   * @param ids An array of user ids
   * @returns A unique key from the user ids
   */
  function generateChatGroupKey(ids) {
    return ids.sort((a, b) => a.localeCompare(b)).join('_');
  }
  function handleFilesDataTransfer(items, callback) {
    if (items == null)
      return true;
    for (const item of items) {
      if (item.kind === 'file') {
        const file = item.getAsFile();
        if (item.type.startsWith('image/')) {
          callback('image', file);
        }
        else {
          callback('file', file);
        }
      }
    }
  }
  const TEMPORARY_CHANNEL_PREFIX = 'dm__';
  function isDirectMessageChannel(channel) {
    return channel.isDirectMessage;
  }
  function getDMComparator(memberIds) {
    const uniqueMemberIds = [...new Set(memberIds)];
    return uniqueMemberIds.sort(alphabeticalSorter).join('<>');
  }
  function reverse(str) {
    return str.split('').reverse().join('');
  }
  const boldPattern = /^\*([^*\s]+)\*/;
  const italicsPattern = /^_([^_\s]+)_/;
  const strikethroughPattern = /^~([^~\s]+)~/;
  // Source: https://stackoverflow.com/a/8234912/2013580
  const linkPattern = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.,~#?&//=]*)/;
  const replyBlockPattern = /<blockquote>[.\s\S]*<\/blockquote>\n\n/m;
  function extractReplyBlock(message, excludeTags = false) {
    if (!replyBlockPattern.test(message)) {
      return '';
    }
    let startOffset = 0;
    let endOffset = '</blockquote>'.length;
    if (excludeTags) {
      startOffset = '<blockquote>'.length;
      endOffset = 0;
    }
    return message.substring(message.indexOf('<blockquote>') + startOffset, message.indexOf('</blockquote>') + endOffset);
  }
  function stripOutReplyBlock(message) {
    return message.replace(replyBlockPattern, '');
  }
  const MAX_TEXT_LENGTH = 2000;
  const KNOWN_TAGS = ['<a>', '<b>', '<i>', '<q>', '<s>'];
  function parseRichText(text) {
    text = text
      .split(' ')
      .map((word) => {
      if (linkPattern.test(word)) {
        const res = linkPattern.exec(word);
        word = word.replace(res[0], `<a>${res[0]}</a>`);
      }
      else {
        if (boldPattern.test(word)) {
          const res = boldPattern.exec(word);
          word = word.replace(res[0], `<b>${res[1]}</b>`);
        }
        if (italicsPattern.test(word)) {
          const res = italicsPattern.exec(word);
          word = word.replace(res[0], `<i>${res[1]}</i>`);
        }
        if (strikethroughPattern.test(word)) {
          const res = strikethroughPattern.exec(word);
          word = word.replace(res[0], `<s>${res[1]}</s>`);
        }
      }
      return word;
    })
      .join(' ');
    text = text
      .split(' ')
      .map((word, idx) => {
      if (word === '>' && (idx === 0 || word[idx - 1] === '>')) {
        return `<q></q>`;
      }
      return word;
    })
      .join(' ');
    const [tokens] = tokenizeRichText(text);
    return tokens;
  }
  function tokenizeRichText(text, endTag = '') {
    const tokens = [];
    if (text.length === 0) {
      return [tokens, 0];
    }
    let i = 0;
    while (i < text.length) {
      if (endTag.length && endTag === text.substring(i, i + endTag.length)) {
        return [tokens, i + endTag.length];
      }
      if (KNOWN_TAGS.includes(text.substring(i, i + 3))) {
        const [subtokens, pos] = tokenizeRichText(text.substring(i + 3), `</${text[i + 1]}>`);
        tokens.push({
          type: text[i + 1],
          content: subtokens.length === 1 && subtokens[0].type === 'plain_text'
            ? subtokens[0].content
            : subtokens,
        });
        i += pos + 3;
      }
      else {
        let top = tokens[tokens.length - 1];
        if (!top || top.type !== 'plain_text') {
          tokens.push({ type: 'plain_text', content: '' });
          top = tokens[tokens.length - 1];
        }
        top.content += text[i];
        i++;
      }
    }
    return [tokens, i];
  }

  const renderLink = (content) => {
    return (h("a", { class: "link", href: content, target: "_blank", rel: "noopener noreferrer" }, content));
  };
  const renderBold = (content) => {
    if (typeof content === 'string') {
      return h("b", null, content);
    }
    return h("b", null, renderTokens(content));
  };
  const renderItalic = (content) => {
    if (typeof content === 'string') {
      return h("i", null, content);
    }
    return h("i", null, renderTokens(content));
  };
  const renderStrikethrough = (content) => {
    if (typeof content === 'string') {
      return h("s", null, content);
    }
    return h("b", null, renderTokens(content));
  };
  const renderPlainText = (content) => {
    if (typeof content === 'string') {
      return content;
    }
    return h("p", null, renderTokens(content));
  };
  const renderTokens = (tokens) => {
    return tokens.map((token) => {
      switch (token.type) {
        case 'a':
          if (typeof token.content === 'string') {
            return renderLink(token.content);
          }
        case 'b':
          return renderBold(token.content);
        case 'i':
          return renderItalic(token.content);
        case 's':
          return renderStrikethrough(token.content);
        case 'q':
          return h("span", { class: "block-quote" });
        case 'plain_text':
        default:
          return renderPlainText(token.content);
      }
    });
  };
  const TextMessageView = ({ message }) => {
    const slicedMessage = message.slice(0, MAX_TEXT_LENGTH);
    const withReply = extractReplyBlock(slicedMessage, true);
    const withoutReply = stripOutReplyBlock(slicedMessage);
    return (h("p", null,
      withReply.length !== 0 && (h("blockquote", null, withReply.split('\n').map((line) => {
        const tokens = parseRichText(line);
        return h("p", null, renderTokens(tokens));
      }))),
      withoutReply.split('\n').map((line) => {
        const tokens = parseRichText(line);
        return h("p", null, renderTokens(tokens));
      })));
  };

  const dyteChannelSelectorUiCss = ".scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex}.container{display:flex;height:100%;width:var(--dyte-space-96, 384px);flex-direction:column;position:absolute;--tw-translate-x:calc(var(--dyte-space-96, 384px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-sm, 1px);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-right-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity));transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}@keyframes fade{0%{opacity:0}100%{opacity:1}}.overlay-container{width:100vw;--tw-translate-x:var(--dyte-space-96, 384px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;animation:fade 0.8s}.overlay-container .sidebar-btn{position:static;padding:var(--dyte-space-4, 16px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.sidebar-btn{position:absolute;right:calc(var(--dyte-space-9, 36px) * -1);top:var(--dyte-space-4, 16px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-7, 28px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px)}@media (orientation: landscape) and (min-width: 400px){.container{position:static;--tw-translate-x:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.sidebar-btn,.overlay-container{display:none}}.search-wrapper{display:flex;align-items:center;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-2, 8px);border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}.search{position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-8, 32px);width:100%}.search .search-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);padding:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));border-top-right-radius:var(--dyte-border-radius-sm, 4px);border-bottom-right-radius:var(--dyte-border-radius-sm, 4px)}.search input{box-sizing:border-box;width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;font-size:14px;line-height:1.25rem}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input{border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px)}.channel-container{box-sizing:border-box;display:flex;flex-direction:column;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);overflow-y:scroll}.channel-container .channel{display:flex;align-items:center;justify-content:space-between;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px);border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-border-opacity))}.channel-container .channel:hover{cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}.channel-container .channel:hover .latest-msg-time,.channel-container .channel:hover .latest-msg,.channel-container .channel:hover .latest-msg.new{color:rgb(var(--dyte-colors-text-on-brand-700, var(--dyte-colors-text-700, 255 255 255 / 0.64)))}.channel-container .channel-display{display:flex;gap:var(--dyte-space-2, 8px);align-self:center;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-0, 0px)}.channel-container .channel-display dyte-avatar{height:var(--dyte-space-9, 36px);width:var(--dyte-space-9, 36px);flex-shrink:0;font-size:12px}.channel-container .channel-display dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);flex-shrink:0;padding:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.channel-container .channel-card{width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-1, 4px)}.channel-container .channel-card .channel-name{max-width:var(--dyte-space-60, 240px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px;font-weight:500}.channel-container .channel-card .latest-msg{margin:var(--dyte-space-0, 0px);max-width:var(--dyte-space-56, 224px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:14px}.channel-container .channel-card .latest-msg.new{font-weight:200;font-style:italic;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.channel-container .channel-card .latest-msg-time{font-size:12px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.channel-container .channel-meta{width:var(--dyte-space-12, 48px);display:flex;flex-direction:column;align-items:flex-end;justify-content:space-between;gap:var(--dyte-space-1\\.5, 6px);font-size:12px;font-weight:600}.channel-container .new-msgs-count{height:var(--dyte-space-4, 16px);min-width:var(--dyte-space-4, 16px);padding-top:1px;padding-bottom:1px;padding-left:2px;padding-right:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:var(--dyte-border-radius-sm, 4px);text-align:center;font-size:12px}.channel-container .selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}.channel-container .selected .latest-msg-time,.channel-container .selected .latest-msg,.channel-container .selected .latest-msg.new{color:rgb(var(--dyte-colors-text-on-brand-700, var(--dyte-colors-text-700, 255 255 255 / 0.64)))}.channel-container .highlight .channel-title span{font-weight:700}.latest-msg p{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-1, 4px);display:inline-block}.latest-msg blockquote{display:none}.recent-message-row{margin-bottom:var(--dyte-space-2, 8px);display:flex;width:100%;flex-direction:row;justify-content:space-between}";

  const DyteChannelSelectorUi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.channelChanged = createEvent(this, "channelChanged", 7);
      this.handleResize = (e) => {
        this.isHidden = !e.matches;
      };
      this.channelSelected = (channelId) => {
        this.channelChanged.emit(channelId);
        this.onRevealClicked();
      };
      this.onSearchInput = (e) => {
        this.searchQuery = e.target.value;
      };
      this.onRevealClicked = () => {
        if (this.matchMedia.matches)
          return;
        this.isHidden = !this.isHidden;
      };
      this.renderChannelDisplayPic = (channel) => {
        const hasDisplayPic = channel.displayPictureUrl && channel.displayPictureUrl.length !== 0;
        if (channel.isDirectMessage || hasDisplayPic) {
          return (h("div", { class: "channel-display" }, h("dyte-avatar", { participant: {
              name: channel.displayName,
              picture: channel.displayPictureUrl,
            } })));
        }
        else {
          return (h("div", { class: "channel-display" }, h("dyte-icon", { icon: this.iconPack.people, slot: "start" })));
        }
      };
      this.renderRecentMessage = (channel) => {
        if (!channel.latestMessage)
          return h("p", { class: "latest-msg new" }, this.t('chat.start_conversation'));
        let senderFragment = channel.isDirectMessage ? '' : `${channel.latestMessage.displayName}: `;
        if (channel.latestMessage.type === 'text') {
          return (h("p", { class: "latest-msg" }, senderFragment, h(TextMessageView, { message: channel.latestMessage.message })));
        }
        // non text
        let messageFragment = '';
        if (channel.latestMessage.type === 'image') {
          messageFragment = this.t('image');
        }
        else if (channel.latestMessage.type === 'file') {
          messageFragment = this.t('file');
        }
        return h("p", { class: "latest-msg" }, `${senderFragment}${messageFragment}`);
      };
      this.channels = undefined;
      this.selectedChannelId = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showRecentMessage = false;
      this.isHidden = false;
      this.searchQuery = '';
    }
    connectedCallback() {
      this.matchMedia = window.matchMedia(`(orientation: landscape) and (min-width: 400px)`);
      this.matchMedia.addEventListener('change', this.handleResize);
      this.isHidden = !this.matchMedia.matches;
    }
    disconnectedCallback() {
      this.matchMedia.removeEventListener('change', this.handleResize);
    }
    componentDidRender() {
      this.$el.style.transform = this.isHidden ? 'translateX(-380px)' : 'translateX(0)';
    }
    getTimeLabel(message) {
      const messageDate = message.time;
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(today.getDate() - 1);
      const firstDayOfWeek = new Date(today);
      firstDayOfWeek.setDate(today.getDate() - today.getDay() - 1);
      if (messageDate.toDateString() === today.toDateString()) {
        return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      else if (messageDate.toDateString() === yesterday.toDateString()) {
        return this.t('date.yesteday');
      }
      else if (messageDate > firstDayOfWeek) {
        const weekdays = [
          'date.sunday',
          'date.monday',
          'date.tuesday',
          'date.wednesday',
          'date.thursday',
          'date.friday',
          'date.saturday',
        ];
        return this.t(weekdays[messageDate.getDay()]);
      }
      else {
        return Intl.DateTimeFormat([], {
          day: '2-digit',
          month: '2-digit',
          year: '2-digit',
        }).format(messageDate);
      }
    }
    render() {
      return (h(Host, null, h("div", { class: "container", ref: (el) => (this.$el = el) }, this.isHidden && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "icon", variant: "ghost", size: "md", onClick: this.onRevealClicked, class: "sidebar-btn" }, h("dyte-icon", { icon: this.isHidden ? this.iconPack.chevron_left : this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("slot", { name: "header" }), h("div", { class: "search-wrapper" }, h("div", { class: "search" }, h("input", { type: "search", autocomplete: "off", placeholder: this.t('chat.search_conversations'), onInput: this.onSearchInput }), h("dyte-icon", { icon: this.iconPack.search, iconPack: this.iconPack, t: this.t, class: "search-icon" }))), h("div", { class: "channel-container scrollbar", role: "list" }, this.channels
        .filter((channel) => this.searchQuery === '' || channel.displayName.includes(this.searchQuery))
        .map((channel) => {
        return (h("div", { class: {
            channel: true,
            selected: channel.id === this.selectedChannelId,
            highlight: !!channel.unreadCount,
          }, role: "listitem", onClick: () => {
            this.channelSelected(channel.id);
          } }, this.renderChannelDisplayPic(channel), h("div", { class: "channel-card", "is-direct-message": channel.isDirectMessage }, h("div", { class: 'recent-message-row' }, h("span", { class: "channel-name" }, channel.displayName), channel.latestMessage && (h("span", { class: "latest-msg-time" }, this.getTimeLabel(channel.latestMessage)))), h("div", { class: 'recent-message-row' }, this.renderRecentMessage(channel), channel.unreadCount > 0 && channel.id !== this.selectedChannelId ? (h("span", { class: "new-msgs-count" }, channel.unreadCount < 99 ? channel.unreadCount : '99+')) : null))));
      }))), !this.isHidden && (h("div", { class: "overlay-container" }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "icon", variant: "ghost", size: "md", onClick: this.onRevealClicked, class: "sidebar-btn" }, h("dyte-icon", { icon: this.isHidden ? this.iconPack.chevron_left : this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))));
    }
  };
  DyteChannelSelectorUi.style = dyteChannelSelectorUiCss;

  var dyteChannelSelectorUi_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_channel_selector_ui: DyteChannelSelectorUi
  });

  const dyteChatCss = ":host {\n  line-height: initial;\n  font-family: var(--dyte-font-family, sans-serif);\n\n  font-feature-settings: normal;\n  font-variation-settings: normal;\n}\n\np {\n  margin: var(--dyte-space-0, 0px);\n  padding: var(--dyte-space-0, 0px);\n}\n\n.scrollbar {\n  /* For Firefox */\n  scrollbar-width: thin;\n  scrollbar-color: var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent);\n}\n\n/* For WebKit */\n.scrollbar::-webkit-scrollbar {\n  height: var(--dyte-space-1\\.5, 6px);\n  width: var(--dyte-space-1\\.5, 6px);\n  border-radius: 9999px;\n  background-color: var(--dyte-scrollbar-background, transparent);\n}\n\n.scrollbar::-webkit-scrollbar-thumb {\n  border-radius: 9999px;\n  background-color: var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)));\n}\n\n\n:host {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  flex-direction: column;\n  font-size: 14px;\n  position: relative;\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n}\n\nh3 {\n  margin: var(--dyte-space-0, 0px);\n  display: flex;\n  height: var(--dyte-space-12, 48px);\n  align-items: center;\n  justify-content: center;\n  font-size: 16px;\n  font-weight: 400;\n  color: rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));\n  text-align: center;\n}\n\n#dropzone {\n  position: absolute;\n  top: var(--dyte-space-0, 0px);\n  right: var(--dyte-space-0, 0px);\n  bottom: var(--dyte-space-0, 0px);\n  left: var(--dyte-space-0, 0px);\n  z-index: 10;\n  display: none;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));\n}\n\n#dropzone.active {\n  display: flex;\n  animation: 0.2s slide-up ease-in;\n}\n\ndyte-chat-messages-ui,\ndyte-chat-messages-ui-paginated {\n  flex: 1 0 0;\n}\n\ndyte-chat-composer-view {\n  margin: var(--dyte-space-2, 8px);\n}\n\n.chat-container {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  flex-direction: row;\n  container-type: size;\n  container-name: chatcontainer;\n}\n\n@container chatcontainer (height < 360px) {\n  dyte-channel-selector-view {\n    height: var(--dyte-space-8, 32px);\n    min-height: 24px;\n  }\n}\n\n.chat {\n  display: flex;\n  flex: 1 1 0%;\n  flex-direction: column;\n}\n\n.banner {\n  height: 100%;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.banner .welcome-new-channel {\n  width: var(--dyte-space-48, 192px);\n}\n\n.banner .create-channel-illustration {\n  height: var(--dyte-space-40, 160px);\n  width: var(--dyte-space-40, 160px);\n}\n\n.channel-selector-header {\n  box-sizing: border-box;\n  height: var(--dyte-space-16, 64px);\n  padding: var(--dyte-space-4, 16px);\n  display: flex;\n  justify-content: space-between;\n  border-bottom: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-700, 44 44 44));\n}\n\n.channel-selector-header .channel-create-btn {\n  width: var(--dyte-space-8, 32px);\n  justify-content: center;\n}\n\n.channel-selector-header .channel-create-btn:hover {\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));\n}\n\n.view-chats-btn {\n  margin-top: var(--dyte-space-4, 16px);\n}\n\n.selector-container {\n  z-index: 50;\n  width: 100%;\n  max-width: var(--dyte-space-80, 320px);\n  border-right: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));\n}\n\n.selector-container.hide {\n  display: none;\n}\n\n.mobile-close-btn {\n  display: none;\n}\n\n.selector-container.mobile {\n  height: 100%;\n  width: 100%;\n  max-width: 100%;\n  position: absolute;\n  top: var(--dyte-space-0, 0px);\n  right: var(--dyte-space-0, 0px);\n  bottom: var(--dyte-space-0, 0px);\n  left: var(--dyte-space-0, 0px);\n  background-color: rgba(var(--dyte-colors-background-1000, 8 8 8) / 0.6);\n  display: flex;\n}\n\n.selector-container.mobile dyte-channel-selector-view {\n  max-width: var(--dyte-space-96, 384px);\n    animation: 0.3s swipe-in;\n}\n\n.selector-container.mobile .mobile-close-btn {\n  margin-top: var(--dyte-space-4, 16px);\n  margin-bottom: var(--dyte-space-4, 16px);\n  margin-left: var(--dyte-space-6, 24px);\n  margin-right: var(--dyte-space-6, 24px);\n  display: block;\n}\n\n.pinned-messages-header {\n  display: flex;\n  align-items: center;\n  gap: var(--dyte-space-2, 8px);\n  padding: var(--dyte-space-2, 8px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.pinned-messages-header dyte-icon {\n  height: var(--dyte-space-3, 12px);\n  width: var(--dyte-space-3, 12px);\n}\n\n.pinned-messages-header:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n}\n\n.pinned-messages-header.active {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n}\n\n@keyframes swipe-in {\n  from {\n    transform: translateX(-100%);\n  }\n  to {\n    transform: translateX(0);\n  }\n}\n";

  const DyteChat = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.chatUpdateListener = ({ message }) => {
        if (message.channelId)
          return;
        if (!this.displayFilter || this.displayFilter(message)) {
          this.addToChatGroup(message);
          // shallow copy to trigger render
          this.chatGroups = Object.assign({}, this.chatGroups);
        }
      };
      this.chatPermissionUpdateListener = () => {
        this.canSend = this.meeting.self.permissions.chatPublic.canSend;
        this.canSendTextMessage = this.meeting.self.permissions.chatPublic.text;
        this.canSendFiles = this.meeting.self.permissions.chatPublic.files;
      };
      this.channelMap = new Map();
      this.onDragOver = (e) => {
        e.preventDefault();
        this.dropzoneActivated = true;
      };
      this.onDragLeave = () => {
        this.dropzoneActivated = false;
      };
      this.onDrop = (e) => {
        e.preventDefault();
        this.dropzoneActivated = false;
        handleFilesDataTransfer(e.dataTransfer.items, (type, file) => {
          var _a, _b, _c, _d;
          switch (type) {
            case 'image':
              if (this.isFileMessagingAllowed()) {
                (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.chat) === null || _b === undefined ? undefined : _b.sendImageMessage(file, this.getRecipientPeerIds());
              }
              break;
            case 'file':
              if (this.isFileMessagingAllowed()) {
                (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.chat) === null || _d === undefined ? undefined : _d.sendFileMessage(file, this.getRecipientPeerIds());
              }
              break;
          }
        });
      };
      this.disconnectMeeting = (meeting) => {
        var _a, _b, _c, _d, _e, _f;
        if (this.isPrivateChatSupported()) {
          meeting === null || meeting === undefined ? undefined : meeting.participants.joined.removeListener('participantJoined', this.onParticipantUpdate);
          meeting === null || meeting === undefined ? undefined : meeting.participants.joined.removeListener('participantLeft', this.onParticipantUpdate);
        }
        (_a = meeting === null || meeting === undefined ? undefined : meeting.chat) === null || _a === undefined ? undefined : _a.removeListener('chatUpdate', this.chatUpdateListener);
        (_b = meeting === null || meeting === undefined ? undefined : meeting.chat) === null || _b === undefined ? undefined : _b.removeListener('channelCreate', this.onChannelCreateOrUpdate);
        (_c = meeting === null || meeting === undefined ? undefined : meeting.chat) === null || _c === undefined ? undefined : _c.removeListener('channelUpdate', this.onChannelCreateOrUpdate);
        (_d = meeting === null || meeting === undefined ? undefined : meeting.chat) === null || _d === undefined ? undefined : _d.removeListener('channelMessageUpdate', this.onChannelCreateOrUpdate);
        (_f = (_e = meeting === null || meeting === undefined ? undefined : meeting.participants) === null || _e === undefined ? undefined : _e.all) === null || _f === undefined ? undefined : _f.removeListener('participantsUpdate', this.onChannelCreateOrUpdate);
        meeting.self.permissions.removeListener('*', this.chatPermissionUpdateListener);
      };
      this.getFilteredParticipants = () => {
        if (this.privatePresetFilter.length === 0)
          return this.participants;
        return this.participants.filter((p) => this.privatePresetFilter.includes(p.presetName));
      };
      this.onParticipantUpdate = () => {
        this.participants = this.meeting.participants.joined
          .toArray()
          .filter((p) => this.privatePresetFilter.length === 0 || this.privatePresetFilter.includes(p.presetName));
        // if selected participant leaves, reset state to everyone
        if (this.selectedParticipant && !this.participants.includes(this.selectedParticipant)) {
          this.selectedParticipant = null;
          this.chatRecipientId = this.selectedGroup = 'everyone';
        }
      };
      this.usePaginatedChat = () => {
        if (this.isGroupCall && this.showPinnedMessages)
          return false;
        return this.selectedGroup === 'everyone' && usePaginatedChat(this.meeting);
      };
      this.updateUnreadCountGroups = (obj) => {
        this.unreadCountGroups = Object.assign(Object.assign({}, this.unreadCountGroups), obj);
      };
      this.isPrivateChatSupported = () => {
        return this.canPrivateMessage && !this.disablePrivateChat;
      };
      this.updateRecipients = (event) => {
        const { id } = event.detail;
        this.chatRecipientId = id;
        this.selectedParticipant = this.participants.find((p) => p.userId === id);
        if (this.chatRecipientId !== 'everyone') {
          const allParticipants = [this.chatRecipientId, this.meeting.self.userId];
          const targetKey = generateChatGroupKey(allParticipants);
          this.selectedGroup = targetKey;
        }
        else {
          this.selectedGroup = 'everyone';
        }
        this.updateUnreadCountGroups({ [this.selectedGroup]: 0 });
      };
      this.isTextMessagingAllowed = () => {
        if (this.chatRecipientId === 'everyone') {
          // public chat
          return this.canSend && this.canSendTextMessage;
        }
        // private chat
        return this.canPrivateMessage && this.canSendPrivateTexts;
      };
      this.isFileMessagingAllowed = () => {
        if (this.chatRecipientId === 'everyone') {
          // public chat
          return this.canSend && this.canSendFiles;
        }
        // private chat
        return this.canPrivateMessage && this.canSendPrivateFiles;
      };
      this.onChannelChanged = (e) => {
        const channel = e.detail;
        if (channel.id.includes(TEMPORARY_CHANNEL_PREFIX)) {
          this.createDMChannel(channel.id.replace(TEMPORARY_CHANNEL_PREFIX, ''));
        }
        else {
          this.selectedChannelId = channel.id;
        }
        this.cleanup();
        if (this.selectorState !== 'desktop') {
          this.selectorState = 'hide';
        }
      };
      this.createDMChannel = async (memberId) => {
        this.creatingChannel = true;
        const newChannel = await this.meeting.chat.createChannel('Direct Message', [memberId], {
          visibility: 'private',
          isDirectMessage: true,
        });
        this.creatingChannel = false;
        this.selectedChannelId = newChannel.id;
      };
      this.cleanup = () => {
        this.editingMessage = null;
        this.replyMessage = null;
        this.searchQuery = '';
      };
      this.onQuotedMessageDismiss = () => {
        this.replyMessage = null;
      };
      this.onChannelCreateOrUpdate = (channel) => {
        if (channel) {
          this.channelMap.set(channel.id, channel);
        }
        else {
          this.meeting.chat.channels.forEach((chan) => this.channelMap.set(chan.id, chan));
        }
        const allChannels = Array.from(this.channelMap.values());
        const channels = allChannels
          .filter((channel) => !isDirectMessageChannel(channel))
          .sort((a, b) => alphabeticalSorter(a.displayName, b.displayName));
        const membersWithChannel = allChannels.filter(isDirectMessageChannel).map((channel) => {
          return Object.assign(Object.assign({}, channel), { displayName: this.getMemberDisplayName(channel) });
        });
        const membersWithoutChannel = this.meeting.participants.all
          .toArray()
          .filter((member) => {
          if (member.userId === this.meeting.self.userId)
            return false;
          const matcher = getDMComparator([this.meeting.self.userId, member.userId]);
          return membersWithChannel.every((channel) => getDMComparator(channel.memberIds) !== matcher);
        })
          .map((member) => {
          return {
            id: `${TEMPORARY_CHANNEL_PREFIX}${member.userId}`,
            displayName: member.name,
            displayPictureUrl: member.picture,
            isDirectMessage: true,
            unreadCount: 0,
          };
        });
        const dms = [...membersWithChannel, ...membersWithoutChannel].sort((a, b) => alphabeticalSorter(a.displayName, b.displayName));
        this.channels = [...channels, ...dms];
        // select channel only if it is created in db
        const nonTemporaryChannel = [...channels, ...membersWithChannel];
        if (!this.selectedChannelId && nonTemporaryChannel.length !== 0) {
          this.selectedChannelId = nonTemporaryChannel[0].id;
        }
      };
      this.getMemberDisplayName = (channel) => {
        var _a;
        let id;
        if (channel.memberIds.length === 1) {
          // channel with self
          id = channel.memberIds[0];
        }
        else {
          id =
            channel.memberIds[0] === this.meeting.self.userId
              ? channel.memberIds[1]
              : channel.memberIds[0];
        }
        const member = this.meeting.participants.all.toArray().find((member) => member.userId === id);
        return (_a = member === null || member === undefined ? undefined : member.name) !== null && _a !== undefined ? _a : id;
      };
      this.onNewMessageHandler = async (e) => {
        const message = e.detail;
        if (this.isChatViewType) {
          await this.meeting.chat.sendMessageToChannel(message, this.selectedChannelId, this.replyMessage
            ? {
              replyTo: this.replyMessage,
            }
            : {});
          this.replyMessage = null;
        }
        else {
          this.meeting.chat.sendMessage(message, this.getRecipientPeerIds());
        }
      };
      this.onEditMessageHandler = async (e) => {
        var _a, _b;
        await ((_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.chat) === null || _b === undefined ? undefined : _b.editTextMessage(this.editingMessage.id, e.detail, this.editingMessage.channelId));
        this.editingMessage = null;
      };
      this.onEditCancel = () => {
        this.editingMessage = null;
      };
      this.onSearchHandler = async (e) => {
        this.searchQuery = e.detail;
      };
      this.onSearchDismissed = () => {
        this.searchQuery = '';
      };
      this.onChannelCreateClicked = () => {
        this.stateUpdate.emit({ activeChannelCreator: true });
        state.activeChannelCreator = true;
      };
      this.onPinMessage = (event) => {
        const message = event.detail;
        if (message.pinned) {
          this.meeting.chat.unpin(message.id);
        }
        else {
          this.meeting.chat.pin(message.id);
        }
      };
      this.onDeleteMessage = (event) => {
        const message = event.detail;
        this.meeting.chat.deleteMessage(message.id);
      };
      this.getChannelItems = () => {
        return this.channels.map((channel) => {
          const result = {
            id: channel.id,
            name: channel.displayName,
            avatarUrl: channel.displayPictureUrl,
          };
          if (channel.latestMessage) {
            result.latestMessage =
              channel.latestMessage.type === 'text'
                ? stripOutReplyBlock(channel.latestMessage.message)
                : '';
            result.latestMessageTime = channel.latestMessage.time;
          }
          return result;
        });
      };
      this.getPrivateChatRecipients = () => {
        const participants = this.getFilteredParticipants().map((participant) => {
          const key = generateChatGroupKey([participant.userId, this.meeting.self.userId]);
          const result = {
            id: participant.userId,
            name: participant.name,
            avatarUrl: participant.picture,
            unreadCount: this.unreadCountGroups[key],
          };
          return result;
        });
        const everyone = {
          id: 'everyone',
          name: this.t('chat.everyone'),
          icon: 'participants',
          unreadCount: this.unreadCountGroups['everyone'],
        };
        return [everyone, ...participants];
      };
      this.onTogglePinnedMessages = () => {
        this.showPinnedMessages = !this.showPinnedMessages;
      };
      this.renderPinnedMessagesHeader = () => {
        if (this.meeting.chat.pinned.length === 0)
          return null;
        return (h("dyte-tooltip", { label: this.t('chat.toggle_pinned_msgs'), iconPack: this.iconPack, t: this.t }, h("div", { class: { 'pinned-messages-header': true, active: this.showPinnedMessages }, onClick: this.onTogglePinnedMessages }, h("dyte-icon", { icon: this.iconPack.pin, iconPack: this.iconPack, t: this.t }), this.t('chat.pinned_msgs'), ` (${this.meeting.chat.pinned.length})`)));
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.disablePrivateChat = false;
      this.canPinMessages = false;
      this.privatePresetFilter = [];
      this.displayFilter = undefined;
      this.unreadCountGroups = {};
      this.chatGroups = { everyone: [] };
      this.selectedGroup = 'everyone';
      this.now = new Date();
      this.dropzoneActivated = false;
      this.showLatestMessageButton = false;
      this.canSend = false;
      this.canSendTextMessage = false;
      this.canSendFiles = false;
      this.canPrivateMessage = false;
      this.canSendPrivateTexts = false;
      this.canSendPrivateFiles = false;
      this.emojiPickerEnabled = false;
      this.chatRecipientId = 'everyone';
      this.participants = [];
      this.selectedParticipant = undefined;
      this.channels = [];
      this.selectedChannelId = undefined;
      this.editingMessage = null;
      this.replyMessage = null;
      this.searchQuery = '';
      this.selectorState = 'hide';
      this.creatingChannel = false;
      this.showPinnedMessages = false;
    }
    connectedCallback() {
      if (!this.meeting)
        return;
      this.meetingChanged(this.meeting);
      if (this.meeting && !this.meeting.chat) {
        return;
      }
      if (this.isFileMessagingAllowed()) {
        this.host.addEventListener('dragover', this.onDragOver);
        this.host.addEventListener('dragleave', this.onDragLeave);
        this.host.addEventListener('drop', this.onDrop);
      }
    }
    onEditMessageInit(event) {
      if (event.detail.flags.isReply) {
        this.replyMessage = event.detail.payload;
      }
      else if (event.detail.flags.isEdit) {
        this.editingMessage = event.detail.payload;
      }
    }
    disconnectedCallback() {
      var _a;
      (_a = this.resizeObserver) === null || _a === undefined ? undefined : _a.disconnect();
      this.disconnectMeeting(this.meeting);
      this.host.removeEventListener('dragover', this.onDragOver);
      this.host.removeEventListener('dragleave', this.onDragLeave);
      this.host.removeEventListener('drop', this.onDrop);
    }
    meetingChanged(meeting, oldMeeting) {
      var _a, _b, _c, _d, _e, _f;
      if (oldMeeting != undefined)
        this.disconnectMeeting(oldMeeting);
      if (meeting && !meeting.chat)
        return;
      if (meeting != null) {
        this.canSend = meeting.self.permissions.chatPublic.canSend;
        this.canSendTextMessage = meeting.self.permissions.chatPublic.text;
        this.canSendFiles = meeting.self.permissions.chatPublic.files;
        this.canPrivateMessage = !!(((_a = meeting.self.permissions.chatPrivate) === null || _a === undefined ? undefined : _a.canSend) ||
          ((_b = meeting.self.permissions.chatPrivate) === null || _b === undefined ? undefined : _b.canReceive));
        this.canSendPrivateTexts = !!((_c = meeting.self.permissions.chatPrivate) === null || _c === undefined ? undefined : _c.text);
        this.canSendPrivateFiles = !!((_d = meeting.self.permissions.chatPrivate) === null || _d === undefined ? undefined : _d.files);
        this.canPinMessages =
          ((_e = meeting === null || meeting === undefined ? undefined : meeting.__internals__) === null || _e === undefined ? undefined : _e.features.hasFeature(FlagsmithFeatureFlags.PINNED_MESSAGES)) &&
            meeting.self.permissions.pinParticipant;
        this.isGroupCall = meeting.meta.viewType === 'GROUP_CALL';
        this.isChatViewType = meeting.meta.viewType === 'CHAT';
        if (this.isChatViewType) {
          this.onChannelCreateOrUpdate();
          const validChannels = this.channels.filter((channel) => !channel.id.includes(TEMPORARY_CHANNEL_PREFIX));
          if (validChannels.length) {
            this.selectedChannelId = this.channels[0].id;
          }
          if (this.resizeObserver) {
            this.resizeObserver.disconnect();
          }
          this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
              if (entry.contentBoxSize[0].inlineSize < 758) {
                this.selectorState = 'hide';
              }
              else {
                this.selectorState = 'desktop';
              }
            }
          });
          if (this.isChatViewType) {
            this.resizeObserver.observe(this.host);
          }
        }
        this.initializeChatGroups();
        // shallow copy to trigger render
        this.chatGroups = Object.assign({}, this.chatGroups);
        meeting.self.permissions.on('*', this.chatPermissionUpdateListener);
        this.onParticipantUpdate();
        (_f = meeting.chat) === null || _f === undefined ? undefined : _f.addListener('chatUpdate', this.chatUpdateListener);
        if (this.isPrivateChatSupported()) {
          meeting.participants.joined.addListener('participantJoined', this.onParticipantUpdate);
          meeting.participants.joined.addListener('participantLeft', this.onParticipantUpdate);
        }
        if (this.isChatViewType) {
          meeting.chat.addListener('channelCreate', this.onChannelCreateOrUpdate);
          meeting.chat.addListener('channelUpdate', this.onChannelCreateOrUpdate);
          meeting.chat.addListener('channelMessageUpdate', this.onChannelCreateOrUpdate);
          meeting.participants.all.addListener('participantsUpdate', this.onChannelCreateOrUpdate);
        }
      }
    }
    chatGroupsChanged(chatGroups) {
      var _a, _b;
      if (!this.isPrivateChatSupported()) {
        return;
      }
      const unreadCounts = {};
      for (const key in chatGroups) {
        const lastReadTimestamp = (_a = chatUnreadTimestamps[key]) !== null && _a !== undefined ? _a : 0;
        unreadCounts[key] = chatGroups[key].filter((c) => c.type == 'chat' &&
          c.message.time > lastReadTimestamp &&
          c.message.userId !== this.meeting.self.userId).length;
        if (key ===
          generateChatGroupKey([this.meeting.self.userId, (_b = this.selectedParticipant) === null || _b === undefined ? undefined : _b.userId]) ||
          (key === 'everyone' && this.selectedParticipant === null)) {
          unreadCounts[key] = 0;
          chatUnreadTimestamps[key] = new Date();
        }
      }
      this.updateUnreadCountGroups(unreadCounts);
    }
    initializeChatGroups() {
      var _a;
      (_a = this.meeting.chat) === null || _a === undefined ? undefined : _a.messages.forEach((message) => {
        if (!this.displayFilter || this.displayFilter(message)) {
          this.addToChatGroup(message);
        }
      });
    }
    onDisplayFilterChanged(newFilter, oldFilter) {
      if (newFilter !== oldFilter) {
        this.chatGroups = {};
        this.initializeChatGroups();
      }
    }
    addToChatGroup(message) {
      var _a;
      const parsedMessage = parseMessageForTarget(message);
      let key = 'everyone';
      if (((_a = parsedMessage.targetUserIds) === null || _a === undefined ? undefined : _a.length) > 0) {
        const allParticipants = new Set([
          parsedMessage.userId,
          ...parsedMessage.targetUserIds,
        ]);
        key = generateChatGroupKey(Array.from(allParticipants));
      }
      if (this.chatGroups[key] === undefined)
        this.chatGroups[key] = [];
      let isEditedMessage = false;
      let messages = [];
      this.chatGroups[key].forEach((chat) => {
        if (chat.type === 'chat' && chat.message.id === message.id) {
          isEditedMessage = true;
          messages.push({ type: 'chat', message: parsedMessage });
        }
        else {
          messages.push(chat);
        }
      });
      if (!isEditedMessage) {
        messages.push({ type: 'chat', message: parsedMessage });
      }
      this.chatGroups[key] = messages;
    }
    getRecipientPeerIds() {
      let peerIds = [];
      if (this.chatRecipientId !== 'everyone') {
        peerIds = [this.selectedParticipant.id];
      }
      return peerIds;
    }
    channelSwitchListener(e) {
      this.onChannelChanged(e);
    }
    renderHeadlessComponents() {
      return (h(Fragment, null, h("dyte-dialog-manager", { meeting: this.meeting }), h("dyte-notifications", { meeting: this.meeting })));
    }
    renderComposerUI() {
      var _a, _b, _c;
      if (this.isChatViewType && this.channels.length === 0)
        return null;
      if (this.isChatViewType && this.searchQuery !== '')
        return null;
      if (this.isChatViewType && !this.selectedChannelId)
        return null;
      if (this.chatRecipientId === 'everyone') {
        if (!this.canSendTextMessage && !this.canSendFiles)
          return null;
      }
      else {
        if (!this.canSendPrivateTexts && !this.canSendPrivateFiles)
          return null;
      }
      const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
      const message = this.editingMessage ? this.editingMessage.message : '';
      const quotedMessage = this.replyMessage ? this.replyMessage.message : '';
      return (h("dyte-chat-composer-view", Object.assign({ message: message, storageKey: (_a = this.selectedChannelId) !== null && _a !== undefined ? _a : `draft-${this.selectedChannelId}`, quotedMessage: quotedMessage, isEditing: !!this.editingMessage, canSendTextMessage: this.isTextMessagingAllowed(), canSendFiles: this.isFileMessagingAllowed(), disableEmojiPicker: !!((_c = (_b = this.meeting) === null || _b === undefined ? undefined : _b.__internals__) === null || _c === undefined ? undefined : _c.features.hasFeature(FlagsmithFeatureFlags.DISABLE_EMOJI_PICKER)), maxLength: this.meeting.chat.maxTextLimit, rateLimits: this.meeting.chat.rateLimits, inputTextPlaceholder: this.t('chat.message_placeholder'), onNewMessage: this.onNewMessageHandler, onEditMessage: this.onEditMessageHandler, onEditCancel: this.onEditCancel, onQuotedMessageDismiss: this.onQuotedMessageDismiss }, uiProps), h("slot", { name: "chat-addon", slot: "chat-addon" })));
    }
    renderFullChat() {
      if (this.creatingChannel) {
        return (h("div", { class: "banner" }, h("dyte-spinner", { size: "lg" })));
      }
      if (this.channels.length === 0 || !this.selectedChannelId) {
        return (h("div", { class: "banner" }, h("dyte-icon", { icon: this.iconPack.create_channel_illustration, iconPack: this.iconPack, t: this.t, slot: "start", class: 'create-channel-illustration' }), h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "wide", variant: "primary", size: "md", onClick: this.onChannelCreateClicked, class: "welcome-new-channel" }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t, slot: "start" }), h("span", null, this.t('chat.new_channel'))), (this.selectorState === 'mobile' || this.selectorState === 'hide') && (h("dyte-button", { kind: "button", variant: "secondary", size: "md", class: "view-chats-btn", onClick: () => {
            this.selectorState = 'mobile';
          } }, h("dyte-icon", { icon: this.iconPack.chat, slot: "start" }), h("span", null, this.t('chat.view_chats'))))));
      }
      const selectedChannel = this.channels.find((channel) => channel.id === this.selectedChannelId);
      return (h("div", { class: "chat" }, h("dyte-channel-header", { slot: "header", meeting: this.meeting, channel: selectedChannel, onSearch: this.onSearchHandler, onSearchDismissed: this.onSearchDismissed, showBackButton: this.selectorState === 'mobile' || this.selectorState === 'hide', onBack: () => {
          this.selectorState = 'mobile';
        } }), this.searchQuery !== '' && (h("dyte-chat-search-results", { meeting: this.meeting, query: this.searchQuery, channelId: this.selectedChannelId })), this.searchQuery === '' && (h("dyte-chat-messages-ui-paginated", { meeting: this.meeting, size: this.size, iconPack: this.iconPack, t: this.t, selectedChannelId: this.selectedChannelId, selectedChannel: selectedChannel }))));
    }
    render() {
      var _a, _b;
      if (!this.meeting)
        return null;
      const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
      const selfUserId = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.userId;
      let chatMessages = this.chatGroups[this.selectedGroup] || [];
      if (this.showPinnedMessages && this.meeting.chat.pinned.length !== 0) {
        chatMessages = chatMessages.filter((chat) => chat.type === 'chat' && chat.message.pinned);
      }
      return (h(Host, null, this.isChatViewType && this.renderHeadlessComponents(), h("div", { class: "chat-container" }, this.isChatViewType && (h("div", { class: { 'selector-container': true, [this.selectorState]: true } }, h("dyte-channel-selector-view", { channels: this.getChannelItems(), selectedChannelId: this.selectedChannelId, onChannelChange: this.onChannelChanged, t: this.t }, h("div", { class: "channel-selector-header", slot: "header" }, h("dyte-logo", { meeting: this.meeting, config: this.config, t: this.t }), h("dyte-tooltip", { label: this.t('chat.new_channel'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", size: "md", onClick: this.onChannelCreateClicked, class: "channel-create-btn" }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }))))), h("dyte-button", { kind: "icon", variant: "ghost", class: "mobile-close-btn", onClick: () => (this.selectorState = 'hide') }, h("dyte-icon", { icon: this.iconPack.dismiss })))), h("div", { class: "chat" }, this.isFileMessagingAllowed() && (h("div", { id: "dropzone", class: { active: this.dropzoneActivated }, part: "dropzone" }, h("dyte-icon", { icon: this.iconPack.attach, iconPack: this.iconPack, t: this.t }), h("p", null, this.t('chat.send_attachment')))), this.renderPinnedMessagesHeader(), this.isPrivateChatSupported() && (h("dyte-channel-selector-view", { channels: this.getPrivateChatRecipients(), selectedChannelId: ((_b = this.selectedParticipant) === null || _b === undefined ? undefined : _b.userId) || 'everyone', onChannelChange: this.updateRecipients, t: this.t, viewAs: "dropdown" })), this.isChatViewType ? (this.renderFullChat()) : this.usePaginatedChat() ? (h("dyte-chat-messages-ui-paginated", { meeting: this.meeting, onPinMessage: this.onPinMessage, onDeleteMessage: this.onDeleteMessage, size: this.size, iconPack: this.iconPack, t: this.t })) : (h("dyte-chat-messages-ui", Object.assign({ messages: chatMessages, selfUserId: selfUserId, selectedGroup: this.selectedGroup, onPinMessage: this.onPinMessage, canPinMessages: this.canPinMessages }, uiProps))), this.renderComposerUI()))));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "chatGroups": ["chatGroupsChanged"],
      "displayFilter": ["onDisplayFilterChanged"]
    }; }
  };
  DyteChat.style = dyteChatCss;

  var dyteChat_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_chat: DyteChat
  });

  const dyteChatComposerUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.chat-input{position:relative;margin:var(--dyte-space-2, 8px);z-index:10;box-sizing:border-box;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}textarea{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));box-sizing:border-box;padding:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea::-moz-placeholder{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea::placeholder{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}textarea{border-top-left-radius:var(--dyte-border-radius-md, 8px);border-top-right-radius:var(--dyte-border-radius-md, 8px);font-family:var(--dyte-font-family, sans-serif);outline:2px solid transparent;outline-offset:2px;resize:none;overflow-y:auto;border-width:var(--dyte-border-width-none, 0);border-style:none;min-height:60px;font-size:14px}.chat-buttons{border-bottom-right-radius:var(--dyte-border-radius-md, 8px);border-bottom-left-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));display:flex;height:var(--dyte-space-8, 32px);align-items:center;justify-content:space-between;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.chat-buttons .left dyte-button{margin-right:var(--dyte-space-1, 4px)}.chat-buttons .left dyte-button dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.chat-buttons .right{z-index:10}.chat-buttons .right .edit-buttons{display:flex;gap:var(--dyte-space-2, 8px)}.chat-buttons>div{display:flex;align-items:center}dyte-emoji-picker{z-index:0;position:absolute;bottom:var(--dyte-space-32, 128px);border-top:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));animation:0.3s slide-up ease}@keyframes slide-up{from{transform:translateY(100%)}to{transform:translateY(0%)}}.member-list{margin:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-1, 4px);max-height:var(--dyte-space-28, 112px);min-width:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);padding:var(--dyte-space-0, 0px);position:absolute;bottom:var(--dyte-space-28, 112px);list-style-type:none;overflow-y:auto;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px);--tw-border-spacing-x:var(--dyte-space-2, 8px);--tw-border-spacing-y:var(--dyte-space-2, 8px);border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-style:solid;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.member-list .member{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-4, 16px);cursor:pointer}.member-list .member dyte-avatar{flex-shrink:0;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);font-size:14px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.member-list .member span{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.member-list .member:hover,.member-list .member.selected{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.suggested-replies{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-3, 12px);display:flex;flex-wrap:nowrap;gap:var(--dyte-space-2, 8px);list-style-type:none;overflow-x:auto}.suggested-replies dyte-tooltip{flex-shrink:0}.suggested-replies li{padding:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.75);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));cursor:pointer}.suggested-replies li:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity))}.preview-overlay{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-md, 8px)}.file-preview{position:absolute;top:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);max-width:-moz-fit-content;max-width:fit-content;max-height:var(--dyte-space-20, 80px)}.file-preview:hover dyte-tooltip{display:block}.file-preview dyte-tooltip{position:absolute;top:calc(var(--dyte-space-1, 4px) * -1);left:calc(var(--dyte-space-1, 4px) * -1);display:none;margin-left:calc(var(--dyte-space-1, 4px) * -1);margin-top:calc(var(--dyte-space-1, 4px) * -1)}.file-preview dyte-button{display:flex;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));border:1px solid rgb(var(--dyte-colors-text-1000, 255 255 255))}.file-preview dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.preview-image{height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);-o-object-fit:cover;object-fit:cover;max-height:100%;max-width:100%;overflow:clip;border-radius:var(--dyte-border-radius-md, 8px)}.preview-file{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-radius:var(--dyte-border-radius-md, 8px);max-width:200px}@keyframes scroll-text{0%{transform:translateX(0%)}70%{transform:translateX(-100%)}80%{transform:translateX(0%)}100%{transform:translateX(0%)}}";

  const MENTION_CHAR = '@';
  const DyteChatComposerUi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onNewMessage = createEvent(this, "dyteNewMessage", 7);
      this.onEditMessage = createEvent(this, "dyteEditMessage", 7);
      this.onEditCancelled = createEvent(this, "dyteEditCancelled", 7);
      this.fileReader = new FileReader();
      this.fileToUpload = null;
      this.handleKeyDown = (e) => {
        if (e.key === MENTION_CHAR && [undefined, ' '].includes(this.$textArea.value.at(-1))) {
          // [undefined, ' '] checks if mention is start of text or start of new word
          this.mentionQuery = MENTION_CHAR;
        }
        if (e.key === 'ArrowDown') {
          this.focusedMemberIndex = Math.min(this.focusedMemberIndex + 1, this.getFilteredMembers().length - 1);
        }
        if (e.key === 'ArrowUp') {
          this.focusedMemberIndex = Math.max(0, this.focusedMemberIndex - 1);
        }
        if (e.key === 'Escape' || (e.key === 'Backspace' && this.mentionQuery === MENTION_CHAR)) {
          this.mentionQuery = '';
        }
        if (['Enter', 'Tab', ' '].includes(e.key) && this.mentionQuery !== '') {
          const member = this.getFilteredMembers()[this.focusedMemberIndex];
          this.onMemberSelect(member);
          e.preventDefault();
          return;
        }
        // slack like typing experience
        if (e.key === 'Enter' && e.shiftKey) {
          const height = this.$textArea.clientHeight;
          if (height < 200) {
            this.$textArea.style.height = this.$textArea.clientHeight + 20 + 'px';
          }
        }
        else if (e.key === 'Enter') {
          e.preventDefault();
          if (this.prefill.editMessage) {
            this.handleEditMessage();
          }
          else {
            this.handleSendMessage();
          }
        }
        else if (e.key === 'Backspace') {
          if (this.$textArea.value.endsWith('\n')) {
            this.$textArea.style.height = this.$textArea.clientHeight - 20 + 'px';
          }
          else if (this.$textArea.value === '') {
            this.$textArea.style.height = 'auto';
          }
        }
      };
      this.handleKeyUp = (_e) => {
        if (this.mentionQuery !== '') {
          const reversed = reverse(this.$textArea.value.trim());
          const query = reversed.substring(0, reversed.indexOf(MENTION_CHAR));
          this.mentionQuery = `${MENTION_CHAR}${reverse(query)}`;
        }
      };
      this.onPaste = (e) => {
        const data = e.clipboardData || e.originalEvent.clipboardData;
        writeTask(() => {
          if (data && data.items && data.items.length > 0) {
            handleFilesDataTransfer(data.items, this.generateFilePreview);
            this.$textArea.value = '';
          }
        });
      };
      this.generateFilePreview = (type, file) => {
        this.fileToUpload = { type, image: file, file };
        if (type === 'image') {
          this.fileReader.readAsDataURL(file);
        }
        else if (type === 'file') {
          this.filePreview = file.name;
        }
      };
      this.sendFile = () => {
        if (!this.canSendFiles) {
          return;
        }
        if (this.fileToUpload.type === 'image') {
          this.onNewMessage.emit({
            type: 'image',
            file: this.fileToUpload.image,
            image: this.fileToUpload.image,
          });
        }
        else {
          this.onNewMessage.emit({ type: 'file', file: this.fileToUpload.file });
        }
        this.cleanUpFileUpload();
      };
      this.handleSendMessage = () => {
        if (!this.canSendTextMessage) {
          return;
        }
        if (this.fileToUpload !== null) {
          this.sendFile();
          return;
        }
        const message = this.$textArea.value.trim();
        if (message.length > 0) {
          if (this.prefill.replyMessage) {
            this.onNewMessage.emit({
              type: 'text',
              message,
              replyTo: this.prefill.replyMessage,
            });
          }
          else {
            this.onNewMessage.emit({ type: 'text', message });
          }
          this.cleanup();
        }
      };
      this.cleanup = () => {
        this.mentionQuery = '';
        this.focusedMemberIndex = 0;
        this.$textArea.value = '';
        this.$textArea.style.height = 'auto';
        gracefulStorage$1.setItem(this.storageKey, '');
      };
      this.handleEditMessage = () => {
        var _a;
        let editedMessage = this.$textArea.value.trim();
        if (((_a = this.prefill.editMessage) === null || _a === undefined ? undefined : _a.message) &&
          replyBlockPattern.test(this.prefill.editMessage.message)) {
          // add back the reply block which we stripped out for editing
          const replyBlock = extractReplyBlock(this.prefill.editMessage.message);
          editedMessage = `${replyBlock}\n\n${editedMessage}`;
        }
        this.onEditMessage.emit({
          id: this.prefill.editMessage.id,
          message: editedMessage,
          channelId: this.prefill.editMessage.channelId,
        });
        this.cleanup();
      };
      this.handleEditCancel = () => {
        this.onEditCancelled.emit();
        this.cleanup();
      };
      this.initializeTextField = (el) => {
        this.$textArea = el;
        const message = gracefulStorage$1.getItem(this.storageKey) || '';
        this.$textArea.value = message;
      };
      this.onMemberSelect = (member) => {
        const reversedQuery = reverse(this.mentionQuery);
        const reversed = reverse(this.$textArea.value.trim()).replace(reversedQuery, '');
        this.$textArea.value = reverse(reversed) + `${MENTION_CHAR}${member.name} `;
        this.mentionQuery = '';
        this.focusedMemberIndex = 0;
        writeTask(() => this.$textArea.focus());
      };
      this.getFilteredMembers = () => {
        const query = this.mentionQuery.replace(MENTION_CHAR, '');
        return this.members.filter((member) => member.name.toLowerCase().includes(query.toLowerCase()));
      };
      this.cleanUpFileUpload = () => {
        this.filePreview = null;
        this.fileToUpload = null;
      };
      this.renderSuggestedReplies = () => {
        if (!this.prefill.suggestedReplies)
          return;
        if (this.prefill.suggestedReplies.length === 0)
          return;
        return (h("ul", { class: "suggested-replies scrollbar" }, this.prefill.suggestedReplies.map((reply) => (h("dyte-tooltip", { label: this.t('chat.click_to_send') }, h("li", { onClick: () => this.onNewMessage.emit({ type: 'text', message: reply }) }, reply))))));
      };
      this.renderMenu = () => {
        if (this.mentionQuery.length === 0)
          return;
        const filteredMembers = this.getFilteredMembers();
        if (filteredMembers.length === 0)
          return;
        return (h("ul", { class: "member-list scrollbar" }, filteredMembers.map((member, index) => (h("li", { class: { member: true, selected: index === this.focusedMemberIndex }, onClick: () => this.onMemberSelect(member), ref: ($li) => {
            if (index === this.focusedMemberIndex) {
              writeTask(() => {
                if ($li)
                  $li.scrollIntoView({ behavior: 'smooth', block: 'end', inline: 'nearest' });
              });
            }
          } }, h("dyte-avatar", { participant: {
            name: member.name,
            picture: member.picture,
          }, size: "sm" }), h("span", null, member.name))))));
      };
      this.canSendTextMessage = false;
      this.canSendFiles = false;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.disableEmojiPicker = false;
      this.prefill = {};
      this.members = [];
      this.channelId = undefined;
      this.emojiPickerActive = false;
      this.mentionQuery = '';
      this.focusedMemberIndex = 0;
      this.filePreview = null;
    }
    connectedCallback() {
      this.fileReader.onload = (e) => {
        if (typeof e.target.result === 'string') {
          this.filePreview = e.target.result;
        }
      };
      // this.fileReader.onloadstart = () => {};
      // this.fileReader.onloadend = () => {};
    }
    onChannelChanged() {
      this.mentionQuery = '';
      this.focusedMemberIndex = 0;
      const message = gracefulStorage$1.getItem(this.storageKey) || '';
      this.$textArea.value = message;
      this.emojiPickerActive = false;
    }
    componentDidRender() {
      if (this.prefill.editMessage || this.prefill.replyMessage) {
        writeTask(() => this.$textArea.focus());
      }
    }
    get storageKey() {
      if (this.channelId) {
        return `dyte-text-message-${this.channelId}`;
      }
      return 'dyte-text-message';
    }
    uploadFile(type) {
      const input = document.createElement('input');
      input.type = 'file';
      if (type === 'image') {
        input.accept = 'image/*';
      }
      input.onchange = (e) => {
        const { validity, files: [file], } = e.target;
        if (validity.valid) {
          this.generateFilePreview(type, file);
        }
      };
      input.click();
    }
    renderFilePreview() {
      if (typeof this.filePreview !== 'string')
        return;
      return (h("div", { class: "preview-overlay" }, h("div", { class: "file-preview" }, h("dyte-tooltip", { label: this.t('chat.cancel_upload') }, h("dyte-button", { variant: "secondary", kind: "icon", onClick: this.cleanUpFileUpload }, h("dyte-icon", { icon: this.iconPack.dismiss }))), this.fileToUpload.type === 'image' ? (h("img", { class: "preview-image", src: this.filePreview })) : (h("div", { class: "preview-file" }, h("span", null, this.filePreview))))));
    }
    render() {
      var _a;
      const uiProps = { iconPack: this.iconPack, t: this.t, size: this.size };
      let defaultValue = '';
      if ((_a = this.prefill.editMessage) === null || _a === undefined ? undefined : _a.message) {
        defaultValue = stripOutReplyBlock(this.prefill.editMessage.message);
      }
      return (h(Host, null, this.canSendTextMessage && this.emojiPickerActive && (h("dyte-emoji-picker", { part: "emoji-picker", onPickerClose: () => {
          this.emojiPickerActive = false;
        }, onDyteEmojiClicked: (e) => {
          this.$textArea.value += e.detail;
          this.$textArea.focus();
        }, t: this.t })), this.renderSuggestedReplies(), h("slot", { name: "chat-addon" }), h("slot", { name: "quote-block" }), h("div", { class: "chat-input", part: "chat-input" }, this.renderMenu(), this.canSendTextMessage && (h("textarea", { class: "scrollbar", part: "textarea", ref: this.initializeTextField, autoFocus: true, placeholder: this.fileToUpload ? '' : this.t('chat.message_placeholder'), value: defaultValue, onPaste: this.onPaste, maxLength: MAX_TEXT_LENGTH, onKeyDown: this.handleKeyDown, onKeyUp: this.handleKeyUp, onInput: (e) => {
          gracefulStorage$1.setItem(this.storageKey, e.target.value);
        }, disabled: !!this.filePreview })), h("div", { class: "chat-buttons", part: "chat-buttons" }, h("div", { class: "left", part: "chat-buttons-left" }, !this.prefill.editMessage &&
        this.canSendFiles && [
        h("dyte-tooltip", Object.assign({ label: this.t('chat.send_file') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", onClick: () => this.uploadFile('file'), title: this.t('chat.send_file'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.attach }))),
        h("dyte-tooltip", Object.assign({ label: this.t('chat.send_img') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", onClick: () => this.uploadFile('image'), title: this.t('chat.send_img'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.image }))),
      ], !this.prefill.editMessage && this.canSendTextMessage && !this.disableEmojiPicker && (h("dyte-tooltip", Object.assign({ label: this.t('chat.send_emoji') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", class: { active: this.emojiPickerActive }, title: this.t('chat.send_emoji'), iconPack: this.iconPack, t: this.t, onClick: () => {
          this.emojiPickerActive = !this.emojiPickerActive;
        } }, h("dyte-icon", { icon: this.iconPack.emoji_multiple }))))), !!this.filePreview && this.renderFilePreview(), this.canSendTextMessage && (h("div", { class: "right", part: "chat-buttons-right" }, !this.prefill.editMessage && (h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.send_msg'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", onClick: () => this.handleSendMessage(), title: this.t('chat.send_msg'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.send })))), this.prefill.editMessage && (h("div", { class: "edit-buttons" }, h("dyte-tooltip", Object.assign({ variant: "secondary", label: this.t('cancel'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", variant: "secondary", onClick: () => this.handleEditCancel(), title: this.t('cancel'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss }))), h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.update_msg'), delay: 2000 }, uiProps), h("dyte-button", { kind: "icon", onClick: () => this.handleEditMessage(), title: this.t('chat.send_msg'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.checkmark })))))))))));
    }
    static get watchers() { return {
      "channelId": ["onChannelChanged"]
    }; }
  };
  DyteChatComposerUi.style = dyteChatComposerUiCss;

  var dyteChatComposerUi_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_chat_composer_ui: DyteChatComposerUi
  });

  const dyteChatSelectorUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;flex-direction:column}.chat-scope-selector{position:relative;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));z-index:10}.chat-scope-selector button{width:100%;border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-4, 16px);display:flex;align-items:center;justify-content:space-between;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px;cursor:pointer;height:var(--dyte-space-12, 48px)}.chat-scope-selector button span{display:flex;align-items:center;justify-content:flex-start}.chat-scope-selector button dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.chat-scope-selector .search{position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-0, 0px)}.chat-scope-selector .search dyte-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.chat-scope-selector .search input{box-sizing:border-box;height:var(--dyte-space-9, 36px);width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.chat-scope-selector .search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat-scope-selector .search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat-scope-selector .participants-container{position:absolute;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));top:var(--dyte-space-12, 48px);animation:0.3s slide-down ease}@keyframes slide-down{from{transform:translateY(-50px)}to{transform:translateY(0%)}}.chat-scope-selector .scope-list{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);list-style-type:none;padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px);overflow:auto;max-height:375px}.chat-scope-selector .scope-list .scope{position:relative;display:flex;flex-direction:row;align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px)}.chat-scope-selector .scope-list .scope:hover{cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.chat-scope-selector .scope-list .scope-special{margin-top:var(--dyte-space-4, 16px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.chat-scope-selector .scope-list .everyone-icon>dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.chat-scope-selector .scope-list .everyone-icon{display:flex;height:100%;width:100%;align-items:center;justify-content:center;margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px}.unread-count.selector{position:unset;margin-left:var(--dyte-space-2, 8px)}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}dyte-avatar{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px)}";

  const DyteChatSelectorUi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.groupChanged = createEvent(this, "dyteChatGroupChanged", 7);
      this.onScopeClick = (scope) => {
        this.showParticipantsPanel = false;
        this.groupChanged.emit(scope);
      };
      this.selfUserId = undefined;
      this.selectedGroupId = undefined;
      this.unreadCounts = {};
      this.groups = [];
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showParticipantsPanel = false;
      this.query = '';
    }
    toggleParticipants() {
      this.showParticipantsPanel = !this.showParticipantsPanel;
    }
    getGroups() {
      return this.groups.filter((participant) => participant.name.toLowerCase().includes(this.query.toLowerCase()));
    }
    getName() {
      if (!this.selectedGroupId || this.selectedGroupId === 'everyone') {
        return this.t('everyone');
      }
      const group = this.groups.find((g) => g.userId === this.selectedGroupId);
      if (group) {
        return group.name;
      }
      return this.t('everyone');
    }
    render() {
      const unreadCountTotal = Object.keys(this.unreadCounts).reduce((total, key) => {
        return total + this.unreadCounts[key];
      }, 0);
      return (h(Host, null, h("div", { class: "chat-scope-selector" }, this.showParticipantsPanel && (h("div", { class: "participants-container" }, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon" }), h("input", { type: "search", autocomplete: "off", placeholder: this.t('search'), value: this.query, onInput: (e) => {
          this.query = e.target.value;
        }, part: "search-input" })), h("ul", { class: "scope-list scrollbar" }, this.query === '' && (h("li", { class: "scope scope-special", onClick: () => this.onScopeClick('everyone') }, h("div", { class: "everyone-icon" }, h("dyte-icon", { icon: this.iconPack.participants })), this.t('everyone'), this.unreadCounts['everyone'] > 0 && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadCounts['everyone']))))), this.getGroups().map((group) => {
        const count = this.unreadCounts[generateChatGroupKey([this.selfUserId, group.userId])];
        return (h("li", { class: "scope", onClick: () => this.onScopeClick(group), key: group.userId }, group.name, count > 0 && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, count)))));
      })))), h("button", { onClick: () => this.toggleParticipants() }, h("span", null, `${this.t('to')} ${this.getName()}`, '  ', unreadCountTotal > 0 && (h("div", { class: "unread-count selector" }, h("span", null, unreadCountTotal)))), h("dyte-icon", { icon: this.showParticipantsPanel ? this.iconPack.chevron_up : this.iconPack.chevron_down })))));
    }
  };
  DyteChatSelectorUi.style = dyteChatSelectorUiCss;

  var dyteChatSelectorUi_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_chat_selector_ui: DyteChatSelectorUi
  });

  const canViewChat = (meeting) => {
    if (meeting && !meeting.chat)
      return false;
    const config = meeting === null || meeting === undefined ? undefined : meeting.self.config;
    if (config && !config.controlBar.elements.chat)
      return false;
    const { chatPublic, chatPrivate } = meeting.self.permissions;
    return (chatPublic.canSend ||
      chatPublic.canReceive || // TODO(ravindra-dyte): add web-core equivalent of chatPublic.canReceive, remove type casting
      chatPublic.text ||
      chatPublic.files ||
      chatPrivate.canSend ||
      chatPrivate.canReceive ||
      chatPrivate.files ||
      chatPrivate.text);
  };
  const canViewPolls = (meeting) => {
    if (meeting && !meeting.polls)
      return false;
    const config = meeting === null || meeting === undefined ? undefined : meeting.self.config;
    if (config && !config.controlBar.elements.polls)
      return false;
    const { polls } = meeting.self.permissions;
    return polls.canCreate || polls.canView || polls.canVote;
  };
  const canViewParticipants = (meeting) => {
    var _a;
    if (!((_a = meeting.self.permissions) === null || _a === undefined ? undefined : _a.showParticipantList)) {
      return false;
    }
    if (meeting && !meeting.participants)
      return false;
    const config = meeting === null || meeting === undefined ? undefined : meeting.self.config;
    if (config && !config.controlBar.elements.participants)
      return false;
    return true;
  };
  const canViewPlugins = (meeting) => {
    if (isLiveStreamViewer(meeting))
      return false;
    if (meeting && !meeting.plugins)
      return false;
    if (meeting.meta.viewType === 'LIVESTREAM')
      return meeting.stage.status === 'ON_STAGE';
    const config = meeting === null || meeting === undefined ? undefined : meeting.self.config;
    if (config && !config.controlBar.elements.plugins)
      return false;
    const { plugins } = meeting.self.permissions;
    return plugins.canClose || plugins.canStart;
  };

  const dyteChatToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}.unread-count-dot{position:absolute;right:var(--dyte-space-3, 12px);z-index:10;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));border-radius:50%;display:flex;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);align-items:center;justify-content:center}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .unread-count{right:var(--dyte-space-4, 16px);top:auto}";

  const DyteChatToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.onChatUpdate = ({ action, message }) => {
        var _a;
        if (this.chatActive)
          return;
        if (action === 'add' && message.userId !== ((_a = this.meeting) === null || _a === undefined ? undefined : _a.self.userId)) {
          this.hasNewMessages = true;
          this.unreadMessageCount += 1;
        }
      };
      this.toggleChat = () => {
        const states = this.states || state;
        this.chatActive = !((states === null || states === undefined ? undefined : states.activeSidebar) && (states === null || states === undefined ? undefined : states.sidebar) === 'chat');
        if (this.chatActive) {
          this.unreadMessageCount = 0;
          this.hasNewMessages = false;
        }
        state.activeSidebar = this.chatActive;
        state.activeMoreMenu = false;
        state.sidebar = this.chatActive ? 'chat' : undefined;
        state.activeAI = false;
        this.stateUpdate.emit({
          activeSidebar: this.chatActive,
          sidebar: this.chatActive ? 'chat' : undefined,
          activeMoreMenu: false,
          activeAI: false,
        });
      };
      this.updateCanView = () => {
        this.canViewChat = canViewChat(this.meeting);
      };
      this.unreadMessageCount = 0;
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.chatActive = false;
      this.canViewChat = false;
      this.hasNewMessages = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.statesChanged(this.states);
      this.removeStateChangeListener = onChange('sidebar', () => this.statesChanged());
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f;
      this.removeStateChangeListener && this.removeStateChangeListener();
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.chat) === null || _b === undefined ? undefined : _b.removeListener('chatUpdate', this.onChatUpdate);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.stage) === null || _d === undefined ? undefined : _d.removeListener('stageStatusUpdate', this.updateCanView);
      (_f = (_e = this.meeting) === null || _e === undefined ? undefined : _e.self) === null || _f === undefined ? undefined : _f.permissions.removeListener('chatUpdate', this.updateCanView);
    }
    meetingChanged(meeting) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (meeting == null)
        return;
      if (usePaginatedChat(meeting)) {
        (_a = meeting.chat) === null || _a === undefined ? undefined : _a.getMessages(new Date().getTime(), 1, true).then((res) => {
          var _a;
          if ((_a = res === null || res === undefined ? undefined : res.messages) === null || _a === undefined ? undefined : _a.length)
            this.hasNewMessages = true;
        });
      }
      const meetingStartedTimeMs = (_c = (_b = meeting.meta) === null || _b === undefined ? undefined : _b.meetingStartedTimestamp.getTime()) !== null && _c !== undefined ? _c : 0;
      const newMessages = (_d = meeting.chat) === null || _d === undefined ? undefined : _d.messages.filter((m) => m.timeMs > meetingStartedTimeMs);
      this.unreadMessageCount = newMessages.length || 0;
      (_e = meeting.chat) === null || _e === undefined ? undefined : _e.addListener('chatUpdate', this.onChatUpdate);
      this.canViewChat = canViewChat(meeting);
      (_f = meeting === null || meeting === undefined ? undefined : meeting.stage) === null || _f === undefined ? undefined : _f.on('stageStatusUpdate', this.updateCanView);
      (_g = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _g === undefined ? undefined : _g.permissions.on('chatUpdate', this.updateCanView);
    }
    statesChanged(s) {
      const states = s || state;
      if (states != null) {
        this.chatActive = states.activeSidebar === true && states.sidebar === 'chat';
      }
    }
    render() {
      if (!this.canViewChat)
        return;
      return (h(Host, { title: this.t('chat') }, usePaginatedChat(this.meeting)
        ? this.hasNewMessages && h("div", { class: "unread-count-dot", part: "unread-count-dot" })
        : this.unreadMessageCount !== 0 &&
          !this.chatActive && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadMessageCount <= 100 ? this.unreadMessageCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.chatActive }, onClick: this.toggleChat, icon: this.iconPack.chat, label: this.t('chat'), variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DyteChatToggle.style = dyteChatToggleCss;

  var dyteChatToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_chat_toggle: DyteChatToggle
  });

  const dyteClockCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;align-items:center;-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-variant-numeric:tabular-nums}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

  const addZero = (n) => Math.trunc(n).toString().padStart(2, '0');
  const DyteClock = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.disconnectMeeting = () => {
        var _a, _b;
        this.timeout && clearTimeout(this.timeout);
        typeof this.request === 'number' && cancelAnimationFrame(this.request);
        (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.removeListener('meetingStartTimeUpdate', this.startedTimeUpdateListener);
      };
      this.startedTimeUpdateListener = () => {
        var _a, _b, _c;
        this.startedTime = (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.meetingStartedTimestamp) === null || _c === undefined ? undefined : _c.toISOString();
      };
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.startedTime = undefined;
      this.timeDiff = undefined;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.disconnectMeeting();
    }
    meetingChanged(meeting) {
      var _a, _b, _c;
      this.disconnectMeeting();
      if (meeting != null) {
        this.startedTime = (_b = (_a = meeting.meta) === null || _a === undefined ? undefined : _a.meetingStartedTimestamp) === null || _b === undefined ? undefined : _b.toISOString();
        (_c = meeting.meta) === null || _c === undefined ? undefined : _c.addListener('meetingStartTimeUpdate', this.startedTimeUpdateListener);
      }
    }
    startedTimeChanged(startedTime) {
      if (startedTime !== undefined) {
        const animate = () => {
          this.timeDiff = (Date.now() - new Date(this.startedTime).getTime()) / 1000;
          this.timeout = setTimeout(() => {
            if (this.request != null) {
              this.request = requestAnimationFrame(animate);
            }
          }, 500);
        };
        this.request = requestAnimationFrame(animate);
      }
    }
    getFormattedTime() {
      if (this.timeDiff == null) {
        return null;
      }
      const diff = this.timeDiff;
      let time = '';
      if (diff >= 3600) {
        time = `${addZero(diff / 3600)}:`;
      }
      time += `${addZero((diff % 3600) / 60)}:${addZero(diff % 60)}`;
      return time;
    }
    render() {
      return (h(Host, { tabIndex: 0, role: "timer", "aria-live": "off" }, this.startedTime !== undefined && [
        h("dyte-icon", { icon: this.iconPack.clock, "aria-hidden": true, tabIndex: -1, part: "icon", iconPack: this.iconPack, t: this.t }),
        h("span", { part: "text" }, this.getFormattedTime()),
      ]));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "startedTime": ["startedTimeChanged"]
    }; }
  };
  DyteClock.style = dyteClockCss;

  var dyteClock_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_clock: DyteClock
  });

  const dyteConfirmationModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);padding:var(--dyte-space-8, 32px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));width:400px;max-width:80%}.leave-modal{width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px)}.leave-modal .content{font-size:14px}.leave-message p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px)}.leave-meeting{display:flex;flex-direction:row;justify-content:space-between;gap:var(--dyte-space-4, 16px)}.leave-meeting dyte-button{color:rgb(var(--dyte-colors-text-1000, 255 255 255));flex:1 1 0%}.end-meeting{margin-top:var(--dyte-space-2, 8px)}.br-secondary-btn{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.br-secondary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

  const DyteConfirmationModal = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.keyPressListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      this.close = () => {
        this.states.activeConfirmationModal.onClose(this.stateUpdate, state, this.meeting);
        this.stateUpdate.emit({ activeConfirmationModal: { active: false } });
        state.activeConfirmationModal = { active: false };
      };
      this.onConfirmation = async () => {
        this.states.activeConfirmationModal.onClick(this.stateUpdate, state, this.meeting);
        this.stateUpdate.emit({ activeConfirmationModal: { active: false } });
        state.activeConfirmationModal = { active: false };
      };
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      document.addEventListener('keydown', this.keyPressListener);
    }
    componentDidLoad() { }
    disconnectedCallback() {
      document.removeEventListener('keydown', this.keyPressListener);
    }
    render() {
      var _a, _b;
      const state = this.states.activeConfirmationModal;
      return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, state.header ? this.t(state.header) : this.t('cta.confirmation'))), h("p", { class: "message" }, state.content ? this.t(state.content) : ''), h("div", { class: "content" }, h("div", { class: "leave-meeting" }, h("dyte-button", { variant: "secondary", title: state.cancelText ? this.t(state.cancelText) : this.t('cancel'), onClick: this.close, iconPack: this.iconPack, t: this.t, class: "br-secondary-btn" }, state.cancelText ? this.t(state.cancelText) : this.t('cancel')), h("dyte-button", { onClick: () => this.onConfirmation(), variant: (_b = (_a = this.states.activeConfirmationModal) === null || _a === undefined ? undefined : _a.variant) !== null && _b !== undefined ? _b : 'danger', title: state.ctaText ? this.t(state.ctaText) : this.t('yes'), iconPack: this.iconPack, t: this.t }, state.ctaText ? this.t(state.ctaText) : this.t('yes')))))));
    }
  };
  DyteConfirmationModal.style = dyteConfirmationModalCss;

  var dyteConfirmationModal_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_confirmation_modal: DyteConfirmationModal
  });

  const dyteControlbarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:flex;align-items:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);position:relative;z-index:10}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{padding-top:var(--dyte-space-0, 0px) !important}}";

  const DyteControlbar = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.variant = 'solid';
      this.disableRender = false;
      this.meeting = undefined;
      this.config = defaultConfig;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states,
        t: this.t,
        iconPack: this.iconPack,
        size: this.size,
      };
      return (h(Host, null, !this.disableRender && (h(Render, { element: "dyte-controlbar", defaults: defaults, onlyChildren: true })), h("slot", null)));
    }
  };
  DyteControlbar.style = dyteControlbarCss;

  var dyteControlbar_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_controlbar: DyteControlbar
  });

  const dyteDebuggerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{margin-right:var(--dyte-space-2, 8px);display:flex;align-items:center;justify-content:space-between;padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}header h3{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px)}.back-btn{border-radius:var(--dyte-border-radius-sm, 4px);background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.back-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside{box-sizing:border-box;display:flex;max-width:var(--dyte-space-56, 224px) !important;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px)}aside button{margin-top:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;width:100%;align-items:center;justify-content:space-between;border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);background-color:transparent;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));cursor:default;font-size:14px;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px}aside button .right{display:flex;align-items:center}aside button .right dyte-icon{height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}aside button .right dyte-icon:last-child{margin-left:var(--dyte-space-4, 16px)}aside button[type='button']{cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}aside button[type='button']:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside button[type='button']{border-right:var(--dyte-border-width-md, 2px) solid transparent}aside button.active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}aside button.active:hover{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}aside button.hidden{display:none}main{position:relative;box-sizing:border-box;display:flex;height:100%;width:100%;flex-direction:column}:host([size='sm']) aside{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));width:100% !important;max-width:100% !important;padding-left:var(--dyte-space-0, 0px)}:host([size='sm']) aside button{border-radius:var(--dyte-border-radius-none, 0)}:host([size='sm']) aside button.active{border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}:host([size='sm']) aside button.active:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) aside button.hidden{display:none}:host([size='sm']) aside.hide{display:none}aside button:host([size='sm']) aside.hide{display:none}:host([size='sm']) aside button:host([size='sm']) aside.hide{display:none}:host([size='sm']) main{display:none;height:100%;width:100%;padding:var(--dyte-space-0, 0px)}aside button:host([size='sm']) main{display:none}:host([size='sm']) aside button:host([size='sm']) main{display:none}:host([size='sm']) main.active{display:block}:host([size='sm']) header{margin:var(--dyte-space-0, 0px);justify-content:center}:host([size='sm']) header dyte-button{position:absolute;left:var(--dyte-space-4, 16px)}::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}::-webkit-scrollbar-thumb:hover{border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.progress-bar{height:var(--dyte-space-1, 4px);width:100%;overflow:hidden;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.progress-indicator{height:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}";

  const DyteDebugger = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.keyPressListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.activeTab = 'audio';
      this.isMobileMainVisible = false;
      this.progress = 0;
    }
    connectedCallback() {
      document.addEventListener('keydown', this.keyPressListener);
    }
    disconnectedCallback() {
      this.keyPressListener && document.removeEventListener('keydown', this.keyPressListener);
    }
    progressUpdate(event) {
      this.progress = event.detail;
    }
    changeTab(tab) {
      this.activeTab = tab;
      if (this.size === 'sm') {
        if (!this.isMobileMainVisible) {
          this.isMobileMainVisible = true;
        }
      }
    }
    close() {
      this.stateUpdate.emit({ activeDebugger: false });
      state.activeDebugger = false;
    }
    getActiveTab() {
      switch (this.activeTab) {
        case 'audio':
          return this.t('debugger.audio.troubleshooting.label');
        case 'screenshare':
          return this.t('debugger.screenshare.troubleshooting.label');
        case 'video':
          return this.t('debugger.video.troubleshooting.label');
        case 'system':
          return this.t('debugger.system.troubleshooting.label');
        default:
          return this.t('debugger.troubleshooting.label');
      }
    }
    render() {
      if (this.meeting == null)
        return null;
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        iconPack: this.iconPack,
        t: this.t,
        size: this.size,
      };
      const tab = this.getActiveTab();
      const showSystemsTab = typeof navigator.getBattery !== 'undefined';
      return (h(Host, null, h("aside", { class: { hide: this.isMobileMainVisible }, part: "menu" }, h("header", null, h("h3", null, this.t('debugger.troubleshooting.label'))), h("button", { type: "button", class: { active: this.activeTab === 'audio' }, onClick: () => this.changeTab('audio') }, this.t('debugger.audio.label'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.mic_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), h("button", { type: "button", class: { active: this.activeTab === 'video' }, onClick: () => this.changeTab('video') }, this.t('debugger.video.label'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.video_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), h("button", { type: "button", class: { active: this.activeTab === 'screenshare' }, onClick: () => this.changeTab('screenshare') }, this.t('debugger.screenshare.label'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.share_screen_start, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), h("button", { type: "button", class: { active: this.activeTab === 'system', hidden: !showSystemsTab }, onClick: () => this.changeTab('system') }, this.t('debugger.system.label'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.settings, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t }))))), h("main", { class: { active: this.isMobileMainVisible }, part: "main-content" }, this.size === 'sm' && (h("header", null, h("dyte-button", { kind: "icon", class: "back-btn", onClick: () => (this.isMobileMainVisible = false), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), h("h4", null, tab))), this.activeTab === 'audio' && h("dyte-debugger-audio", Object.assign({}, defaults)), this.activeTab === 'video' && h("dyte-debugger-video", Object.assign({}, defaults)), this.activeTab === 'screenshare' && (h("dyte-debugger-screenshare", Object.assign({}, defaults))), this.activeTab === 'system' && showSystemsTab && (h("dyte-debugger-system", Object.assign({}, defaults))))));
    }
  };
  DyteDebugger.style = dyteDebuggerCss;

  var dyteDebugger_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_debugger: DyteDebugger
  });

  const dyteDebuggerToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteDebuggerToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.size = undefined;
    }
    toggleDebugger() {
      var _a;
      this.stateUpdate.emit({
        activeDebugger: !((_a = this.states) === null || _a === undefined ? undefined : _a.activeDebugger),
        activeMoreMenu: false,
      });
      state.activeDebugger = !state.activeDebugger;
      state.activeMoreMenu = false;
    }
    render() {
      return (h(Host, { title: this.t('Troubleshooting') }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleDebugger(), icon: this.iconPack.debug, label: this.t('Troubleshooting'), variant: this.variant })));
    }
  };
  DyteDebuggerToggle.style = dyteDebuggerToggleCss;

  var dyteDebuggerToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_debugger_toggle: DyteDebuggerToggle
  });

  const dyteEndedScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;-webkit-user-select:none;-moz-user-select:none;user-select:none;display:flex;flex-direction:column;align-items:center;justify-content:center}.ctr{display:flex;flex-direction:column;align-items:center;gap:var(--dyte-space-8, 32px)}dyte-logo.loaded{height:var(--dyte-space-12, 48px)}.rejoin-button{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-6, 24px);padding-bottom:var(--dyte-space-6, 24px);padding-left:var(--dyte-space-16, 64px);padding-right:var(--dyte-space-16, 64px)}.rejoin-icon{margin-right:var(--dyte-space-2, 8px)}p{font-size:16px;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}p.breakout{font-size:20px;display:flex;flex-direction:column;align-items:center}p.breakout span{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-0, 0px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}span{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}";

  const DyteEndedScreen = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.config = defaultConfig;
      this.size = undefined;
      this.icon = defaultIconPack;
      this.states = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.message = '';
      this.meeting = undefined;
    }
    connectedCallback() {
      this.statesChanged(this.states);
      this.removeStateChangeListener = onChange('roomLeftState', () => this.statesChanged());
    }
    disconnectedCallback() {
      this.removeStateChangeListener && this.removeStateChangeListener();
    }
    getBreakoutRoomsMessage(states) {
      var _a;
      let message;
      if ((states === null || states === undefined ? undefined : states.roomLeftState) === 'connected-meeting') {
        if (((_a = state.activeBreakoutRoomsManager) === null || _a === undefined ? undefined : _a.destinationMeetingId) ===
          this.meeting.connectedMeetings.parentMeeting.id) {
          message = 'breakout_rooms.move_reason.switch_main_room';
        }
        else {
          message = 'breakout_rooms.move_reason.switch_room';
        }
      }
      return message;
    }
    statesChanged(s) {
      const states = s || state;
      if (states != null) {
        switch (states === null || states === undefined ? undefined : states.roomLeftState) {
          case 'left':
            this.message = 'ended.left';
            break;
          case 'kicked':
            this.message = 'ended.kicked';
            break;
          case 'disconnected':
            this.message = 'ended.disconnected';
            break;
          case 'rejected':
            this.message = 'ended.rejected';
            break;
          case 'connected-meeting':
            this.message = this.getBreakoutRoomsMessage(states);
            break;
          default:
            this.message = 'ended';
        }
      }
    }
    renderBreakoutRoomScreen() {
      return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("dyte-icon", { icon: this.iconPack.breakout_rooms }), h("p", { part: "message", class: "breakout" }, this.t(this.message)))));
    }
    render() {
      const states = this.states || state;
      if (states.roomLeftState === 'connected-meeting') {
        return this.renderBreakoutRoomScreen();
      }
      return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("dyte-logo", { meeting: this.meeting, config: this.config, part: "logo", t: this.t }), h("p", { part: "message" }, this.t(this.message)), (states === null || states === undefined ? undefined : states.roomLeftState) === 'disconnected' && (h("span", { part: "description" }, this.t('ended.network'))))));
    }
    static get watchers() { return {
      "states": ["statesChanged"]
    }; }
  };
  DyteEndedScreen.style = dyteEndedScreenCss;

  var dyteEndedScreen_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ended_screen: DyteEndedScreen
  });

  const dyteFileDropzoneCss = "#dropzone{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:10;display:none;flex-direction:column;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}#dropzone.active{display:flex;animation:0.2s slide-up ease-in}";

  const DyteFileDropzone = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onDropCallback = createEvent(this, "dropCallback", 7);
      this.hostEl = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.dropzoneActivated = false;
    }
    connectedCallback() {
      if (!this.hostEl)
        throw new Error('hostEl prop is required');
      this.hostEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        this.dropzoneActivated = true;
      });
      this.hostEl.addEventListener('dragleave', () => {
        this.dropzoneActivated = false;
      });
      this.hostEl.addEventListener('drop', (e) => {
        e.preventDefault();
        this.dropzoneActivated = false;
        this.onDropCallback.emit(e);
      });
    }
    render() {
      return (h(Host, null, h("div", { id: "dropzone", class: { active: this.dropzoneActivated }, part: "dropzone" }, h("dyte-icon", { icon: this.iconPack.attach, iconPack: this.iconPack, t: this.t }), h("p", null, this.t('chat.send_attachment')))));
    }
  };
  DyteFileDropzone.style = dyteFileDropzoneCss;

  var dyteFileDropzone_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_file_dropzone: DyteFileDropzone
  });

  const requestFullScreen = (el) => {
    if (el == null)
      return;
    if (el.requestFullscreen != null) {
      el.requestFullscreen();
    }
    else if (el.mozRequestFullScreen != null) {
      /* Firefox */
      el.mozRequestFullScreen();
    }
    else if (el.webkitRequestFullscreen != null) {
      /* Chrome, Safari & Opera */
      el.webkitRequestFullscreen();
    }
    else if (el.msRequestFullscreen != null) {
      /* IE/Edge */
      el.msRequestFullscreen();
    }
  };
  const exitFullSreen = () => {
    if (document.exitFullscreen != null) {
      document.exitFullscreen();
    }
    else if (document.mozExitFullScreen != null) {
      /* Firefox */
      document.mozExitFullScreen();
    }
    else if (document.webkitExitFullscreen != null) {
      /* Chrome, Safari & Opera */
      document.webkitExitFullscreen();
    }
    else if (document.msExitFullscreen != null) {
      /* IE/Edge */
      document.msExitFullscreen();
    }
  };
  const isFullScreenEnabled = () => {
    return document.fullscreenElement != null || document.webkitCurrentFullScreenElement != null;
  };
  const isFullScreenSupported = () => {
    if (typeof document !== 'undefined') {
      return (document.fullscreenEnabled ||
        document.mozFullscreenEnabled ||
        document.webkitFullscreenEnabled ||
        document.msFullscreenEnabled);
    }
    return false;
  };

  const dyteFullscreenToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteFullscreenToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.onFullScreenchange = () => {
        this.fullScreenActive = isFullScreenEnabled();
      };
      this.toggleFullScreen = () => {
        let fullScreenElement = this.targetElement || document.querySelector('dyte-meeting');
        if (!fullScreenElement)
          return;
        if (!this.fullScreenActive) {
          requestFullScreen(fullScreenElement);
          this.fullScreenActive = true;
        }
        else {
          exitFullSreen();
          this.fullScreenActive = false;
        }
        this.stateUpdate.emit({ activeMoreMenu: false });
        state.activeMoreMenu = false;
      };
      this.states = undefined;
      this.targetElement = undefined;
      this.variant = 'button';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.fullScreenActive = false;
      this.isFullScreenSupported = true;
    }
    connectedCallback() {
      this.isFullScreenSupported = isFullScreenSupported();
      this.onFullScreenchange();
      window.addEventListener('webkitfullscreenchange', this.onFullScreenchange);
      window.addEventListener('fullscreenchange', this.onFullScreenchange);
    }
    disconnectedCallback() {
      window.removeEventListener('webkitfullscreenchange', this.onFullScreenchange);
      window.removeEventListener('fullscreenchange', this.onFullScreenchange);
    }
    render() {
      if (!this.isFullScreenSupported) {
        return null;
      }
      return (h(Host, { title: this.t('full_screen') }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.toggleFullScreen, icon: this.fullScreenActive
          ? this.iconPack.full_screen_minimize
          : this.iconPack.full_screen_maximize, label: this.fullScreenActive ? this.t('full_screen.exit') : this.t('full_screen'), variant: this.variant })));
    }
  };
  DyteFullscreenToggle.style = dyteFullscreenToggleCss;

  var dyteFullscreenToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_fullscreen_toggle: DyteFullscreenToggle
  });

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$1 = function() {
    return _root.Date.now();
  };

  var now_1 = now$1;

  /** Used to match a single whitespace character. */
  var reWhitespace$1 = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex$1(string) {
    var index = string.length;

    while (index-- && reWhitespace$1.test(string.charAt(index))) {}
    return index;
  }

  var _trimmedEndIndex = trimmedEndIndex$1;

  /** Used to match leading whitespace. */
  var reTrimStart$1 = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim$1(string) {
    return string
      ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart$1, '')
      : string;
  }

  var _baseTrim = baseTrim$1;

  /** Built-in value references. */
  var Symbol$2 = _root.Symbol;

  var _Symbol = Symbol$2;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto$1.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$1(value) {
    return typeof value == 'symbol' ||
      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
  }

  var isSymbol_1 = isSymbol$1;

  /** Used as references for various `Number` constants. */
  var NAN$1 = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary$1 = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal$1 = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt$1 = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol_1(value)) {
      return NAN$1;
    }
    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = _baseTrim(value);
    var isBinary = reIsBinary$1.test(value);
    return (isBinary || reIsOctal$1.test(value))
      ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex$1.test(value) ? NAN$1 : +value);
  }

  var toNumber_1 = toNumber$1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max,
      nativeMin$1 = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$1(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber_1(wait) || 0;
    if (isObject_1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax$1(toNumber_1(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now_1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now_1());
    }

    function debounced() {
      var time = now_1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce$1;

  function roundDown(num, places) {
    const factor = Math.pow(10, places);
    return Math.floor(num * factor) / factor;
  }
  function useGrid({ dimensions, count, aspectRatio, gap }) {
    const { width, height, rows, cols } = useGridItemDimensions({
      dimensions,
      count,
      aspectRatio,
      gap,
    });
    const getPosition = useGridPositioning({
      parentDimensions: dimensions,
      dimensions: { width, height },
      rows,
      cols,
      count,
      gap,
    });
    return { width, height, getPosition };
  }
  function useGridItemDimensions({ count, dimensions, aspectRatio, gap, }) {
    let { width: W, height: H } = dimensions;
    if (W === 0 || H === 0)
      return { width: 0, height: 0, rows: 1, cols: 1 };
    W -= gap * 2;
    H -= gap * 2;
    const s = gap, N = count;
    const r = getAspectRatio(aspectRatio);
    let w = 0, h = 0;
    let a = 1, b = 1;
    const widths = [];
    for (let n = 1; n <= N; n++) {
      widths.push((W - s * (n - 1)) / n);
      widths.push((H - s * (n - 1)) / (n * r));
    }
    // sort in descending order, largest first
    widths.sort((a, b) => b - a);
    for (const width of widths) {
      // We fix the precision to 4 decimal places to prevent
      // floating point overflow errors. Anyway, accuracy above
      // 4 decimal places does not really matter.
      w = roundDown(width, 4);
      h = roundDown(w * r, 4);
      a = Math.floor((W + s) / (w + s));
      b = Math.floor((H + s) / (h + s));
      if (a * b >= N) {
        // recalculate rows, as row calculated above can be inaccurate
        b = Math.ceil(N / a);
        break;
      }
    }
    return { width: w, height: h, rows: b, cols: a };
  }
  function useGridPositioning({ parentDimensions, dimensions, rows, cols, count, gap, }) {
    const { width: W, height: H } = parentDimensions;
    const { width: w, height: h } = dimensions;
    const firstTop = (H - (h * rows + (rows - 1) * gap)) / 2;
    let firstLeft = (W - (w * cols + (cols - 1) * gap)) / 2;
    const topAdd = h + gap;
    const leftAdd = w + gap;
    let col = 0, row = 0;
    const incompleteRowCols = count % cols;
    function getPosition(index) {
      const remaining = count - index;
      if (remaining === incompleteRowCols) {
        // in last row with incomplete columns, recalculate firstLeft to make it centered
        firstLeft = (W - (w * remaining + (remaining - 1) * gap)) / 2;
      }
      const top = firstTop + row * topAdd;
      const left = firstLeft + col * leftAdd;
      col++;
      if ((index + 1) % cols === 0) {
        // if a row has been traversed completely, increment row, reset col
        row++;
        col = 0;
      }
      return { top, left };
    }
    return getPosition;
  }
  /**
   * Parses the Aspect Ratio value
   * @param ratio The aspect ratio in the format of `16:9` where `width:height`
   * @returns The parsed value of aspect ratio
   */
  const getAspectRatio = (ratio) => {
    const [width, height] = ratio.split(':');
    return Number.parseInt(height) / Number.parseInt(width);
  };
  const defaultGridSize = {
    spotlight: 'sm',
    mixed: 'sm',
  };

  const dyteGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:100%;width:100%}.offline-grid{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center}.offline-grid h3{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);font-size:20px;font-weight:500;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.offline-grid p{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);text-align:center;font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.offline-grid dyte-icon{margin-bottom:var(--dyte-space-2, 8px)}.webinar-stage{box-sizing:border-box;height:100%;display:flex;align-content:center;align-items:center;justify-content:center;text-align:center}.webinar-stage h2{margin:var(--dyte-space-0, 0px);font-weight:normal}dyte-viewer-count{display:none}.ctr{display:flex;flex-direction:column;align-items:center}.message{font-size:16px;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.description{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);font-size:14px}dyte-livestream-indicator{display:none}@media only screen and (max-device-height: 480px) and (orientation: landscape){dyte-viewer-count[variant='embedded']{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-2, 8px);z-index:20;margin-top:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0, 0px);display:flex}dyte-livestream-indicator{position:absolute;top:var(--dyte-space-0, 0px);left:var(--dyte-space-2, 8px);z-index:20;margin-top:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0, 0px);display:flex}}";

  const MASS_ACTIONS_DEBOUNCE_TIMER$1 = 50; // In ms
  const DyteGrid = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.hideSelf = false;
      this.invalidRoomStates = ['init', 'waitlisted', 'ended', 'kicked', 'rejected'];
      // TODO(@madhugb): Temp hack, remove this when we ship manual subscription
      this.filterParticipants = (participants) => {
        var _a;
        // Only filter for non recorders
        if (this.overrides && ((_a = this.overrides) === null || _a === undefined ? undefined : _a.videoUnsubscribed)) {
          const presetFilters = this.overrides.videoUnsubscribed.preset;
          if (presetFilters.length > 0) {
            // Filter out unsubscribed participants
            participants = participants.filter((p) => {
              const unsubscribed = presetFilters.some((regex) => {
                if (p.presetName === undefined)
                  return false;
                return p.presetName.match(regex);
              });
              return !unsubscribed;
            });
          }
        }
        return participants;
      };
      this.onViewModeChanged = () => {
        if (this.meeting == null)
          return;
        this.updateActiveParticipants();
      };
      this.onParticipantJoined = debounce_1(() => {
        this.updateActiveParticipants();
      }, MASS_ACTIONS_DEBOUNCE_TIMER$1);
      this.onParticipantLeft = debounce_1(() => {
        this.updateActiveParticipants();
      }, MASS_ACTIONS_DEBOUNCE_TIMER$1);
      this.stageStatusListener = () => {
        this.updateActiveParticipants();
        this.showLiveStreamPlayer = isLiveStreamViewer(this.meeting);
        if (this.meeting.stage.status !== 'ON_STAGE') {
          this.removeScreenShare(this.meeting.self);
        }
      };
      this.peerStageStatusListener = (participant) => {
        this.updateActiveParticipants();
        if (this.meeting.stage.status !== 'ON_STAGE') {
          this.removePinned(participant);
          this.removeScreenShare(participant);
        }
      };
      this.onScreenShareUpdate = (participant) => {
        if (participant.screenShareEnabled) {
          this.addScreenShare(participant);
        }
        else {
          this.removeScreenShare(participant);
        }
      };
      this.onSelfScreenShareUpdate = ({ screenShareEnabled, }) => {
        if (screenShareEnabled) {
          this.addScreenShare(this.meeting.self);
        }
        else {
          this.removeScreenShare(this.meeting.self);
        }
      };
      this.onPluginStateUpdate = (plugin, { active }) => {
        if (active) {
          if (!this.plugins.some((p) => p.id === plugin.id)) {
            this.plugins = [...this.plugins, plugin];
          }
        }
        else {
          this.plugins = this.plugins.filter((p) => p.id !== plugin.id);
        }
      };
      this.onParticipantPinned = () => {
        this.updateActiveParticipants();
      };
      this.onParticipantUnpinned = () => {
        this.updateActiveParticipants();
      };
      this.updateRoomStateListener = () => {
        this.roomState = this.meeting.self.roomState;
      };
      this.participants = [];
      this.pinnedParticipants = [];
      this.screenShareParticipants = [];
      this.plugins = [];
      this.emptyStage = false;
      this.showLiveStreamPlayer = false;
      this.canCurrentPeerHost = false;
      this.pipSupported = false;
      this.pipEnabled = false;
      this.roomState = undefined;
      this.layout = 'row';
      this.aspectRatio = '16:9';
      this.meeting = undefined;
      this.gap = 8;
      this.size = undefined;
      this.states = state;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.gridSize = defaultGridSize;
      this.overrides = {};
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.disconnectMeeting(this.meeting);
    }
    disconnectMeeting(meeting) {
      var _a;
      if (meeting == null)
        return;
      this.participants = [];
      this.plugins = [];
      const { self, participants, plugins } = meeting;
      self.removeListener('pinned', this.onParticipantPinned);
      self.removeListener('unpinned', this.onParticipantUnpinned);
      self.removeListener('roomLeft', this.updateRoomStateListener);
      self.removeListener('roomJoined', this.updateRoomStateListener);
      self.removeListener('screenShareUpdate', this.onSelfScreenShareUpdate);
      plugins === null || plugins === undefined ? undefined : plugins.all.removeListener('stateUpdate', this.onPluginStateUpdate);
      (_a = meeting.stage) === null || _a === undefined ? undefined : _a.removeListener('stageStatusUpdate', this.stageStatusListener);
      participants.removeListener('viewModeChanged', this.onViewModeChanged);
      participants.active.removeListener('participantLeft', this.onParticipantLeft);
      participants.active.removeListener('participantJoined', this.onParticipantJoined);
      participants.pinned.removeListener('participantJoined', this.onParticipantPinned);
      participants.pinned.removeListener('participantLeft', this.onParticipantUnpinned);
      participants.joined.removeListener('screenShareUpdate', this.onScreenShareUpdate);
      participants.joined.removeListener('stageStatusUpdate', this.peerStageStatusListener);
    }
    meetingChanged(meeting, oldMeeting) {
      var _a, _b, _c, _d;
      if (oldMeeting !== null)
        this.disconnectMeeting(oldMeeting);
      if (meeting != null) {
        const { self, participants, plugins, stage } = meeting;
        // Check if PiP is supported and enabled
        this.pipSupported =
          ((_a = this.meeting.participants.pip) === null || _a === undefined ? undefined : _a.isSupported()) && ((_b = meeting.self.config) === null || _b === undefined ? undefined : _b.pipMode);
        if (this.pipSupported) {
          this.meeting.participants.pip.init();
        }
        // Initialize values
        const { permissions } = self;
        this.roomState = self.roomState;
        const isOffStage = this.meeting.stage.status !== 'ON_STAGE';
        const isRecorder = permissions === null || permissions === undefined ? undefined : permissions.isRecorder;
        this.hideSelf = isOffStage || isRecorder || permissions.hiddenParticipant;
        this.participants = this.filterParticipants([
          ...participants.active.toArray(),
          ...(!self.isPinned && !this.hideSelf ? [self] : []),
        ]);
        this.pinnedParticipants = [
          ...participants.pinned.toArray(),
          ...(self.isPinned && !this.hideSelf ? [self] : []),
        ];
        this.screenShareParticipants = participants.joined
          .toArray()
          .filter((participant) => participant.screenShareEnabled);
        this.plugins = (plugins === null || plugins === undefined ? undefined : plugins.active.toArray()) || [];
        if (permissions === null || permissions === undefined ? undefined : permissions.stageEnabled) {
          this.canCurrentPeerHost = permissions.acceptStageRequests || permissions.canPresent;
          this.updateStage();
        }
        // Add all listeners
        self.addListener('roomLeft', this.updateRoomStateListener);
        self.addListener('roomJoined', this.updateRoomStateListener);
        self.addListener('screenShareUpdate', this.onSelfScreenShareUpdate);
        self.addListener('pinned', this.onParticipantPinned);
        self.addListener('unpinned', this.onParticipantUnpinned);
        stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStatusListener);
        plugins === null || plugins === undefined ? undefined : plugins.all.addListener('stateUpdate', this.onPluginStateUpdate);
        participants.addListener('viewModeChanged', this.onViewModeChanged);
        participants.active.addListener('participantLeft', this.onParticipantLeft);
        (_c = participants === null || participants === undefined ? undefined : participants.joined) === null || _c === undefined ? undefined : _c.on('stageStatusUpdate', this.peerStageStatusListener);
        participants.joined.addListener('screenShareUpdate', this.onScreenShareUpdate);
        participants.active.addListener('participantJoined', this.onParticipantJoined);
        participants.pinned.addListener('participantJoined', this.onParticipantPinned);
        participants.pinned.addListener('participantLeft', this.onParticipantUnpinned);
        if ((_d = meeting.stage) === null || _d === undefined ? undefined : _d.status) {
          this.stageStatusListener();
        }
      }
    }
    overridesChanged(_overrides) {
      this.updateActiveParticipants();
    }
    screenShareParticipantsChanged(participants) {
      const activeScreenShare = participants.length > 0;
      if (!!state.activeScreenShare === activeScreenShare)
        return;
      this.stateUpdate.emit({ activeScreenShare });
      state.activeScreenShare = activeScreenShare;
    }
    pluginsChanged(plugins) {
      const activePlugin = plugins.length > 0;
      if (!!state.activePlugin === activePlugin)
        return;
      this.stateUpdate.emit({ activePlugin });
      state.activePlugin = activePlugin;
    }
    pinnedParticipantsChanged(participants) {
      const activeSpotlight = participants.length > 0;
      if (!!state.activeSpotlight === activeSpotlight)
        return;
      this.stateUpdate.emit({ activeSpotlight });
      state.activeSpotlight = activeSpotlight;
    }
    updateActiveParticipants() {
      var _a;
      const { self, participants, stage } = this.meeting;
      // NOTE(ishita1805): checking hiddenParticipant for v2 meetings.
      this.hideSelf =
        stage.status !== 'ON_STAGE' ||
          ((_a = self.permissions) === null || _a === undefined ? undefined : _a.isRecorder) ||
          self.permissions.hiddenParticipant;
      this.participants = this.filterParticipants([
        ...participants.active.toArray().filter((p) => p.id !== self.id),
        ...(participants.viewMode === 'ACTIVE_GRID' && !self.isPinned && !this.hideSelf
          ? [self]
          : []),
      ]);
      this.pinnedParticipants = [
        ...participants.pinned.toArray().filter((p) => p.id !== self.id),
        ...(self.isPinned && !this.hideSelf ? [self] : []),
      ];
      this.screenShareParticipants = participants.joined
        .toArray()
        .filter((participant) => participant.screenShareEnabled);
      if (self.screenShareEnabled) {
        this.screenShareParticipants = this.screenShareParticipants.concat([self]);
      }
      this.updateStage();
    }
    updateStage() {
      var _a;
      const { self } = this.meeting;
      if (!this.meeting)
        return;
      if ((_a = self === null || self === undefined ? undefined : self.permissions) === null || _a === undefined ? undefined : _a.stageEnabled) {
        this.emptyStage = this.participants.length === 0 && this.pinnedParticipants.length === 0;
      }
      else {
        this.emptyStage = false;
      }
    }
    addScreenShare(participant) {
      if (!this.screenShareParticipants.some((p) => p.id === participant.id)) {
        this.screenShareParticipants = [...this.screenShareParticipants, participant];
      }
    }
    removeScreenShare(participant) {
      this.screenShareParticipants = this.screenShareParticipants.filter((p) => p.id !== participant.id);
    }
    removePinned(participant) {
      this.pinnedParticipants = this.pinnedParticipants.filter((p) => p.id !== participant.id);
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        states: this.states || state,
        config: this.config,
        iconPack: this.iconPack,
        t: this.t,
      };
      if (this.invalidRoomStates.includes(this.roomState)) {
        return (h(Host, null, h("div", { class: "offline-grid" }, h("dyte-icon", { icon: this.iconPack.join_stage, size: "xl" }), h("h3", null, this.t('disconnected')), h("p", null, this.t('disconnected.description')))));
      }
      if (this.roomState === 'disconnected') {
        return (h(Host, null, h("div", { class: "offline-grid" }, h("dyte-icon", { icon: this.iconPack.disconnected, size: "xl" }), h("h3", null, this.t('offline')), h("p", null, this.t('offline.description')))));
      }
      if (this.roomState === 'failed') {
        return (h(Host, null, h("div", { class: "offline-grid" }, h("dyte-icon", { icon: this.iconPack.disconnected, size: "xl" }), h("h3", null, this.t('failed')), h("p", null, this.t('failed.description')))));
      }
      if (this.showLiveStreamPlayer) {
        return (h(Host, null, h("dyte-livestream-player", { meeting: this.meeting, size: this.size }), h("dyte-livestream-indicator", { meeting: this.meeting, size: "sm", t: this.t }), h("dyte-viewer-count", { meeting: this.meeting, variant: "embedded", t: this.t })));
      }
      if (this.emptyStage) {
        return (h(Host, null, h("div", { class: "webinar-stage" }, h("div", { class: "center" }, this.canCurrentPeerHost && (h("div", { class: "ctr", part: "container" }, h("p", { class: "message", part: "message" }, this.t('stage.empty_host')), h("span", { class: "description", part: "description" }, this.t('stage.empty_host_summary')))), !this.canCurrentPeerHost && (h("div", { class: "ctr", part: "container" }, h("p", { class: "message", part: "message" }, this.t('stage.empty_viewer'))))))));
      }
      return (h(Host, null, h(Render, { element: "dyte-grid", defaults: defaults, childProps: {
          participants: this.participants,
          screenShareParticipants: this.screenShareParticipants,
          plugins: this.plugins,
          pinnedParticipants: this.pinnedParticipants,
          aspectRatio: this.aspectRatio,
          gap: this.gap,
          layout: this.layout,
          gridSize: this.gridSize,
        }, onlyChildren: true }), h("dyte-livestream-indicator", { meeting: this.meeting, size: "sm", t: this.t }), h("dyte-viewer-count", { meeting: this.meeting, variant: "embedded" })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "overrides": ["overridesChanged"],
      "screenShareParticipants": ["screenShareParticipantsChanged"],
      "plugins": ["pluginsChanged"],
      "pinnedParticipants": ["pinnedParticipantsChanged"]
    }; }
  };
  DyteGrid.style = dyteGridCss;

  var dyteGrid_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_grid: DyteGrid
  });

  const dyteGridPaginationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;font-size:16px}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}:host([size='sm']) .center{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host([size='sm']) dyte-button{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}:host([size='sm']) dyte-button dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}dyte-button{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.center{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.center .page{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.center .slash{margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-0\\.5, 2px)}.center .pages{align-self:flex-end;font-size:12px}:host([variant='rounded']){overflow:hidden;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([variant='rounded']) dyte-button{border-radius:9999px;border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}:host([variant='rounded']) dyte-button:not([disabled]):hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='rounded']) dyte-button:not([disabled]):focus{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='grid']){margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host([variant='grid']) dyte-button{position:absolute;top:50%;height:var(--dyte-space-20, 80px);width:var(--dyte-space-20, 80px);opacity:0.2;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}:host([variant='grid']) dyte-button:hover{opacity:1}:host([variant='grid']) dyte-button{transform:translateY(-50%)}:host([variant='grid']) dyte-button.prev{left:var(--dyte-space-0, 0px);border-top-right-radius:9999px;border-bottom-right-radius:9999px}:host([variant='grid']) dyte-button.next{right:var(--dyte-space-0, 0px);border-top-left-radius:9999px;border-bottom-left-radius:9999px}:host([variant='grid']) dyte-button.auto{left:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);border-top-right-radius:9999px;border-bottom-right-radius:9999px}:host([variant='grid']) .dots{position:absolute;left:50%;bottom:var(--dyte-space-3, 12px);display:flex;align-items:center;transform:translateX(-50%)}:host([variant='grid']) .dots .dot{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-2, 8px);width:var(--dyte-space-2, 8px);cursor:pointer;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([variant='grid']) .dots .dot:last-child{margin-right:var(--dyte-space-0, 0px)}:host([variant='grid']) .dots .dot.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host([variant='grid'][size='sm']) dyte-button{height:var(--dyte-space-14, 56px);width:var(--dyte-space-14, 56px);opacity:0.1}";

  const MASS_ACTIONS_DEBOUNCE_TIMER = 50; // In ms
  const DyteGridPagination = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onPageChanged = ({ currentPage, pageCount, }) => {
        this.pageCount = pageCount;
        this.page = currentPage;
      };
      this.toggleGridPagination = debounce_1(() => {
        var _a;
        const { self, participants } = this.meeting;
        const { mobile, desktop } = (_a = self.config) === null || _a === undefined ? undefined : _a.maxVideoStreams;
        const maxCount = this.size === 'sm' ? mobile : desktop;
        const stagePeopleCount = participants.joined
          .toArray()
          .filter((p) => p.stageStatus === 'ON_STAGE').length;
        if (stagePeopleCount < maxCount) {
          this.showPagination = false;
        }
        else {
          this.showPagination = true;
        }
      }, MASS_ACTIONS_DEBOUNCE_TIMER);
      this.onParticipantJoin = debounce_1(() => {
        this.pageCount = this.meeting.participants.pageCount;
        this.toggleGridPagination();
      }, MASS_ACTIONS_DEBOUNCE_TIMER);
      this.onParticipantLeave = debounce_1(() => {
        this.pageCount = this.meeting.participants.pageCount;
        this.toggleGridPagination();
      }, MASS_ACTIONS_DEBOUNCE_TIMER);
      this.onStateStatusUpdate = debounce_1(() => {
        this.pageCount = this.meeting.participants.pageCount;
        this.toggleGridPagination();
      }, MASS_ACTIONS_DEBOUNCE_TIMER);
      this.prevPage = () => {
        if (this.meeting == null)
          return;
        const { participants } = this.meeting;
        if (this.page > 1) {
          participants.setPage((this.page -= 1));
        }
        else if (participants.viewMode === 'PAGINATED') {
          participants.setViewMode('ACTIVE_GRID');
        }
      };
      this.nextPage = () => {
        if (this.meeting == null)
          return;
        const { participants } = this.meeting;
        if (this.page > 0 && this.page < this.pageCount) {
          participants.setPage((this.page += 1));
        }
        else if (participants.count > 0 && this.pageCount === 0) {
          participants.setViewMode('PAGINATED');
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.variant = 'rounded';
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.page = 1;
      this.pageCount = 0;
      this.activeCount = 0;
      this.activeComputedCount = 0;
      this.showPagination = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.sizeChanged();
    }
    disconnectedCallback() {
      if (this.meeting == null)
        return;
      const { participants, stage } = this.meeting;
      participants.removeListener('pageChanged', this.onPageChanged);
      participants.removeListener('viewModeChanged', this.onPageChanged);
      participants.joined.removeListener('participantJoined', this.onParticipantJoin);
      participants.joined.removeListener('participantLeft', this.onParticipantLeave);
      participants.joined.removeListener('stageStatusUpdate', this.onStateStatusUpdate);
      stage.removeListener('stageStatusUpdate', this.onStateStatusUpdate);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        const { stage, participants } = meeting;
        this.page = participants.currentPage;
        this.pageCount = participants.pageCount;
        participants.addListener('viewModeChanged', this.onPageChanged);
        participants.addListener('pageChanged', this.onPageChanged);
        participants.joined.addListener('participantJoined', this.onParticipantJoin);
        participants.joined.addListener('participantLeft', this.onParticipantLeave);
        participants.joined.addListener('stageStatusUpdate', this.onStateStatusUpdate);
        stage.addListener('stageStatusUpdate', this.onStateStatusUpdate);
        this.activeCount = this.meeting.participants.joined.size;
        this.activeComputedCount = this.meeting.participants.joined.size;
        this.toggleGridPagination();
      }
    }
    sizeChanged() {
      this.toggleGridPagination();
    }
    render() {
      const { meta } = this.meeting;
      const isAudioRoom = (meta === null || meta === undefined ? undefined : meta.viewType) === 'AUDIO_ROOM';
      if (isAudioRoom || !this.showPagination) {
        return;
      }
      return (h(Host, null, h("dyte-button", { class: "prev", variant: "secondary", kind: "icon", disabled: this.pageCount === 0, onClick: this.prevPage, "aria-label": this.t('page.prev'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), this.variant !== 'grid' && (h("div", { class: "center" }, h("span", { class: "page" }, this.pageCount === 0 ? (h("dyte-tooltip", { label: this.t('layout.auto'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { kind: "icon", class: "auto", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.wand, iconPack: this.iconPack, t: this.t })))) : (this.page)), this.pageCount !== 0 && [
        h("span", { class: "slash" }, "/"),
        h("span", { class: "pages" }, this.pageCount),
      ])), this.variant === 'grid' && this.pageCount > 0 && (h("div", { class: "dots" }, [...Array(this.pageCount)].map((_, index) => (h("div", { key: `dot-${index}`, class: { dot: true, active: index + 1 === this.page } }))))), h("dyte-button", { class: "next", variant: "secondary", kind: "icon", disabled: this.page !== 0 && this.page === this.pageCount, onClick: this.nextPage, "aria-label": this.t('page.next'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_right, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "size": ["sizeChanged"]
    }; }
  };
  DyteGridPagination.style = dyteGridPaginationCss;

  var dyteGridPagination_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_grid_pagination: DyteGridPagination
  });

  const dyteHeaderCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:var(--dyte-space-12, 48px);align-items:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{display:none !important}}@media only screen and (max-height: 480px) and (orientation: landscape){:host{display:none !important}}";

  const DyteHeader = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.variant = 'solid';
      this.disableRender = false;
      this.meeting = undefined;
      this.config = defaultConfig;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states,
        t: this.t,
        iconPack: this.iconPack,
        size: this.size,
      };
      return (h(Host, null, !this.disableRender && h(Render, { element: "dyte-header", defaults: defaults, onlyChildren: true }), h("slot", null)));
    }
  };
  DyteHeader.style = dyteHeaderCss;

  var dyteHeader_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_header: DyteHeader
  });

  const dyteIdleScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.ctr{display:flex;flex-direction:column;align-items:center;gap:var(--dyte-space-8, 32px)}dyte-logo.loaded{height:var(--dyte-space-12, 48px)}dyte-spinner{height:var(--dyte-space-12, 48px);width:var(--dyte-space-12, 48px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

  const DyteIdleScreen = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.meeting = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("slot", null, h("div", { class: "ctr", part: "container" }, h("dyte-logo", { meeting: this.meeting, config: this.config, t: this.t, part: "logo" }), h("dyte-spinner", { "aria-label": "Idle, waiting for meeting data", part: "spinner", iconPack: this.iconPack, t: this.t })))));
    }
  };
  DyteIdleScreen.style = dyteIdleScreenCss;

  var dyteIdleScreen_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_idle_screen: DyteIdleScreen
  });

  const getExtension = (name) => {
    // split query and hash from url, then get the filename
    return name.split(/[#?]/)[0].split('.').pop().trim();
  };
  /**
   * Formats size in bytes to human readable formats
   * @param size Size in bytes
   * @returns Human readable file size
   */
  const getFileSize = (size) => {
    if (!size)
      return '0 B';
    const i = Math.floor(Math.log(size) / Math.log(1024));
    return `${(size / 1024 ** i).toFixed(2)} ${['B', 'kB', 'MB', 'GB', 'TB'][i]}`;
  };
  /**
   * Extracts the file name from a URL.
   * @param link The URL of the file
   * @param fallback Fallback filename
   * @returns File name
   */
  const getFileName = (link, fallback = 'file') => {
    try {
      const url = new URL(link);
      const name = url.pathname.split('/').pop();
      return name !== '/' ? name : fallback;
    }
    catch (_) {
      return fallback;
    }
  };
  /**
   * Downloads file from a given URL without leaving the current page
   * @param link URL of the file to download
   * @param options Optional Options for file download - `name` and `fallbackName`
   */
  const downloadFile = async (link, options) => {
    link = sanitizeLink(link);
    let name = options === null || options === undefined ? undefined : options.name;
    const res = await fetch(link);
    if (!res.ok) {
      // if unable to download file (CORS or some other error)
      // open the URL in new tab
      window.open(link, '_blank');
      return;
    }
    const blobURL = URL.createObjectURL(await res.blob());
    // Creates an anchor tag and simulates download
    const a = document.createElement('a');
    a.href = blobURL;
    a.download = name !== null && name !== undefined ? name : getFileName(link, options === null || options === undefined ? undefined : options.fallbackName);
    a.click();
  };

  const dyteImageViewerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{width:1140px;max-width:100%;box-sizing:border-box;display:flex;flex-direction:column;padding:var(--dyte-space-6, 24px);padding-top:var(--dyte-space-5, 20px);overflow-y:auto;color:rgb(var(--dyte-colors-text-1000, 255 255 255));z-index:40;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.displayName{font-weight:700}.image-ctr{margin-top:var(--dyte-space-2, 8px);box-sizing:border-box;display:flex;justify-content:center;overflow:hidden}.actions{display:flex;align-items:center;justify-content:flex-end;gap:var(--dyte-space-2, 8px)}img{box-sizing:border-box;display:block;max-height:100%;max-width:100%;-o-object-fit:contain;object-fit:contain}.header{display:flex;align-items:center;justify-content:space-between;padding-bottom:var(--dyte-space-4, 16px)}.shared-by-user{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}:host([size='sm']) .header{flex-direction:column}:host([size='sm']) .header .actions{margin-top:var(--dyte-space-4, 16px)}";

  const DyteImageViewer = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.close = createEvent(this, "close", 7);
      this.keypressListener = (e) => {
        if (e.key === 'Escape') {
          this.close.emit();
        }
      };
      this.handleOutsideClick = () => this.close.emit();
      this.image = undefined;
      this.size = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
    }
    connectedCallback() {
      document.addEventListener('keydown', this.keypressListener);
      document.addEventListener('click', this.handleOutsideClick);
    }
    disconnectedCallback() {
      document.removeEventListener('keydown', this.keypressListener);
      document.removeEventListener('click', this.handleOutsideClick);
    }
    render() {
      return (h(Host, { class: "scrollbar", onClick: (e) => e.stopPropagation() }, h("div", { class: "header" }, h("div", { class: "shared-by-user" }, this.t('chat.img.shared_by'), ' ', h("span", { class: "displayName" }, formatName(shorten(this.image.displayName)))), h("div", { class: "actions" }, h("dyte-button", { onClick: () => downloadFile(this.image.link, { fallbackName: 'image' }), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.download, slot: "start", iconPack: this.iconPack, t: this.t }), "Download"), h("dyte-button", { kind: "icon", variant: "secondary", onClick: () => this.close.emit(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t })))), h("div", { class: "image-ctr" }, h("img", { src: this.image.link }))));
    }
  };
  DyteImageViewer.style = dyteImageViewerCss;

  var dyteImageViewer_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_image_viewer: DyteImageViewer
  });

  const dyteInformationTooltipCss = ":host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);cursor:pointer}.tooltip-container{position:relative;display:flex;flex-direction:row;align-items:center}.tooltip-container dyte-icon{cursor:pointer;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.tooltip-container dyte-icon:hover+.tooltip{display:flex !important}.tooltip{position:absolute;margin-left:var(--dyte-space-2, 8px);display:none !important;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);font-weight:400;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));z-index:50;display:flex;min-width:var(--dyte-space-60, 240px);flex-direction:column;--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);left:14px}";

  const DyteInformationTooltip = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.iconPack = defaultIconPack;
    }
    render() {
      return (h(Host, null, h("div", { class: "tooltip-container" }, h("dyte-icon", { icon: this.iconPack.info, size: "sm" }), h("div", { class: "tooltip" }, h("slot", { name: "tootlip-text" })))));
    }
  };
  DyteInformationTooltip.style = dyteInformationTooltipCss;

  var dyteInformationTooltip_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_information_tooltip: DyteInformationTooltip
  });

  const dyteLeaveButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteLeaveButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.leave = () => {
        this.stateUpdate.emit({ activeLeaveConfirmation: true });
        state.activeLeaveConfirmation = true;
      };
      this.variant = 'button';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      const text = this.t('leave');
      return (h(Host, { label: text }, h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, class: "leave red-icon", onClick: this.leave, icon: this.iconPack.call_end, label: text, variant: this.variant, part: "controlbar-button" })));
    }
  };
  DyteLeaveButton.style = dyteLeaveButtonCss;

  var dyteLeaveButton_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_leave_button: DyteLeaveButton
  });

  const dyteLeaveMeetingCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.leave-modal{width:var(--dyte-space-72, 288px)}@media (min-width: 768px){.leave-modal{width:var(--dyte-space-96, 384px)}}.leave-modal{position:relative;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding:var(--dyte-space-8, 32px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}.leave-modal .message{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.leave-modal .content{margin-top:var(--dyte-space-4, 16px);font-size:14px;display:flex;flex-wrap:wrap;gap:var(--dyte-space-4, 16px)}.leave-modal .content dyte-button{height:var(--dyte-space-9, 36px);min-width:var(--dyte-space-44, 176px);flex-grow:1}.leave-modal .content .secondary-btn{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.leave-modal .content .secondary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.leave-modal .content .secondary-danger-btn{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DyteLeaveMeeting = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.keyPressListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      this.isBreakoutRoomsActive = false;
      this.isChildMeeting = false;
      this.canJoinMainRoom = false;
      this.permissionsUpdateListener = () => {
        this.canEndMeeting = this.meeting.self.permissions.kickParticipant;
        this.canJoinMainRoom = this.meeting.self.permissions.connectedMeetings.canSwitchToParentMeeting;
      };
      this.close = () => {
        this.stateUpdate.emit({ activeLeaveConfirmation: false });
        state.activeLeaveConfirmation = false;
      };
      this.handleLeave = () => {
        var _a;
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.leaveRoom();
        this.close();
      };
      this.handleJoinMainRoom = () => {
        this.meeting.connectedMeetings.moveParticipants(this.meeting.meta.meetingId, this.meeting.connectedMeetings.parentMeeting.id, [this.meeting.self.userId]);
        this.close();
      };
      this.handleEndMeeting = () => {
        var _a;
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.participants.kickAll();
        this.close();
      };
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.canEndMeeting = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      document.addEventListener('keydown', this.keyPressListener);
    }
    disconnectedCallback() {
      var _a;
      document.removeEventListener('keydown', this.keyPressListener);
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        this.isBreakoutRoomsActive =
          this.meeting.connectedMeetings.supportsConnectedMeetings &&
            this.meeting.connectedMeetings.isActive;
        this.isChildMeeting =
          this.meeting.connectedMeetings.supportsConnectedMeetings &&
            this.meeting.connectedMeetings.meetings.some((cMeet) => cMeet.id === meeting.meta.meetingId);
        this.meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
        this.permissionsUpdateListener();
      }
    }
    render() {
      return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, this.t('leave'))), h("p", { class: "message" }, this.isBreakoutRoomsActive && this.isChildMeeting
        ? this.t('breakout_rooms.leave_confirmation')
        : this.t('leave_confirmation')), h("div", { class: "content" }, h("dyte-button", { variant: "secondary", onClick: this.close, iconPack: this.iconPack, class: "secondary-btn", t: this.t }, this.t('cancel')), this.isBreakoutRoomsActive && this.isChildMeeting && this.canJoinMainRoom && (h("dyte-button", { variant: "secondary", onClick: this.handleJoinMainRoom, iconPack: this.iconPack, class: "secondary-btn", t: this.t }, this.t('breakout_rooms.leave_confirmation.main_room_btn'))), h("dyte-button", { variant: this.canEndMeeting ? 'secondary' : 'danger', title: this.t('leave'), onClick: this.handleLeave, iconPack: this.iconPack, class: {
          'secondary-btn': this.canEndMeeting,
          'secondary-danger-btn': this.canEndMeeting,
        }, t: this.t }, this.t('leave')), this.canEndMeeting && (h("dyte-button", { variant: "danger", onClick: this.handleEndMeeting, iconPack: this.iconPack, t: this.t }, this.t('end.all')))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteLeaveMeeting.style = dyteLeaveMeetingCss;

  var dyteLeaveMeeting_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_leave_meeting: DyteLeaveMeeting
  });

  const dyteLivestreamToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteLivestreamToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
      this.livestreamStateListener = (state$1) => {
        this.livestreamState = state$1;
        if (state$1 === 'LIVESTREAMING' || state$1 === 'IDLE') {
          this.stateUpdate.emit({ activeMoreMenu: false });
          state.activeMoreMenu = false;
        }
      };
      this.isLoading = () => {
        return (this.meeting == null ||
          this.livestreamState === 'STARTING' ||
          this.livestreamState === 'STOPPING');
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.livestreamState = 'IDLE';
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.clearListeners();
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting == null)
        return;
      this.livestreamState = (_a = this.meeting.livestream) === null || _a === undefined ? undefined : _a.state;
      (_b = this.meeting.livestream) === null || _b === undefined ? undefined : _b.on('livestreamUpdate', this.livestreamStateListener);
    }
    async toggleLivestream() {
      var _a, _b;
      if (this.livestreamState === 'LIVESTREAMING') {
        try {
          await ((_a = this.meeting.livestream) === null || _a === void 0 ? void 0 : _a.stop());
        }
        catch (_c) {
          this.dyteAPIError.emit({
            trace: this.t('livestream.stop'),
            message: this.t('livestream.error.stop'),
          });
        }
      }
      else {
        try {
          await ((_b = this.meeting.livestream) === null || _b === void 0 ? void 0 : _b.start());
        }
        catch (_d) {
          this.dyteAPIError.emit({
            trace: this.t('livestream.start'),
            message: this.t('livestream.error.start'),
          });
        }
      }
    }
    clearListeners() {
      var _a;
      (_a = this.meeting.livestream) === null || _a === undefined ? undefined : _a.removeListener('livestreamUpdate', this.livestreamStateListener);
    }
    getLivestreamLabel() {
      switch (this.livestreamState) {
        case 'IDLE':
          return this.t('livestream.go_live');
        case 'LIVESTREAMING':
          return this.t('livestream.end_live');
        case 'STARTING':
          return this.t('livestream.starting');
        case 'STOPPING':
          return this.t('livestream.stopping');
        default:
          return this.t('livestream.error');
      }
    }
    getLivestreamIcon() {
      switch (this.livestreamState) {
        case 'IDLE':
          return this.iconPack.start_livestream;
        case 'LIVESTREAMING':
          return this.iconPack.stop_livestream;
        case 'STARTING':
        case 'STOPPING':
        default:
          return this.iconPack.stop_livestream;
      }
    }
    render() {
      if (!isLiveStreamHost(this.meeting))
        return;
      return (h(Host, null, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, isLoading: this.isLoading(), class: { 'active-livestream': this.livestreamState === 'LIVESTREAMING' }, onClick: () => this.toggleLivestream(), icon: this.getLivestreamIcon(), disabled: this.isLoading(), label: this.t(this.getLivestreamLabel()), variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteLivestreamToggle.style = dyteLivestreamToggleCss;

  var dyteLivestreamToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_livestream_toggle: DyteLivestreamToggle
  });

  const dyteMeetingTitleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:16px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.title{text-align:center;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}:host([size='sm']){font-size:12px}";

  const DyteMeetingTitle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      var _a;
      const title = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta.meetingTitle;
      if (title == null)
        return null;
      return (h(Host, { tabIndex: 0, role: "banner", "aria-label": title }, h("dyte-tooltip", { label: title, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("div", { class: "title", part: "title" }, title))));
    }
  };
  DyteMeetingTitle.style = dyteMeetingTitleCss;

  var dyteMeetingTitle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_meeting_title: DyteMeetingTitle
  });

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike$1(value) && baseGetTag$1(value) == symbolTag);
  }

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject$1(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root$1.Date.now();
  };

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  const dyteMessageListViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.loading{cursor:wait}.content-wrapper{height:100%;overflow-y:auto;position:relative;contain:strict}.scroller{width:1px;opacity:0}.content{position:absolute;top:0;width:100%}.smallest-dom-element{width:100%;height:2px;background:red}.loader{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;justify-content:center}";

  const MAX_VISIBLE_ITEMS = 20;
  const OVERSCAN_BUFFER = 5;
  const DyteMessageListView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.sizes = new Map();
      this.lastScrollTop = 0;
      this.scrollToBottomRetries = 0;
      this.elementObserver = (() => {
        let _ro = null;
        const get = () => {
          if (_ro) {
            return _ro;
          }
          else if (typeof ResizeObserver !== 'undefined') {
            return (_ro = new ResizeObserver((entries) => {
              entries.forEach((entry) => {
                this.measureElement(entry.target, entry);
              });
            }));
          }
          else {
            return null;
          }
        };
        return {
          disconnect: () => { var _a; return (_a = get()) === null || _a === undefined ? undefined : _a.disconnect(); },
          observe: (target) => { var _a; return (_a = get()) === null || _a === undefined ? undefined : _a.observe(target, { box: 'border-box' }); },
          unobserve: (target) => { var _a; return (_a = get()) === null || _a === undefined ? undefined : _a.unobserve(target); },
        };
      })();
      this.measureElement = (node, entry) => {
        if (!node)
          return;
        const id = node.dataset.id;
        if (this.sizes.has(id)) {
          this.elementObserver.unobserve(node);
          return;
        }
        if (entry) {
          const box = entry.borderBoxSize[0];
          if (box && box.blockSize > 0) {
            this.saveItemSize(id, box.blockSize);
            this.elementObserver.unobserve(node);
            return;
          }
        }
        const rect = node.getBoundingClientRect();
        if (rect.height > 0)
          this.saveItemSize(id, rect.height);
      };
      this.getVisibleItems = () => {
        return this.messages.slice(this.range.start, this.range.end + 1);
      };
      this.updateVisibleItems = (start, end) => {
        const total = this.messages.length;
        let newStart = start;
        let newEnd = end;
        if (total <= this.visibleItemsCount) {
          // render all
          newStart = 0;
          newEnd = total - 1;
        }
        else if (end - start < this.visibleItemsCount - 1) {
          // if range is less then visible, adjust start based on end
          newStart = this.range.end - this.visibleItemsCount + 1;
        }
        if (this.range.start !== newStart) {
          this.range = { start: newStart, end: newEnd };
          this.totalHeight = this.getRangeSize(0, total);
        }
      };
      this.getEstimatedItemSize = () => {
        return this.estimateItemSize;
      };
      this.getRangeSize = (start, end) => {
        let total = 0;
        let itemSize = 0;
        for (let index = start; index < end; index++) {
          itemSize = this.sizes.get(this.messages[index].id);
          total = total + (!!itemSize ? itemSize : this.getEstimatedItemSize());
        }
        return total;
      };
      this.getScrollTop = () => {
        return this.$listRef ? Math.ceil(this.$listRef.scrollTop) : 0;
      };
      this.getClientHeight = () => {
        return this.$listRef ? Math.ceil(this.$listRef.clientHeight) : 0;
      };
      this.getScrollHeight = () => {
        return this.$listRef ? Math.ceil(this.$listRef.scrollHeight) : 0;
      };
      this.getItemsScrolled = () => {
        const offset = this.lastScrollTop;
        if (offset <= 0) {
          return 0;
        }
        let low = 0;
        let middle = 0;
        let middleOffset = 0;
        let high = this.messages.length;
        while (low <= high) {
          middle = (low + high) >>> 1;
          middleOffset = this.getRangeSize(0, middle);
          if (middleOffset === offset) {
            return middle;
          }
          else if (middleOffset < offset) {
            low = middle + 1;
          }
          else if (middleOffset > offset) {
            high = middle - 1;
          }
        }
        return low > 0 ? --low : 0;
      };
      this.getEndByStart = (start) => {
        return Math.min(start + this.visibleItemsCount, this.messages.length - 1);
      };
      this.scrollToOffset = (offset) => {
        if (this.$listRef) {
          this.$listRef.scrollTop = offset;
        }
      };
      this.scrollToIndex = (index) => {
        if (index >= this.messages.length - 1) {
          this.scrollToBottom();
        }
        else {
          const offset = index < 1 ? 0 : this.getRangeSize(0, index);
          this.scrollToOffset(offset);
        }
      };
      this.scrollToBottom = () => {
        if (!this.$listEndRef)
          return;
        writeTask(() => {
          this.$listEndRef.scrollIntoView();
          if (this.getScrollHeight() - (this.getScrollTop() + this.getClientHeight()) > 0 &&
            this.scrollToBottomRetries < 10) {
            setTimeout(() => {
              this.scrollToBottom();
            }, 1000 / 60);
          }
          else {
            this.scrollToBottomRetries = 0;
            this.autoScroll = true;
          }
        });
      };
      this.handleScroll = async () => {
        if (this.isFetching)
          return;
        const scrollTop = this.getScrollTop();
        const direction = scrollTop < this.lastScrollTop || scrollTop === 0 ? 'UP' : 'DOWN';
        this.lastScrollTop = scrollTop;
        if (this.loadMore && scrollTop === 0 && direction === 'UP' && this.isFetching === false) {
          this.isFetching = true;
          const newMessages = await this.loadMore(this.messages[0]);
          if (newMessages && newMessages.length) {
            this.messages = [...newMessages, ...this.messages];
          }
          this.isFetching = false;
        }
        if (direction === 'UP') {
          this.handleTop();
        }
        else if (direction === 'DOWN') {
          this.handleBottom();
        }
      };
      this.handleTop = () => {
        const scrolledItems = this.getItemsScrolled();
        if (scrolledItems <= this.range.end - OVERSCAN_BUFFER) {
          this.autoScroll = false;
        }
        if (scrolledItems > this.range.start + OVERSCAN_BUFFER) {
          return;
        }
        const newStart = Math.max(this.range.start - OVERSCAN_BUFFER, 0);
        this.updateVisibleItems(newStart, this.getEndByStart(newStart));
      };
      this.handleBottom = () => {
        const scrolledItems = this.getItemsScrolled();
        if (scrolledItems < this.range.start + OVERSCAN_BUFFER) {
          return;
        }
        const newStart = this.range.start + OVERSCAN_BUFFER;
        const newEnd = this.getEndByStart(newStart);
        if (newEnd === this.messages.length - 1) {
          this.updateVisibleItems(newEnd - this.visibleItemsCount, newEnd);
        }
        else {
          this.updateVisibleItems(newStart, newEnd);
        }
      };
      this.updateTotalHeight = debounce(() => {
        this.totalHeight = this.getRangeSize(0, this.messages.length);
      }, 1000 / 30, { leading: true });
      this.rendererInternal = (containerElement, message, index) => {
        if (!containerElement)
          return;
        if (containerElement.dataset.id === message.id)
          return;
        const viewElement = this.renderer(message, index);
        if (containerElement.hasChildNodes) {
          containerElement.innerHTML = '';
        }
        this.elementObserver.observe(containerElement);
        containerElement.dataset.id = message.id;
        containerElement.appendChild(viewElement);
      };
      this.messages = undefined;
      this.renderer = undefined;
      this.loadMore = undefined;
      this.visibleItemsCount = MAX_VISIBLE_ITEMS;
      this.estimateItemSize = 100;
      this.iconPack = defaultIconPack;
      this.range = undefined;
      this.isFetching = false;
      this.autoScroll = true;
      this.totalHeight = 0;
    }
    connectedCallback() {
      const total = this.messages.length - 1;
      this.range = { start: total - this.visibleItemsCount, end: total };
      this.updateVisibleItems(this.range.start, this.range.end);
      this.totalHeight = this.getRangeSize(0, total);
    }
    componentDidLoad() {
      if (this.autoScroll) {
        this.scrollToBottom();
      }
    }
    messagesUpdated(newValue, previousValue) {
      if (newValue.length > previousValue.length) {
        const diff = newValue.length - previousValue.length;
        this.updateVisibleItems(diff, this.getEndByStart(diff));
        this.scrollToIndex(this.range.start);
      }
    }
    saveItemSize(id, height) {
      this.sizes.set(id, Math.round(height));
      this.updateTotalHeight();
    }
    render() {
      return (h("div", { class: "scrollbar content-wrapper", ref: (el) => (this.$listRef = el), onScroll: this.handleScroll }, h("div", { class: "scroller" }, h("div", { style: {
          height: `${this.totalHeight}px`,
        } }), h("div", { class: "smallest-dom-element", id: "list-end", ref: (el) => (this.$listEndRef = el) })), h("div", { class: "content", style: {
          transform: `translateY(${this.getRangeSize(0, this.range.start)}px)`,
        } }, this.isFetching && (h("div", { class: "loader" }, h("dyte-spinner", { size: "md" }))), this.getVisibleItems().map((msg, index) => (h("div", { key: msg.id, ref: (el) => this.rendererInternal(el, msg, index) }))))));
    }
    static get watchers() { return {
      "messages": ["messagesUpdated"]
    }; }
  };
  DyteMessageListView.style = dyteMessageListViewCss;

  var dyteMessageListView_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_message_list_view: DyteMessageListView
  });

  const dyteMicToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}:host(.audioDisabled) :slotted(dyte-icon){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DyteMicToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.audioUpdateListener = ({ audioEnabled }) => {
        this.audioEnabled = audioEnabled;
      };
      this.stageStatusListener = () => {
        this.stageStatus = this.meeting.stage.status;
        this.canProduceAudio = this.meeting.self.permissions.canProduceAudio === 'ALLOWED';
      };
      this.mediaPermissionUpdateListener = ({ kind, message }) => {
        if (kind === 'audio') {
          this.micPermission = message;
        }
      };
      this.meetingPermissionsUpdateListener = (patch) => {
        var _a;
        if ((_a = patch === null || patch === undefined ? undefined : patch.media) === null || _a === undefined ? undefined : _a.audio) {
          this.canProduceAudio = this.meeting.self.permissions.canProduceAudio === 'ALLOWED';
        }
      };
      this.toggleMic = () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.__internals__.logger.info('dyteMicToggle::toggleMic', {
          media: {
            audio: {
              enabled: Boolean((_c = (_b = this.meeting) === null || _b === undefined ? undefined : _b.self) === null || _c === undefined ? undefined : _c.audioEnabled),
              permission: this.micPermission,
              canProduce: (_f = (_e = (_d = this.meeting) === null || _d === undefined ? undefined : _d.self) === null || _e === undefined ? undefined : _e.permissions) === null || _f === undefined ? undefined : _f.canProduceAudio,
            },
          },
          webinar: {
            stageStatus: (_h = (_g = this.meeting) === null || _g === undefined ? undefined : _g.stage) === null || _h === undefined ? undefined : _h.status,
          },
          livestream: {
            stageStatus: (_k = (_j = this.meeting) === null || _j === undefined ? undefined : _j.stage) === null || _k === undefined ? undefined : _k.status,
          },
          moduleExists: {
            self: Boolean((_l = this.meeting) === null || _l === undefined ? undefined : _l.self),
          },
        });
        if (this.hasPermissionError()) {
          const permissionModalSettings = {
            enabled: true,
            kind: 'audio',
          };
          this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
          state.activePermissionsMessage = permissionModalSettings;
          return false;
        }
        const self = (_m = this.meeting) === null || _m === undefined ? undefined : _m.self;
        if (self == null || !this.canProduceAudio) {
          return;
        }
        if (self.audioEnabled) {
          self.disableAudio();
        }
        else {
          self.enableAudio();
        }
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.audioEnabled = false;
      this.canProduceAudio = false;
      this.micPermission = 'NOT_REQUESTED';
      this.stageStatus = 'OFF_STAGE';
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f, _g;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.removeListener('audioUpdate', this.audioUpdateListener);
      (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.stage) === null || _d === undefined ? undefined : _d.removeListener('stageStatusUpdate', this.stageStatusListener);
      (_g = (_f = (_e = this.meeting) === null || _e === undefined ? undefined : _e.self) === null || _f === undefined ? undefined : _f.permissions) === null || _g === undefined ? undefined : _g.removeListener('permissionsUpdate', this.meetingPermissionsUpdateListener);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting != null) {
        const { self, stage } = meeting;
        this.canProduceAudio = this.meeting.self.permissions.canProduceAudio === 'ALLOWED';
        this.micPermission = meeting.self.mediaPermissions.audio || 'NOT_REQUESTED';
        this.audioEnabled = self.audioEnabled;
        this.stageStatus = meeting.stage.status;
        self.addListener('audioUpdate', this.audioUpdateListener);
        self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
        stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStatusListener);
        (_b = (_a = meeting.self) === null || _a === undefined ? undefined : _a.permissions) === null || _b === undefined ? undefined : _b.addListener('permissionsUpdate', this.meetingPermissionsUpdateListener);
      }
    }
    hasPermissionError() {
      return this.micPermission === 'DENIED' || this.micPermission === 'SYSTEM_DENIED';
    }
    getState() {
      let tooltipLabel = '';
      let label = '';
      let icon = '';
      let classList = {};
      let hasError = this.hasPermissionError();
      let couldNotStart = this.micPermission === 'COULD_NOT_START';
      if (this.audioEnabled && !hasError) {
        label = this.t('mic_on');
        icon = this.iconPack.mic_on;
      }
      else {
        label = this.t('mic_off');
        icon = this.iconPack.mic_off;
        classList['red-icon'] = true;
      }
      if (couldNotStart) {
        tooltipLabel = this.t('perm_could_not_start.audio');
      }
      else if (this.micPermission === 'SYSTEM_DENIED') {
        tooltipLabel = this.t('perm_sys_denied.audio');
      }
      else if (this.micPermission === 'DENIED') {
        tooltipLabel = this.t('perm_denied.audio');
      }
      else {
        tooltipLabel = this.audioEnabled ? this.t('disable_mic') : this.t('enable_mic');
      }
      return {
        tooltipLabel,
        label,
        icon,
        classList,
        showWarning: hasError || couldNotStart,
        disable: hasError,
      };
    }
    render() {
      if (!this.canProduceAudio ||
        ['OFF_STAGE', 'REQUESTED_TO_JOIN_STAGE'].includes(this.stageStatus)) {
        return null;
      }
      const { tooltipLabel, label, icon, classList, showWarning, disable } = this.getState();
      return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: tooltipLabel, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", icon: icon, label: label, size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, class: classList, onClick: this.toggleMic, showWarning: showWarning, disabled: disable }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteMicToggle.style = dyteMicToggleCss;

  var dyteMicToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_mic_toggle: DyteMicToggle
  });

  const dyteMixedGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:100%;width:100%;display:flex}main{display:flex;flex:1 1 0%;padding-left:var(--dyte-space-4, 16px)}:host([layout='column']) main{padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}main dyte-tab-bar{margin-right:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;height:100%;width:var(--dyte-space-16, 64px);flex-direction:column}main #tabs{height:100%;flex:1 1 0%}dyte-button{z-index:10}.grid-width-sm{width:25%}.grid-width-md{width:50%}.grid-width-lg{width:66.666667%}.col{display:flex;flex-direction:column;align-items:center}.tab{display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center;margin-bottom:var(--dyte-space-2, 8px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.tab.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}.tab img{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);border-radius:var(--dyte-border-radius-sm, 4px)}:host([size='sm']){flex-direction:column}:host([size='sm']) .grid-width-lg,:host([size='sm']) .grid-width-md{height:50%;width:100%;max-width:100%}:host([size='sm']) .grid-width-sm{height:33.333333%;width:100%;max-width:100%}:host([size='sm']) main{display:flex;flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='sm']) dyte-tab-bar{height:var(--dyte-space-12, 48px);width:100%;flex-direction:row}:host([size='sm']) #tabs{flex:1 1 0%}:host([size='sm']) .tab{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-2, 8px)}:host([layout='column']){flex-direction:column}:host([layout='column']) main{display:flex;flex:1 1 0%}:host([layout='column']) .grid-width-lg,:host([layout='column']) .grid-width-md{height:50%;max-width:100%;width:100%}:host([layout='column']) .grid-width-sm{height:33.333333%;max-width:100%;width:100%}@media (orientation: portrait){:host{flex-direction:column}:host .grid-width-lg{height:50%;width:100%;max-width:100%}:host .grid-width-md{height:33.333333%;width:100%;max-width:100%}:host .grid-width-sm{height:25%;width:100%;max-width:100%}:host main{flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='md']) main{flex:1 1 0%;flex-direction:column;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host dyte-tab-bar{height:var(--dyte-space-16, 64px);width:100%;flex-direction:row}:host #tabs{flex:1 1 0%}:host .tab{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-2, 8px)}}@media (orientation: landscape){:host{flex-direction:row}:host([size='sm']){flex-direction:row}:host .grid-width-lg{height:50%;width:100%;max-width:100%}:host([size='sm']) .grid-width-sm{height:100%;max-height:100%;width:16.666667%}:host([size='sm']) main{flex:1 1 0%;flex-direction:row;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}:host([size='md']) main{flex:1 1 0%;flex-direction:row;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='sm']) dyte-tab-bar{margin-right:var(--dyte-space-2, 8px);height:100%;width:var(--dyte-space-12, 48px);flex-direction:column}:host #tabs{flex:1 1 0%}:host .tab{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-2, 8px)}}";

  const DyteMixedGrid = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.layout = 'row';
      this.participants = [];
      this.pinnedParticipants = [];
      this.screenShareParticipants = [];
      this.plugins = [];
      this.aspectRatio = '16:9';
      this.gap = 8;
      this.size = undefined;
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.gridSize = defaultGridSize;
      this.activeTab = undefined;
      this.initialised = undefined;
    }
    componentWillLoad() {
      // initialise states
      this.initialised = false;
      this.screenShareParticipantsChanged(this.screenShareParticipants);
      this.pluginsChanged(this.plugins);
      this.initialised = true;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting.meta) === null || _a === undefined ? undefined : _a.removeListener('activeTabUpdate', this.activeTabUpdateListener);
    }
    meetingChanged(meeting) {
      var _a, _b, _c, _d;
      if (meeting != null) {
        if (((_a = meeting.meta) === null || _a === undefined ? undefined : _a.selfActiveTab) != undefined) {
          this.onActiveTabUpdate((_b = meeting.meta.selfActiveTab) === null || _b === undefined ? undefined : _b.type, (_c = meeting.meta.selfActiveTab) === null || _c === undefined ? undefined : _c.id);
        }
        this.activeTabUpdateListener = (activeTab) => {
          this.onActiveTabUpdate(activeTab === null || activeTab === undefined ? undefined : activeTab.type, activeTab === null || activeTab === undefined ? undefined : activeTab.id);
        };
        (_d = meeting.meta) === null || _d === undefined ? undefined : _d.addListener('activeTabUpdate', this.activeTabUpdateListener);
      }
    }
    screenShareParticipantsChanged(participants = []) {
      // If active tab has already been initialised by spotlight then don't change tab.
      if (!this.initialised && this.activeTab != null)
        return;
      if (this.activeTab == null && participants.length > 0) {
        this.setActiveTab({ type: 'screenshare', participant: participants[0] });
      }
      else {
        this.revalidateActiveTab();
      }
    }
    pluginsChanged(plugins) {
      // If active tab has already been initialised by spotlight then don't change tab.
      if (!this.initialised && this.activeTab != null)
        return;
      if (plugins.length > 0) {
        const lastIndex = plugins.length - 1;
        this.setActiveTab({ type: 'plugin', plugin: plugins[lastIndex] });
      }
      else {
        this.revalidateActiveTab();
      }
    }
    revalidateActiveTab() {
      if (this.activeTab != null) {
        if (this.activeTab.type === 'screenshare') {
          const { participant } = this.activeTab;
          if (!this.screenShareParticipants.some((p) => p.id === participant.id)) {
            this.reassignActiveTab();
          }
        }
        else {
          const { plugin } = this.activeTab;
          if (!this.plugins.some((p) => p.id === plugin.id)) {
            this.reassignActiveTab();
          }
        }
      }
    }
    setActiveTab(activeTab, shouldUpdateSelfActiveTab = true) {
      var _a;
      this.activeTab = activeTab;
      const id = activeTab.type === 'screenshare' ? activeTab.participant.id : activeTab.plugin.id;
      if (shouldUpdateSelfActiveTab)
        (_a = this.meeting.meta) === null || _a === undefined ? undefined : _a.setSelfActiveTab({ type: activeTab.type, id }, 0);
    }
    reassignActiveTab() {
      if (this.screenShareParticipants.length > 0) {
        this.setActiveTab({ type: 'screenshare', participant: this.screenShareParticipants[0] });
      }
      else if (this.plugins.length > 0) {
        const lastIndex = this.plugins.length - 1;
        this.setActiveTab({ type: 'plugin', plugin: this.plugins[lastIndex] });
      }
    }
    onActiveTabUpdate(type, id) {
      if (type == undefined)
        return;
      if (id == undefined)
        return;
      switch (type) {
        case 'plugin':
          const plugin = this.plugins.find((p) => p.id === id);
          if (plugin != undefined)
            this.setActiveTab({ type: 'plugin', plugin }, false);
          break;
        case 'screenshare':
          const participant = this.screenShareParticipants.find((ssp) => ssp.id === id);
          if (participant != undefined)
            this.setActiveTab({ type: 'screenshare', participant }, false);
      }
    }
    getTabs() {
      const screenshares = this.screenShareParticipants.map((participant) => ({
        type: 'screenshare',
        participant,
      }));
      const plugins = this.plugins.map((plugin) => ({ type: 'plugin', plugin }));
      return screenshares.concat(plugins);
    }
    render() {
      var _a, _b;
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("main", { id: "main-view", part: "main-view" }, ((_a = this.getTabs()) === null || _a === undefined ? undefined : _a.length) > 1 && (h("dyte-tab-bar", Object.assign({ activeTab: this.activeTab, tabs: this.getTabs(), onTabChange: (e) => this.setActiveTab(e.detail) }, defaults))), h("div", { id: "tabs", key: "tabs" }, this.screenShareParticipants.map((participant) => {
        var _a, _b;
        return (h(Render, { element: "dyte-screenshare-view", defaults: defaults, props: {
            participant,
            key: participant.id,
            style: {
              display: ((_a = this.activeTab) === null || _a === undefined ? undefined : _a.type) === 'screenshare' &&
                ((_b = this.activeTab) === null || _b === undefined ? undefined : _b.participant.id) === participant.id
                ? 'flex'
                : 'none',
            },
          }, childProps: { participant, isScreenShare: true }, deepProps: true }));
      }), this.plugins.map((plugin) => {
        var _a, _b;
        return (h(Render, { element: "dyte-plugin-main", defaults: defaults, props: {
            plugin,
            key: plugin.id,
            style: {
              display: ((_a = this.activeTab) === null || _a === undefined ? undefined : _a.type) === 'plugin' && ((_b = this.activeTab) === null || _b === undefined ? undefined : _b.plugin.id) === plugin.id
                ? 'flex'
                : 'none',
            },
          } }));
      }))), h(Render, { element: "dyte-mixed-grid", defaults: defaults, childProps: {
          part: 'participants-grid',
          class: this.gridSize.mixed ? `grid-width-${this.gridSize.mixed}` : 'grid-width-lg',
          participants: this.participants,
          pinnedParticipants: this.pinnedParticipants,
          screenShareParticipants: this.screenShareParticipants,
          plugins: this.plugins,
          aspectRatio: this.aspectRatio,
          gap: this.gap,
          size: ((_b = this.meeting.meta) === null || _b === undefined ? undefined : _b.viewType) === 'AUDIO_ROOM' ? 'md' : 'sm',
          layout: 'row',
        }, onlyChildren: true })));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "screenShareParticipants": ["screenShareParticipantsChanged"],
      "plugins": ["pluginsChanged"]
    }; }
  };
  DyteMixedGrid.style = dyteMixedGridCss;

  var dyteMixedGrid_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_mixed_grid: DyteMixedGrid
  });

  const dyteMoreToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;flex-direction:column;overflow:visible}.more-menu{position:absolute;right:calc(var(--dyte-space-24, 96px) * -1);bottom:var(--dyte-space-16, 64px);z-index:50;margin-bottom:var(--dyte-space-3, 12px);box-sizing:border-box;max-height:60vh;width:var(--dyte-space-64, 256px);overflow:auto;border-radius:var(--dyte-border-radius-md, 8px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));outline:2px solid transparent;outline-offset:2px}:host([size='sm']) .more-menu{bottom:var(--dyte-space-10, 40px)}.more-menu::-webkit-scrollbar{height:var(--dyte-space-0, 0px);width:var(--dyte-space-1\\.5, 6px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.more-menu::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}";

  const DyteMoreToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.handleKeyDown = ({ key }) => {
        if (key === 'Escape' && this.states.activeMoreMenu) {
          this.stateUpdate.emit({ activeMoreMenu: false });
          state.activeMoreMenu = !state.activeMoreMenu;
        }
      };
      this.handleOnClick = (e) => {
        if (!e.composedPath().includes(this.host) && this.states.activeMoreMenu) {
          this.stateUpdate.emit({ activeMoreMenu: false });
          state.activeMoreMenu = !state.activeMoreMenu;
        }
      };
      this.toggleMoreMenu = () => {
        this.stateUpdate.emit({ activeMoreMenu: !state.activeMoreMenu });
        state.activeMoreMenu = !state.activeMoreMenu;
      };
      this.states = state;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      /** A11y */
      window.addEventListener('keydown', this.handleKeyDown);
      window.addEventListener('click', this.handleOnClick);
      // };
    }
    disconnectedCallback() {
      window.removeEventListener('keydown', this.handleKeyDown);
      window.removeEventListener('click', this.handleOnClick);
    }
    render() {
      const text = this.t('more');
      return (h(Host, { title: text }, this.states.activeMoreMenu && (h("div", { class: "more-menu" }, h("slot", { name: "more-elements" }))), h("dyte-controlbar-button", { size: this.size, iconPack: this.iconPack, t: this.t, onClick: (e) => {
          e.stopPropagation();
          this.toggleMoreMenu();
        }, icon: this.iconPack.horizontal_dots, label: text, part: "controlbar-button" }), h("slot", { name: "expanded" })));
    }
    get host() { return getElement(this); }
  };
  DyteMoreToggle.style = dyteMoreToggleCss;

  var dyteMoreToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_more_toggle: DyteMoreToggle
  });

  const dyteMuteAllButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteMuteAllButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.permissionsUpdateListener = () => {
        var _a;
        this.canDisable = !!((_a = this.meeting) === null || _a === undefined ? undefined : _a.self.permissions.canDisableParticipantAudio);
      };
      this.onMuteAll = () => {
        this.stateUpdate.emit({ activeMuteAllConfirmation: true });
        state.activeMuteAllConfirmation = true;
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.canDisable = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions) === null || _c === undefined ? undefined : _c.removeListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    meetingChanged(meeting) {
      if (!meeting)
        return;
      this.canDisable = !!(meeting === null || meeting === undefined ? undefined : meeting.self.permissions.canDisableParticipantAudio);
      meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    render() {
      if (!this.canDisable) {
        return null;
      }
      const label = this.t('mute_all');
      return (h(Host, { title: label }, h("dyte-tooltip", { kind: "block", label: label, part: "tooltip" }, h("dyte-controlbar-button", { part: "controlbar-button", icon: this.iconPack.speaker_off, label: label, size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, onClick: this.onMuteAll }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteMuteAllButton.style = dyteMuteAllButtonCss;

  var dyteMuteAllButton_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_mute_all_button: DyteMuteAllButton
  });

  const dyteMuteAllConfirmationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;-webkit-user-select:none;-moz-user-select:none;user-select:none}.leave-modal{position:relative;display:flex;flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));padding:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.leave-modal .header h2{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}.leave-modal .content{font-size:14px}.leave-message p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px)}.leave-meeting{display:flex;flex-direction:row;justify-content:space-between;gap:var(--dyte-space-2, 8px)}.leave-meeting dyte-button{flex:1 1 0%}.end-meeting{margin-top:var(--dyte-space-2, 8px)}.message{margin-bottom:var(--dyte-space-4, 16px)}label{display:flex;align-items:center}input[type='checkbox']{margin-right:var(--dyte-space-2, 8px);accent-color:rgb(var(--dyte-colors-brand-500, 33 96 253))}";

  const DyteMuteAllConfirmation = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.onClose = () => {
        this.stateUpdate.emit({ activeMuteAllConfirmation: false });
        state.activeMuteAllConfirmation = false;
      };
      this.onMuteAll = () => {
        var _a;
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.participants.disableAllAudio(this.allowUnmute);
        this.onClose();
      };
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.allowUnmute = true;
    }
    render() {
      return (h(Host, null, h("div", { class: "leave-modal" }, h("div", { class: "header" }, h("h2", { class: "title" }, this.t('mute_all.header'))), h("p", { class: "message" }, this.t('mute_all.description')), h("div", { class: "content" }, h("div", { class: "leave-meeting" }, h("dyte-button", { variant: "secondary", title: this.t('close'), onClick: this.onClose, iconPack: this.iconPack, t: this.t }, this.t('cancel')), h("dyte-button", { variant: "danger", title: this.t('mute_all'), onClick: this.onMuteAll, iconPack: this.iconPack, t: this.t }, this.t('mute_all')))))));
    }
  };
  DyteMuteAllConfirmation.style = dyteMuteAllConfirmationCss;

  var dyteMuteAllConfirmation_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_mute_all_confirmation: DyteMuteAllConfirmation
  });

  const dyteNetworkIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block;height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}dyte-icon{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:10;height:100%;width:100%;--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}dyte-icon.good{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}dyte-icon.poor{--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}dyte-icon.poorest{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([size='md']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}.bg-signal{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);z-index:0;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}";

  const DyteNetworkIndicator = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onMediaScoreUpdate = ({ kind, isScreenshare, score }) => {
        if (kind === 'video' || (this.isScreenShare && isScreenshare)) {
          this.score = score;
        }
      };
      this.participant = undefined;
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isScreenShare = false;
      this.score = 10;
    }
    connectedCallback() {
      this.participantChanged(this.participant);
    }
    participantChanged(participant) {
      if (!participant)
        return;
      participant.addListener('mediaScoreUpdate', this.onMediaScoreUpdate);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.participant) === null || _a === undefined ? undefined : _a.removeListener('mediaScoreUpdate', this.onMediaScoreUpdate);
    }
    render() {
      let signal_strength = Math.round(this.score / 2);
      let signal_status = 'good';
      // make sure signal strength is within bounds [1,3]
      // do not show if it is good
      if (signal_strength > 3) {
        return null;
      }
      else if (signal_strength < 1) {
        signal_strength = 1;
      }
      switch (signal_strength) {
        case 3:
        case 2:
          signal_status = 'poor';
          break;
        case 1:
          signal_status = 'poorest';
      }
      return (h(Host, null, h("dyte-icon", { icon: this.iconPack[`signal_${signal_strength}`], class: signal_status }), h("dyte-icon", { icon: this.iconPack.signal_5, class: "bg-signal" })));
    }
    static get watchers() { return {
      "participant": ["participantChanged"]
    }; }
  };
  DyteNetworkIndicator.style = dyteNetworkIndicatorCss;

  var dyteNetworkIndicator_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_network_indicator: DyteNetworkIndicator
  });

  const dyteParticipantCountCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;height:var(--dyte-space-10, 40px);-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

  const DyteParticipantCount = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.disconnectMeeting = (meeting) => {
        if (meeting != null && this.countListener != null) {
          meeting.participants.joined.removeListener('participantJoined', this.countListener);
          meeting.participants.joined.removeListener('participantLeft', this.countListener);
          (meeting === null || meeting === undefined ? undefined : meeting.stage) &&
            this.stageUpdateListener &&
            meeting.stage.removeListener('stageStatusUpdate', this.stageUpdateListener);
          meeting.self.removeListener('roomJoined', this.countListener);
        }
      };
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
      this.participantCount = 0;
      this.isViewer = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.disconnectMeeting(this.meeting);
    }
    meetingChanged(meeting, oldMeeting) {
      this.disconnectMeeting(oldMeeting);
      if (meeting != null) {
        this.countListener = () => {
          this.participantCount =
            meeting.participants.joined.size + (meeting.self.roomJoined ? 1 : 0);
        };
        this.countListener();
        this.isViewer = isLiveStreamViewer(this.meeting);
        meeting.participants.joined.addListener('participantJoined', this.countListener);
        meeting.participants.joined.addListener('participantLeft', this.countListener);
        if (meeting === null || meeting === undefined ? undefined : meeting.stage) {
          this.stageUpdateListener = () => {
            this.isViewer = isLiveStreamViewer(this.meeting);
          };
          meeting === null || meeting === undefined ? undefined : meeting.stage.addListener('stageStatusUpdate', this.stageUpdateListener);
        }
        meeting.self.addListener('roomJoined', this.countListener);
      }
    }
    render() {
      if (this.isViewer)
        return null;
      return (h(Host, { tabIndex: 0, role: "log", "aria-label": `${this.participantCount} ${this.t('participants')}` }, h("dyte-icon", { icon: this.iconPack.people, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t }), this.participantCount));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteParticipantCount.style = dyteParticipantCountCss;

  var dyteParticipantCount_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participant_count: DyteParticipantCount
  });

  const dyteParticipantSetupCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;align-items:center;justify-content:center;aspect-ratio:16 / 9;height:var(--dyte-space-56, 224px);overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));transition-property:var(--dyte-transition-property, all);transition-duration:150ms}@media (prefers-reduced-motion){:host{--dyte-transition-property:none}}:host([size='sm'][variant='solid']) ::slotted(dyte-name-tag){left:var(--dyte-space-2, 8px);bottom:var(--dyte-space-2, 8px);height:var(--dyte-space-4, 16px)}video{display:none;position:absolute;height:100%;width:100%;border-radius:var(--dyte-border-radius-lg, 12px)}video.contain{-o-object-fit:contain;object-fit:contain}video.cover{-o-object-fit:cover;object-fit:cover}video.visible{display:block}video::-webkit-media-controls{display:none !important}:host([variant='gradient']) ::slotted(dyte-audio-visualizer){position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px)}:host([variant='gradient']) ::slotted(dyte-name-tag){bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);display:flex;width:100%;align-items:center;justify-content:center;text-align:center;background-color:transparent;background-image:linear-gradient(to top, var(--tw-gradient-stops));--tw-gradient-from:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-gradient-to:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to);--tw-gradient-to:transparent}video.mirror{transform:scaleX(-1)}@media (orientation: portrait){:host{height:var(--dyte-space-44, 176px)}}";

  const DyteParticipantSetup = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onVideoUpdate = (videoState) => {
        this.videoState = videoState;
      };
      this.videoState = undefined;
      this.isPinned = false;
      this.nameTagPosition = 'bottom-left';
      this.isPreview = false;
      this.participant = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.variant = 'solid';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      // set videoState before initial render and initialize listeners
      this.participantsChanged(this.participant);
    }
    componentDidLoad() {
      // load videoState into video element after first render
      this.videoStateChanged(this.videoState);
    }
    disconnectedCallback() {
      if (this.participant == null)
        return;
      this.participant.removeListener('videoUpdate', this.onVideoUpdate);
    }
    async participantsChanged(participant) {
      if (participant != null) {
        this.videoState = {
          videoEnabled: participant.videoEnabled,
          videoTrack: participant.videoTrack,
        };
        this.isPinned = participant.isPinned;
        participant.addListener('videoUpdate', this.onVideoUpdate);
      }
    }
    videoStateChanged(videoState) {
      if (videoState != null && this.videoEl != null) {
        if (videoState.videoEnabled) {
          const stream = new MediaStream();
          stream.addTrack(videoState.videoTrack);
          this.videoEl.srcObject = stream;
        }
        else {
          this.videoEl.srcObject = undefined;
        }
      }
    }
    isMirrored() {
      var _a;
      if (this.participant != null) {
        const isSelf = 'preview' in this.participant || this.isPreview;
        if (isSelf) {
          const states = this.states || state;
          const mirrorVideo = (_a = states === null || states === undefined ? undefined : states.prefs) === null || _a === undefined ? undefined : _a.mirrorVideo;
          if (typeof mirrorVideo === 'boolean') {
            return mirrorVideo;
          }
        }
      }
      return false;
    }
    render() {
      var _a, _b, _c, _d;
      return (h(Host, null, h("video", { ref: (el) => (this.videoEl = el), class: {
          visible: (_a = this.videoState) === null || _a === undefined ? undefined : _a.videoEnabled,
          mirror: this.isMirrored(),
          [(_d = (_c = (_b = this.config) === null || _b === undefined ? undefined : _b.config) === null || _c === undefined ? undefined : _c.videoFit) !== null && _d !== undefined ? _d : 'cover']: true,
        }, autoPlay: true, playsInline: true, muted: true }), h("slot", null)));
    }
    static get watchers() { return {
      "participant": ["participantsChanged"],
      "videoState": ["videoStateChanged"]
    }; }
  };
  DyteParticipantSetup.style = dyteParticipantSetupCss;

  var dyteParticipantSetup_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participant_setup: DyteParticipantSetup
  });

  const dyteParticipantsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;height:100%;width:100%;flex-direction:column;font-size:14px}*{box-sizing:border-box}.ctr{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);box-sizing:border-box;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);overflow-y:auto;flex-grow:1;flex-basis:0}.ctr.virtualised{overflow-y:hidden}.search{position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));margin-left:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-3, 12px);margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px)}.search dyte-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search input{box-sizing:border-box;height:var(--dyte-space-9, 36px);width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}:host([size='md']) .search{margin-top:var(--dyte-space-4, 16px) !important;margin-bottom:var(--dyte-space-4, 16px) !important}:host([size='sm']) .search{margin-top:var(--dyte-space-4, 16px) !important;margin-bottom:var(--dyte-space-4, 16px) !important}.no-pending-requests{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}";

  const DyteParticipants$1 = class DyteParticipants {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.updateParticipantCountsInTabs = debounce(() => {
        var _a;
        // totalRequests consist of stage requests & waitlisted ones
        let totalRequests = ((_a = this.meeting.participants.waitlisted) === null || _a === undefined ? undefined : _a.size) || 0;
        let totalOnStage = 0;
        let totalViewers = 0;
        this.meeting.participants.joined.toArray().forEach((participant) => {
          if (participant.stageStatus === 'ON_STAGE') {
            totalOnStage++;
          }
          if (participant.stageStatus === 'OFF_STAGE') {
            totalViewers++;
          }
          if (participant.stageStatus === 'REQUESTED_TO_JOIN_STAGE') {
            totalRequests++;
            totalViewers++;
          }
          if (participant.stageStatus === 'ACCEPTED_TO_JOIN_STAGE') {
            totalViewers++;
          }
        });
        if (this.meeting.self.stageStatus === 'ON_STAGE') {
          totalOnStage++;
        }
        if (this.meeting.self.stageStatus === 'OFF_STAGE') {
          totalViewers++;
        }
        if (this.meeting.self.stageStatus === 'REQUESTED_TO_JOIN_STAGE') {
          totalRequests++;
          totalViewers++;
        }
        if (this.meeting.self.stageStatus === 'ACCEPTED_TO_JOIN_STAGE') {
          totalViewers++;
        }
        const tabs = [];
        if (this.shouldShowRequestsTab()) {
          tabs.push({
            id: 'requests',
            name: (h("span", null, this.t('requests'), "\u00A0", h("span", { class: `tab-participant-count-badge ${totalRequests > 0 ? 'requests-pending' : ''} ${this.currentParticipantsTabId === 'requests' ? 'selected-tab' : ''}` }, totalRequests))),
          });
        }
        tabs.push({
          id: 'stage-list',
          name: (h("span", null, this.t('participants'), "\u00A0", h("span", { class: `tab-participant-count-badge ${this.currentParticipantsTabId === 'stage-list' ? 'selected-tab' : ''}` }, totalOnStage))),
        });
        if (this.shouldShowViewersTab()) {
          tabs.push({
            id: 'viewer-list',
            name: (h("span", null, this.t('viewers'), "\u00A0", h("span", { class: `tab-participant-count-badge ${this.currentParticipantsTabId === 'viewer-list' ? 'selected-tab' : ''}` }, totalViewers))),
          });
        }
        this.tabs = tabs;
        this.hasRequests = totalRequests > 0;
      });
      this.onSearchInput = (e) => {
        this.search = e.target.value;
      };
      this.shouldShowViewersTab = () => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions) === null || _c === undefined ? undefined : _c.stageEnabled;
      };
      this.shouldShowRequestsTab = () => {
        var _a;
        let shouldShowWaitlist = false;
        if (this.meeting.meta.viewType === 'LIVESTREAM') {
          shouldShowWaitlist = false;
        }
        else {
          shouldShowWaitlist =
            ((_a = this.meeting.self.config.waitingRoom) === null || _a === undefined ? undefined : _a.isEnabled) &&
              this.meeting.self.permissions.acceptWaitingRequests;
        }
        return ((this.meeting.self.permissions.stageEnabled &&
          this.meeting.self.permissions.acceptStageRequests) ||
          shouldShowWaitlist);
      };
      this.viewSection = (section) => {
        this.currentParticipantsTabId = section;
      };
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.defaultParticipantsTabId = 'stage-list';
      this.t = useLanguage();
      this.currentParticipantsTabId = this.defaultParticipantsTabId;
      this.tabs = [];
      this.hasRequests = false;
      this.search = '';
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (this.meeting == null)
        return;
      this.meeting.participants.joined.off('participantJoined', this.updateParticipantCountsInTabs);
      this.meeting.participants.joined.off('participantsUpdate', this.updateParticipantCountsInTabs);
      this.meeting.participants.joined.off('participantLeft', this.updateParticipantCountsInTabs);
      this.meeting.participants.joined.off('stageStatusUpdate', this.updateParticipantCountsInTabs);
      this.meeting.stage.off('stageStatusUpdate', this.updateParticipantCountsInTabs);
      this.meeting.participants.waitlisted.off('participantJoined', this.updateParticipantCountsInTabs);
      this.meeting.participants.waitlisted.off('participantLeft', this.updateParticipantCountsInTabs);
      this.meeting.participants.waitlisted.off('stageStatusUpdate', this.updateParticipantCountsInTabs);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      meeting.participants.joined.on('participantJoined', this.updateParticipantCountsInTabs);
      meeting.participants.joined.on('participantsUpdate', this.updateParticipantCountsInTabs);
      meeting.participants.joined.on('participantLeft', this.updateParticipantCountsInTabs);
      meeting.participants.joined.on('stageStatusUpdate', this.updateParticipantCountsInTabs);
      meeting.stage.on('stageStatusUpdate', this.updateParticipantCountsInTabs);
      meeting.participants.waitlisted.on('participantJoined', this.updateParticipantCountsInTabs);
      meeting.participants.waitlisted.on('participantLeft', this.updateParticipantCountsInTabs);
      meeting.participants.waitlisted.on('stageStatusUpdate', this.updateParticipantCountsInTabs);
      this.updateParticipantCountsInTabs();
    }
    currentParticipantsTabIdChanged() {
      state.participantsTabId = this.currentParticipantsTabId;
      this.stateUpdate.emit({
        participantsTabId: this.currentParticipantsTabId,
      });
      this.updateParticipantCountsInTabs();
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        config: this.config,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon", iconPack: this.iconPack, t: this.t }), h("input", { type: "search", autocomplete: "off", placeholder: this.t('search'), onInput: this.onSearchInput, part: "search-input" })), h("slot", { name: "start" }), h("div", { class: `ctr scrollbar ${this.currentParticipantsTabId !== 'requests' ? 'virtualised' : ''}`, part: "container" }, h("dyte-sidebar-ui", { tabs: this.tabs, currentTab: this.currentParticipantsTabId, view: "full-screen", hideHeader: true, hideCloseAction: true, style: { position: 'relative' }, onTabChange: (e) => {
          this.viewSection(e.detail);
          e.stopPropagation();
        } }, (!this.currentParticipantsTabId || this.currentParticipantsTabId === 'stage-list') && (h("div", { slot: "stage-list", style: { marginTop: '10px', height: '100%' } }, h(Render, { element: "dyte-participants-stage-list", defaults: defaults, props: {
          search: this.search,
          hideHeader: true,
        } }))), this.currentParticipantsTabId === 'requests' && (h("div", { slot: "requests", style: { marginTop: '10px', height: '100%' } }, !this.hasRequests && (h("div", { class: "no-pending-requests" }, this.t('participants.no_pending_requests'))), h(Render, { element: "dyte-participants-stage-queue", defaults: defaults }), h(Render, { element: "dyte-participants-waiting-list", defaults: defaults }))), this.currentParticipantsTabId === 'viewer-list' && (h("div", { slot: "viewer-list", style: { marginTop: '10px', height: '100%' } }, h(Render, { element: "dyte-participants-viewer-list", defaults: defaults, props: {
          search: this.search,
          hideHeader: true,
        } }))))), h("slot", { name: "end" })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "currentParticipantsTabId": ["currentParticipantsTabIdChanged"]
    }; }
  };
  DyteParticipants$1.style = dyteParticipantsCss;

  var dyteParticipants_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants: DyteParticipants$1
  });

  const logger = console;

  /**
   * Handles audio from participants in a meeting
   */
  class DyteAudio {
    constructor(meeting, audio) {
      this.meeting = meeting;
      this.audio = audio !== null && audio !== undefined ? audio : document.createElement('audio');
      this.audio.autoplay = true;
      this.audioStream = new MediaStream();
      this.audio.srcObject = this.audioStream;
      this.audioTracks = [];
    }
    addTrack(id, track) {
      if (!this.audioTracks.some((a) => a.id === id)) {
        this.audioTracks.push({ id, track });
        this.audioStream.addTrack(track);
        this.play();
      }
    }
    removeTrack(id) {
      const track = this.audioTracks.find((a) => a.id === id);
      if (track != null) {
        this.audioStream.removeTrack(track.track);
        this.audioTracks = this.audioTracks.filter((a) => a.id !== id);
      }
    }
    async play() {
      var _a;
      this.audio.srcObject = this.audioStream;
      await ((_a = this.audio.play()) === null || _a === undefined ? undefined : _a.catch((err) => {
        if (err.name === 'NotAllowedError') {
          if (this._onError != null) {
            this._onError();
          }
        }
        else if (err.name !== 'AbortError') {
          logger.error('[dyte-audio] play() error\n', err);
        }
      }));
    }
    async setDevice(id) {
      var _a, _b, _c;
      if (disableSettingSinkId(this.meeting))
        return;
      await ((_c = (_b = (_a = this.audio).setSinkId) === null || _b === undefined ? undefined : _b.call(_a, id)) === null || _c === undefined ? undefined : _c.catch((err) => {
        logger.error('[dyte-audio] setSinkId() error\n', err);
      }));
    }
    onError(onError) {
      this._onError = onError;
    }
  }

  const dyteParticipantsAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;overflow-wrap:break-word;color:rgb(var(--dyte-colors-text-1000, 255 255 255));word-wrap:break-word}.modal{box-sizing:border-box;width:100%;max-width:var(--dyte-space-96, 384px);padding:var(--dyte-space-4, 16px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.modal h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:24px;font-weight:500}.modal p{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-6, 24px)}.modal dyte-button{width:100%}";

  const DyteParticipantsAudio = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dialogClose = createEvent(this, "dialogClose", 7);
      this.onDyteDialogClose = () => {
        this.showPlayDialog = false;
        this.dialogClose.emit();
      };
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.preloadedAudioElem = undefined;
      this.showPlayDialog = false;
    }
    componentDidLoad() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      if (this.meeting == null)
        return;
      this.audioUpdateListener &&
        this.meeting.participants.joined.removeListener('audioUpdate', this.audioUpdateListener);
      this.screenShareUpdateListener &&
        this.meeting.participants.joined.removeListener('screenShareUpdate', this.screenShareUpdateListener);
      this.participantLeftListener &&
        this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
      this.deviceUpdateListener &&
        this.meeting.self.removeListener('deviceUpdate', this.deviceUpdateListener);
      this.stageStatusUpdateListener &&
        ((_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.removeListener('stageStatusUpdate', this.stageStatusUpdateListener));
    }
    async setupAudio() {
      this.audio = new DyteAudio(this.meeting, this.preloadedAudioElem);
      // Set the device to the current speaker device
      const currentDevices = this.meeting.self.getCurrentDevices();
      if (currentDevices.speaker != null) {
        await this.audio.setDevice(currentDevices.speaker.deviceId);
      }
    }
    async handleAutoPlayError() {
      if (!this.audio) {
        await this.setupAudio();
      }
      this.audio.onError(() => {
        this.showPlayDialog = true;
      });
      this.audio.play();
      return;
    }
    async handleEvents(meeting) {
      this.audioUpdateListener = ({ id, audioEnabled, audioTrack }) => {
        const audioId = `audio-${id}`;
        if (audioEnabled && audioTrack != null) {
          this.audio.addTrack(audioId, audioTrack);
        }
        else {
          this.audio.removeTrack(audioId);
        }
      };
      const participants = meeting.participants.joined.toArray();
      for (const participant of participants) {
        this.audioUpdateListener(participant);
      }
      this.participantLeftListener = ({ id }) => {
        this.audio.removeTrack(`audio-${id}`);
        this.audio.removeTrack(`screenshare-${id}`);
      };
      this.screenShareUpdateListener = ({ id, screenShareEnabled, screenShareTracks }) => {
        const audioId = `screenshare-${id}`;
        if (screenShareEnabled && screenShareTracks.audio != null) {
          this.audio.addTrack(audioId, screenShareTracks.audio);
        }
        else {
          this.audio.removeTrack(audioId);
        }
      };
      this.deviceUpdateListener = ({ device, preview }) => {
        if (preview)
          return;
        if (device.kind === 'audiooutput') {
          this.audio.setDevice(device.deviceId);
        }
      };
      meeting.participants.joined.addListener('audioUpdate', this.audioUpdateListener);
      meeting.participants.joined.addListener('screenShareUpdate', this.screenShareUpdateListener);
      meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
      meeting.self.addListener('deviceUpdate', this.deviceUpdateListener);
    }
    async meetingChanged(meeting) {
      var _a;
      if (meeting == null)
        return;
      this.setupAudio();
      if (isLiveStreamViewer(meeting)) {
        this.stageStatusUpdateListener = async (status) => {
          if (status === 'ON_STAGE') {
            // NOTE(@madhugb): When someone joins stage handle autoplay and also handle events
            await this.handleAutoPlayError();
          }
        };
        (_a = meeting.stage) === null || _a === undefined ? undefined : _a.on('stageStatusUpdate', this.stageStatusUpdateListener);
      }
      else {
        await this.handleAutoPlayError();
      }
      await this.handleEvents(meeting);
    }
    render() {
      return (h(Host, null, this.showPlayDialog && (h("dyte-dialog", { open: true, onDyteDialogClose: this.onDyteDialogClose, hideCloseButton: true, disableEscapeKey: true, iconPack: this.iconPack, t: this.t }, h("div", { class: "modal" }, h("h3", null, this.t('audio_playback.title')), h("p", null, this.t('audio_playback.description')), h("dyte-button", { kind: "wide", onClick: () => {
          this.audio.play();
          this.onDyteDialogClose();
        }, title: this.t('audio_playback'), iconPack: this.iconPack, t: this.t }, this.t('audio_playback')))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteParticipantsAudio.style = dyteParticipantsAudioCss;

  var dyteParticipantsAudio_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_audio: DyteParticipantsAudio
  });

  const dyteParticipantsStageListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:100%;flex-direction:column;font-size:14px}.participants-container{margin-bottom:var(--dyte-space-4, 16px);height:100%;width:100%}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.empty-stage-list{margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}dyte-participant{width:100%}";

  const DyteParticipants = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.createParticipantNode = (participant) => {
        const defaults = {
          meeting: this.meeting,
          view: this.view,
          t: this.t,
          config: this.config,
          states: state,
          size: this.size,
          iconPack: this.iconPack,
        };
        return (h("div", null, h(Render, { element: "dyte-participant", defaults: defaults, props: { role: 'listitem', participant, key: participant.id }, childProps: Object.assign(Object.assign({}, defaults), { participant, size: this.size }), deepProps: true })));
      };
      this.updateStageList = () => {
        this.getParticipants(this.search);
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.hideHeader = false;
      this.iconPack = defaultIconPack;
      this.view = 'sidebar';
      this.t = useLanguage();
      this.search = '';
      this.participants = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.searchChanged(this.search);
    }
    disconnectedCallback() {
      const { participants, stage } = this.meeting;
      if (this.meeting == null)
        return;
      this.participantJoinedListener &&
        this.meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
      this.participantLeftListener &&
        this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
      participants.joined.removeListener('stageStatusUpdate', this.updateStageList);
      stage === null || stage === undefined ? undefined : stage.removeListener('stageStatusUpdate', this.updateStageList);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      this.participantJoinedListener = (participant) => {
        if (participant.stageStatus !== 'ON_STAGE')
          return;
        // Do not append if participant name or id does not match search query
        const lowerCaseSearch = this.search.toLowerCase();
        if (!participant.name.toLowerCase().includes(lowerCaseSearch) ||
          !participant.id.toLowerCase().includes(lowerCaseSearch))
          return;
        this.participants = [
          ...this.participants.filter((p) => p.id !== participant.id),
          participant,
        ];
      };
      this.participantLeftListener = (participant) => {
        this.participants = this.participants.filter((p) => p.id !== participant.id);
      };
      meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
      meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
      this.updateStageList();
      meeting === null || meeting === undefined ? undefined : meeting.participants.joined.on('stageStatusUpdate', this.updateStageList);
      meeting === null || meeting === undefined ? undefined : meeting.stage.on('stageStatusUpdate', this.updateStageList);
    }
    searchChanged(search) {
      this.getParticipants(search);
    }
    getParticipants(search = this.search) {
      let list = this.meeting.stage.status === 'ON_STAGE' ? [this.meeting.self] : [];
      list = [
        ...list,
        ...this.meeting.participants.joined.toArray().filter((p) => p.stageStatus === 'ON_STAGE'),
      ];
      if (search === '')
        this.participants = list;
      else {
        this.participants = list.filter((p) => { var _a; return ((_a = p.name) !== null && _a !== undefined ? _a : p.id).toLowerCase().includes(search.toLowerCase()); });
      }
    }
    render() {
      return (h(Host, null, h("div", { class: "participants-container" }, !this.hideHeader && (h("div", { class: "heading-count", part: "heading-count" }, this.t('participants'), " (", this.participants.length, ")")), h("dyte-virtualized-participant-list", { items: this.participants, renderItem: this.createParticipantNode, part: "participants", class: "participants", emptyListElement: h("div", { class: "empty-stage-list" }, this.search.length > 0 ? this.t('search.could_not_find') : this.t('search.empty')) }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "search": ["searchChanged"]
    }; }
  };
  DyteParticipants.style = dyteParticipantsStageListCss;

  var dyteParticipantsStageList_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_stage_list: DyteParticipants
  });

  const dyteParticipantsStageQueueCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-top:var(--dyte-space-2, 8px);display:flex;width:100%;flex-direction:column;font-size:14px}.stage-requested-participants{margin-bottom:var(--dyte-space-8, 32px)}.stage-requested-participants .bulk-actions{display:flex;gap:var(--dyte-space-2, 8px)}.stage-requested-participants .bulk-actions .accept-all-button{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.stage-requested-participants .bulk-actions dyte-button{flex:1 1 0%}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.waiting-participant{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;align-items:center}.waiting-participant .participant-details{margin-right:auto;display:flex;align-items:center}.waiting-participant .participant-details dyte-avatar{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);flex-shrink:0;font-size:14px}.waiting-participant .participant-details .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}@media (min-width: 1080px){.waiting-participant .participant-details .name{max-width:var(--dyte-space-40, 160px)}}.waiting-participant .waitlist-controls{display:flex}.waiting-participant .waitlist-controls dyte-button{margin-left:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}.waiting-participant .waitlist-controls dyte-icon.accept{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.waiting-participant .waitlist-controls dyte-icon.deny{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DyteParticipantsStaged = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.updateStageRequestedParticipants = () => {
        this.stageRequestedParticipants = this.meeting.participants.joined
          .toArray()
          .filter((p) => p.stageStatus === 'REQUESTED_TO_JOIN_STAGE');
      };
      this.acceptStageRequest = async (p) => {
        const { userId } = p;
        await this.meeting.stage.grantAccess([userId]);
        this.updateStageRequestedParticipants();
      };
      this.rejectStageRequest = async (p) => {
        const { userId } = p;
        await this.meeting.stage.denyAccess([userId]);
        this.updateStageRequestedParticipants();
      };
      this.acceptAllStageRequest = async () => {
        await this.meeting.stage.grantAccess(this.stageRequestedParticipants.map((p) => p.userId));
        this.updateStageRequestedParticipants();
      };
      this.denyAllStageRequest = async () => {
        var _a;
        await ((_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.denyAccess(this.stageRequestedParticipants.map((p) => p.userId)));
        this.updateStageRequestedParticipants();
      };
      this.shouldShowStageRequests = () => {
        return (this.meeting.self.permissions.stageEnabled &&
          this.meeting.self.permissions.acceptStageRequests &&
          this.stageRequestedParticipants.length > 0);
      };
      this.updateRequestList = async (stageRequests) => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.meeting.self.permissions.acceptStageRequests ||
          !this.meeting.self.permissions.stageEnabled) {
          this.stageRequestedParticipants = [];
          return;
        }
        if (this.meeting.meta.viewType === 'LIVESTREAM' ||
          ((_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions) === null || _c === undefined ? undefined : _c.mediaRoomType) === 'HIVE') {
          if (!stageRequests) {
            stageRequests = (_f = (_e = (await ((_d = this.meeting.stage) === null || _d === undefined ? undefined : _d.getAccessRequests()))) === null || _e === undefined ? undefined : _e.stageRequests) !== null && _f !== undefined ? _f : [];
          }
          /**
           * NOTE(ishita1805): Temporarily mapping `displayName` to `name` till socket service sends the correct key.
           */
          this.stageRequestedParticipants = stageRequests.map((p) => {
            return Object.assign(Object.assign({}, p), { name: p.displayName });
          });
        }
        else {
          this.stageRequestedParticipants = (_g = [
            this.meeting.self,
            ...this.meeting.participants.joined.toArray(),
          ]) === null || _g === undefined ? undefined : _g.filter((p) => p.stageStatus === 'REQUESTED_TO_JOIN_STAGE');
        }
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.view = 'sidebar';
      this.t = useLanguage();
      this.stageRequestedParticipants = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      const { stage } = this.meeting;
      stage === null || stage === undefined ? undefined : stage.removeListener('stageAccessRequestUpdate', this.updateRequestList);
    }
    meetingChanged(meeting) {
      var _a;
      if (meeting == null)
        return;
      this.updateRequestList();
      (_a = meeting.stage) === null || _a === undefined ? undefined : _a.on('stageAccessRequestUpdate', this.updateRequestList);
    }
    render() {
      if (this.view !== 'sidebar' || !this.shouldShowStageRequests())
        return;
      return (h("div", { class: "stage-requested-participants" }, h("div", { class: "heading-count", part: "staged-heading-count" }, this.t('stage_request.header_title'), " (", this.stageRequestedParticipants.length, ")"), h("ul", { class: "participants", part: "staged-participants" }, this.stageRequestedParticipants.map((participant) => (h("li", { class: "waiting-participant", key: participant.id }, h("div", { class: "participant-details" }, h("dyte-avatar", { participant: participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: participant.name }, participant.name)), h("div", { class: "waitlist-controls" }, h("dyte-tooltip", { label: this.t('stage_request.deny_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", onClick: () => this.rejectStageRequest(participant), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { class: "deny", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("dyte-tooltip", { label: this.t('stage_request.accept_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.acceptStageRequest(participant) }, h("dyte-icon", { class: "accept", icon: this.iconPack.checkmark })))))))), h("div", { class: "bulk-actions" }, h("dyte-button", { class: "accept-all-button", variant: "secondary", iconPack: this.iconPack, t: this.t, onClick: this.acceptAllStageRequest }, this.t('stage_request.accept_all')), h("dyte-button", { class: "deny-all-button", variant: "danger", iconPack: this.iconPack, t: this.t, onClick: this.denyAllStageRequest }, this.t('stage_request.deny_all')))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteParticipantsStaged.style = dyteParticipantsStageQueueCss;

  var dyteParticipantsStageQueue_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_stage_queue: DyteParticipantsStaged
  });

  const dyteParticipantsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.waiting-participants-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .waiting-participants-count{right:var(--dyte-space-4, 16px);top:auto}";

  const DyteParticipantsToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.updateStageRequests = async (stageRequests) => {
        var _a, _b, _c;
        if (!stageRequests) {
          stageRequests = (_c = (_b = (_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.getAccessRequests()) === null || _b === undefined ? undefined : _b.stageRequests) !== null && _c !== undefined ? _c : [];
        }
        this.stageRequestedParticipants = stageRequests;
        this.stageRequestedParticipants =
          this.meeting.stage.status === 'REQUESTED_TO_JOIN_STAGE'
            ? [this.meeting.self, ...stageRequests]
            : stageRequests;
        this.updateBadgeCount();
      };
      this.updateBadgeCount = () => {
        this.badgeCount = this.waitlistedParticipants.length + this.stageRequestedParticipants.length;
      };
      this.updateCanView = () => {
        this.canViewParticipants = canViewParticipants(this.meeting);
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.participantsActive = false;
      this.waitlistedParticipants = [];
      this.stageRequestedParticipants = [];
      this.badgeCount = 0;
      this.canViewParticipants = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.statesChanged(this.states);
      this.removeStateChangeListener = onChange('sidebar', () => this.statesChanged());
    }
    disconnectedCallback() {
      var _a, _b, _c;
      this.removeStateChangeListener && this.removeStateChangeListener();
      if (this.meeting == null)
        return;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', this.updateCanView);
      this.waitlistedParticipantJoinedListener &&
        this.meeting.participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
      this.waitlistedParticipantLeftListener &&
        this.meeting.participants.waitlisted.removeListener('participantLeft', this.waitlistedParticipantLeftListener);
      (_c = this.meeting.stage) === null || _c === undefined ? undefined : _c.removeListener('stageAccessRequestUpdate', this.updateStageRequests);
    }
    meetingChanged(meeting) {
      var _a;
      if (meeting == null)
        return;
      this.canViewParticipants = canViewParticipants(meeting);
      (_a = meeting === null || meeting === undefined ? undefined : meeting.stage) === null || _a === undefined ? undefined : _a.on('stageStatusUpdate', this.updateCanView);
      if (meeting.self.permissions.acceptWaitingRequests) {
        this.waitlistedParticipants = meeting.participants.waitlisted.toArray();
        this.waitlistedParticipantJoinedListener = (participant) => {
          if (!this.waitlistedParticipants.some((p) => p.id === participant.id)) {
            this.waitlistedParticipants = [...this.waitlistedParticipants, participant];
            this.updateBadgeCount();
          }
        };
        this.waitlistedParticipantLeftListener = (participant) => {
          this.waitlistedParticipants = this.waitlistedParticipants.filter((p) => p.id !== participant.id);
          this.updateBadgeCount();
        };
        meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
        meeting.participants.waitlisted.addListener('participantLeft', this.waitlistedParticipantLeftListener);
      }
      if (this.meeting.self.permissions.stageEnabled &&
        this.meeting.self.permissions.acceptStageRequests) {
        this.updateStageRequests();
        meeting === null || meeting === undefined ? undefined : meeting.stage.on('stageAccessRequestUpdate', this.updateStageRequests);
      }
      this.updateBadgeCount();
    }
    statesChanged(s) {
      const states = s || state;
      if (states != null) {
        this.participantsActive = states.activeSidebar === true && states.sidebar === 'participants';
      }
    }
    toggleParticipantsTab() {
      const states = this.states || state;
      this.participantsActive = !((states === null || states === undefined ? undefined : states.activeSidebar) && (states === null || states === undefined ? undefined : states.sidebar) === 'participants');
      state.activeSidebar = this.participantsActive;
      state.sidebar = this.participantsActive ? 'participants' : undefined;
      state.activeMoreMenu = false;
      state.activeAI = false;
      this.stateUpdate.emit({
        activeSidebar: this.participantsActive,
        sidebar: this.participantsActive ? 'participants' : undefined,
        activeMoreMenu: false,
        activeAI: false,
      });
    }
    render() {
      if (!this.canViewParticipants)
        return;
      const text = this.t('participants');
      // const badgeCount = this.waitlistedParticipants.length + this.stageRequestedParticipants.length;
      return (h(Host, { title: text }, this.badgeCount !== 0 && !this.participantsActive && (h("div", { class: "waiting-participants-count", part: "waiting-participants-count" }, h("span", null, this.badgeCount <= 100 ? this.badgeCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.participantsActive }, onClick: () => this.toggleParticipantsTab(), icon: this.iconPack.participants, label: text, variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DyteParticipantsToggle.style = dyteParticipantsToggleCss;

  var dyteParticipantsToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_toggle: DyteParticipantsToggle
  });

  const dyteParticipantsViewerListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column;font-size:14px}.list{margin-bottom:var(--dyte-space-4, 16px);display:flex;height:100%;flex-direction:column}h3,.heading-count{margin:var(--dyte-space-0, 0px);align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.empty-viewers-list{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);text-align:center;font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}";

  const DyteParticipantsViewers = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.updateStageViewers = () => {
        this.getViewers(this.search);
      };
      this.createParticipantNode = (participant) => {
        return (h("dyte-participant", { role: "listitem", key: participant.id, meeting: this.meeting, participant: participant, view: this.view, iconPack: this.iconPack, config: this.config, t: this.t }));
      };
      // TODO: (ishita1805) Remove viewtype check when we start supporting viewers in livestream.
      this.shouldShowViewers = () => {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self) === null || _b === undefined ? undefined : _b.permissions) === null || _c === undefined ? undefined : _c.stageEnabled;
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.hideHeader = false;
      this.iconPack = defaultIconPack;
      this.view = 'sidebar';
      this.search = '';
      this.t = useLanguage();
      this.stageViewers = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.searchChanged(this.search);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      this.participantJoinedListener = (participant) => {
        if (participant.stageStatus === 'ON_STAGE')
          return;
        // Do not append if participant name or id does not match search query
        const lowerCaseSearch = this.search.toLowerCase();
        if (lowerCaseSearch.length > 0 && !participant.name.toLowerCase().includes(lowerCaseSearch))
          return;
        this.stageViewers = [
          ...this.stageViewers.filter((p) => p.id !== participant.id),
          participant,
        ];
      };
      this.participantLeftListener = (participant) => {
        this.stageViewers = this.stageViewers.filter((p) => p.id !== participant.id);
      };
      meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
      meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
      meeting.participants.joined.on('stageStatusUpdate', this.updateStageViewers);
      meeting.stage.on('stageStatusUpdate', this.updateStageViewers);
    }
    searchChanged(search) {
      this.getViewers(search);
    }
    disconnectedCallback() {
      const { participants, stage } = this.meeting;
      this.participantJoinedListener &&
        this.meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
      this.participantLeftListener &&
        this.meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
      participants.joined.removeListener('stageStatusUpdate', this.updateStageViewers);
      stage.removeListener('stageStatusUpdate', this.updateStageViewers);
    }
    getViewers(search) {
      let list = this.meeting.stage.status === 'ON_STAGE' ? [] : [this.meeting.self];
      list = [...list, ...this.meeting.participants.joined.toArray()].filter((p) => p.stageStatus !== 'ON_STAGE');
      if (search === '') {
        this.stageViewers = list;
      }
      else {
        this.stageViewers = list.filter((p) => { var _a; return ((_a = p.name) !== null && _a !== undefined ? _a : p.id).toLowerCase().includes(search.toLowerCase()); });
      }
    }
    render() {
      if (this.view !== 'sidebar' || !this.shouldShowViewers())
        return;
      return (h("div", { class: "list" }, !this.hideHeader && (h("div", { class: "heading-count", part: "heading-count" }, this.t('viewers'), " (", this.stageViewers.length, ")")), h("dyte-virtualized-participant-list", { items: this.stageViewers, renderItem: this.createParticipantNode, class: "participants", part: "participants", style: { height: '100%' }, emptyListElement: h("div", { class: "empty-viewers-list" }, this.search.length > 0
          ? this.t('participants.errors.empty_results')
          : this.t('participants.empty_list')) })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "search": ["searchChanged"]
    }; }
  };
  DyteParticipantsViewers.style = dyteParticipantsViewerListCss;

  var dyteParticipantsViewerList_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_viewer_list: DyteParticipantsViewers
  });

  const dyteParticipantsWaitingListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-top:var(--dyte-space-4, 16px);margin-bottom:calc(var(--dyte-space-2, 8px) * -1);display:flex;width:100%;flex-direction:column;font-size:14px}.waiting-participants{margin-bottom:var(--dyte-space-8, 32px)}.waiting-participants .accept-all-button{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}h3,.heading-count{margin:var(--dyte-space-0, 0px);display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}.heading-count{font-size:14px}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.waiting-participant{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;align-items:center}.waiting-participant .participant-details{margin-right:auto;display:flex;align-items:center}.waiting-participant .participant-details dyte-avatar{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);flex-shrink:0;font-size:14px}.waiting-participant .participant-details .name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}@media (min-width: 1080px){.waiting-participant .participant-details .name{max-width:var(--dyte-space-40, 160px)}}.waiting-participant .waitlist-controls{display:flex}.waiting-participant .waitlist-controls dyte-button{margin-left:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}.waiting-participant .waitlist-controls dyte-icon.accept{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}.waiting-participant .waitlist-controls dyte-icon.deny{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DyteParticipantsWaitlisted = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.acceptWaitingRoomRequest = async (id) => {
        await this.meeting.participants.acceptWaitingRoomRequest(id);
      };
      this.acceptAllWaitingRoomRequests = async () => {
        await this.meeting.participants.acceptAllWaitingRoomRequest(this.waitlistedParticipants.map((p) => p.id));
      };
      this.rejectWaitingRoomRequest = async (id) => {
        await this.meeting.participants.rejectWaitingRoomRequest(id);
      };
      this.shouldShowWaitlist = () => {
        if (this.meeting.meta.viewType === 'LIVESTREAM')
          return false;
        return (this.meeting.self.permissions.acceptWaitingRequests &&
          this.waitlistedParticipants.length !== 0);
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.view = 'sidebar';
      this.t = useLanguage();
      this.waitlistedParticipants = [];
    }
    disconnectedCallback() {
      const { participants } = this.meeting;
      this.waitlistedParticipantJoinedListener &&
        participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
      this.waitlistedParticipantLeftListener &&
        participants.waitlisted.removeListener('participantLeft', this.waitlistedParticipantLeftListener);
      this.waitlistedParticipantsClearedListener &&
        participants.waitlisted.removeListener('participantsCleared', this.waitlistedParticipantsClearedListener);
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      this.waitlistedParticipants = meeting.participants.waitlisted.toArray();
      this.waitlistedParticipantJoinedListener = (participant) => {
        if (!this.waitlistedParticipants.some((p) => p.id === participant.id)) {
          this.waitlistedParticipants = [...this.waitlistedParticipants, participant];
        }
      };
      this.waitlistedParticipantLeftListener = (participant) => {
        this.waitlistedParticipants = this.waitlistedParticipants.filter((p) => p.id !== participant.id);
      };
      this.waitlistedParticipantsClearedListener = () => {
        this.waitlistedParticipants = [];
      };
      meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
      meeting.participants.waitlisted.addListener('participantLeft', this.waitlistedParticipantLeftListener);
      meeting.participants.waitlisted.addListener('participantsCleared', this.waitlistedParticipantsClearedListener);
    }
    render() {
      if (this.view !== 'sidebar' || !this.shouldShowWaitlist())
        return;
      return (h("div", { class: "waiting-participants" }, h("div", { class: "heading-count", part: "waitlisted-heading-count" }, this.t('waitlist.header_title'), " (", this.waitlistedParticipants.length, ")"), h("ul", { class: "participants", part: "waitlisted-participants" }, this.waitlistedParticipants.map((participant) => (h("li", { class: "waiting-participant", key: participant.id }, h("div", { class: "participant-details" }, h("dyte-avatar", { participant: participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: participant.name }, participant.name)), h("div", { class: "waitlist-controls" }, h("dyte-tooltip", { label: this.t('waitlist.deny_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.rejectWaitingRoomRequest(participant.id) }, h("dyte-icon", { class: "deny", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))), h("dyte-tooltip", { label: this.t('waitlist.accept_request'), variant: "secondary", iconPack: this.iconPack, t: this.t }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => this.acceptWaitingRoomRequest(participant.id) }, h("dyte-icon", { class: "accept", icon: this.iconPack.checkmark, iconPack: this.iconPack, t: this.t })))))))), h("dyte-button", { class: "accept-all-button", variant: "secondary", kind: "wide", iconPack: this.iconPack, t: this.t, onClick: this.acceptAllWaitingRoomRequests }, this.t('waitlist.accept_all'))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteParticipantsWaitlisted.style = dyteParticipantsWaitingListCss;

  var dyteParticipantsWaitingList_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participants_waiting_list: DyteParticipantsWaitlisted
  });

  const dytePermissionsMessageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:block;max-height:100%;width:600px;overflow-y:auto;padding:var(--dyte-space-6, 24px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));overflow-wrap:break-word;color:rgb(var(--dyte-colors-text-1000, 255 255 255));word-wrap:break-word}.actions{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.text-icon{display:inline-block;vertical-align:middle}h2{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-4, 16px)}h2 .text-icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-4, 16px)}.need-help-link{margin-top:var(--dyte-space-2, 8px);display:inline-block;text-underline-offset:2px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-400, 53 110 253) / var(--tw-text-opacity))}.need-help-link:hover{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-text-opacity))}a dyte-icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) .actions{flex-direction:column;align-items:flex-start;justify-content:center}:host([size='sm']) .action{width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.actions{margin-top:var(--dyte-space-6, 24px)}.actions dyte-button{flex:1 1 0%}.svg-container{display:flex;width:100%;justify-content:center !important}.svg-ins{width:80%;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))}";

  const steps = {
    'Chrome.Desktop.audio': ['Chrome1.svg', 'Chrome2.svg', 'Chrome3.svg'],
    'Chrome.Desktop.video': ['Chrome1.svg', 'Chrome2.svg', 'Chrome3.svg'],
  };
  const DytePermissionsMessage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.continue = () => {
        this.stateUpdate.emit({
          activePermissionsMessage: { enabled: false },
        });
        state.activePermissionsMessage = { enabled: false };
      };
      this.reload = () => {
        if (typeof window !== 'undefined') {
          window.location.reload();
        }
      };
      this.getImage = async (stepURL) => {
        function replaceAll(target, search, replacement) {
          return target.split(search).join(replacement);
        }
        const svgReq = await fetch(`https://assets.dyte.io/ui-kit/permissions/${stepURL}`);
        let svg = await svgReq.text();
        svg = replaceAll(svg, 'yoursite.com', location.host);
        svg = replaceAll(svg, 'Yoursite', document.title.length > 14 ? `${document.title.slice(0, 14)}...` : document.title);
        return svg;
      };
      this.nextStep = () => {
        this.currentStep = (this.currentStep + 1) % this.svgSteps.length;
      };
      this.openMacSystemSettings = () => {
        const l = document.createElement('a');
        switch (this.mediaType) {
          case 'audio':
            l.href = 'x-apple.systempreferences:com.apple.preference.security?Privacy_Microphone';
            break;
          case 'screenshare':
            l.href = 'x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture';
            break;
          case 'video':
            l.href = 'x-apple.systempreferences:com.apple.preference.security?Privacy_Camera';
            break;
        }
        l.click();
      };
      this.meeting = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.states = undefined;
      this.device = undefined;
      this.currentStep = 0;
      this.svgSteps = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (this.stepsTimer)
        clearTimeout(this.stepsTimer);
    }
    meetingChanged(meeting) {
      var _a, _b, _c;
      if (meeting != null) {
        this.device = meeting.self.device;
        const deviceType = ((_a = this.device) === null || _a === undefined ? undefined : _a.isMobile) ? 'Mobile' : 'Desktop';
        const currentSteps = (_c = steps[`${(_b = this.device) === null || _b === undefined ? undefined : _b.browserName}.${deviceType}.${this.mediaType}`]) !== null && _c !== undefined ? _c : [];
        Promise.all(currentSteps.map(this.getImage)).then((currentImages) => {
          this.svgSteps = currentImages;
        });
      }
    }
    getLink(media) {
      let kind;
      switch (media) {
        case 'audio':
          kind = 'microphone';
          break;
        case 'video':
          kind = 'camera';
          break;
        default:
          kind = 'screenshare';
          break;
      }
      const GOOGLE_SEARCH_BASE = 'https://www.google.com/search?q=';
      let query = `Allow+${kind}+access`;
      if (this.device != null) {
        const { browserName, isMobile } = this.device;
        query += '+' + browserName;
        if (isMobile) {
          query += '+mobile';
        }
      }
      return GOOGLE_SEARCH_BASE + query;
    }
    isDeniedBySystem() {
      var _a;
      const permissionsMessage = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.mediaPermissions;
      if (permissionsMessage == null)
        return false;
      if (permissionsMessage[this.mediaType] === 'SYSTEM_DENIED') {
        return true;
      }
      return false;
    }
    getTitle() {
      const isDeniedBySystem = this.isDeniedBySystem();
      if (isDeniedBySystem) {
        return this.t(`perm_sys_denied.${this.mediaType}`);
      }
      return this.t(`perm_denied.${this.mediaType}`);
    }
    get mediaType() {
      var _a, _b, _c;
      return (_c = (_b = (_a = this.states) === null || _a === undefined ? undefined : _a.activePermissionsMessage) === null || _b === undefined ? undefined : _b.kind) !== null && _c !== undefined ? _c : 'audio';
    }
    getMessage() {
      var _a;
      const { browserName, osName } = this.meeting.self.device;
      const isDeniedBySystem = this.isDeniedBySystem();
      const browser = (_a = browserName.toLowerCase()) !== null && _a !== undefined ? _a : 'others';
      const os = osName !== null && osName !== undefined ? osName : 'others';
      /* NOTE(ravindra-dyte):
        If in case a unknown browser or os doesn't have a translation,
        use the translation for `others`, instead of showing ugly error string,
        such as `perm_denied.video.yandex browser.message`.
      */
      if (isDeniedBySystem) {
        const systemErrorKey = `perm_sys_denied.${this.mediaType}.${os.toLowerCase()}.message`;
        return this.t(systemErrorKey) === systemErrorKey
          ? this.t(`perm_sys_denied.${this.mediaType}.others.message`)
          : this.t(systemErrorKey);
      }
      const browserErrorKey = `perm_denied.${this.mediaType}.${browser}.message`;
      return this.t(browserErrorKey) === browserErrorKey
        ? this.t(`perm_denied.${this.mediaType}.others.message`)
        : this.t(browserErrorKey);
    }
    render() {
      var _a, _b, _c;
      const isDeniedBySystem = this.isDeniedBySystem();
      if (this.svgSteps.length > 0) {
        if (this.stepsTimer)
          clearTimeout(this.stepsTimer);
        this.stepsTimer = setTimeout(this.nextStep, 2500);
      }
      const showMacDeepLink = isDeniedBySystem && this.meeting.self.device.osName == 'macOS';
      return (h(Host, null, h("h2", null, h("dyte-icon", { class: "text-icon", icon: this.iconPack.warning, iconPack: this.iconPack, t: this.t }), this.getTitle()), this.svgSteps.length > 0 && (h("div", { class: 'svg-container' }, this.svgSteps.map((e, index) => (h("p", { innerHTML: e, class: "svg-ins", key: this.currentStep, hidden: index !== this.currentStep }))))), h("div", null, this.getMessage()), !isDeniedBySystem && (h("a", { class: "need-help-link", href: this.getLink((_c = (_b = (_a = this.states) === null || _a === undefined ? undefined : _a.activePermissionsMessage) === null || _b === undefined ? undefined : _b.kind) !== null && _c !== undefined ? _c : 'audio'), target: "_blank", rel: "noreferrer external noreferrer noopener" }, h("dyte-icon", { class: "text-icon", icon: this.iconPack.attach, iconPack: this.iconPack, t: this.t }), this.t('cta.help'))), h("div", { class: "actions" }, h("dyte-button", { size: "lg", kind: "wide", variant: "secondary", onClick: this.continue, iconPack: this.iconPack, t: this.t }, this.t('cta.continue')), showMacDeepLink ? (h("dyte-button", { size: "lg", kind: "wide", onClick: this.openMacSystemSettings, iconPack: this.iconPack, t: this.t }, this.t('cta.system_settings'))) : (h("dyte-button", { size: "lg", kind: "wide", onClick: this.reload, iconPack: this.iconPack, t: this.t }, this.t('cta.reload')))), h("slot", null)));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DytePermissionsMessage.style = dytePermissionsMessageCss;

  var dytePermissionsMessage_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_permissions_message: DytePermissionsMessage
  });

  const dytePipToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DytePipToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.size = undefined;
      this.t = useLanguage();
      this.pipSupported = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    meetingChanged(meeting) {
      var _a, _b, _c;
      if (!meeting)
        return;
      // Check if PiP is supported and enabled
      this.pipSupported =
        ((_a = meeting.participants.pip) === null || _a === undefined ? undefined : _a.isSupported()) &&
          ((_b = meeting.self.config) === null || _b === undefined ? undefined : _b.pipMode) &&
          ((_c = meeting.self.config) === null || _c === undefined ? undefined : _c.viewType) !== 'LIVESTREAM';
    }
    togglePip() {
      if (!this.meeting.participants.pip)
        return;
      // Not active, activate
      if (this.meeting.participants.pip.isActive) {
        this.meeting.participants.pip.disable();
      }
      else {
        this.meeting.participants.pip.enable();
      }
      this.stateUpdate.emit({ activeMoreMenu: false });
      state.activeMoreMenu = false;
    }
    render() {
      if (!this.pipSupported)
        return;
      const pipEnabled = this.meeting.participants.pip.isActive;
      return (h(Host, { tabIndex: 0, role: "log", "aria-label": `Picture-in-Picture mode` }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.togglePip(), icon: pipEnabled ? this.iconPack.pip_on : this.iconPack.pip_off, label: pipEnabled ? this.t('pip_off') : this.t('pip_on'), variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DytePipToggle.style = dytePipToggleCss;

  var dytePipToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_pip_toggle: DytePipToggle
  });

  const dytePluginMainCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column;overflow:hidden;border-radius:var(--dyte-border-radius-lg, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{display:flex;height:var(--dyte-space-8, 32px);align-items:center;justify-content:space-between;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}header>div{display:flex;align-items:center}dyte-button{display:flex;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);flex-direction:column;align-items:center;border-radius:9999px}dyte-button dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px)}iframe{display:block;flex:1 1 0%;margin:var(--dyte-space-0, 0px);border-width:var(--dyte-border-width-none, 0);border-style:none;padding:var(--dyte-space-0, 0px);outline:2px solid transparent;outline-offset:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity))}.iframe-container{position:relative;height:100%;width:100%}.block-inputs{position:absolute;z-index:10;height:100%;width:100%;border-left-width:var(--dyte-border-width-none, 0);border-top-width:var(--dyte-border-width-lg, 4px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-border-opacity))}iframe{height:100%;width:100%}";

  const DytePluginMain = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.canInteractWithPlugin = () => {
        const pluginId = this.plugin.id;
        if (!pluginId)
          return true;
        /**
         * For v1 canStartPlugins is the controller
         * For v2 the controller is within plugin config
         */
        const pluginConfig = this.meeting.self.permissions.plugins
          .config[pluginId];
        /**
         * In some cases plugin config is undefined, specifically seen in cases of self
         * hosted plugins, in that case just return true
         */
        if (!pluginConfig)
          return true;
        /**
         * In V2 config currently in dev portal when a preset is saved without opening the
         * config menu then it gets added with access control undefined, to handle this case
         * the following has been done
         */
        if (!pluginConfig.accessControl)
          return true;
        /**
         * If access conrol is defined then return the permission
         */
        return pluginConfig.accessControl === 'FULL_ACCESS';
      };
      this.meeting = undefined;
      this.plugin = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.canClosePlugin = false;
      this.viewModeEnabled = false;
    }
    componentDidLoad() {
      this.meetingChanged(this.meeting);
      this.pluginChanged(this.plugin);
    }
    meetingChanged(meeting) {
      if (meeting == undefined)
        return;
      const enabled = this.canInteractWithPlugin();
      this.viewModeEnabled = !enabled;
      writeTask(() => {
        this.canClosePlugin =
          meeting.self.permissions.plugins.canClose || this.plugin.enabledBy === meeting.self.id;
      });
    }
    pluginChanged(plugin) {
      this.toggleViewModeListener = (enable) => {
        const enabled = this.canInteractWithPlugin();
        if (enabled)
          return;
        this.viewModeEnabled = enable;
      };
      if (plugin != null) {
        plugin.addPluginView(this.iframeEl, 'plugin-main');
        plugin.addListener('toggleViewMode', this.toggleViewModeListener);
      }
    }
    disconnectedCallback() {
      var _a, _b;
      (_a = this.plugin) === null || _a === undefined ? undefined : _a.removePluginView('plugin-main');
      (_b = this.plugin) === null || _b === undefined ? undefined : _b.removeListener('toggleViewMode', this.toggleViewModeListener);
    }
    render() {
      if (this.plugin == null)
        return null;
      return (h(Host, null, h("header", { part: "header" }, h("div", null, this.plugin.name), this.canClosePlugin && (h("div", null, h("dyte-button", { kind: "icon", onClick: () => this.plugin.deactivate(), part: "button", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))), h("div", { class: 'iframe-container' }, !(this.canInteractWithPlugin() || !this.viewModeEnabled) ? (h("div", { class: "block-inputs" })) : null, h("iframe", { ref: (el) => (this.iframeEl = el), part: "iframe" }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "plugin": ["pluginChanged"]
    }; }
  };
  DytePluginMain.style = dytePluginMainCss;

  var dytePluginMain_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_plugin_main: DytePluginMain
  });

  const dytePluginsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;flex-direction:column;font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}h3{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-4, 16px);display:block;padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:400;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));text-align:center}ul{overflow-y:auto;padding:var(--dyte-space-0, 0px);flex-grow:1;flex-basis:0}.metadata{display:flex;align-items:center}.metadata img{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-sm, 4px)}.metadata .name{margin-left:var(--dyte-space-2, 8px);font-weight:500}.plugin{display:flex;align-items:center;justify-content:space-between;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.plugin .buttons{display:flex;align-items:center}dyte-button:hover{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-opacity:1;--tw-ring-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-ring-opacity));--tw-ring-offset-width:2px;--tw-ring-offset-color:rgb(var(--dyte-colors-background-1000, 8 8 8))}";

  const DytePlugins = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.close = () => {
        this.stateUpdate.emit({ activeSidebar: false, sidebar: undefined });
        state.activeSidebar = false;
        state.sidebar = undefined;
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.plugins = [];
      this.canStartPlugins = false;
      this.canClosePlugins = false;
      this.activatedPluginsId = [];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.plugins.all.removeListener('stateUpdate', this.updateActivePlugins);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        this.canStartPlugins = meeting.self.permissions.plugins.canStart;
        this.canClosePlugins = meeting.self.permissions.plugins.canClose;
        this.plugins = meeting.plugins.all
          .toArray()
          .filter((plugin) => { var _a; return !((_a = meeting.self.config.disabledPlugins) === null || _a === undefined ? undefined : _a.includes(plugin.id)); });
        this.updateActivePlugins = () => {
          this.activatedPluginsId = meeting.plugins.active.toArray().map((p) => p.id);
        };
        this.updateActivePlugins();
        meeting.plugins.all.addListener('stateUpdate', this.updateActivePlugins);
      }
    }
    render() {
      return (h(Host, null, h("ul", { class: "scrollbar" }, this.plugins.map((plugin) => (h("li", { key: plugin.name, class: "plugin" }, h("div", { class: "metadata" }, h("img", { src: plugin.picture }), h("div", { class: "name" }, plugin.name)), !this.activatedPluginsId.includes(plugin.id) && this.canStartPlugins && (h("div", { class: "buttons" }, h("dyte-button", { kind: "icon", size: "lg", iconPack: this.iconPack, t: this.t, onClick: () => {
          plugin.activate();
          this.close();
        }, "aria-label": `${this.t('activate')} ${plugin.name}` }, h("dyte-icon", { icon: this.iconPack.rocket, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t })))), this.activatedPluginsId.includes(plugin.id) && this.canClosePlugins && (h("div", { class: "buttons" }, h("dyte-button", { kind: "icon", size: "lg", onClick: () => {
          plugin.deactivate();
        }, iconPack: this.iconPack, t: this.t, "aria-label": `${this.t('close')} ${plugin.name}` }, h("dyte-icon", { icon: this.iconPack.dismiss, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }))))))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DytePlugins.style = dytePluginsCss;

  var dytePlugins_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_plugins: DytePlugins
  });

  const dytePluginsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DytePluginsToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.updateCanView = () => {
        this.canViewPlugins = canViewPlugins(this.meeting);
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.pluginsActive = false;
      this.canViewPlugins = false;
    }
    disconnectedCallback() {
      var _a, _b, _c, _d;
      this.removeStateChangeListener && this.removeStateChangeListener();
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', this.updateCanView);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.self) === null || _d === undefined ? undefined : _d.permissions.removeListener('pluginsUpdate', this.updateCanView);
    }
    connectedCallback() {
      this.statesChanged(this.states);
      this.meetingChanged(this.meeting);
      this.removeStateChangeListener = onChange('sidebar', () => this.statesChanged());
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting == null)
        return;
      this.canViewPlugins = canViewPlugins(meeting);
      (_a = meeting === null || meeting === undefined ? undefined : meeting.stage) === null || _a === undefined ? undefined : _a.on('stageStatusUpdate', this.updateCanView);
      (_b = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _b === undefined ? undefined : _b.permissions.addListener('pluginsUpdate', this.updateCanView);
    }
    statesChanged(s) {
      const states = s || state;
      if (states != null) {
        this.pluginsActive = states.activeSidebar === true && states.sidebar === 'plugins';
      }
    }
    togglePlugins() {
      const states = this.states || state;
      this.pluginsActive = !((states === null || states === undefined ? undefined : states.activeSidebar) && (states === null || states === undefined ? undefined : states.sidebar) === 'plugins');
      this.stateUpdate.emit({
        activeSidebar: this.pluginsActive,
        sidebar: this.pluginsActive ? 'plugins' : undefined,
        activeMoreMenu: false,
        activeAI: false,
      });
      state.activeSidebar = this.pluginsActive;
      state.sidebar = this.pluginsActive ? 'plugins' : undefined;
      state.activeMoreMenu = false;
      state.activeAI = false;
    }
    render() {
      if (!this.canViewPlugins)
        return;
      const text = this.t('plugins');
      return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.pluginsActive }, onClick: () => this.togglePlugins(), icon: this.iconPack.rocket, label: text, variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DytePluginsToggle.style = dytePluginsToggleCss;

  var dytePluginsToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_plugins_toggle: DytePluginsToggle
  });

  const dytePollsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{margin-top:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;flex-direction:column;font-size:14px}*{box-sizing:border-box}.ctr{box-sizing:border-box;padding:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-0, 0px);display:flex;flex:1 1 0%;flex-direction:column}.polls-view{overflow-y:auto;flex:1 1 0%;flex-basis:0}.empty-polls{display:flex;height:100%;width:100%;align-items:center;justify-content:center}";

  const DytePolls$1 = class DytePolls {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onPollsUpdate = (data) => {
        this.polls = [...data.polls];
      };
      this.onUpdatePermissions = () => {
        this.permissions = this.meeting.self.permissions;
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.create = false;
      this.polls = undefined;
      this.permissions = undefined;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      if (this.meeting == null)
        return;
      (_a = this.meeting.polls) === null || _a === undefined ? undefined : _a.removeListener('pollsUpdate', this.onPollsUpdate);
      this.meeting.self.permissions.removeListener('pollsUpdate', this.onUpdatePermissions);
    }
    meetingChanged(meeting) {
      if (meeting == undefined)
        return;
      if (meeting && !meeting.polls)
        return;
      this.permissions = this.meeting.self.permissions;
      this.polls = [...meeting.polls.items];
      meeting.polls.addListener('pollsUpdate', this.onPollsUpdate);
      this.meeting.self.permissions.addListener('pollsUpdate', this.onUpdatePermissions);
      this.onCreate = async (data) => {
        this.create = false;
        await meeting.polls.create(data.question, data.options, data.anonymous, data.hideVotes);
      };
      this.onVote = async (id, index) => {
        await meeting.polls.vote(id, index);
      };
    }
    toggleCreateState() {
      this.create = !this.create;
    }
    componentDidRender() {
      smoothScrollToBottom(this.pollEl);
    }
    render() {
      return (h(Host, null, h("div", { class: "ctr", part: "container" }, h("div", { class: "polls-view scrollbar", ref: (el) => (this.pollEl = el), part: "polls" }, this.polls.length == 0 && this.create !== true && (h("div", { class: "empty-polls" }, this.t('polls.empty'))), this.polls.map((item) => {
        var _a;
        return (h("dyte-poll", { key: item.id, poll: item, onDyteVotePoll: (e) => {
            this.onVote(e.detail.id, e.detail.index);
          }, self: (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.userId, iconPack: this.iconPack, t: this.t, permissions: this.permissions }));
      }), this.create && (h("dyte-poll-form", { part: "poll-form", onDyteCreatePoll: (e) => {
          this.onCreate(e.detail);
        }, iconPack: this.iconPack, t: this.t }))), this.permissions.polls.canCreate && (h("dyte-button", { kind: "wide", onClick: () => this.toggleCreateState(), variant: this.create ? 'secondary' : 'primary', part: "button", iconPack: this.iconPack, t: this.t }, this.create ? this.t('polls.cancel') : this.t('polls.create'))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DytePolls$1.style = dytePollsCss;

  var dytePolls_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_polls: DytePolls$1
  });

  const dytePollsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block}.unread-count{position:absolute;right:var(--dyte-space-3, 12px);box-sizing:border-box;padding:var(--dyte-space-0\\.5, 2px);-webkit-user-select:none;-moz-user-select:none;user-select:none;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));display:flex;height:var(--dyte-space-5, 20px);min-width:var(--dyte-space-5, 20px);align-items:center;justify-content:center;border-radius:9999px;z-index:1}:host([variant='horizontal']){display:flex;flex-direction:row-reverse;align-items:center}:host([variant='horizontal']) .unread-count{right:var(--dyte-space-4, 16px);top:auto}";

  const DytePollsToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.onPollsUpdate = ({ newPoll }) => {
        if (newPoll === true)
          this.unreadPollsCount += 1;
      };
      this.updateCanView = () => {
        this.canViewPolls = canViewPolls(this.meeting);
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.pollsActive = false;
      this.unreadPollsCount = 0;
      this.canViewPolls = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.statesChanged(this.states);
      this.removeStateChangeListener = onChange('sidebar', () => this.statesChanged());
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f;
      this.removeStateChangeListener && this.removeStateChangeListener();
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.polls) === null || _b === undefined ? undefined : _b.removeListener('pollsUpdate', this.onPollsUpdate);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.self) === null || _d === undefined ? undefined : _d.permissions.removeListener('pollsUpdate', this.updateCanView);
      (_f = (_e = this.meeting) === null || _e === undefined ? undefined : _e.stage) === null || _f === undefined ? undefined : _f.removeListener('stageStatusUpdate', this.updateCanView);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting && meeting.polls) {
        this.unreadPollsCount = meeting.polls.items.length;
        this.meeting.polls.addListener('pollsUpdate', this.onPollsUpdate);
        (_a = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _a === undefined ? undefined : _a.permissions.addListener('pollsUpdate', this.updateCanView);
        this.canViewPolls = canViewPolls(meeting);
        (_b = meeting === null || meeting === undefined ? undefined : meeting.stage) === null || _b === undefined ? undefined : _b.on('stageStatusUpdate', this.updateCanView);
      }
    }
    statesChanged(s) {
      const states = s || state;
      if (states != null) {
        this.pollsActive = states.activeSidebar === true && states.sidebar === 'polls';
      }
    }
    togglePollsTab() {
      const states = this.states || state;
      this.unreadPollsCount = 0;
      this.pollsActive = !((states === null || states === undefined ? undefined : states.activeSidebar) && (states === null || states === undefined ? undefined : states.sidebar) === 'polls');
      this.stateUpdate.emit({
        activeSidebar: this.pollsActive,
        sidebar: this.pollsActive ? 'polls' : undefined,
        activeMoreMenu: false,
        activeAI: false,
      });
      state.activeSidebar = this.pollsActive;
      state.sidebar = this.pollsActive ? 'polls' : undefined;
      state.activeMoreMenu = false;
      state.activeAI = false;
    }
    render() {
      if (!this.canViewPolls)
        return;
      const text = this.t('polls');
      // TODO(callmetarush): Just showing polls for all V2 users irrespective of themes
      // untill we get ui theme for V2.
      return (h(Host, { title: text }, this.unreadPollsCount !== 0 && !this.pollsActive && (h("div", { class: "unread-count", part: "unread-count" }, h("span", null, this.unreadPollsCount <= 100 ? this.unreadPollsCount : '99+'))), h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, class: { active: this.pollsActive }, onClick: () => this.togglePollsTab(), icon: this.iconPack.poll, label: text, variant: this.variant })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DytePollsToggle.style = dytePollsToggleCss;

  var dytePollsToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_polls_toggle: DytePollsToggle
  });

  const dyteRecordingIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:block}:host[size='sm']{margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px)}.indicator{display:flex;flex-direction:row;align-items:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);animation:blink 4s linear infinite}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([size='sm']) .indicator span{display:none}@keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}";

  const DyteRecordingIndicator = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.setIsRecording = (recordingState) => {
        this.isRecording = recordingState === 'RECORDING';
      };
      this.meeting = undefined;
      this.size = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.isRecording = undefined;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.recording.removeListener('recordingUpdate', this.updateRecordingStatus);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        this.setIsRecording(meeting.recording.recordingState);
        this.updateRecordingStatus = (recordingState) => {
          this.setIsRecording(recordingState);
        };
        meeting.recording.addListener('recordingUpdate', this.updateRecordingStatus);
      }
    }
    render() {
      return (h(Host, null, this.isRecording && (h("div", { class: "indicator", "aria-label": this.t('recording.indicator'), part: "indicator" }, h("dyte-icon", { icon: this.iconPack.recording, "aria-hidden": true, tabIndex: -1, part: "icon", iconPack: this.iconPack, t: this.t }), h("span", null, this.t('recording.label'))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteRecordingIndicator.style = dyteRecordingIndicatorCss;

  var dyteRecordingIndicator_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_recording_indicator: DyteRecordingIndicator
  });

  const dyteRecordingToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteRecordingToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
      this.permissionsUpdateListener = () => {
        this.canRecord = this.meeting.self.permissions.canRecord === true;
      };
      this.toggleRecording = async () => {
        var _a, _b, _c;
        if (this.isLoading() || this.disabled)
          return;
        switch (this.recordingState) {
          case 'IDLE':
            try {
              await ((_a = this.meeting) === null || _a === void 0 ? void 0 : _a.recording.start());
              return;
            }
            catch (_d) {
              this.dyteAPIError.emit({
                trace: this.t('recording.start'),
                message: this.t('recording.error.start'),
              });
            }
            return;
          case 'RECORDING':
            try {
              await ((_b = this.meeting) === null || _b === void 0 ? void 0 : _b.recording.stop());
              return;
            }
            catch (_e) {
              this.dyteAPIError.emit({
                trace: this.t('recording.stop'),
                message: this.t('recording.error.stop'),
              });
            }
            return;
          case 'PAUSED':
            try {
              await ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.recording.resume());
              return;
            }
            catch (_f) {
              this.dyteAPIError.emit({
                trace: this.t('recording.resume'),
                message: this.t('recording.error.resume'),
              });
            }
            return;
          case 'STARTING':
          case 'STOPPING':
          default:
            return;
        }
      };
      this.isLoading = () => {
        return (this.meeting == null ||
          this.recordingState === 'STARTING' ||
          this.recordingState === 'STOPPING');
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.size = undefined;
      this.disabled = false;
      this.recordingState = undefined;
      this.canRecord = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b;
      this.recordingStateUpdateListener &&
        ((_a = this.meeting) === null || _a === undefined ? undefined : _a.recording.removeListener('recordingUpdate', this.recordingStateUpdateListener));
      (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        this.recordingState = meeting.recording.recordingState;
        this.permissionsUpdateListener();
        this.recordingStateUpdateListener = (recordingState) => {
          this.recordingState = recordingState;
        };
        meeting.recording.addListener('recordingUpdate', this.recordingStateUpdateListener);
        meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
      }
    }
    getLabel() {
      switch (this.recordingState) {
        case 'IDLE':
          return 'recording.idle';
        case 'RECORDING':
          return 'recording.stop';
        case 'STARTING':
          return 'recording.starting';
        case 'STOPPING':
          return 'recording.stopping';
        case 'PAUSED':
          return 'recording.resume';
        default:
          return 'recording.loading';
      }
    }
    getIcon() {
      switch (this.recordingState) {
        case 'IDLE':
          return this.iconPack.recording;
        case 'RECORDING':
          return this.iconPack.stop_recording;
        case 'STARTING':
        case 'STOPPING':
        default:
          return this.iconPack.recording;
      }
    }
    render() {
      if (!this.canRecord)
        return;
      return (h(Host, { title: this.t(this.recordingState === 'RECORDING' ? 'recording.stop' : 'recording.idle') }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: this.toggleRecording, icon: this.getIcon(), isLoading: this.isLoading(), label: this.t(this.getLabel()), variant: this.variant, disabled: this.disabled })));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteRecordingToggle.style = dyteRecordingToggleCss;

  var dyteRecordingToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_recording_toggle: DyteRecordingToggle
  });

  const dyteScreenShareToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const deviceCanScreenShare = () => {
    return (typeof navigator !== 'undefined' &&
      typeof navigator.mediaDevices !== 'undefined' &&
      'getDisplayMedia' in navigator.mediaDevices);
  };
  const DyteScreenShareToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
      this.screenShareListener = () => {
        const activeScreenShares = this.meeting.participants.active
          .toArray()
          .filter((p) => p.screenShareEnabled).length;
        const selfScreenShare = this.meeting.self.screenShareEnabled ? 1 : 0;
        this.screenShareCount = activeScreenShares + selfScreenShare;
        this.screenShareEnabled = this.meeting.self.screenShareEnabled;
        this.getState();
        this.meeting.__internals__.logger.info('dyteScreenShare::screenShareUpdate', {
          media: {
            screenshare: {
              enabled: this.screenShareEnabled,
              count: this.screenShareCount,
            },
          },
        });
      };
      this.participantLeftListener = ({ screenShareEnabled }) => {
        if (screenShareEnabled) {
          // decrement count if participant who left had screenShareEnabled
          // and don't let it go below 0 (just a failsafe)
          this.screenShareCount = Math.max(this.screenShareCount - 1, 0);
          this.getState();
          this.meeting.__internals__.logger.info('dyteScreenShare::screenShareUpdate', {
            media: {
              screenshare: {
                enabled: this.screenShareEnabled,
                count: this.screenShareCount,
              },
            },
          });
        }
      };
      this.stageStatusListener = () => {
        this.stageStatus = this.meeting.stage.status;
        this.canScreenShare = this.meeting.self.permissions.canProduceScreenshare === 'ALLOWED';
      };
      this.mediaPermissionUpdateListener = ({ kind, message }) => {
        if (kind === 'screenshare') {
          this.shareScreenPermission = message;
          this.getState();
          if (message === 'COULD_NOT_START') {
            this.dyteAPIError.emit({
              trace: this.t('screenshare.permissions'),
              message: this.t('screenshare.error.unknown'),
            });
          }
          if (this.hasPermissionError()) {
            const permissionModalSettings = {
              enabled: true,
              kind: 'screenshare',
            };
            this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
            state.activePermissionsMessage = permissionModalSettings;
          }
        }
      };
      this.reachedMaxScreenShares = () => {
        // checks if a limit exists, and if limit is reached
        return this.maxScreenShareCount > 0 && this.screenShareCount >= this.maxScreenShareCount;
      };
      this.toggleScreenShare = async () => {
        var _a;
        if (this.screenShareState.disable)
          return;
        if (this.hasPermissionError()) {
          const permissionModalSettings = {
            enabled: true,
            kind: 'screenshare',
          };
          this.stateUpdate.emit({ activePermissionsMessage: permissionModalSettings });
          state.activePermissionsMessage = permissionModalSettings;
          return false;
        }
        const self = (_a = this.meeting) === null || _a === undefined ? undefined : _a.self;
        if (this.screenShareEnabled) {
          self.disableScreenShare();
          return;
        }
        if (self == null ||
          !this.canScreenShare ||
          this.reachedMaxScreenShares() ||
          this.hasPermissionError())
          return;
        this.screenShareState = Object.assign(Object.assign({}, this.screenShareState), { disable: true });
        await self.enableScreenShare();
        this.screenShareState = Object.assign(Object.assign({}, this.screenShareState), { disable: false });
        this.stateUpdate.emit({ activeMoreMenu: false });
        state.activeMoreMenu = false;
      };
      this.states = undefined;
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.maxScreenShareCount = -1;
      this.screenShareCount = 0;
      this.screenShareEnabled = false;
      this.canScreenShare = false;
      this.shareScreenPermission = 'NOT_REQUESTED';
      this.screenShareState = {
        tooltipLabel: this.t('screenshare.start'),
        label: this.t('screenshare.start'),
        icon: this.iconPack.share_screen_start,
        classList: {},
        showWarning: false,
        disable: false,
      };
      this.stageStatus = 'OFF_STAGE';
    }
    connectedCallback() {
      if (!deviceCanScreenShare()) {
        logger.error('[dyte-screenshare-toggle] Device does not support screensharing.');
        return;
      }
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e, _f;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.participants.joined.removeListener('screenShareUpdate', this.screenShareListener);
      (_b = this.meeting) === null || _b === undefined ? undefined : _b.participants.joined.removeListener('participantLeft', this.participantLeftListener);
      (_c = this.meeting) === null || _c === undefined ? undefined : _c.self.removeListener('screenShareUpdate', this.screenShareListener);
      (_d = this.meeting) === null || _d === undefined ? undefined : _d.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      (_f = (_e = this.meeting) === null || _e === undefined ? undefined : _e.stage) === null || _f === undefined ? undefined : _f.removeListener('stageStatusUpdate', this.stageStatusListener);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        const { self, stage } = meeting;
        this.canScreenShare = this.meeting.self.permissions.canProduceScreenshare === 'ALLOWED';
        this.maxScreenShareCount = self.config.maxScreenShareCount;
        this.screenShareEnabled = self.screenShareEnabled;
        let screenShareCount = 0;
        for (const participant of meeting.participants.joined.toArray()) {
          if (participant.screenShareEnabled) {
            screenShareCount++;
          }
        }
        this.screenShareCount = screenShareCount;
        this.getState();
        meeting.__internals__.logger.info('dyteScreenShare::initialise', {
          media: {
            screenshare: {
              enabled: this.screenShareEnabled,
              count: this.screenShareCount,
              maxAllowedCount: this.maxScreenShareCount,
            },
          },
        });
        this.stageStatus = meeting.stage.status;
        meeting.participants.joined.addListener('screenShareUpdate', this.screenShareListener);
        meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
        self.addListener('screenShareUpdate', this.screenShareListener);
        self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
        stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStatusListener);
      }
    }
    hasPermissionError() {
      return (this.shareScreenPermission === 'SYSTEM_DENIED' || this.shareScreenPermission === 'DENIED');
    }
    getState() {
      let tooltipLabel = '';
      let label = '';
      let icon = '';
      let classList = {};
      const hasError = this.hasPermissionError() && !this.screenShareEnabled;
      const limitReached = this.reachedMaxScreenShares() && !this.screenShareEnabled;
      const couldNotStart = this.shareScreenPermission === 'COULD_NOT_START';
      if (this.screenShareEnabled && !hasError) {
        label = this.t('screenshare.stop');
        icon = this.iconPack.share_screen_stop;
        classList['red-icon'] = true;
      }
      else {
        label = this.t('screenshare.start');
        icon = this.iconPack.share_screen_start;
      }
      if (this.shareScreenPermission === 'SYSTEM_DENIED') {
        tooltipLabel = this.t('perm_sys_denied.screenshare');
        classList['red-icon'] = true;
      }
      else if (this.shareScreenPermission === 'DENIED') {
        tooltipLabel = this.t('perm_denied.screenshare');
        classList['red-icon'] = true;
      }
      else {
        tooltipLabel = label;
      }
      if (limitReached) {
        tooltipLabel = this.t('screenshare.error.max_count');
      }
      if (couldNotStart) {
        tooltipLabel = this.t('screenshare.error.unknown');
      }
      this.screenShareState = {
        tooltipLabel,
        label,
        icon,
        classList,
        disable: hasError || limitReached,
        showWarning: hasError || limitReached || couldNotStart,
      };
    }
    render() {
      if (!deviceCanScreenShare() ||
        !this.canScreenShare ||
        ['OFF_STAGE', 'REQUESTED_TO_JOIN_STAGE'].includes(this.stageStatus)) {
        return null;
      }
      return (h(Host, { title: this.screenShareState.label }, h("dyte-tooltip", { placement: "top", kind: "block", label: this.screenShareState.tooltipLabel, delay: 600, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, label: this.screenShareState.label, icon: this.screenShareState.icon, class: this.screenShareState.classList, onClick: this.toggleScreenShare, disabled: this.screenShareState.disable, showWarning: this.screenShareState.showWarning }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteScreenShareToggle.style = dyteScreenShareToggleCss;

  var dyteScreenShareToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_screen_share_toggle: DyteScreenShareToggle
  });

  const dyteScreenshareViewCss = ":host {\n  line-height: initial;\n  font-family: var(--dyte-font-family, sans-serif);\n\n  font-feature-settings: normal;\n  font-variation-settings: normal;\n}\n\np {\n  margin: var(--dyte-space-0, 0px);\n  padding: var(--dyte-space-0, 0px);\n}\n\n\n:host {\n  height: 100%;\n  width: 100%;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  border-radius: var(--dyte-border-radius-lg, 12px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));\n  container-type: inline-size;\n  container-name: screentile;\n}\n\n::slotted(dyte-name-tag) {\n  position: absolute;\n  left: var(--dyte-space-3, 12px);\n  bottom: var(--dyte-space-3, 12px);\n  opacity: 0.8;\n}\n\n#video-container {\n  position: absolute;\n  display: block;\n  height: 100%;\n  width: 100%;\n}\n\n#video-container .fit-in-container {\n  -o-object-fit: fill;\n     object-fit: fill;\n}\n\nvideo {\n  height: 100%;\n  width: 100%;\n  -o-object-fit: contain;\n     object-fit: contain;\n}\n\n:host([variant='gradient']) ::slotted(dyte-audio-visualizer) {\n  position: absolute;\n  top: var(--dyte-space-2, 8px);\n  right: var(--dyte-space-2, 8px);\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n  padding: var(--dyte-space-2, 8px);\n}\n\n:host([variant='gradient']) ::slotted(dyte-name-tag) {\n  bottom: var(--dyte-space-0, 0px);\n  left: var(--dyte-space-0, 0px);\n  display: flex;\n  width: 100%;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  background-color: transparent;\n  background-image: linear-gradient(to top, var(--tw-gradient-stops));\n  --tw-gradient-from: rgb(var(--dyte-colors-background-1000, 8 8 8));\n  --tw-gradient-to: rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\n  --tw-gradient-to: transparent;\n}\n\n:host([size='sm'][variant='gradient']) ::slotted(dyte-audio-visualizer) {\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n}\n\nvideo.visible {\n  animation: video-fadein 0.4s ease;\n}\n\n#controls {\n  display: none;\n  position: absolute;\n  top: var(--dyte-space-3, 12px);\n  right: var(--dyte-space-3, 12px);\n  align-items: center;\n  justify-content: flex-end;\n  gap: var(--dyte-space-2, 8px);\n}\n\n:host(:hover) #controls, \n:host(:active) #controls, \n:host(:focus-visible) #controls {\n  display: flex;\n}\n\n#full-screen-btn {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));\n}\n\n/** For self view */\n\nh3 {\n  margin-top: var(--dyte-space-10, 40px);\n  margin-bottom: var(--dyte-space-6, 24px);\n  text-align: center;\n  font-size: 20px;\n  font-weight: 500;\n}\n\n:host([size='sm']) h3 {\n  font-size: 16px;\n}\n\n#self-message {\n  padding-left: var(--dyte-space-4, 16px);\n  padding-right: var(--dyte-space-4, 16px);\n}\n\n:host(.isSelf) #self-view {\n  flex: 1 1 0%;\n}\n\n:host(.isSelf) #video-container {\n  position: static;\n  aspect-ratio: auto;\n  height: auto;\n  width: 50%;\n  max-width: var(--dyte-space-96, 384px);\n  border-radius: var(--dyte-border-radius-md, 8px);\n  transition: 0.6s ease;\n}\n\n:host(.isSelf) #video-container.expand {\n  width: 60%;\n  max-width: 100%;\n}\n\n.actions {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: var(--dyte-space-2, 8px);\n}\n\n:host([size='sm'].isSelf) #video-container,\n:host([size='md'].isSelf) #video-container,\n:host([size='sm'].isSelf) #expand-btn,\n:host([size='md'].isSelf) #expand-btn {\n  /** Hide video, fullscreen buttons in sm and md breakpoints */\n  display: none;\n}\n\n/** Remote control */\n\np {\n  margin: var(--dyte-space-0, 0px);\n  padding: var(--dyte-space-0, 0px);\n}\n\n.remote-control {\n  z-index: 10;\n  height: 100%;\n  max-height: 100%;\n  flex: 0 1 auto;\n}\n\n#remote-control-self {\n  position: absolute;\n  top: var(--dyte-space-0, 0px);\n  left: 50%;\n  z-index: 10;\n  width: -moz-max-content;\n  width: max-content;\n  max-width: 100%;\n  box-sizing: border-box;\n  display: flex;\n  height: var(--dyte-space-8, 32px);\n  align-items: center;\n  overflow: hidden;\n  border-radius: var(--dyte-border-radius-sm, 4px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-bg-opacity));\n  font-size: 12px;\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n  transform: translateX(-50%);\n}\n\n#remote-control-self p {\n  padding-left: var(--dyte-space-3, 12px);\n  padding-right: var(--dyte-space-3, 12px);\n  padding-top: var(--dyte-space-2, 8px);\n  padding-bottom: var(--dyte-space-2, 8px);\n}\n\n#remote-control-self dyte-button {\n  height: 100%;\n  border-radius: var(--dyte-border-radius-none, 0);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity));\n  font-size: 12px;\n}\n\n:host([size='sm']) #remote-control-self {\n  height: auto;\n  flex-direction: column;\n}\n\n:host([size='sm']) #remote-control-self dyte-button {\n  width: 100%;\n  padding-top: var(--dyte-space-1, 4px);\n  padding-bottom: var(--dyte-space-1, 4px);\n}\n\n/** Name tag positions */\n\n:host([name-tag-position='bottom-right']) ::slotted(dyte-name-tag) {\n  left: auto;\n  right: var(--dyte-space-3, 12px);\n}\n\n:host([name-tag-position='bottom-center']) ::slotted(dyte-name-tag) {\n  left: auto;\n  right: auto;\n}\n\n:host([name-tag-position='top-left']) ::slotted(dyte-name-tag) {\n  top: var(--dyte-space-3, 12px);\n  bottom: auto;\n}\n\n:host([name-tag-position='top-right']) ::slotted(dyte-name-tag) {\n  top: var(--dyte-space-3, 12px);\n  right: var(--dyte-space-3, 12px);\n  left: auto;\n  bottom: auto;\n}\n\n:host([name-tag-position='top-center']) ::slotted(dyte-name-tag) {\n  left: auto;\n  right: auto;\n  bottom: auto;\n  top: var(--dyte-space-3, 12px);\n}\n\n/** Keyframes */\n\n@keyframes video-fadein {\n  0% {\n    opacity: 0;\n    transform: scale(1.4) translateY(20px);\n  }\n\n  100% {\n    opacity: 1;\n    transform: scale(1) translateY(0);\n  }\n}\n\n::slotted(dyte-network-indicator) {\n  position: absolute;\n  right: var(--dyte-space-3, 12px);\n  bottom: var(--dyte-space-3, 12px);\n}\n\n@media only screen and (max-height: 480px) and (orientation: landscape) {\n    :host([size='sm'][variant='solid']) ::slotted(dyte-name-tag), \n    :host([size='sm'][variant='solid']) dyte-name-tag {\n    left: var(--dyte-space-0, 0px);\n    bottom: var(--dyte-space-0, 0px);\n    border-radius: var(--dyte-border-radius-none, 0);\n      transform-origin: 0% 110%;\n      transform: scale(0.6);\n  }\n}\n\n@container screentile (max-width: 400px) {\n  ::slotted(dyte-name-tag) {\n    transform-origin: 0 130%;\n    transform: scale(0.7);\n  }\n}\n";

  const DyteScreenshareView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.play = createEvent(this, "screensharePlay", 7);
      this.fullScreenListener = () => {
        this.isFullScreen = isFullScreenEnabled();
      };
      this.participantScreenshareUpdate = (p) => {
        if (p.id !== this.participant.id)
          return;
        this.screenShareListener(p);
      };
      this.toggleFullScreen = () => {
        if (!this.isFullScreen) {
          requestFullScreen(this.host);
          this.isFullScreen = true;
        }
        else {
          exitFullSreen();
          this.isFullScreen = false;
        }
      };
      this.hideFullScreenButton = false;
      this.nameTagPosition = 'bottom-left';
      this.participant = undefined;
      this.meeting = undefined;
      this.variant = 'solid';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.videoExpanded = false;
      this.screenShareEnabled = false;
      this.isFullScreen = false;
      this.remoteControlInfo = undefined;
    }
    connectedCallback() {
      window === null || window === undefined ? undefined : window.addEventListener('fullscreenchange', this.fullScreenListener);
      window === null || window === undefined ? undefined : window.addEventListener('webkitfullscreenchange', this.fullScreenListener);
    }
    componentDidLoad() {
      this.participantChanged(this.participant);
    }
    disconnectedCallback() {
      if (!this.meeting)
        return;
      const { self } = this.meeting;
      if (this.participant.id === self.id && this.screenShareListener)
        this.participant.removeListener('screenShareUpdate', this.screenShareListener);
      else
        this.meeting.participants.joined.removeListener('screenShareUpdate', this.participantScreenshareUpdate);
      window === null || window === undefined ? undefined : window.removeEventListener('fullscreenchange', this.fullScreenListener);
      window === null || window === undefined ? undefined : window.removeEventListener('webkitfullscreenchange', this.fullScreenListener);
    }
    participantChanged(participant) {
      if (participant != null && this.meeting) {
        const { self } = this.meeting;
        this.screenShareListener = ({ screenShareEnabled, screenShareTracks }) => {
          const enabled = screenShareEnabled && screenShareTracks.video != null;
          writeTask(() => {
            this.screenShareEnabled = enabled;
          });
          if (enabled) {
            const stream = new MediaStream();
            stream.addTrack(screenShareTracks.video);
            if (this.videoEl != null) {
              this.videoEl.srcObject = stream;
              this.videoEl.play();
            }
          }
          else if (this.videoEl != null) {
            this.videoEl.srcObject = undefined;
          }
        };
        this.screenShareListener(participant);
        if (participant.id === self.id)
          participant.addListener('screenShareUpdate', this.screenShareListener);
        else
          this.meeting.participants.joined.addListener('screenShareUpdate', this.participantScreenshareUpdate);
      }
    }
    render() {
      var _a, _b;
      const isSelf = ((_a = this.participant) === null || _a === undefined ? undefined : _a.id) === ((_b = this.meeting) === null || _b === undefined ? undefined : _b.self.id);
      const text = this.isFullScreen ? this.t('full_screen.exit') : this.t('full_screen');
      const icon = this.isFullScreen
        ? this.iconPack.full_screen_minimize
        : this.iconPack.full_screen_maximize;
      return (h(Host, { class: { isSelf } }, h("div", { key: "video-container", id: "video-container", class: { expand: this.videoExpanded } }, h("video", { ref: (el) => (this.videoEl = el), class: {
          visible: this.screenShareEnabled,
          'fit-in-container': this.participant.supportsRemoteControl,
        }, playsInline: true, onPlay: () => {
          this.play.emit({
            screenshareParticipant: this.participant,
            participant: this.meeting.self,
          });
        }, autoPlay: true, muted: true, id: `screen-share-video-${this.participant.id}` })), h("div", { id: "controls", key: "controls" }, !this.hideFullScreenButton && !isSelf && isFullScreenSupported() && (h("dyte-tooltip", { label: text, iconPack: this.iconPack, t: this.t }, h("dyte-button", { id: "full-screen-btn", kind: "icon", onClick: this.toggleFullScreen, title: text, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: icon, "aria-hidden": true, tabIndex: -1, iconPack: this.iconPack, t: this.t }))))), isSelf && (h("div", { id: "self-message", key: "self-message" }, h("h3", null, this.t('screenshare.shared')), h("div", { class: "actions" }, this.meeting != null && (h("dyte-button", { variant: "danger", onClick: () => {
          this.meeting.self.disableScreenShare();
        }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.share_screen_stop, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('screenshare.stop'))), h("dyte-button", { variant: "secondary", id: "expand-btn", iconPack: this.iconPack, t: this.t, onClick: () => {
          this.videoExpanded = !this.videoExpanded;
        } }, h("dyte-icon", { icon: this.videoExpanded
          ? this.iconPack.full_screen_minimize
          : this.iconPack.full_screen_maximize, slot: "start", iconPack: this.iconPack, t: this.t }), this.videoExpanded
        ? this.t('screenshare.min_preview')
        : this.t('screenshare.max_preview'))))), h("slot", null)));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "participant": ["participantChanged"]
    }; }
  };
  DyteScreenshareView.style = dyteScreenshareViewCss;

  var dyteScreenshareView_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_screenshare_view: DyteScreenshareView
  });

  const dyteSettingsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px);width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header{display:flex;align-items:center;justify-content:space-between;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}.title{font-size:20px;line-height:1}.back-btn,.dismiss-btn{border-radius:var(--dyte-border-radius-sm, 4px);background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.back-btn:hover,.dismiss-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside{box-sizing:border-box;display:flex;min-width:var(--dyte-space-56, 224px);flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px)}aside button{margin-top:var(--dyte-space-4, 16px);box-sizing:border-box;display:flex;width:100%;align-items:center;justify-content:space-between;border-top-left-radius:var(--dyte-border-radius-sm, 4px);border-bottom-left-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);background-color:transparent;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));cursor:default;font-size:16px;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px}aside button .right{display:flex;align-items:center}aside button .right dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}aside button .right dyte-icon:last-child{margin-left:var(--dyte-space-4, 16px)}aside button[type='button']{cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}aside button[type='button']:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}aside button[type='button']{border-right:var(--dyte-border-width-md, 2px) solid transparent}aside button.active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}aside button.active:hover{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}dyte-icon.poor{--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}dyte-icon.poorest{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon.good{--tw-text-opacity:1;color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-text-opacity))}main{display:flex;flex:1 1 0%;align-items:center;justify-content:center;padding-left:var(--dyte-space-6, 24px);padding-right:var(--dyte-space-6, 24px);box-sizing:border-box;width:100%;max-width:calc(100% - var(--dyte-space-56, 224px))}.dismiss-btn{position:absolute;top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']) aside{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([size='sm']) .dismiss-btn{top:var(--dyte-space-5, 20px);right:var(--dyte-space-4, 16px)}:host([size='sm']) aside{width:100%;padding-left:var(--dyte-space-0, 0px)}:host([size='sm']) aside button{border-radius:var(--dyte-border-radius-none, 0)}:host([size='sm']) aside button.active{border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}:host([size='sm']) aside button.active:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) aside.hide{display:none}:host([size='sm']) main{display:none;max-width:100%;overflow-y:auto;padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host([size='sm']) main header{justify-content:center}:host([size='sm']) main header dyte-button{position:absolute;left:var(--dyte-space-4, 16px)}:host([size='sm']) main.active{display:block}";

  const DyteSettings = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.keyPressListener = (e) => {
        if (e.key === 'Escape') {
          this.close();
        }
      };
      this.stageStatusListener = () => {
        this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.activeTab = 'connection';
      this.isMobileMainVisible = false;
      this.networkStatus = 'good';
      this.canProduceVideo = false;
    }
    connectedCallback() {
      document.addEventListener('keydown', this.keyPressListener);
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      // NOTE(ishita1805): hidden because preview was removed from self.
      // this.meeting?.self.disablePreview();
      this.keyPressListener && document.removeEventListener('keydown', this.keyPressListener);
      this.poorConnectionListener &&
        ((_a = this.meeting) === null || _a === undefined ? undefined : _a.meta.removeListener('poorConnection', this.poorConnectionListener));
      this.meeting.stage.removeListener('stageStatusUpdate', this.stageStatusListener);
    }
    meetingChanged(meeting) {
      if (meeting != null) {
        this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
        if (!this.canProduceVideo) {
          this.activeTab = 'audio';
        }
        else {
          this.activeTab = 'video';
        }
        this.poorConnectionListener = ({ score }) => {
          if (score < 7) {
            this.networkStatus = 'poor';
          }
          else if (score < 4) {
            this.networkStatus = 'poorest';
          }
          setTimeout(() => {
            // reset after 5 seconds
            this.networkStatus = 'good';
          }, 5000);
        };
        meeting.meta.addListener('poorConnection', this.poorConnectionListener);
        meeting.stage.addListener('stageStatusUpdate', this.stageStatusListener);
      }
    }
    changeTab(tab) {
      this.activeTab = tab;
      if (this.size === 'sm') {
        if (!this.isMobileMainVisible) {
          this.isMobileMainVisible = true;
        }
      }
    }
    close() {
      this.stateUpdate.emit({ activeSettings: false });
      state.activeSettings = false;
    }
    render() {
      if (this.meeting == null)
        return null;
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("aside", { class: { hide: this.isMobileMainVisible }, part: "menu" }, h("header", null, h("h2", null, this.t('settings'))), h("button", { type: "button", class: { active: this.activeTab === 'audio' }, onClick: () => this.changeTab('audio') }, this.t('audio'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.mic_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t })))), this.canProduceVideo && (h("button", { type: "button", class: { active: this.activeTab === 'video' }, onClick: () => this.changeTab('video') }, this.t('video'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.video_on, iconPack: this.iconPack, t: this.t }), this.size === 'sm' && (h("dyte-icon", { icon: this.iconPack.chevron_right, iconPack: this.iconPack, t: this.t }))))), h("button", { type: "none", title: `Your network condition is ${this.networkStatus}` }, this.t('connection'), h("div", { class: "right" }, h("dyte-icon", { icon: this.iconPack.wifi, class: this.networkStatus, iconPack: this.iconPack, t: this.t })))), h("main", { class: { active: this.isMobileMainVisible, scrollbar: true }, part: "main-content" }, this.size === 'sm' && (h("header", null, h("dyte-button", { kind: "icon", class: "back-btn", onClick: () => (this.isMobileMainVisible = false), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_left, iconPack: this.iconPack, t: this.t })), h("h2", null, this.t(this.activeTab === 'audio' ? 'audio' : 'video')))), this.activeTab === 'audio' && h("dyte-settings-audio", Object.assign({}, defaults)), this.activeTab === 'video' && h("dyte-settings-video", Object.assign({}, defaults)))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteSettings.style = dyteSettingsCss;

  var dyteSettings_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_settings: DyteSettings
  });

  const dyteSettingsToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteSettingsToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.variant = 'button';
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    toggleSettings() {
      var _a;
      this.stateUpdate.emit({
        activeSettings: !((_a = this.states) === null || _a === undefined ? undefined : _a.activeSettings),
        activeMoreMenu: false,
      });
      state.activeSettings = !state.activeSettings;
      state.activeMoreMenu = false;
    }
    render() {
      const text = this.t('settings');
      return (h(Host, { title: text }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleSettings(), icon: this.iconPack.settings, label: text, variant: this.variant })));
    }
  };
  DyteSettingsToggle.style = dyteSettingsToggleCss;

  var dyteSettingsToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_settings_toggle: DyteSettingsToggle
  });

  const dyteSetupScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;padding:var(--dyte-space-4, 16px);height:100%;min-height:100%;width:100%;display:flex;place-items:center;justify-content:center;--dyte-controlbar-button-background-color:rgb(var(--dyte-colors-background-700, 44 44 44))}.container{width:100%;max-width:1080px;display:flex;align-items:center;justify-content:space-evenly;gap:var(--dyte-space-4, 16px)}.metadata{width:100%;max-width:var(--dyte-space-80, 320px)}.label{display:flex;flex-direction:column;align-items:center;font-size:14px}.label p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-2, 8px);display:inline-block;font-size:16px}.container-tile{display:flex;height:100%;width:100%;max-width:584px;flex-direction:column;gap:var(--dyte-space-2, 8px)}.name{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-6, 24px);text-align:center;font-size:28px;font-weight:500;letter-spacing:-0.025em;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}input{margin-bottom:var(--dyte-space-6, 24px);display:block;height:var(--dyte-space-10, 40px);width:100%;max-width:var(--dyte-space-80, 320px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255));box-sizing:border-box;font-size:16px;outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}input::placeholder{color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}input{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}dyte-spinner{color:rgb(var(--dyte-colors-text-1000, 255 255 255));--icon-size:var(--dyte-space-8, 32px)}:host([size='sm']) .container,:host([size='md']) .container{height:100%;flex-direction:column;justify-content:space-evenly}:host([size='sm']) .container-tile,:host([size='md']) .container-tile{height:-moz-min-content;height:min-content;flex-direction:column;justify-content:center}dyte-participant-tile{height:auto;width:100%;max-width:584px}.media-selectors{display:flex;flex-direction:column;justify-content:space-between}.media-selectors .row{display:grid;grid-template-columns:repeat(2, minmax(0, 1fr))}.no-network-badge{margin-top:var(--dyte-space-2, 8px);display:flex;width:100%;flex-direction:row;align-items:center;justify-content:flex-start;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);font-size:12px;color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.75)}.no-network-badge dyte-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px)}";

  const DyteSetupScreen = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.socketStateUpdate = ({ state }) => {
        this.connectionState = state;
        if (state === 'failed')
          this.isJoining = false;
      };
      this.join = async () => {
        var _a, _b, _c;
        if (((_a = this.displayName) === null || _a === undefined ? undefined : _a.trim()) !== '' && !this.isJoining) {
          this.isJoining = true;
          (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.setName(this.displayName);
          gracefulStorage$1.setItem('dyte-display-name', this.displayName);
          try {
            await ((_c = this.meeting) === null || _c === void 0 ? void 0 : _c.joinRoom());
          }
          catch (e) {
            this.isJoining = false;
          }
        }
      };
      this.meeting = undefined;
      this.states = state;
      this.size = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.displayName = undefined;
      this.isJoining = false;
      this.canEditName = true;
      this.canProduceAudio = true;
      this.connectionState = undefined;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.meeting.meta.removeListener('socketConnectionUpdate', this.socketStateUpdate);
    }
    componentDidLoad() {
      var _a;
      (_a = this.inputEl) === null || _a === undefined ? undefined : _a.focus();
    }
    meetingChanged(meeting) {
      var _a, _b, _c;
      if (meeting != null) {
        this.connectionState = (_a = meeting.meta.socketState) === null || _a === undefined ? undefined : _a.state;
        this.canEditName = (_b = meeting.self.permissions.canEditDisplayName) !== null && _b !== undefined ? _b : true;
        this.displayName = ((_c = meeting.self.name) === null || _c === undefined ? undefined : _c.trim()) || (this.canEditName ? '' : 'Participant');
        state.meeting = 'setup';
        meeting.meta.addListener('socketConnectionUpdate', this.socketStateUpdate);
      }
    }
    render() {
      var _a, _b, _c, _d;
      const disabled = ((_a = this.displayName) === null || _a === undefined ? undefined : _a.trim()) === '' || this.connectionState !== 'connected' || this.isJoining;
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states || state,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("div", { class: "container" }, h("div", { class: 'container-tile' }, h(Render, { element: "dyte-participant-tile", defaults: defaults, props: { participant: (_b = this.meeting) === null || _b === undefined ? undefined : _b.self, size: 'md', isPreview: true }, childProps: { participant: (_c = this.meeting) === null || _c === undefined ? undefined : _c.self, size: 'md' }, deepProps: true }), h("div", { class: 'media-selectors' }, h("dyte-microphone-selector", Object.assign({}, defaults, { variant: "inline" })), h("dyte-camera-selector", Object.assign({}, defaults, { variant: "inline" })), h("dyte-speaker-selector", Object.assign({}, defaults, { variant: "inline" })))), h("div", { class: "metadata" }, ((_d = this.displayName) === null || _d === undefined ? undefined : _d.trim()) === '' ? (h("div", { class: "name" }, this.t('setup_screen.join_in_as'))) : (h("div", { class: "label" }, h("p", null, this.t('setup_screen.joining_as')), h("div", { class: "name" }, !this.canEditName && shorten(this.displayName, 20)))), this.canEditName && (h("input", { placeholder: this.t('setup_screen.your_name'), value: this.displayName, spellcheck: false, autoFocus: true, ref: (el) => {
          this.inputEl = el;
        }, onInput: (e) => {
          this.displayName = e.target.value;
        }, onKeyDown: (e) => {
          if (e.key === 'Enter') {
            this.join();
          }
        } })), h("dyte-button", { size: "lg", kind: "wide", onClick: this.join, disabled: disabled, iconPack: this.iconPack, t: this.t }, this.isJoining ? (h("dyte-spinner", { iconPack: this.iconPack, t: this.t })) : (this.t('join'))), this.connectionState !== 'connected' && (h("div", { class: "no-network-badge" }, h("dyte-icon", { size: "md", variant: "danger", icon: this.iconPack.disconnected }), this.connectionState === 'failed'
        ? this.t('network.lost_extended')
        : this.t('network.lost')))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteSetupScreen.style = dyteSetupScreenCss;

  var dyteSetupScreen_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_setup_screen: DyteSetupScreen
  });

  const dyteSidebarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;max-width:var(--dyte-space-96, 384px);box-sizing:border-box;display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));border-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-border-opacity))}:host([view='sidebar']){right:var(--dyte-space-2, 8px);overflow:clip;border-radius:var(--dyte-border-radius-lg, 12px);--tw-shadow:0 25px 50px -12px rgb(0 0 0 / 0.25);--tw-shadow-colored:0 25px 50px -12px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);--tw-shadow-color:rgb(var(--dyte-colors-background-900, 26 26 26));--tw-shadow:var(--tw-shadow-colored)}:host([view='full-screen']){top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);max-width:100%}:host(.floating){position:absolute !important;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);left:auto;z-index:50}.pinned-state{position:absolute;right:var(--dyte-space-1, 4px);display:inline-flex;width:var(--dyte-space-2, 8px);justify-content:flex-end}";

  const DyteSidebar = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.getTabs = () => {
        if (!this.meeting.self.config) {
          return this.enabledSections;
        }
        return this.enabledSections.filter((section) => this.meeting.self.config.controlBar.elements[section.id]);
      };
      this.close = () => {
        this.stateUpdate.emit({ activeSidebar: false, sidebar: this.defaultSection });
        state.sidebar = this.currentTab;
        state.activeSidebar = false;
      };
      this.toggleFloating = () => {
        this.isFloating = !this.isFloating;
        state.sidebarFloating = this.isFloating;
      };
      this.enabledSections = [];
      this.defaultSection = 'chat';
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
      this.view = 'sidebar';
      this.currentTab = this.defaultSection;
      this.isFloating = false;
      this.enablePinning = true;
    }
    connectedCallback() {
      this.viewChanged(this.view);
      this.statesChanged(this.states);
      this.meetingChanged(this.meeting);
      this.isFloating = (state === null || state === undefined ? undefined : state.sidebarFloating) || false;
    }
    disconnectedCallback() {
      var _a, _b;
      document.removeEventListener('keydown', this.keydownListener);
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', this.onStageStatusUpdate);
      this.onStageStatusUpdate = null;
    }
    meetingChanged(meeting) {
      var _a, _b;
      this.updateEnabledSections(meeting);
      this.onStageStatusUpdate = (_status) => {
        this.updateEnabledSections(this.meeting);
      };
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.on('stageStatusUpdate', this.onStageStatusUpdate);
    }
    statesChanged(s) {
      const states = s || state;
      if (states === null || states === undefined ? undefined : states.sidebar) {
        this.currentTab = states.sidebar;
      }
    }
    viewChanged(view) {
      if (view === 'full-screen') {
        this.enablePinning = false;
        this.keydownListener = (e) => {
          if (e.key === 'Escape') {
            this.close();
          }
        };
        document.addEventListener('keydown', this.keydownListener);
      }
      else {
        this.enablePinning = true;
      }
    }
    viewSection(section) {
      this.currentTab = section;
      this.stateUpdate.emit({ activeSidebar: true, sidebar: this.currentTab });
      state.activeSidebar = true;
      state.sidebar = this.currentTab;
    }
    updateEnabledSections(meeting = this.meeting) {
      const list = [];
      if (canViewChat(meeting)) {
        list.push({ id: 'chat', name: this.t('chat') });
      }
      if (canViewPolls(meeting)) {
        list.push({ id: 'polls', name: this.t('polls') });
      }
      if (canViewParticipants(meeting)) {
        list.push({ id: 'participants', name: this.t('participants') });
      }
      if (canViewPlugins(meeting)) {
        list.push({ id: 'plugins', name: this.t('plugins') });
      }
      this.enabledSections = list;
    }
    render() {
      var _a;
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states || state,
        size: this.size,
        t: this.t,
        iconPack: this.iconPack,
      };
      // NOTE(ishita1805): This makes it easier to use the sidebar component in isolation.
      if (((_a = defaults.states) === null || _a === undefined ? undefined : _a.activeSidebar) === false || !this.currentTab) {
        return null;
      }
      return (h(Host, { class: this.enablePinning ? (this.isFloating ? 'floating' : '') : 'floating' }, h("dyte-sidebar-ui", { tabs: this.getTabs(), currentTab: this.currentTab, view: this.view, onTabChange: (e) => {
          this.viewSection(e.detail);
        }, onSidebarClose: this.close }, this.enablePinning && (h("div", { class: "pinned-state", slot: "pinned-state" }, h("dyte-button", { variant: "ghost", kind: "icon", onClick: this.toggleFloating, "aria-label": this.isFloating ? this.t('pin') : this.t('unpin') }, h("dyte-icon", { icon: this.isFloating ? this.iconPack.pin : this.iconPack.pin_off })))), defaults.states.sidebar === 'chat' && (h(Render, { element: "dyte-chat", defaults: defaults, props: { slot: 'chat' } })), defaults.states.sidebar === 'polls' && (h(Render, { element: "dyte-polls", defaults: defaults, props: { slot: 'polls' } })), defaults.states.sidebar === 'participants' && (h(Render, { element: "dyte-participants", defaults: defaults, props: { slot: 'participants' } })), defaults.states.sidebar === 'plugins' && (h(Render, { element: "dyte-plugins", defaults: defaults, props: { slot: 'plugins' } })))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"],
      "view": ["viewChanged"]
    }; }
  };
  DyteSidebar.style = dyteSidebarCss;

  var dyteSidebar_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_sidebar: DyteSidebar
  });

  const dyteSimpleGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:block;height:100%;width:100%}";

  const DyteSimpleGrid = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.setHostDimensions = () => {
        const { clientWidth: width, clientHeight: height } = this.host;
        this.dimensions = { width, height };
      };
      this.participants = [];
      this.aspectRatio = '16:9';
      this.gap = 8;
      this.size = undefined;
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.dimensions = { width: 0, height: 0 };
      this.mediaConnection = undefined;
    }
    connectedCallback() {
      this.resizeObserver = new index(this.setHostDimensions);
      this.resizeObserver.observe(this.host);
      const { meta } = this.meeting;
      this.mediaConnection = Object.assign({}, meta.mediaState);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.resizeObserver) === null || _a === undefined ? undefined : _a.disconnect();
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      const { width, height, getPosition } = useGrid({
        dimensions: this.dimensions,
        count: this.participants.length,
        aspectRatio: this.aspectRatio,
        gap: this.gap,
      });
      return (h(Host, null, this.participants.map((participant, index) => {
        const { top, left } = getPosition(index);
        return (h(Render, { element: "dyte-participant-tile", defaults: defaults, props: {
            participant,
            style: {
              position: 'absolute',
              top: `${top}px`,
              left: `${left}px`,
              width: `${width}px`,
              height: `${height}px`,
            },
            key: participant.id,
            'data-participant': participant.id,
            mediaConnection: this.mediaConnection,
          }, childProps: { participant }, deepProps: true }));
      }), h("slot", null)));
    }
    get host() { return getElement(this); }
  };
  DyteSimpleGrid.style = dyteSimpleGridCss;

  var dyteSimpleGrid_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_simple_grid: DyteSimpleGrid
  });

  const dyteSpotlightGridCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%}main{flex:1 1 0%}.grid-width-sm{width:25%}.grid-width-md{width:50%}.grid-width-lg{width:66.666667%}:host([size='sm']),:host([size='md']){flex-direction:column}:host([size='md']) aside{max-height:var(--dyte-space-96, 384px);width:100%;max-width:100%}:host([size='md']) .grid-width-sm{height:25%}:host([size='md']) .grid-width-md{height:50%}:host([size='md']) .grid-width-lg{height:66.666667%}:host([size='sm']) aside{max-height:var(--dyte-space-96, 384px);width:100%;max-width:100%}:host([size='sm']) .grid-width-sm,:host([size='sm']) .grid-width-md,:host([size='sm']) .grid-width-lg{height:50%}:host([size='xl']) .grid-width-sm,:host([size='xl']) .grid-width-md,:host([size='xl']) .grid-width-lg{width:400px}:host([layout='column']){flex-direction:column}:host([layout='column']) main{flex:4}:host([layout='column']) aside{flex:2;max-width:100%;width:100%}";

  const DyteSpotlightGrid = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.getAdaptiveSize = (length) => {
        if (this.size === 'sm') {
          return 'sm';
        }
        if (length > 3) {
          return 'sm';
        }
        else {
          if (this.size === 'md') {
            return 'sm';
          }
          return 'md';
        }
      };
      this.layout = 'row';
      this.participants = [];
      this.pinnedParticipants = [];
      this.aspectRatio = '16:9';
      this.gap = 8;
      this.size = undefined;
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.gridSize = defaultGridSize;
    }
    render() {
      const defaults = {
        meeting: this.meeting,
        config: this.config,
        states: this.states,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      const nonPinnedParticipants = this.participants.filter((p) => this.pinnedParticipants.some((pt) => pt.id != p.id));
      return (h(Host, null, h("main", { part: "main" }, h(Render, { element: "dyte-simple-grid", defaults: defaults, props: {
          part: 'main-grid',
          participants: this.pinnedParticipants,
          aspectRatio: this.aspectRatio,
          gap: this.gap,
          size: this.getAdaptiveSize(this.pinnedParticipants.length),
        } })), nonPinnedParticipants.length > 0 && (h("aside", { part: "aside", class: this.gridSize.spotlight ? `grid-width-${this.gridSize.spotlight}` : 'grid-width-md' }, h(Render, { element: "dyte-simple-grid", defaults: defaults, props: {
          part: 'aside-grid',
          participants: nonPinnedParticipants,
          aspectRatio: this.aspectRatio,
          gap: this.gap,
          size: this.getAdaptiveSize(nonPinnedParticipants.length),
        } })))));
    }
    get host() { return getElement(this); }
  };
  DyteSpotlightGrid.style = dyteSpotlightGridCss;

  var dyteSpotlightGrid_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_spotlight_grid: DyteSpotlightGrid
  });

  const dyteStageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;position:relative;overflow:hidden}";

  const DyteStage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("slot", null)));
    }
  };
  DyteStage.style = dyteStageCss;

  var dyteStage_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_stage: DyteStage
  });

  const canJoinStage = (meeting) => {
    var _a, _b;
    return (((_a = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _a === undefined ? undefined : _a.permissions.stageEnabled) && ((_b = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _b === undefined ? undefined : _b.permissions.stageAccess) === 'ALLOWED');
  };
  const canRequestToJoinStage = (meeting) => {
    var _a, _b;
    return (((_a = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _a === undefined ? undefined : _a.permissions.stageEnabled) &&
      ((_b = meeting === null || meeting === undefined ? undefined : meeting.self) === null || _b === undefined ? undefined : _b.permissions.stageAccess) !== 'NOT_ALLOWED');
  };

  const dyteStageToggleCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteStageToggle = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.stageCallback = async () => {
        var _a, _b, _c, _d, _e, _f, _g;
        const stageStatus = (_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.status;
        if (stageStatus === 'ON_STAGE') {
          await ((_c = (_b = this === null || this === undefined ? undefined : this.meeting) === null || _b === undefined ? undefined : _b.stage) === null || _c === undefined ? undefined : _c.leave());
        }
        if (stageStatus === 'OFF_STAGE') {
          (_e = (_d = this === null || this === undefined ? undefined : this.meeting) === null || _d === undefined ? undefined : _d.stage) === null || _e === undefined ? undefined : _e.requestAccess();
          if (canJoinStage(this.meeting)) {
            this.stateUpdate.emit({ activeJoinStage: true });
            state.activeJoinStage = true;
          }
        }
        if (stageStatus === 'REQUESTED_TO_JOIN_STAGE') {
          (_g = (_f = this === null || this === undefined ? undefined : this.meeting) === null || _f === undefined ? undefined : _f.stage) === null || _g === undefined ? undefined : _g.cancelRequestAccess();
        }
      };
      this.variant = 'button';
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.stageStatus = 'OFF_STAGE';
      this.state = {
        label: '',
        disabled: false,
        icon: '',
      };
      this.t = useLanguage();
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    stageStatusHandler(meeting, status) {
      this.stageStatus = status;
      if (status === 'ACCEPTED_TO_JOIN_STAGE') {
        meeting.self.setupTracks({ audio: false, video: false });
        this.stateUpdate.emit({ activeJoinStage: true });
        state.activeJoinStage = true;
      }
      this.state = this.getState();
    }
    disconnectedCallback() {
      var _a, _b;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', (status) => this.stageStatusHandler(this.meeting, status));
    }
    meetingChanged(meeting) {
      var _a, _b, _c, _d;
      if (meeting == null)
        return;
      this.stageStatus = (_a = meeting.stage) === null || _a === undefined ? undefined : _a.status;
      this.stageStatusHandler(meeting, (_b = meeting.stage) === null || _b === undefined ? undefined : _b.status);
      (_d = (_c = this.meeting) === null || _c === undefined ? undefined : _c.stage) === null || _d === undefined ? undefined : _d.on('stageStatusUpdate', (status) => this.stageStatusHandler(meeting, status));
    }
    getState() {
      let label = '';
      let icon = '';
      let disabled = false;
      switch (this.stageStatus) {
        case 'ON_STAGE': {
          icon = this.iconPack.leave_stage;
          label = this.t('stage_request.leave_stage');
          disabled = false;
          break;
        }
        case 'ACCEPTED_TO_JOIN_STAGE': {
          icon = this.iconPack.join_stage;
          label = this.t('stage_request.request');
          disabled = true;
          break;
        }
        case 'REQUESTED_TO_JOIN_STAGE': {
          icon = this.iconPack.join_stage;
          label = this.t('stage_request.requested');
          disabled = false;
          break;
        }
        default: {
          icon = this.iconPack.join_stage;
          label = this.t('stage_request.request');
          disabled = false;
          break;
        }
      }
      return { label, disabled, icon };
    }
    render() {
      if (!canRequestToJoinStage(this.meeting))
        return;
      return (h(Host, { title: this.state.label }, h("dyte-tooltip", { placement: "top", kind: "block", label: this.state.label, delay: 600, part: "tooltip", iconPack: this.iconPack, t: this.t }, h("dyte-controlbar-button", { part: "controlbar-button", size: this.size, iconPack: this.iconPack, t: this.t, variant: this.variant, label: this.state.label, icon: this.state.icon, onClick: this.stageCallback, disabled: this.state.disabled, showWarning: false }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteStageToggle.style = dyteStageToggleCss;

  var dyteStageToggle_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_stage_toggle: DyteStageToggle
  });

  const dyteTextFieldCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}input{display:block;height:var(--dyte-space-10, 40px);padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-size:14px;border-width:var(--dyte-border-width-md, 2px);border-style:solid;border-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input::placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input:focus{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}input{border-radius:var(--dyte-border-radius-sm, 4px);outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity))}input:disabled{cursor:not-allowed}";

  const DyteTextField = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.type = 'text';
      this.placeholder = '';
      this.disabled = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.stateUpdate.emit({ abc: false });
      state.abc = false;
    }
    get value() {
      return this.input.value;
    }
    render() {
      return (h(Host, null, h("input", { ref: (el) => (this.input = el), type: this.type, placeholder: this.placeholder, disabled: this.disabled })));
    }
  };
  DyteTextField.style = dyteTextFieldCss;

  var dyteTextField_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_text_field: DyteTextField
  });

  const dyteTranscriptsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:absolute;top:var(--dyte-space-4, 16px);right:var(--dyte-space-4, 16px);bottom:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);top:auto;display:flex;flex-direction:column;pointer-events:none;justify-content:center;width:100%;z-index:5}dyte-transcript{margin-top:var(--dyte-space-2, 8px)}";

  const DyteTranscripts = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onTranscript = (transcript) => {
        if (transcript.transcript) {
          this.add(transcript);
        }
      };
      this.meeting = undefined;
      this.states = state;
      this.config = defaultConfig;
      this.t = useLanguage();
      this.transcripts = [];
      this.listenerAttached = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    addListener(meeting) {
      var _a;
      (_a = meeting === null || meeting === undefined ? undefined : meeting.ai) === null || _a === undefined ? undefined : _a.addListener('transcript', this.onTranscript);
      this.listenerAttached = true;
    }
    clearListeners(meeting) {
      var _a;
      this.onTranscript && ((_a = meeting === null || meeting === undefined ? undefined : meeting.ai) === null || _a === undefined ? undefined : _a.removeListener('transcript', this.onTranscript));
      this.listenerAttached = false;
      clearTimeout(this.disconnectTimeout);
      this.transcripts = [];
    }
    disconnectedCallback() {
      if (this.meeting == null)
        return;
      this.clearListeners(this.meeting);
    }
    meetingChanged(meeting, oldMeeting) {
      clearTimeout(this.disconnectTimeout);
      if (oldMeeting !== undefined)
        this.clearListeners(oldMeeting);
      if (meeting == null)
        return;
      if (this.states.activeCaptions) {
        this.addListener(meeting);
      }
    }
    statesChanged(s) {
      const states = s || state;
      if (states.activeCaptions && !this.listenerAttached) {
        this.addListener(this.meeting);
      }
      if (!states.activeCaptions && this.listenerAttached) {
        this.clearListeners(this.meeting);
      }
    }
    transcriptionsReducer(acc, t) {
      if (!acc.length) {
        return [t];
      }
      let lastElement = acc[acc.length - 1];
      if (lastElement.peerId !== t.peerId) {
        return acc.concat(t);
      }
      if (lastElement.id === t.id) {
        lastElement.transcript = t.transcript;
        acc.pop();
        return acc.concat(clone(lastElement));
      }
      return acc.concat(t);
    }
    add(transcript) {
      // show transcripts only if tab is in focus and a maximum of 3 at a time
      // this.transcripts.splice(0, this.transcripts.length - 2);
      this.transcripts = this.transcriptionsReducer(this.transcripts, transcript);
    }
    remove(renderedId) {
      this.transcripts = this.transcripts.filter((transcript) => transcript.renderedId !== renderedId);
    }
    handleDismiss(e) {
      e.stopPropagation();
      const { id, renderedId } = e.detail;
      const el = this.host.shadowRoot.querySelector(`[data-id="${id}"]`);
      // exit animation
      el === null || el === undefined ? undefined : el.classList.add('exit');
      setTimeout(() => {
        writeTask(() => {
          this.remove(renderedId);
        });
      }, 400);
    }
    renderTranscripts() {
      const renderedTranscripts = [];
      this.transcripts.forEach((transcript) => {
        const t = {
          name: transcript.name,
          date: transcript.date,
          peerId: transcript.peerId,
          transcript: transcript.transcript,
          id: transcript.id,
          renderedId: transcript.id,
        };
        if (!renderedTranscripts.length) {
          transcript.renderedId = t.renderedId;
          renderedTranscripts.push(t);
          return;
        }
        const lastTranscript = renderedTranscripts[renderedTranscripts.length - 1];
        const maxTranscriptLength = 400;
        if (lastTranscript.transcript.length + t.transcript.length > maxTranscriptLength ||
          lastTranscript.peerId !== transcript.peerId) {
          transcript.renderedId = t.renderedId;
          renderedTranscripts.push(t);
          return;
        }
        lastTranscript.transcript += ' ' + transcript.transcript;
        transcript.renderedId = lastTranscript.renderedId;
      });
      renderedTranscripts.splice(0, renderedTranscripts.length - 2);
      return renderedTranscripts === null || renderedTranscripts === undefined ? undefined : renderedTranscripts.map((transcript) => (h("dyte-transcript", { key: transcript.id, "data-id": transcript.id, transcript: transcript, onDyteTranscriptDismiss: (e) => this.handleDismiss(e), t: this.t })));
    }
    render() {
      if (!this.states.activeCaptions)
        return;
      return h(Host, null, this.renderTranscripts());
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DyteTranscripts.style = dyteTranscriptsCss;

  var dyteTranscripts_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_transcripts: DyteTranscripts
  });

  const DyteUiProvider = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.meeting = undefined;
      this.size = undefined;
      this.config = defaultConfig;
      this.t = useLanguage();
      this.iconPackUrl = undefined;
      this.loadConfigFromPreset = true;
      this.applyDesignSystem = true;
      this.joinRoom = true;
      this.isReady = false;
      this.iconPack = defaultIconPack;
    }
    async iconPackUrlChanged(url) {
      this.iconPack = await getIconPack(url);
    }
    async meetingChanged(meeting) {
      var _a;
      if (!meeting)
        return;
      if (!meeting.self.roomJoined && this.joinRoom) {
        this.isReady = false;
        await meeting.joinRoom();
        this.isReady = true;
      }
      if (this.loadConfigFromPreset && meeting.self.config != null) {
        const theme = meeting.self.config;
        const { config } = generateConfig(theme, meeting);
        if (this.config === defaultConfig) {
          // only override the config if the object is same as defaultConfig
          // which means it's a different object passed via prop
          this.config = Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { designTokens: Object.assign(Object.assign({}, defaultConfig.designTokens), config.designTokens) });
        }
      }
      if (this.applyDesignSystem &&
        ((_a = this.config) === null || _a === undefined ? undefined : _a.designTokens) != null &&
        typeof document !== 'undefined') {
        provideDyteDesignSystem(document.documentElement, this.config.designTokens);
      }
      Array.from(this.hostEl.children)
        .filter((element) => element.tagName.startsWith('DYTE-'))
        .forEach((element) => {
        element['meeting'] = meeting;
        element['config'] = this.config;
        element['size'] = this.size;
        element['iconPack'] = this.iconPack;
        element['t'] = this.t;
      });
    }
    connectedCallback() {
      this.resizeObserver = new ResizeObserver(() => this.handleResize());
      this.resizeObserver.observe(this.hostEl);
      this.meetingChanged(this.meeting);
      this.iconPackUrlChanged(this.iconPackUrl);
    }
    handleResize() {
      this.size = getSize(this.hostEl.clientWidth);
    }
    render() {
      if (!this.isReady)
        return null;
      return h("slot", null);
    }
    get hostEl() { return getElement(this); }
    static get watchers() { return {
      "iconPackUrl": ["iconPackUrlChanged"],
      "meeting": ["meetingChanged"]
    }; }
  };

  var dyteUiProvider_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_ui_provider: DyteUiProvider
  });

  const dyteWaitingScreenCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{height:100%;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center}.centered{display:flex;flex-direction:column;align-items:center}dyte-logo{margin-bottom:var(--dyte-space-8, 32px);height:var(--dyte-space-12, 48px)}p{font-size:16px;border-radius:var(--dyte-border-radius-lg, 12px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px);padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

  const DyteWaitingScreen = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.meeting = undefined;
      this.config = defaultConfig;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("slot", null, h("div", { class: "centered", part: "content" }, h("dyte-logo", { meeting: this.meeting, config: this.config, part: "logo", t: this.t }), h("p", null, this.t('waitlist.body_text'))))));
    }
  };
  DyteWaitingScreen.style = dyteWaitingScreenCss;

  var dyteWaitingScreen_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_waiting_screen: DyteWaitingScreen
  });

  const dyteBreakoutRoomManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-radius:var(--dyte-border-radius-sm, 4px)}@keyframes bg-glow{25%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}50%{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}75%{background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.2)}}.glowing-card{animation:bg-glow 0.8s}.selector-mode,.assign-mode{display:flex;flex-direction:column;align-items:center;padding:var(--dyte-space-2, 8px);cursor:pointer}.selector:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.show-on-hover{display:none}.header{width:100%;display:flex;align-items:center}.header dyte-icon{margin-left:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);cursor:pointer}.header .danger{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.header .hide{display:none}.header .rooms-container{display:flex;flex-grow:1;flex-direction:row;align-items:center;justify-content:flex-end}.header input{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-1, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));max-width:var(--dyte-space-36, 144px);font-size:14px;font-weight:500;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}.header input:disabled{overflow-x:visible;border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}.header input:invalid{border-bottom-width:var(--dyte-border-width-sm, 1px);border-style:dashed;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-border-opacity))}.header input.editing-enabled{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.header .participant-count{display:flex;align-items:center;font-size:14px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.header .participant-count dyte-icon{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0\\.5, 2px);width:var(--dyte-space-3, 12px)}.header .assign-button{height:var(--dyte-space-6, 24px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity));-webkit-text-decoration-line:underline;text-decoration-line:underline}.header .assign-button:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.participant-list{display:grid;flex-grow:1;grid-template-columns:repeat(2, minmax(0, 1fr));gap:var(--dyte-space-2, 8px);margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);width:100%;border-radius:var(--dyte-border-radius-sm, 4px)}.participant-list::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px)}.participant-list::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.participant-list::-webkit-scrollbar-track{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.participant-item{display:flex;align-items:center;justify-content:space-between;margin-right:var(--dyte-space-2, 8px);height:-moz-fit-content;height:fit-content;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}.participant-item:hover{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.selector-mode:hover .show-on-hover{display:flex}.message-container{margin:var(--dyte-space-0, 0px);display:flex;width:100%;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px)}.message-container p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-20, 80px);display:flex;width:100%;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));border-style:dashed;--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity))}.message-container p:hover{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.25)}.message-container .drop-zone-active{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / 0.25)}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}.show-on-hover{margin-left:var(--dyte-space-4, 16px);height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);display:none}:host(:hover) .show-on-hover{display:flex}.peer-ui-container{position:relative;display:flex;align-items:center;gap:var(--dyte-space-2, 8px);height:var(--dyte-space-10, 40px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.peer-ui-container dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.peer-ui-container .name{font-size:14px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}";

  const ROOM_TITLE_MIN_CHARS = 3;
  const DyteBreakoutRoomManager = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onParticipantsAdd = createEvent(this, "participantsAdd", 7);
      this.onParticipantDelete = createEvent(this, "participantDelete", 7);
      this.onRoomJoin = createEvent(this, "roomJoin", 7);
      this.deleteRoom = createEvent(this, "delete", 7);
      this.updateRoom = createEvent(this, "update", 7);
      this.permissionsUpdateListener = () => {
        this.permissions = this.meeting.self.permissions.connectedMeetings;
      };
      this.reset = () => {
        this.editingTitleRoomId = null;
        this.newTitle = null;
      };
      this.onEditClick = () => {
        if (this.editingTitleRoomId) {
          if (this.newTitle.length < ROOM_TITLE_MIN_CHARS)
            return;
          this.roomTitle = this.newTitle;
          this.updateRoom.emit({
            title: this.newTitle,
            id: this.editingTitleRoomId,
          });
          this.glowCard();
          this.reset();
        }
        else {
          this.editingTitleRoomId = this.room.id;
          writeTask(() => {
            this.inputTextEl.focus();
            this.inputTextEl.select();
          });
        }
      };
      this.onDrop = (e) => {
        if (e.currentTarget instanceof HTMLParagraphElement) {
          e.currentTarget.classList.remove('drop-zone-active');
          this.onAssign();
        }
      };
      this.onDragOver = (e) => {
        if (e.currentTarget instanceof HTMLParagraphElement) {
          e.currentTarget.classList.add('drop-zone-active');
          e.preventDefault();
        }
      };
      this.meeting = undefined;
      this.assigningParticipants = undefined;
      this.mode = undefined;
      this.states = undefined;
      this.allowDelete = true;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isDragMode = false;
      this.room = undefined;
      this.defaultExpanded = false;
      this.editingTitleRoomId = null;
      this.newTitle = null;
      this.showExpandedCard = false;
      this.glowingCard = false;
    }
    connectedCallback() {
      var _a;
      this.allParticipants = getAllConnectedParticipants(this.meeting);
      this.permissionsUpdateListener();
      this.showExpandedCard = this.defaultExpanded;
      this.roomTitle = this.room.isParent ? this.t('breakout_rooms.main_room') : (_a = this.room) === null || _a === undefined ? undefined : _a.title;
      this.canEditMeetingTitle =
        this.permissions.canAlterConnectedMeetings &&
          !this.room.isParent &&
          !this.meeting.connectedMeetings.isActive; // TODO: remove this once socket supports update meetings
      this.meeting.self.permissions.on('permissionsUpdate', this.permissionsUpdateListener);
    }
    disconnectedCallback() {
      this.meeting.self.permissions.off('permissionsUpdate', this.permissionsUpdateListener);
    }
    onDragLeave(e) {
      if (e.currentTarget instanceof HTMLParagraphElement) {
        e.currentTarget.classList.remove('drop-zone-active');
      }
    }
    getAssignmentHint() {
      if (this.assigningParticipants && this.isDragMode) {
        return this.t('breakout_rooms.drag_drop_participants');
      }
      if (this.assigningParticipants) {
        return this.t('breakout_rooms.click_drop_participants');
      }
      if (this.room.participants.length === 0) {
        return this.t('breakout_rooms.none_assigned');
      }
    }
    toggleCardDisplay() {
      this.showExpandedCard = !this.showExpandedCard;
    }
    glowCard() {
      this.glowingCard = true;
      setTimeout(() => {
        this.glowingCard = false;
      }, 2000);
    }
    onAssign() {
      this.onParticipantsAdd.emit();
      this.glowCard();
    }
    onJoin() {
      this.onRoomJoin.emit();
    }
    onTitleChanged(e) {
      if (e.key === 'Enter') {
        this.newTitle = e.target.value;
        this.onEditClick();
      }
    }
    renderPeer(participant) {
      const { displayPictureUrl: picture } = this.allParticipants.find((p) => participantIdentifier(p) === participantIdentifier(participant));
      const name = formatName(participant.displayName || '');
      return (h("div", { class: "peer-ui-container" }, h("dyte-avatar", { participant: { name, picture }, size: "sm" }), h("p", { class: "name", title: name }, shorten(name, 16), this.meeting.self.userId === participant.id && ` (${this.t('you')})`)));
    }
    renderExpandedCardMaybe() {
      if (!this.showExpandedCard)
        return;
      if (this.room.isParent)
        return;
      if (!this.getAssignmentHint())
        return;
      if (!this.permissions.canAlterConnectedMeetings)
        return;
      return (h("div", { class: "message-container" }, h("p", { class: { 'compact-height': this.room.participants.length !== 0 }, onClick: () => this.onAssign(), onDragOver: this.onDragOver, onDragLeave: this.onDragLeave, onDrop: this.onDrop }, this.getAssignmentHint())));
    }
    renderParticipantsMaybe() {
      if (!this.showExpandedCard)
        return;
      if (this.room.isParent)
        return;
      if (this.room.participants.length === 0)
        return;
      return (h("div", { class: "participant-list", onClick: () => {
          this.onAssign();
        } }, this.room.participants.map((participant) => (h("div", { class: "participant-item", role: "listitem", key: participant.id }, this.renderPeer(participant), this.permissions.canAlterConnectedMeetings && (h("dyte-icon", { class: "show-on-hover", icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t, onClick: () => {
          this.onParticipantDelete.emit(participant);
        } })))))));
    }
    render() {
      var _a, _b, _c;
      return (h(Host, null, h("div", { class: {
          'assign-mode': this.assigningParticipants,
          'selector-mode': !this.assigningParticipants,
          'glowing-card': this.glowingCard,
        } }, h("div", { class: "header" }, h("input", { ref: (el) => (this.inputTextEl = el), placeholder: this.t('breakout_rooms.room_name'), disabled: !(this.editingTitleRoomId === this.room.id), value: this.roomTitle, minlength: ROOM_TITLE_MIN_CHARS, onChange: (e) => {
          this.newTitle = e.target.value;
        }, onKeyPress: (e) => this.onTitleChanged(e), class: { 'editing-enabled': this.editingTitleRoomId === this.room.id }, style: { width: `${this.roomTitle.length + 1}ch` } }), this.editingTitleRoomId !== this.room.id && (h("span", { class: "participant-count" }, "(", h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }), (_c = (_b = (_a = this.room) === null || _a === undefined ? undefined : _a.participants) === null || _b === undefined ? undefined : _b.length) !== null && _c !== undefined ? _c : '0', ")")), this.canEditMeetingTitle && (h("dyte-tooltip", { label: this.editingTitleRoomId === this.room.id
          ? this.t('breakout_rooms.save_room_name')
          : this.t('breakout_rooms.edit_room_name'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.editingTitleRoomId === this.room.id
          ? this.iconPack.checkmark
          : this.iconPack.edit, iconPack: this.iconPack, t: this.t, class: "show-on-hover", onClick: this.onEditClick }))), h("div", { class: "rooms-container" }, this.permissions.canAlterConnectedMeetings &&
        !this.room.isParent &&
        this.allowDelete && (h("dyte-tooltip", { label: this.t('breakout_rooms.delete'), class: "danger", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.delete, class: "show-on-hover", iconPack: this.iconPack, t: this.t, onClick: () => {
          this.deleteRoom.emit();
        } }))), this.assigningParticipants &&
        this.permissions.canAlterConnectedMeetings &&
        !this.room.isParent && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", class: "assign-button", size: "md", onClick: () => this.onAssign() }, this.t('breakout_rooms.assign'))), this.mode === 'edit' &&
        !this.assigningParticipants &&
        this.permissions.canSwitchConnectedMeetings && (h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "ghost", class: "assign-button", size: "md", disabled: this.room.id === this.meeting.meta.meetingId, onClick: () => this.onJoin() }, this.room.id === this.meeting.meta.meetingId
        ? this.t('joined')
        : this.t('join'))), !this.room.isParent && (h("dyte-icon", { icon: this.showExpandedCard ? this.iconPack.chevron_up : this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t, onClick: () => this.toggleCardDisplay() })))), this.renderExpandedCardMaybe(), this.renderParticipantsMaybe())));
    }
  };
  DyteBreakoutRoomManager.style = dyteBreakoutRoomManagerCss;

  const dyteBreakoutRoomParticipantsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{display:flex;height:100%;flex-direction:column;font-size:14px}:host input[type='checkbox']{margin:var(--dyte-space-0, 0px);cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:var(--dyte-border-radius-sm, 4px);position:relative;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;border-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}:host input[type='checkbox']:checked{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host input[type='checkbox']:checked::before{position:absolute;top:1px;left:1px;height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px);background-color:rgb(var(--dyte-colors-text-1000, 255 255 255));content:'';clip-path:polygon(5% 60%, 35% 93%, 100% 19%, 86% 4%, 36% 62%, 19% 44%)}*{box-sizing:border-box}.participants{margin-top:var(--dyte-space-2, 8px);padding:var(--dyte-space-0, 0px)}.ctr{box-sizing:border-box;padding-top:var(--dyte-space-0, 0px);padding-bottom:var(--dyte-space-0, 0px);overflow-y:auto;flex-grow:1;flex-basis:0}.empty-message{margin-top:var(--dyte-space-10, 40px);margin-bottom:var(--dyte-space-10, 40px);text-align:center;font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.empty-room{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:var(--dyte-space-2, 8px);height:100%;text-align:center;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.empty-room dyte-icon{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px)}.empty-room p{font-size:16px;font-weight:500;margin:var(--dyte-space-0, 0px)}.empty-room span{font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search-wrapper{margin-bottom:var(--dyte-space-1, 4px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.search{position:sticky;box-sizing:border-box;display:flex;align-items:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);height:var(--dyte-space-8, 32px)}.search .search-icon{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}.search input{box-sizing:border-box;width:100%;padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:inherit;color:rgb(var(--dyte-colors-text-1000, 255 255 255));outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);font-size:14px}.search input::-moz-placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.search input::placeholder{color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.header{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-1\\.5, 6px);height:var(--dyte-space-9, 36px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-0\\.5, 2px);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-border-opacity));font-size:12px;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));display:flex;align-items:center;justify-content:space-between}.title-wrapper{display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.participant-count{display:flex;align-items:center;font-size:14px}.participant-count dyte-icon{margin-right:var(--dyte-space-0\\.5, 2px);width:var(--dyte-space-3, 12px)}.participant-item{display:flex;align-items:center;justify-content:space-between;margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);cursor:pointer}.participant-item input.hide-checkbox{display:none}.participant-item input:checked{display:inline-block}.dragging input{display:none}.participant-item:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.participant-item:hover input{display:inline-block}.peer-ui-container{position:relative;display:flex;align-items:center;gap:var(--dyte-space-2, 8px);height:var(--dyte-space-10, 40px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.peer-ui-container dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.peer-ui-container .name{font-size:14px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}";

  const DyteBreakoutRoomParticipants = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onSelectedParticipantsUpdate = createEvent(this, "selectedParticipantsUpdate", 7);
      this.onAllToggled = createEvent(this, "allParticipantsToggleUpdate", 7);
      this.onParticipantsDragging = createEvent(this, "participantsDragging", 7);
      this.onSearchInput = (e) => {
        this.search = e.target.value;
      };
      this.onDragStart = (participant) => {
        this.isDragging = true;
        this.onParticipantsDragging.emit(true);
        this.updateSelectedParticipants(participant, true);
      };
      this.onDragEnd = (participant) => {
        this.isDragging = false;
        this.onParticipantsDragging.emit(false);
        this.updateSelectedParticipants(participant, false);
      };
      this.onClick = (participant) => {
        const selected = this.selectedParticipantIds.includes(participantIdentifier(participant));
        this.updateSelectedParticipants(participant, !selected);
      };
      this.onToggleAll = (checked) => {
        const selectedParticipants = checked ? this.participantsToShow.map(participantIdentifier) : [];
        this.onAllToggled.emit(selectedParticipants);
      };
      this.meeting = undefined;
      this.participantIds = [];
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.search = '';
      this.participantsToShow = [];
      this.selectedParticipantIds = [];
      this.isDragging = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.searchChanged(this.search);
    }
    disconnectedCallback() {
      if (this.meeting == null)
        return;
    }
    updateSelectedParticipants(participant, selected) {
      const id = participantIdentifier(participant);
      let selectedParticipants = [];
      if (selected && !this.selectedParticipantIds.includes(id)) {
        selectedParticipants = [...this.selectedParticipantIds, id];
      }
      else {
        selectedParticipants = [...this.selectedParticipantIds.filter((x) => x !== id)];
      }
      this.onSelectedParticipantsUpdate.emit(selectedParticipants);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      this.getParticipants(this.search);
    }
    participantsChanged() {
      this.getParticipants(this.search);
    }
    searchChanged(search) {
      this.getParticipants(search);
    }
    getParticipants(search) {
      const allParticipants = getAllConnectedParticipants(this.meeting);
      this.participantsToShow = allParticipants.filter((participant) => {
        var _a;
        return (this.participantIds.includes(participantIdentifier(participant)) &&
          ((_a = participant.displayName) !== null && _a !== undefined ? _a : '').toLowerCase().includes(search.toLowerCase()));
      });
    }
    renderPeer(participant) {
      const name = formatName(participant.displayName || '');
      return (h("div", { class: "peer-ui-container" }, h("dyte-avatar", { participant: {
          name: participant.displayName,
          picture: participant.displayPictureUrl,
        }, size: "sm" }), h("p", { class: "name", title: name }, shorten(name, 16), this.meeting.self.userId === participant.id && ` (${this.t('you')})`)));
    }
    render() {
      return (h(Host, null, h("div", { class: "search-wrapper" }, h("div", { class: "search", part: "search" }, h("dyte-icon", { icon: this.iconPack.search, part: "search-icon", iconPack: this.iconPack, t: this.t, class: "search-icon" }), h("input", { type: "search", autocomplete: "off", placeholder: this.t('search'), onInput: this.onSearchInput, part: "search-input" })), h("slot", { name: "shuffle-button" })), h("div", { class: "header" }, h("div", { class: "title-wrapper" }, h("span", null, this.t('breakout_rooms.main_room')), h("span", { class: "participant-count" }, "(", h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }), this.participantsToShow.length, ")")), this.selectedParticipantIds.length !== 0 && (h("dyte-tooltip", { label: this.t('breakout_rooms.select_all'), iconPack: this.iconPack, t: this.t }, h("input", { type: "checkbox", checked: this.selectedParticipantIds.length === this.participantsToShow.length, onChange: (e) => this.onToggleAll(!!e.target.checked) })))), h("div", { class: "ctr scrollbar", part: "container" }, this.participantsToShow.length > 0 && (h("ul", { class: "participants", part: "participants" }, this.participantsToShow.map((participant) => (h("li", { class: { 'participant-item': true, dragging: this.isDragging }, onClick: () => this.onClick(participant), onDragStart: () => this.onDragStart(participant), onDragEnd: () => this.onDragEnd(participant), draggable: this.selectedParticipantIds.length === 0, role: "listitem", key: participant.id }, this.renderPeer(participant), !this.isDragging && (h("input", { type: "checkbox", class: {
          'hide-checkbox': this.selectedParticipantIds.length === 0,
        }, checked: this.selectedParticipantIds.includes(participantIdentifier(participant)) }))))))), this.participantsToShow.length === 0 && this.search.length > 0 && (h("div", { class: "empty-message" }, this.t('participants.errors.empty_results'))), this.participantsToShow.length === 0 && this.search.length === 0 && (h("div", { class: "empty-room" }, h("dyte-icon", { icon: this.iconPack.people_checked, part: "search-icon", iconPack: this.iconPack, t: this.t, class: "search-icon" }), h("p", null, this.t('breakout_rooms.all_assigned')), h("span", null, this.t('breakout_rooms.empty_main_room')))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "participantIds": ["participantsChanged"],
      "search": ["searchChanged"]
    }; }
  };
  DyteBreakoutRoomParticipants.style = dyteBreakoutRoomParticipantsCss;

  const dyteCounterCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;flex-direction:row;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));width:-moz-fit-content;width:fit-content;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-1, 4px)}p{margin:var(--dyte-space-0, 0px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}input{margin:var(--dyte-space-0, 0px);width:var(--dyte-space-6, 24px);padding:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-sm, 1px);border-style:solid;border-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));text-align:center;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));border-radius:var(--dyte-border-radius-sm, 4px);font-size:16px;outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{margin:var(--dyte-space-0, 0px);appearance:none;-webkit-appearance:none}input[type='number']{-moz-appearance:textfield}";

  const DyteCounter = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onChange = createEvent(this, "valueChange", 7);
      this.input = '1';
      this.size = undefined;
      this.value = undefined;
      this.minValue = 0;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.watchStateHandler(this.input);
      this.input = this.value.toString();
    }
    watchStateHandler(input) {
      this.onChange.emit(input);
    }
    increment() {
      this.input = Math.max(parseInt(this.input) + 1, this.minValue).toString();
    }
    decrement() {
      this.input = Math.max(this.minValue, parseInt(this.input) - 1).toString();
    }
    render() {
      return (h(Host, null, h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.decrement(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.subtract, iconPack: this.iconPack, t: this.t })), h("input", { type: "number", value: this.input, min: this.minValue, onInput: (e) => {
          const val = parseInt(e.target.value, 10);
          if (isNaN(val) || val < this.minValue) {
            this.input = this.minValue.toString();
          }
          else {
            this.input = val.toString();
          }
        } }), h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.increment(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.add, iconPack: this.iconPack, t: this.t }))));
    }
    static get watchers() { return {
      "input": ["watchStateHandler"]
    }; }
  };
  DyteCounter.style = dyteCounterCss;

  var dyteBreakoutRoomManager_3_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_breakout_room_manager: DyteBreakoutRoomManager,
      dyte_breakout_room_participants: DyteBreakoutRoomParticipants,
      dyte_counter: DyteCounter
  });

  const SOUNDS = {
    joined: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_join.mp3',
    left: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_join.mp3',
    message: 'https://dyte-uploads.s3.ap-south-1.amazonaws.com/notification_message.mp3',
  };
  /**
   * Handles notification sounds in a meeting
   */
  class DyteNotificationsAudio {
    constructor(meeting) {
      this.meeting = meeting;
      this.audio = document.createElement('audio');
      this.audio.volume = 0.3;
    }
    play(sound, duration = 3000) {
      var _a;
      if (this.playing)
        return;
      this.playing = true;
      this.audio.src = SOUNDS[sound];
      this.audio.volume = 0.3;
      (_a = this.audio.play()) === null || _a === undefined ? undefined : _a.catch((err) => {
        logger.error('[dyte-notifications] play() failed\n', { sound, duration }, err);
      });
      setTimeout(() => {
        this.playing = false;
      }, duration);
    }
    async setDevice(id) {
      var _a, _b, _c;
      if (disableSettingSinkId(this.meeting))
        return;
      await ((_c = (_b = (_a = this.audio) === null || _a === undefined ? undefined : _a.setSinkId) === null || _b === undefined ? undefined : _b.call(_a, id)) === null || _c === undefined ? undefined : _c.catch((err) => {
        logger.error('[dyte-notifications] setSinkId() error\n', err);
      }));
    }
  }

  const dyteChannelHeaderCss = "header{box-sizing:border-box;height:var(--dyte-space-16, 64px);width:100%;padding:var(--dyte-space-4, 16px);display:flex;justify-content:space-between;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));border-left-width:var(--dyte-border-width-none, 0);border-right-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-sm, 1px);border-top-width:var(--dyte-border-width-none, 0);border-style:solid;--tw-border-opacity:1;border-bottom-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-border-opacity))}header.searching{justify-content:flex-end}header.searching .channel-details{display:none}header .channel-details{display:flex;flex-grow:1;flex-direction:column;justify-content:center;height:var(--dyte-space-9, 36px);width:var(--dyte-space-1, 4px)}header .channel-details .name{font-weight:500}header .channel-details .members{margin-top:var(--dyte-space-0\\.5, 2px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:12px;color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}header .channel-tools{display:flex;flex-shrink:0;justify-content:flex-end;gap:var(--dyte-space-1, 4px);min-width:var(--dyte-space-24, 96px)}header .channel-tools dyte-tooltip{height:var(--dyte-space-8, 32px);width:var(--dyte-space-10, 40px);display:flex}header .search-input{height:var(--dyte-space-8, 32px);width:var(--dyte-space-48, 192px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}header .name{font-size:16px}header .br-primary-btn{background-color:transparent}header .br-primary-btn:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}@media (orientation: landscape) and (min-width: 400px){header.searching .channel-details{display:flex}}.back-btn{margin-right:var(--dyte-space-3, 12px)}";

  const DyteChannelHeader = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.search = createEvent(this, "search", 7);
      this.searchDismissed = createEvent(this, "searchDismissed", 7);
      this.back = createEvent(this, "back", 7);
      this.meeting = undefined;
      this.channel = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showChannelDetailsDialog = false;
      this.showSearchBar = false;
      this.members = [];
      this.showBackButton = false;
    }
    onChannelChanged() {
      if (this.$searchInput)
        this.$searchInput.value = '';
      this.showSearchBar = false;
      if (!this.channel.isDirectMessage) {
        this.meeting.chat.getChannelMembers(this.channel.id).then((members) => {
          this.members = members;
        });
      }
    }
    connectedCallback() {
      this.onChannelChanged();
    }
    renderChannelDetails() {
      return (h("dyte-dialog", { open: true, onDyteDialogClose: () => {
          this.showChannelDetailsDialog = false;
        }, iconPack: this.iconPack, t: this.t }, h("dyte-channel-details", { members: this.members, channel: this.channel })));
    }
    render() {
      if (!this.channel) {
        return null;
      }
      return (h(Host, null, this.showChannelDetailsDialog && this.renderChannelDetails(), h("header", { class: {
          searching: this.showSearchBar,
        } }, this.showBackButton && (h("dyte-button", { kind: "icon", variant: "secondary", class: "back-btn", onClick: () => {
          this.back.emit();
        } }, h("dyte-icon", { icon: this.iconPack.chevron_left }))), h("div", { class: "channel-details" }, h("span", { class: "name" }, this.channel.displayName), !this.channel.isDirectMessage && (h("span", { class: "members" }, this.members.map((member) => member.name).join(', ')))), h("div", { class: "channel-tools" }, !this.channel.isDirectMessage && (h("dyte-tooltip", { label: this.t('chat.channel_members'), iconPack: this.iconPack, t: this.t, variant: "primary" }, h("dyte-button", { iconPack: this.iconPack, t: this.t, kind: "button", variant: "secondary", size: "md", onClick: () => {
          this.showChannelDetailsDialog = !this.showChannelDetailsDialog;
        }, class: "br-primary-btn" }, h("dyte-icon", { icon: this.iconPack.people, iconPack: this.iconPack, t: this.t }))))))));
    }
    static get watchers() { return {
      "channel": ["onChannelChanged"]
    }; }
  };
  DyteChannelHeader.style = dyteChannelHeaderCss;

  const dyteChannelSelectorViewCss = ".scrollbar {\n  /* For Firefox */\n  scrollbar-width: thin;\n  scrollbar-color: var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent);\n}\n\n/* For WebKit */\n.scrollbar::-webkit-scrollbar {\n  height: var(--dyte-space-1\\.5, 6px);\n  width: var(--dyte-space-1\\.5, 6px);\n  border-radius: 9999px;\n  background-color: var(--dyte-scrollbar-background, transparent);\n}\n\n.scrollbar::-webkit-scrollbar-thumb {\n  border-radius: 9999px;\n  background-color: var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)));\n}\n\n\n:host {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));\n  position: relative;\n  z-index: 10;\n  height: var(--dyte-space-12, 48px);\n  min-height: 48px;\n}\n\n.dropdown-trigger {\n  height: 100%;\n  width: 100%;\n  border-width: var(--dyte-border-width-none, 0);\n  border-style: none;\n  padding: var(--dyte-space-4, 16px);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));\n  font-size: 14px;\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n  cursor: pointer;\n  position: absolute;\n  z-index: 20;\n}\n\n.dropdown-trigger span {\n  display: flex;\n  flex: 1 1 0%;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.dropdown-trigger dyte-icon {\n  margin-left: var(--dyte-space-1, 4px);\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n  flex-shrink: 0;\n}\n\n@container chatcontainer (height < 360px) {\n  .dropdown-trigger {\n    padding: var(--dyte-space-2, 8px);\n  }\n  .dropdown {\n    top: var(--dyte-space-8, 32px) !important;\n  }\n  .search-container {\n    padding-left: var(--dyte-space-0, 0px) !important;\n    padding-right: var(--dyte-space-0, 0px) !important;\n    padding-top: var(--dyte-space-0, 0px) !important;\n    padding-bottom: var(--dyte-space-0, 0px) !important;\n  }\n  input {\n    height: var(--dyte-space-8, 32px) !important;\n    border-radius: var(--dyte-border-radius-none, 0) !important;\n  }\n  .channel {\n    height: var(--dyte-space-8, 32px) !important;\n    border-radius: var(--dyte-border-radius-sm, 4px) !important;\n  }\n  .avatar-icon {\n    height: var(--dyte-space-3, 12px) !important;\n    width: var(--dyte-space-3, 12px) !important;\n    padding: var(--dyte-space-1, 4px) !important;\n  }\n\n  dyte-avatar {\n    height: var(--dyte-space-5, 20px) !important;\n    width: var(--dyte-space-5, 20px) !important;\n  }\n}\n\n.dropdown {\n  position: absolute;\n  width: 100%;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));\n  top: var(--dyte-space-12, 48px);\n  z-index: 10;\n  animation: 0.3s slide-down ease;\n}\n\n.dropdown .channels-container {\n  max-height: var(--dyte-space-80, 320px);\n}\n\n.list {\n  display: flex;\n  flex-direction: column;\n}\n\n.list .channel .channel-data {\n  align-items: flex-start;\n}\n\n.unread-count {\n  display: flex;\n  justify-content: center;\n  height: var(--dyte-space-5, 20px);\n  min-width: var(--dyte-space-3, 12px);\n  border-radius: 9999px;\n  padding-left: var(--dyte-space-1, 4px);\n  padding-right: var(--dyte-space-1, 4px);\n  font-size: 12px;\n  line-height: 1.25rem;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));\n}\n\ninput {\n  height: var(--dyte-space-9, 36px);\n  width: 100%;\n  padding-left: var(--dyte-space-3, 12px);\n  padding-right: var(--dyte-space-3, 12px);\n  box-sizing: border-box;\n  border-width: var(--dyte-border-width-none, 0);\n  border-style: none;\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  border-radius: var(--dyte-border-radius-sm, 4px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n}\n\n.search-container {\n  display: flex;\n  flex-shrink: 0;\n  flex-grow: 0;\n  flex-basis: auto;\n  align-items: center;\n  padding-top: var(--dyte-space-3, 12px);\n  padding-bottom: var(--dyte-space-3, 12px);\n  padding-left: var(--dyte-space-2, 8px);\n  padding-right: var(--dyte-space-2, 8px);\n  border-bottom: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-700, 44 44 44));\n}\n\n.search-container dyte-icon {\n  margin-left: calc(var(--dyte-space-8, 32px) * -1);\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n  color: rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76));\n}\n\n.channels-container {\n  display: flex;\n  flex-direction: column;\n  gap: var(--dyte-space-1, 4px);\n  padding: var(--dyte-space-2, 8px);\n  flex: 1 1 auto;\n  overflow-y: auto;\n}\n\n.channel {\n  flex-shrink: 0;\n  box-sizing: border-box;\n  border-width: var(--dyte-border-width-none, 0);\n  border-style: none;\n  background-color: transparent;\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  cursor: pointer;\n  border-radius: var(--dyte-border-radius-md, 8px);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: var(--dyte-space-2, 8px);\n  height: var(--dyte-space-16, 64px);\n  width: 100%;\n  padding-left: var(--dyte-space-2, 8px);\n  padding-right: var(--dyte-space-3, 12px);\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n  transition-property: color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n\n.channel:hover {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));\n}\n\n.channel .channel-data {\n  flex: 1 1 0%;\n  align-items: center;\n  justify-content: space-between;\n  display: flex;\n  gap: var(--dyte-space-2, 8px);\n}\n\n.channel .name {\n  font-size: 16px;\n}\n\n.channel .name, \n  .channel .last-message {\n  max-width: var(--dyte-space-40, 160px);\n  text-align: left;\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 1;\n}\n\n.channel .no-message {\n  font-style: italic;\n}\n\n.channel dyte-avatar {\n  height: var(--dyte-space-12, 48px);\n  width: var(--dyte-space-12, 48px);\n  overflow: clip;\n  border-radius: 9999px;\n  font-size: 14px;\n}\n\n.channel .avatar-icon {\n  height: var(--dyte-space-6, 24px);\n  width: var(--dyte-space-6, 24px);\n  padding: var(--dyte-space-3, 12px);\n  color: rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));\n  overflow: clip;\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n}\n\n.channel time, \n  .channel .last-message {\n  font-size: 12px;\n  color: rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76));\n}\n\n.channel.active {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));\n}\n\n.channel.active .unread-count {\n  background-color: rgb(var(--dyte-colors-text-on-brand-800, var(--dyte-colors-text-800, 255 255 255 / 0.76)));\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity));\n}\n\n.channel.active time {\n  color: rgb(var(--dyte-colors-text-on-brand-800, var(--dyte-colors-text-800, 255 255 255 / 0.76)));\n}\n\n.channel.active .last-message {\n  color: rgb(var(--dyte-colors-text-on-brand-700, var(--dyte-colors-text-700, 255 255 255 / 0.64)));\n}\n\n.channel.active dyte-avatar {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));\n}\n\n.col {\n  gap: var(--dyte-space-1, 4px);\n  display: flex;\n  flex-direction: column;\n}\n\n.channel-meta {\n  flex-shrink: 0;\n  align-items: flex-end;\n}\n\n@keyframes slide-down {\n  from {\n    transform: translateY(-50px);\n  }\n  to {\n    transform: translateY(0%);\n  }\n}\n";

  const DyteChannelSelectorView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.channelChange = createEvent(this, "channelChange", 7);
      this.calculateListHeight = debounce(() => {
        if (this.viewAs === 'list' && this.$listEl) {
          let height = 0;
          const slotEl = this.$el.shadowRoot.querySelector('slot[name="header"]');
          if (slotEl) {
            slotEl.assignedElements().forEach((e) => (height += e.offsetHeight));
          }
          if (this.$searchEl) {
            height += this.$searchEl.offsetHeight;
          }
          this.$listEl.style.height = `${window.innerHeight - height - 16}px`;
        }
      }, 60);
      this.getFilteredChannels = () => {
        if (this.searchQuery.trim() === '') {
          return this.channels;
        }
        return this.channels.filter((channel) => {
          return channel['name'].toLowerCase().includes(this.searchQuery.toLowerCase());
        });
      };
      this.toggleDropdown = () => {
        this.showDropdown = !this.showDropdown;
      };
      this.getChannelById = (id) => {
        return this.channels.find((channel) => channel.id === id);
      };
      this.getTotalUnreads = () => {
        return this.channels.reduce((acc, curr) => {
          return acc + curr.unreadCount;
        }, 0);
      };
      this.onChannelClickHandler = (channel) => {
        this.channelChange.emit(channel);
        if (this.viewAs === 'dropdown') {
          this.showDropdown = false;
        }
      };
      this.channels = undefined;
      this.selectedChannelId = undefined;
      this.disableSearch = false;
      this.hideAvatar = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.viewAs = 'list';
      this.searchQuery = '';
      this.showDropdown = false;
    }
    connectedCallback() {
      this.resizeObserver = new ResizeObserver(this.calculateListHeight);
    }
    componentDidLoad() {
      this.resizeObserver.observe(this.$el);
      this.calculateListHeight();
    }
    disconnectedCallback() {
      var _a;
      (_a = this.resizeObserver) === null || _a === undefined ? undefined : _a.disconnect();
      this.calculateListHeight.cancel();
    }
    getTimeLabel(messageDate) {
      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(today.getDate() - 1);
      const firstDayOfWeek = new Date(today);
      firstDayOfWeek.setDate(today.getDate() - today.getDay() - 1);
      if (messageDate.toDateString() === today.toDateString()) {
        return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      else if (messageDate.toDateString() === yesterday.toDateString()) {
        return this.t('date.yesteday');
      }
      else if (messageDate > firstDayOfWeek) {
        const weekdays = [
          'date.sunday',
          'date.monday',
          'date.tuesday',
          'date.wednesday',
          'date.thursday',
          'date.friday',
          'date.saturday',
        ];
        return this.t(weekdays[messageDate.getDay()]);
      }
      else {
        return Intl.DateTimeFormat([], {
          day: '2-digit',
          month: '2-digit',
          year: '2-digit',
        }).format(messageDate);
      }
    }
    render() {
      const filteredChannels = this.getFilteredChannels();
      const shouldShowDropdown = this.viewAs === 'list' || (this.viewAs === 'dropdown' && this.showDropdown);
      return (h(Host, null, this.viewAs === 'list' && h("slot", { name: "header" }), shouldShowDropdown && (h("div", { class: {
          dropdown: this.viewAs === 'dropdown',
          scrollbar: this.viewAs === 'dropdown',
          list: this.viewAs === 'list',
        } }, !this.disableSearch && (h("div", { class: "search-container", ref: (el) => (this.$searchEl = el) }, h("input", { type: "text", placeholder: this.t('chat.search_conversations'), value: this.searchQuery, onInput: (e) => (this.searchQuery = e.target.value) }), h("dyte-icon", { icon: this.iconPack.search }))), h("div", { class: "channels-container scrollbar", ref: (el) => (this.$listEl = el) }, filteredChannels.map((channel) => {
        return (h("button", { class: { channel: true, active: this.selectedChannelId === channel.id }, onClick: () => this.onChannelClickHandler(channel) }, !this.hideAvatar && (h("div", null, channel.icon ? (h("dyte-icon", { class: "avatar-icon", icon: this.iconPack[channel.icon] })) : (h("dyte-avatar", { participant: {
            name: channel.name,
            picture: channel.avatarUrl,
          } })))), h("div", { class: "channel-data" }, h("div", { class: "col" }, h("div", { class: "name" }, channel.name), channel.latestMessage && (h("div", { class: {
            'last-message': true,
            'no-message': !channel.latestMessage,
          } }, h("dyte-text-message-view", { isMarkdown: true, text: channel.latestMessage })))), h("div", { class: "col channel-meta" }, channel.latestMessageTime && (h("time", { class: "time" }, this.getTimeLabel(channel.latestMessageTime))), channel.unreadCount > 0 && (h("div", { class: "unread-count" }, channel.unreadCount))))));
      })))), this.viewAs === 'dropdown' && (h("button", { class: "dropdown-trigger", onClick: this.toggleDropdown }, h("span", null, this.selectedChannelId &&
        `${this.t('to')} ${this.getChannelById(this.selectedChannelId).name}`, this.getTotalUnreads() > 0 && (h("div", { class: "unread-count" }, this.getTotalUnreads()))), h("dyte-icon", { icon: this.showDropdown ? this.iconPack.chevron_up : this.iconPack.chevron_down })))));
    }
    get $el() { return getElement(this); }
  };
  DyteChannelSelectorView.style = dyteChannelSelectorViewCss;

  const dyteChatComposerViewCss = ":host {\n  display: flex;\n  flex-direction: column;\n  font-family: var(--dyte-font-family, sans-serif);\n  font-size: 14px;\n  position: relative;\n}\n\n.quoted-message-container {\n  margin-bottom: var(--dyte-space-2, 8px);\n  display: flex;\n  justify-content: space-between;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n  border-radius: var(--dyte-border-radius-md, 8px);\n  border: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));\n}\n\n.quoted-message-container .quoted-message {\n  flex: 1 1 0%;\n  padding: var(--dyte-space-2, 8px);\n  border-radius: var(--dyte-border-radius-md, 8px);\n  max-height: var(--dyte-space-24, 96px);\n  overflow-y: auto;\n  word-break: break-all;\n}\n\n.quoted-message-container .quoted-message blockquote {\n  display: none;\n}\n\n.quoted-message-container dyte-icon.dismiss {\n  margin-left: auto;\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n  padding: var(--dyte-space-2, 8px);\n  border-radius: var(--dyte-border-radius-md, 8px);\n  color: rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));\n}\n\n.quoted-message-container dyte-icon.dismiss:hover {\n  cursor: pointer;\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n}\n\n.quoted-message-container dyte-icon.dismiss {\n  transition-property: color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n\n.composer-container {\n  position: relative;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));\n  border-radius: var(--dyte-border-radius-md, 8px);\n  overflow: hidden;\n  border: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));\n}\n\n.composer-container > .composers {\n    min-height: 60px;\n  }\n\n@container chatcontainer (height < 360px) {\n    .composer-container > .composers {\n      min-height: 30px;\n    }\n}\n\n.chat-buttons {\n  padding: var(--dyte-space-3, 12px);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255));\n}\n\n.chat-buttons .right {\n  z-index: 10;\n}\n\n.chat-buttons .right .edit-buttons {\n  display: flex;\n  gap: var(--dyte-space-2, 8px);\n}\n\n.chat-buttons > div {\n  display: flex;\n  align-items: center;\n}\n\ndyte-emoji-picker {\n  z-index: 20;\n  position: absolute;\n  top: calc(var(--dyte-space-72, 288px) * -1);\n  border-top: var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));\n  animation: 0.3s slide-up ease;\n}\n\n@keyframes slide-up {\n  from {\n    transform: translateY(100%);\n  }\n  to {\n    transform: translateY(0%);\n  }\n}\n";

  const messageLimits = {
    messagesSent: 0,
    startTime: 0,
  };
  const DyteChatComposerView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onNewMessage = createEvent(this, "newMessage", 7);
      this.onEditMessage = createEvent(this, "editMessage", 7);
      this.onEditCancel = createEvent(this, "editCancel", 7);
      this.onQuotedMessageDismiss = createEvent(this, "quotedMessageDismiss", 7);
      this.textMessage = '';
      this.sendFile = () => {
        if (!this.canSendFiles) {
          return;
        }
        if (this.fileToUpload.type === 'image') {
          this.onNewMessage.emit({
            type: 'image',
            image: this.fileToUpload.file,
          });
        }
        else {
          this.onNewMessage.emit({ type: 'file', file: this.fileToUpload.file });
        }
        this.fileToUpload = null;
      };
      this.handleSendMessage = () => {
        if (!this.canSendTextMessage || this.rateLimitsBreached) {
          return;
        }
        if (this.fileToUpload !== null) {
          this.sendFile();
          return;
        }
        const message = this.textMessage;
        const currentTime = Date.now();
        if (currentTime - messageLimits.startTime > this.rateLimits.period * 1000) {
          messageLimits.startTime = currentTime;
          messageLimits.messagesSent = 0;
        }
        messageLimits.messagesSent += 1;
        this.checkRateLimitBreached(currentTime);
        if (message.length > 0) {
          if (this.quotedMessage.length !== 0) {
            this.onNewMessage.emit({
              type: 'text',
              message,
            });
          }
          else {
            this.onNewMessage.emit({ type: 'text', message });
          }
          this.cleanup();
        }
      };
      this.handleEditMessage = () => {
        this.onEditMessage.emit(this.textMessage);
        this.cleanup();
      };
      this.handleEditCancel = () => {
        this.onEditCancel.emit();
        this.cleanup();
      };
      this.onTextChangeHandler = (event) => {
        var _a;
        this.textMessage = event.detail;
        if (this.textMessage.length >= ((_a = this.maxLength) !== null && _a !== undefined ? _a : MAX_TEXT_LENGTH)) {
          this.disableSendButton = true;
        }
        else if (this.disableSendButton) {
          this.disableSendButton = false;
        }
        gracefulStorage$1.setItem(this.storageKey, event.detail);
      };
      this.onKeyDownHandler = (event) => {
        if (event.key === 'Enter' && event.shiftKey) {
          return;
        }
        if (this.disableSendButton) {
          return;
        }
        if (event.key === 'Enter') {
          event.preventDefault();
          if (this.isEditing) {
            this.handleEditMessage();
          }
          else {
            this.handleSendMessage();
          }
        }
      };
      this.onFileUploadHandler = (type, file) => {
        this.fileToUpload = { type, file };
      };
      this.onQuotedMessageDismissHandler = () => {
        this.onQuotedMessageDismiss.emit();
      };
      this.cleanup = () => {
        this.textMessage = '';
        this.fileToUpload = null;
        gracefulStorage$1.setItem(this.storageKey, '');
        this.$textComposer.setText('', true);
        this.isEmojiPickerOpen = false;
      };
      this.canSendTextMessage = true;
      this.canSendFiles = true;
      this.message = '';
      this.quotedMessage = '';
      this.storageKey = 'dyte-text-message';
      this.inputTextPlaceholder = 'Enter your message';
      this.isEditing = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.maxLength = undefined;
      this.disableEmojiPicker = false;
      this.rateLimits = {
        period: 60,
        maxInvocations: 60,
      };
      this.fileToUpload = null;
      this.isEmojiPickerOpen = false;
      this.disableSendButton = false;
      this.rateLimitsBreached = false;
      this.onKeyDownHandler = this.onKeyDownHandler.bind(this);
    }
    connectedCallback() {
      this.textMessage = this.message || gracefulStorage$1.getItem(this.storageKey) || '';
      this.checkRateLimitBreached(Date.now());
    }
    componentWillUpdate() {
      this.textMessage = this.message || gracefulStorage$1.getItem(this.storageKey) || '';
    }
    componentDidLoad() {
      if (this.message) {
        writeTask(() => this.$textComposer.setText(this.message, true));
      }
    }
    checkRateLimitBreached(currentTime) {
      // Check if the function call is within limits
      if (messageLimits.messagesSent >= this.rateLimits.maxInvocations) {
        this.disableSendButton = true;
        this.rateLimitsBreached = true;
        const timeRemainingForReset = currentTime - messageLimits.startTime + this.rateLimits.period * 1000;
        setTimeout(() => {
          messageLimits.messagesSent = 0;
          messageLimits.startTime = Date.now();
          this.disableSendButton = false;
          this.rateLimitsBreached = false;
        }, timeRemainingForReset);
      }
    }
    render() {
      var _a;
      const uiProps = { iconPack: this.iconPack, t: this.t };
      return (h(Host, null, this.canSendTextMessage && this.isEmojiPickerOpen && (h("dyte-emoji-picker", Object.assign({ part: "emoji-picker", onPickerClose: () => {
          this.isEmojiPickerOpen = false;
        }, onDyteEmojiClicked: (e) => {
          this.textMessage += e.detail;
          this.$textComposer.setText(this.textMessage, true);
        } }, uiProps))), h("slot", { name: "chat-addon" }), this.quotedMessage && this.quotedMessage.length !== 0 && (h("div", { class: "quoted-message-container", part: "quoted-message-container" }, h("div", { class: "quoted-message scrollbar" }, h("dyte-text-message-view", { text: this.quotedMessage, isMarkdown: true })), h("div", null, h("dyte-icon", Object.assign({ "aria-label": this.t('dismiss'), class: "dismiss", icon: this.iconPack.dismiss, onClick: this.onQuotedMessageDismissHandler }, uiProps))))), h("div", { class: "composer-container" }, h("div", { class: "composers" }, this.fileToUpload && (h("dyte-draft-attachment-view", Object.assign({}, uiProps, { attachment: this.fileToUpload, onDeleteAttachment: () => (this.fileToUpload = null) }))), !this.fileToUpload && (h("dyte-text-composer-view", { value: this.textMessage, placeholder: this.inputTextPlaceholder, onTextChange: this.onTextChangeHandler, keyDownHandler: this.onKeyDownHandler, maxLength: (_a = this.maxLength) !== null && _a !== undefined ? _a : MAX_TEXT_LENGTH, rateLimitBreached: this.rateLimitsBreached, t: this.t, iconPack: this.iconPack, ref: (el) => (this.$textComposer = el) }))), h("div", { class: "chat-buttons", part: "chat-buttons" }, h("div", { class: "left", part: "chat-buttons-left" }, !this.fileToUpload && !this.isEditing && (h("div", null, this.canSendFiles && [
        h("dyte-file-picker-button", Object.assign({}, uiProps, { onFileChange: (event) => this.onFileUploadHandler('file', event.detail) })),
        h("dyte-file-picker-button", Object.assign({ filter: "image/*", label: this.t('chat.send_img'), icon: "image", onFileChange: (event) => this.onFileUploadHandler('image', event.detail) }, uiProps)),
      ], this.canSendTextMessage && !this.disableEmojiPicker && (h("dyte-emoji-picker-button", Object.assign({ isActive: this.isEmojiPickerOpen, onClick: () => {
          this.isEmojiPickerOpen = !this.isEmojiPickerOpen;
        } }, uiProps))), h("slot", { name: "chat-buttons" })))), h("div", { class: "right", part: "chat-buttons-right" }, !this.isEditing && (h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.send_msg'), delay: 2000 }, uiProps), h("dyte-button", Object.assign({ kind: "icon", disabled: this.disableSendButton, onClick: () => this.handleSendMessage(), title: this.t('chat.send_msg') }, uiProps), h("dyte-icon", { icon: this.iconPack.send })))), this.isEditing && (h("div", { class: "edit-buttons" }, h("dyte-tooltip", Object.assign({ variant: "secondary", label: this.t('cancel'), delay: 2000 }, uiProps), h("dyte-button", Object.assign({ kind: "icon", variant: "secondary", onClick: () => this.handleEditCancel(), title: this.t('cancel') }, uiProps), h("dyte-icon", { icon: this.iconPack.dismiss }))), h("dyte-tooltip", Object.assign({ variant: "primary", label: this.t('chat.update_msg'), delay: 2000 }, uiProps), h("dyte-button", Object.assign({ kind: "icon", onClick: () => this.handleEditMessage(), title: this.t('chat.send_msg') }, uiProps), h("dyte-icon", { icon: this.iconPack.checkmark }))))))))));
    }
  };
  DyteChatComposerView.style = dyteChatComposerViewCss;

  const dyteChatMessagesUiCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));word-break:break-word}.chat-container{box-sizing:border-box;display:flex;flex-direction:column;padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);flex:1 0 0px;overflow-y:scroll}.chat-container .spacer{flex:1 1 auto}.chat-container .chat{flex:0 0 auto}.file-picker{display:none}.chat .head{display:flex;align-items:center}.chat .head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.chat .head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat .body{margin-top:var(--dyte-space-2, 8px);overflow-wrap:break-word;line-height:1.375}.chat .body .emoji{font-size:24px}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-message-view{margin-top:var(--dyte-space-4, 16px);display:block;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}dyte-message-view::part(message){flex-grow:1}*[is-continued] dyte-message-view{margin-top:var(--dyte-space-1, 4px)}.pinned .message-wrapper{position:relative}.pinned .pin-button{position:absolute;right:var(--dyte-space-4, 16px);top:calc(var(--dyte-space-4, 16px) * -1);display:flex;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.pinned .pin-button:hover dyte-button{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}.pinned dyte-message-view{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.new-chat-marker{display:flex;width:100%;align-items:center;gap:var(--dyte-space-2, 8px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.new-chat-marker::before{content:'';height:1px;flex:1 1 0%;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.show-new-messages-ctr{pointer-events:none;display:flex;justify-content:flex-end;padding:var(--dyte-space-3, 12px);z-index:0;margin-top:calc(var(--dyte-space-14, 56px) * -1)}.show-new-messages{pointer-events:auto;--tw-translate-y:var(--dyte-space-16, 64px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}";

  const DyteChatMessagesUi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onPinMessage = createEvent(this, "pinMessage", 7);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.observingEl = [];
      this.autoScrollEnabled = true;
      this.onScroll = (e) => {
        const target = e.target;
        writeTask(() => {
          const { scrollTop, clientHeight, scrollHeight } = target;
          const fromTop = scrollTop + clientHeight;
          if (fromTop + 10 >= scrollHeight) {
            // at bottom
            this.autoScrollEnabled = true;
            this.showLatestMessageButton = false;
          }
          else {
            // not at bottom
            this.autoScrollEnabled = false;
          }
        });
      };
      this.scrollToBottom = () => {
        smoothScrollToBottom(this.$chat);
      };
      this.observeMessage = (el) => {
        if (el) {
          this.observingEl.push(el);
        }
        try {
          this.intersectionObserver.observe(el);
        }
        catch (_a) { }
      };
      this.getMessageActions = (message) => {
        const actions = [];
        if (!message.pinned && this.canPinMessages) {
          actions.push({
            id: 'pin_message',
            label: this.t('pin'),
            icon: this.iconPack.pin,
          });
        }
        return actions;
      };
      this.onMessageActionHandler = (actionId, message) => {
        switch (actionId) {
          case 'pin_message':
            this.onPinMessage.emit(message);
            break;
        }
      };
      this.selectedGroup = undefined;
      this.messages = [];
      this.selfUserId = undefined;
      this.canPinMessages = false;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.now = new Date();
      this.showLatestMessageButton = false;
    }
    connectedCallback() {
      var _a;
      this.lastReadTimestamp = (_a = chatUnreadTimestamps['everyone']) !== null && _a !== undefined ? _a : new Date('0001-01-01T00:00:00Z');
      this.intersectionObserver = new IntersectionObserver((entries) => {
        if (!document.hasFocus())
          return;
        writeTask(() => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              const currTimestamp = parseInt(entry.target.getAttribute('data-timestamp'));
              if (currTimestamp > this.lastReadTimestamp.getTime()) {
                // this.lastReadTimestamp = new Date();
                chatUnreadTimestamps[this.selectedGroup] = new Date();
              }
            }
          }
        });
      });
      // update current time every minute
      const updateNow = () => {
        this.now = new Date();
        this.timeout = setTimeout(() => {
          if (this.request != null) {
            this.request = requestAnimationFrame(updateNow);
          }
        }, 60 * 1000);
      };
      this.request = requestAnimationFrame(updateNow);
      this.chatChanged(this.messages);
    }
    componentDidLoad() {
      this.$chat.addEventListener('scroll', this.onScroll);
      this.$chat.scrollTop = this.$chat.scrollHeight;
    }
    componentDidRender() {
      if (this.autoScrollEnabled) {
        smoothScrollToBottom(this.$chat);
      }
      else if (this.autoScrollEnabled == null) {
        // scroll to bottom on first render
        smoothScrollToBottom(this.$chat, false);
      }
    }
    chatChanged(messages) {
      if (this.$chat == null)
        return;
      if (this.autoScrollEnabled || this.$chat.clientHeight === this.$chat.scrollHeight)
        return;
      for (let i = messages.length - 1; i >= 0; i--) {
        if (messages[i].message.time > this.lastReadTimestamp &&
          messages[i].message.userId !== this.selfUserId) {
          // show latest message button when you have new messages
          // and chat container is scrollable and autoscroll is not enabled
          this.showLatestMessageButton = true;
          break;
        }
      }
    }
    selectedBucketChanged() {
      this.autoScrollEnabled = undefined;
      this.observingEl.forEach((el) => {
        this.intersectionObserver.unobserve(el);
      });
      this.observingEl = [];
    }
    disconnectedCallback() {
      this.$chat.removeEventListener('scroll', this.onScroll);
      this.intersectionObserver.disconnect();
      clearTimeout(this.timeout);
      cancelAnimationFrame(this.request);
    }
    render() {
      var _a;
      let prevMessage = null;
      let reachedFirstUnread = false;
      return (h(Host, null, h("div", { class: "chat-container scrollbar", ref: (el) => (this.$chat = el), part: "container" }, h("div", { class: "spacer", part: "spacer" }), h("div", { class: "chat", part: "chat" }, (_a = this.messages) === null || _a === undefined ? undefined : _a.map((item) => {
        if (item.type === 'chat') {
          const { message } = item;
          const isSelfMessage = message.userId === this.selfUserId;
          const isUnread = !isSelfMessage &&
            !this.autoScrollEnabled &&
            !reachedFirstUnread &&
            message.time > this.lastReadTimestamp;
          if (isUnread)
            reachedFirstUnread = isUnread;
          const isContinued = !isUnread &&
            message.userId === (prevMessage === null || prevMessage === undefined ? undefined : prevMessage.userId) &&
            differenceInMinutes(message.time, prevMessage === null || prevMessage === undefined ? undefined : prevMessage.time) < 2;
          prevMessage = message;
          return (h("div", { "is-continued": isContinued, key: item.message.id, ref: this.observeMessage, "data-timestamp": message.time.getTime(), class: message.pinned ? 'pinned' : '' }, isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("div", { class: "message-wrapper" }, h("dyte-message-view", { time: message.time, actions: this.getMessageActions(message), authorName: message.displayName, hideAuthorName: true, hideAvatar: true, hideMetadata: true, viewType: 'incoming', variant: "bubble", onAction: (event) => this.onMessageActionHandler(event.detail, message) }, h("div", null, !isContinued && (h("div", { class: "head" }, h("div", { class: "name" }, message.displayName), !!message.time && (h("div", { class: "time", title: formatDateTime(message.time) }, elapsedDuration(message.time, new Date(Date.now())))))), h("div", { class: "body" }, message.type === 'text' && (h("dyte-text-message-view", { text: message.message, isMarkdown: true })), message.type === 'file' && (h("dyte-file-message-view", { name: message.name, url: message.link, size: message.size })), message.type === 'image' && (h("dyte-image-message-view", { url: message.link, onPreview: () => {
              this.stateUpdate.emit({ image: message });
              state.image = message;
            } }))))), message.pinned && (h("div", { class: "pin-button", part: "pin-button" }, h("dyte-tooltip", { label: this.t('unpin'), iconPack: this.iconPack, t: this.t }, h("dyte-button", { kind: "icon", variant: "ghost", onClick: () => this.onMessageActionHandler('pin_message', message), iconPack: this.iconPack, t: this.t, disabled: !this.canPinMessages }, h("dyte-icon", { icon: this.iconPack.pin, iconPack: this.iconPack, t: this.t, size: "sm" }))))))));
        }
        return null;
      }))), h("div", { class: "show-new-messages-ctr" }, h("dyte-button", { class: {
          'show-new-messages': true,
          active: this.showLatestMessageButton,
        }, kind: "icon", part: "show-new-messages", onClick: this.scrollToBottom, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t })))));
    }
    static get watchers() { return {
      "messages": ["chatChanged"],
      "selectedGroup": ["selectedBucketChanged"]
    }; }
  };
  DyteChatMessagesUi.style = dyteChatMessagesUiCss;

  const dyteChatMessagesUiPaginatedCss = ":host{display:flex;flex-direction:column;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));flex:1 0 0px}";

  const DyteChatMessagesUiPaginated = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.editMessageInit = createEvent(this, "editMessageInit", 7);
      this.onPinMessage = createEvent(this, "pinMessage", 7);
      this.onDeleteMessage = createEvent(this, "deleteMessage", 7);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.pageSize = 25;
      this.lastReadMessageIndex = -1;
      this.permissionsUpdateListener = () => {
        this.permissionsChanged = !this.permissionsChanged;
      };
      this.maybeMarkChannelAsRead = (messages) => {
        if (!this.selectedChannelId)
          return;
        if (messages.length === 0)
          return;
        if (this.lastReadMessageIndex !== -1)
          return;
        const latestMsg = messages.at(0).time > messages.at(-1).time ? messages.at(0) : messages.at(-1);
        if (!latestMsg.channelIndex)
          return;
        this.lastReadMessageIndex = parseInt(latestMsg.channelIndex, 10);
        this.meeting.chat.markLastReadMessage(this.selectedChannelId, latestMsg);
      };
      this.getChatMessages = async (timestamp, size, reversed) => {
        const { messages } = await this.meeting.chat.getMessages(timestamp, size, reversed, undefined, this.selectedChannelId);
        this.maybeMarkChannelAsRead(messages);
        return messages;
      };
      this.createChatNodes = (data) => {
        /**
         * NOTE(callmetarush): When between pages the message's isContinued
         * will fail in current implementation
         */
        return data.map((message, idx) => {
          var _a;
          const isContinued = message.userId === ((_a = data[idx - 1]) === null || _a === undefined ? undefined : _a.userId);
          return this.createChatNode(message, isContinued);
        });
      };
      this.disconnectMeeting = (meeting) => {
        var _a, _b;
        (_a = meeting === null || meeting === undefined ? undefined : meeting.chat) === null || _a === undefined ? undefined : _a.removeListener('chatUpdate', this.chatUpdateListener);
        (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
      };
      this.getMessageActions = (message) => {
        const actions = [];
        // const isSelf = this.meeting.self.userId === message.userId;
        // const chatMessagePermissions = this.meeting.self.permissions?.chatMessage;
        // const canEdit =
        //   chatMessagePermissions === undefined
        //     ? isSelf
        //     : chatMessagePermissions.canEdit === 'ALL' ||
        //       (chatMessagePermissions.canEdit === 'SELF' && isSelf);
        // const canDelete =
        //   chatMessagePermissions === undefined
        //     ? isSelf
        //     : chatMessagePermissions.canDelete === 'ALL' ||
        //       (chatMessagePermissions.canDelete === 'SELF' && isSelf);
        if (this.meeting.self.permissions.pinParticipant) {
          actions.push({
            id: 'pin_message',
            label: message.pinned ? this.t('unpin') : this.t('pin'),
            icon: this.iconPack.pin,
          });
        }
        // if (canDelete) {
        //   actions.push({
        //     id: 'delete_message',
        //     label: this.t('chat.delete_msg'),
        //     icon: this.iconPack.delete,
        //   });
        // }
        return actions;
      };
      this.onMessageActionHandler = (actionId, message) => {
        switch (actionId) {
          case 'pin_message':
            this.onPinMessage.emit(message);
            break;
          case 'delete_message':
            this.onDeleteMessage.emit(message);
            break;
        }
      };
      this.createChatNode = (message, isContinued) => {
        var _a, _b, _c, _d;
        if (message.targetUserIds.length !== 0)
          return null; // don't render private messages
        let displayPicture;
        if (this.meeting.meta.viewType === 'CHAT') {
          displayPicture = (_a = this.meeting.participants.all
            .toArray()
            .find((p) => p.userId === message.userId)) === null || _a === undefined ? undefined : _a.picture;
        }
        else {
          if (this.meeting.self.userId === message.userId) {
            displayPicture = this.meeting.self.picture;
          }
          else {
            displayPicture =
              (_c = (_b = this.meeting.participants.joined
                .toArray()
                .find((member) => member.userId === message.userId)) === null || _b === undefined ? undefined : _b.picture) !== null && _c !== undefined ? _c : (_d = this.meeting.participants.waitlisted.toArray().find((p) => p.userId === message.userId)) === null || _d === undefined ? undefined : _d.picture;
          }
        }
        return (h("div", { class: { pinned: message.pinned } }, h("div", { class: "message-wrapper" }, h("dyte-message-view", { time: message.time, actions: this.getMessageActions(message), authorName: message.displayName, avatarUrl: displayPicture, hideAuthorName: isContinued, viewType: 'incoming', variant: "bubble", onAction: (event) => this.onMessageActionHandler(event.detail, message) }, h("div", null, h("div", { class: "body" }, message.type === 'text' && (h("dyte-text-message-view", { text: message.message, isMarkdown: true })), message.type === 'file' && (h("dyte-file-message-view", { name: message.name, url: message.link, size: message.size })), message.type === 'image' && (h("dyte-image-message-view", { url: message.link, onPreview: () => {
            this.stateUpdate.emit({ image: message });
            state.image = message;
          } }))), message.pinned && (h("div", { class: "pin-icon", part: "pin-icon" }, h("dyte-icon", { icon: this.iconPack.pin, iconPack: this.iconPack, t: this.t, size: "sm" }))))))));
      };
      this.chatUpdateListener = (data) => {
        if (this.selectedChannelId && data.message.channelId !== this.selectedChannelId)
          return;
        if (data.action === 'add') {
          this.$paginatedListRef.onNewNode(data.message);
          this.lastReadMessageIndex = -1;
          this.maybeMarkChannelAsRead([data.message]);
        }
        else if (data.action === 'delete') {
          this.$paginatedListRef.onNodeDelete(data.message.id);
        }
        else if (data.action === 'edit') {
          this.$paginatedListRef.onNodeUpdate(data.message.id, data.message);
        }
      };
      this.meeting = undefined;
      this.selectedChannel = undefined;
      this.selectedChannelId = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.children = undefined;
      this.leftAlign = false;
      this.permissionsChanged = false;
    }
    componentDidLoad() {
      const slotted = this.host.shadowRoot.querySelector('slot');
      if (!slotted)
        return;
      this.children = slotted.assignedElements()[0];
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.disconnectMeeting(this.meeting);
    }
    meetingChanged(meeting, oldMeeting) {
      var _a;
      if (oldMeeting != undefined)
        this.disconnectMeeting(oldMeeting);
      if (meeting && !meeting.chat)
        return;
      if (meeting != null) {
        (_a = meeting.chat) === null || _a === undefined ? undefined : _a.addListener('chatUpdate', this.chatUpdateListener);
        meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
      }
      this.permissionsUpdateListener();
    }
    channelChanged() {
      this.lastReadMessageIndex = -1;
    }
    render() {
      return (h(Host, null, h("dyte-paginated-list", { ref: (el) => (this.$paginatedListRef = el), pageSize: this.pageSize, pagesAllowed: 3, fetchData: this.getChatMessages, createNodes: this.createChatNodes, selectedItemId: this.selectedChannelId, emptyListLabel: this.t('chat.empty_channel') }, h("slot", null))));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "selectedChannelId": ["channelChanged"]
    }; }
  };
  DyteChatMessagesUiPaginated.style = dyteChatMessagesUiPaginatedCss;

  const dyteChatSearchResultsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;flex-direction:column;position:relative;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}";

  const DyteChatSearchResults = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.pageSize = 50;
      this.searchMessages = async (timestamp, size, reversed) => {
        return this.meeting.chat.searchMessages(this.query, {
          channelId: this.channelId,
          timestamp,
          size,
          reversed,
        });
      };
      this.nodeRenderer = (messages) => {
        return messages.map((message) => (h("dyte-chat-message", { key: message.id, message: message, disableControls: true })));
      };
      this.meeting = undefined;
      this.query = undefined;
      this.channelId = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("dyte-paginated-list", { pageSize: this.pageSize, pagesAllowed: 3, fetchData: this.searchMessages, createNodes: this.nodeRenderer, selectedItemId: this.query })));
    }
  };
  DyteChatSearchResults.style = dyteChatSearchResultsCss;

  const dyteDialogManagerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block}";

  const DyteDialogManager = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.updateStoreState = (state$1, value) => {
        state[state$1] = value;
        this.stateUpdate.emit({ [state$1]: value });
      };
      this.cancelJoinStage = async () => {
        var _a, _b, _c;
        if (((_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.status) === 'ACCEPTED_TO_JOIN_STAGE') {
          await ((_c = (_b = this.meeting) === null || _b === undefined ? undefined : _b.stage) === null || _c === undefined ? undefined : _c.leave());
        }
        this.updateStoreState('activeJoinStage', false);
      };
      this.joinStage = async () => {
        await this.meeting.stage.join();
        /** NOTE(ishita1805): We close the modal once the status has changed */
      };
      this.stageStatusUpdateListener = (status) => {
        var _a;
        if (!((_a = this.states) === null || _a === undefined ? undefined : _a.activeJoinStage) && !state.activeJoinStage)
          return;
        if (status === 'ON_STAGE')
          this.updateStoreState('activeJoinStage', false);
      };
      this.meeting = undefined;
      this.config = defaultConfig;
      this.states = state;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting.stage) === null || _a === undefined ? undefined : _a.removeListener('stageStatusUpdate', this.stageStatusUpdateListener);
    }
    meetingChanged(meeting) {
      if (meeting == undefined)
        return;
      const { stage } = meeting;
      stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStatusUpdateListener);
    }
    render() {
      var _a, _b, _c, _d;
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        config: this.config,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      const states = this.states || state;
      if ((states === null || states === undefined ? undefined : states.image) != null) {
        const image = states.image;
        const onImageClose = () => {
          this.stateUpdate.emit({ image: null });
          state.image = null;
        };
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: onImageClose, hideCloseButton: true, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-image-viewer", defaults: defaults, props: { image, onClose: onImageClose } }))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeSettings) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeSettings', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-settings", defaults: defaults }))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeDebugger) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeDebugger', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-debugger", defaults: defaults }))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeLeaveConfirmation) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeLeaveConfirmation', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-leave-meeting", defaults: defaults }))));
      }
      else if (((_a = states === null || states === undefined ? undefined : states.activePermissionsMessage) === null || _a === undefined ? undefined : _a.enabled) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, hideCloseButton: true, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-permissions-message", defaults: defaults }))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeRemoteAccessManager) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeRemoteAccessManager', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-remote-access-manager", defaults: defaults }))));
      }
      else if (((_b = states === null || states === undefined ? undefined : states.activeBreakoutRoomsManager) === null || _b === undefined ? undefined : _b.active) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeBreakoutRoomsManager', {
            active: false,
            data: undefined,
          }), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-breakout-rooms-manager", defaults: defaults, props: { mode: this.meeting.connectedMeetings.isActive ? 'view' : 'create' } }))));
      }
      else if (((_c = states === null || states === undefined ? undefined : states.activeConfirmationModal) === null || _c === undefined ? undefined : _c.active) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeConfirmationModal', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-confirmation-modal", defaults: defaults }))));
      }
      else if (((_d = states === null || states === undefined ? undefined : states.activeOverlayModal) === null || _d === undefined ? undefined : _d.active) === true) {
        return (h(Host, null, h("dyte-overlay-modal", { meeting: this.meeting, states: this.states, iconPack: this.iconPack, t: this.t })));
      }
      else if (states === null || states === undefined ? undefined : states.activeBroadcastMessageModal) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => this.updateStoreState('activeBroadcastMessageModal', false), iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-broadcast-message-modal", defaults: defaults }))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeJoinStage) === true) {
        const dataState = {
          title: this.t('stage.join_title'),
          label: {
            accept: this.t('stage.join_confirm'),
            reject: this.t('stage.join_cancel'),
          },
          description: this.t('stage.join_summary'),
        };
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: this.cancelJoinStage, iconPack: this.iconPack, t: this.t }, h("dyte-join-stage", Object.assign({ dataConfig: dataState, onDyteJoinStage: this.joinStage, onDyteLeaveStage: this.cancelJoinStage }, defaults)))));
      }
      else if ((states === null || states === undefined ? undefined : states.activeMuteAllConfirmation) === true) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => {
            this.updateStoreState('activeMuteAllConfirmation', false);
          }, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-mute-all-confirmation", defaults: defaults }))));
      }
      else if (states === null || states === undefined ? undefined : states.activeChannelCreator) {
        return (h(Host, null, h("dyte-dialog", { open: true, onDyteDialogClose: () => {
            this.updateStoreState('activeChannelCreator', false);
          }, iconPack: this.iconPack, t: this.t }, h(Render, { element: "dyte-channel-creator", defaults: defaults }))));
      }
      return null;
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteDialogManager.style = dyteDialogManagerCss;

  const DEFAULT_NOTIFICATION_DURATION = 2000;
  const DEFAULT_NOTIFICATION_CONFIG = Object.freeze({
    notifications: {
      participant_joined: true,
      participant_left: true,
      participant_joined_waitlist: true,
      chat: true,
      polls: true,
      webinar: true,
      tab_sync: true,
      recording_started: true,
      recording_stopped: true,
    },
    notification_sounds: {
      participant_joined: true,
      participant_left: true,
      chat: true,
      polls: true,
      webinar: true,
      participant_joined_waitlist: true,
    },
    notification_duration: {
      participant_joined: 2100,
      participant_left: 2100,
      participant_joined_waitlist: 4000,
      chat: DEFAULT_NOTIFICATION_DURATION,
      polls: DEFAULT_NOTIFICATION_DURATION,
      webinar: DEFAULT_NOTIFICATION_DURATION,
      tab_sync: DEFAULT_NOTIFICATION_DURATION,
      recording_started: DEFAULT_NOTIFICATION_DURATION,
      recording_stopped: DEFAULT_NOTIFICATION_DURATION,
    },
    participant_joined_sound_notification_limit: 10,
    participant_chat_message_sound_notification_limit: 10,
  });

  const dyteNotificationsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:absolute;top:var(--dyte-space-4, 16px);right:var(--dyte-space-4, 16px);bottom:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);top:auto;display:flex;flex-direction:column;pointer-events:none;z-index:100}dyte-notification{margin-top:var(--dyte-space-2, 8px)}";

  function parseConfig(config) {
    const permissions = Object.assign({}, DEFAULT_NOTIFICATION_CONFIG);
    if (config == null)
      return permissions;
    Object.assign(permissions.notification_sounds, config.notification_sounds);
    Object.assign(permissions.notifications, config.notifications);
    Object.assign(permissions.notification_duration, config.notification_duration);
    permissions.participant_chat_message_sound_notification_limit =
      config.participant_chat_message_sound_notification_limit;
    permissions.participant_joined_sound_notification_limit =
      config.participant_joined_sound_notification_limit;
    return permissions;
  }
  function getEnabledSounds(sounds) {
    return Object.keys(sounds).filter((key) => sounds[key]);
  }
  const DyteNotifications = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.permissions = DEFAULT_NOTIFICATION_CONFIG;
      this.enabledSounds = getEnabledSounds(DEFAULT_NOTIFICATION_CONFIG.notification_sounds);
      this.addStagePeersListeners = (meeting) => {
        meeting.participants.joined.addListener('participantJoined', this.participantJoinedListener);
        meeting.participants.joined.addListener('participantLeft', this.participantLeftListener);
      };
      this.removeStagePeersListeners = (meeting) => {
        meeting.participants.joined.removeListener('participantJoined', this.participantJoinedListener);
        meeting.participants.joined.removeListener('participantLeft', this.participantLeftListener);
      };
      this.onDyteNotification = (e) => {
        this.add(e.detail);
        const playSound = e.detail.playSound;
        if (playSound != undefined)
          this.audio.play(playSound);
      };
      this.onRecordingUpdate = (recordingState) => {
        var _a, _b;
        if (recordingState === 'RECORDING' &&
          this.permissions.notifications.recording_started !== false) {
          this.add({
            id: 'recording-started',
            icon: this.iconPack.recording,
            message: this.t('recording.started'),
            duration: (_a = this.permissions.notification_duration.recording_started) !== null && _a !== undefined ? _a : DEFAULT_NOTIFICATION_DURATION,
          });
        }
        else if (recordingState === 'STOPPING' &&
          this.permissions.notifications.recording_stopped !== false) {
          this.add({
            id: 'recording-stopped',
            icon: this.iconPack.stop_recording,
            message: this.t('recording.stopped'),
            duration: (_b = this.permissions.notification_duration.recording_stopped) !== null && _b !== undefined ? _b : DEFAULT_NOTIFICATION_DURATION,
          });
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.t = useLanguage();
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.notifications = [];
    }
    connectedCallback() {
      if (typeof document !== 'undefined') {
        document === null || document === undefined ? undefined : document.addEventListener('dyteNotification', this.onDyteNotification);
      }
      this.meetingChanged(this.meeting);
      this.configChanged(this.config);
      this.statesChanged(this.states);
    }
    clearListeners(meeting) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const isLivestream = meeting.meta.viewType === 'LIVESTREAM';
      if ((isLivestream && ((_a = meeting.stage) === null || _a === undefined ? undefined : _a.status) === 'ON_STAGE') || !isLivestream) {
        this.removeStagePeersListeners(meeting);
      }
      this.chatUpdateListener && ((_b = meeting.chat) === null || _b === undefined ? undefined : _b.removeListener('chatUpdate', this.chatUpdateListener));
      this.pollUpdateListener &&
        ((_c = meeting.polls) === null || _c === undefined ? undefined : _c.removeListener('pollsUpdate', this.pollUpdateListener));
      meeting.meta.removeListener('socketConnectionUpdate', this.socketConnectionUpdateListener);
      this.stageRequestAccepted &&
        ((_d = meeting.stage) === null || _d === undefined ? undefined : _d.removeListener('stageRequestApproved', this.stageRequestAccepted));
      this.stageRequestRejected &&
        ((_e = meeting.stage) === null || _e === undefined ? undefined : _e.removeListener('stageRequestRejected', this.stageRequestRejected));
      this.newStageRequests &&
        ((_f = meeting.stage) === null || _f === undefined ? undefined : _f.removeListener('newStageRequest', this.newStageRequests));
      this.stageStatusUpdateListener &&
        ((_g = meeting.stage) === null || _g === undefined ? undefined : _g.removeListener('stageStatusUpdate', this.stageStatusUpdateListener));
      (_h = meeting.recording) === null || _h === undefined ? undefined : _h.removeListener('recordingUpdate', this.onRecordingUpdate);
      clearTimeout(this.disconnectTimeout);
      meeting.self.removeListener('deviceUpdate', this.deviceUpdateListener);
    }
    disconnectedCallback() {
      var _a;
      if (typeof document !== 'undefined') {
        document === null || document === undefined ? undefined : document.removeEventListener('dyteNotification', this.onDyteNotification);
      }
      if (this.meeting == null)
        return;
      this.clearListeners(this.meeting);
      this.waitlistedParticipantJoinedListener &&
        this.meeting.participants.waitlisted.removeListener('participantJoined', this.waitlistedParticipantJoinedListener);
      this.waitlistedParticipantLeftListener &&
        this.meeting.participants.waitlisted.removeListener('participantLeft', this.waitlistedParticipantLeftListener);
      this.activeTabUpdateListener &&
        ((_a = this.meeting.meta) === null || _a === undefined ? undefined : _a.removeListener('activeTabUpdate', this.activeTabUpdateListener));
      this.peerStageStatusListener &&
        this.meeting.participants.joined.removeListener('stageStatusUpdate', this.peerStageStatusListener);
    }
    meetingChanged(meeting, oldMeeting) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      clearTimeout(this.disconnectTimeout);
      if (oldMeeting !== undefined)
        this.clearListeners(oldMeeting);
      if (meeting == null)
        return;
      const isLivestream = meeting.meta.viewType === 'LIVESTREAM';
      this.audio = new DyteNotificationsAudio(meeting);
      const { notifications, notification_duration, notification_sounds } = this.permissions;
      this.participantJoinedListener = (participant) => {
        if (notifications.participant_joined) {
          this.add({
            id: `${participant.id}-joined`,
            message: `${formatName(participant.name)} ${this.t('notifications.joined')}`,
            image: participant.picture,
            duration: notification_duration.participant_joined,
          });
        }
        if (notification_sounds.participant_joined && this.canPlayParticipantJoinedSound()) {
          this.audio.play('joined');
        }
      };
      this.participantLeftListener = (participant) => {
        const { socketState: { state }, } = this.meeting.meta;
        if (notifications.participant_left && state !== 'connected') {
          this.add({
            id: `${participant.id}-left`,
            message: `${formatName(participant.name)} ${this.t('notifications.left')}`,
            image: participant.picture,
            duration: notification_duration.participant_left,
          });
        }
        if (notification_sounds.participant_left && this.canPlayParticipantJoinedSound()) {
          this.audio.play('left');
        }
      };
      this.waitlistedParticipantJoinedListener = (participant) => {
        if (!this.canAcceptWaitingRequests())
          return;
        const id = `${participant.id}-joined-waitlist`;
        this.add({
          id,
          message: `${formatName(participant.name)} ${this.t('notifications.requesting_to_join_meeting')}`,
          image: participant.picture,
          duration: notification_duration.participant_joined_waitlist,
          button: {
            text: this.t('notifications.accept'),
            variant: 'primary',
            onClick: async () => {
              await this.meeting.participants.acceptWaitingRoomRequest(participant.id);
              this.remove(id);
            },
          },
        });
        if (notification_sounds.participant_joined_waitlist && this.canPlayParticipantJoinedSound()) {
          this.audio.play('message');
        }
      };
      this.waitlistedParticipantLeftListener = (participant) => {
        this.remove(`${participant.id}-joined-waitlist`);
      };
      this.chatUpdateListener = ({ message }) => {
        const parsedMessage = parseMessageForTarget(message);
        if (parsedMessage != null) {
          if (parsedMessage.userId === meeting.self.userId) {
            return;
          }
          if (parsedMessage.type === 'text') {
            if (notifications.chat) {
              this.add({
                id: `message-${Math.random().toString(36)}`,
                icon: this.iconPack.chat,
                message: `${parsedMessage.displayName}: ${parsedMessage.message}`,
                duration: notification_duration.chat,
              });
            }
            if (notification_sounds.chat && this.canPlayChatSound()) {
              this.audio.play('message');
            }
          }
        }
      };
      this.pollUpdateListener = ({ polls, newPoll }) => {
        if (newPoll === false)
          return;
        if (notifications.polls &&
          this.meeting.self.userId !== polls[polls.length - 1].createdByUserId) {
          this.add({
            id: `poll-${Math.random().toString(36)}`,
            icon: this.iconPack.poll,
            message: `${this.t('notifications.new_poll_created_by')} ${polls[polls.length - 1].createdBy}`,
            duration: notification_duration.polls,
          });
        }
        if (notification_sounds.polls &&
          this.meeting.self.userId !== polls[polls.length - 1].createdByUserId &&
          this.canPlayChatSound()) {
          this.audio.play('message');
        }
      };
      this.deviceUpdateListener = ({ device, preview }) => {
        if (preview)
          return;
        if (device.kind === 'audiooutput') {
          this.audio.setDevice(device.deviceId);
          this.remove(`speaker-switched`);
          this.add({
            id: `speaker-switched`,
            message: `${this.t('notifications.connected_to')} ${device.label}`,
            icon: this.iconPack.speaker,
            duration: 5000,
          });
        }
        if (device.kind === 'videoinput') {
          this.remove(`camera-switched`);
          this.add({
            id: `camera-switched`,
            message: `${this.t('notifications.connected_to')} ${device.label}`,
            icon: this.meeting.self.videoEnabled ? this.iconPack.video_on : this.iconPack.video_off,
            iconVariant: this.meeting.self.videoEnabled ? 'primary' : 'danger',
            duration: 5000,
          });
        }
        if (device.kind === 'audioinput') {
          this.remove(`mic-switched`);
          this.add({
            id: `mic-switched`,
            message: `${this.t('notifications.connected_to')} ${device.label}`,
            icon: this.meeting.self.audioEnabled ? this.iconPack.mic_on : this.iconPack.mic_off,
            iconVariant: this.meeting.self.audioEnabled ? 'primary' : 'danger',
            duration: 5000,
          });
        }
      };
      this.socketConnectionUpdateListener = ({ state, reconnectionAttempt, reconnected }) => {
        switch (state) {
          case 'connected':
            this.remove('socket');
            if (reconnected)
              this.add({
                id: `socket`,
                icon: this.iconPack.wifi,
                message: this.t('network.restored'),
                duration: 3000,
              });
            break;
          case 'disconnected':
            this.remove('socket');
            this.add({
              id: 'socket',
              icon: this.iconPack.disconnected,
              message: this.t('network.reconnecting'),
            });
            break;
          case 'reconnecting':
            if (reconnectionAttempt >= 6) {
              this.remove('socket');
              this.add({
                id: 'socket',
                icon: this.iconPack.disconnected,
                message: this.t('network.disconnected'),
                button: {
                  text: this.t('end'),
                  variant: 'danger',
                  onClick: () => { var _a; return (_a = this.meeting) === null || _a === undefined ? undefined : _a.leaveRoom(); },
                },
              });
            }
            else if (reconnectionAttempt >= 4) {
              this.remove('socket');
              this.add({
                id: 'socket',
                icon: this.iconPack.disconnected,
                message: this.t('network.delay_extended'),
              });
            }
            break;
          case 'failed':
            this.remove('socket');
            this.add({
              id: 'socket',
              icon: this.iconPack.disconnected,
              message: this.t('network.leaving'),
              button: {
                text: this.t('end'),
                variant: 'danger',
                onClick: () => { var _a; return (_a = this.meeting) === null || _a === undefined ? undefined : _a.leaveRoom(); },
              },
            });
            break;
        }
      };
      this.activeTabUpdateListener = (activeTab) => {
        if (!notifications.tab_sync)
          return;
        switch (activeTab.type) {
          case 'plugin':
            const activePlugin = meeting.plugins.active
              .toArray()
              .find((plugin) => plugin.id == activeTab.id);
            if (activePlugin != undefined) {
              this.add({
                id: 'activeTab',
                message: `${this.t('notifications.plugin_switched_to')} ${activePlugin.name}`,
                duration: notification_duration.participant_joined,
              });
            }
            break;
          case 'screenshare':
            const screenShareParticipant = meeting.participants.joined
              .toArray()
              .filter((participant) => participant.screenShareEnabled)
              .find((participant) => participant.id == activeTab.id);
            if (screenShareParticipant != undefined) {
              this.add({
                id: 'spotlight',
                message: `Now watching ${screenShareParticipant.name}'s screen`,
                duration: notification_duration.webinar,
              });
            }
            break;
        }
      };
      this.peerStageStatusListener = (participant) => {
        if (participant.stageStatus === 'REQUESTED_TO_JOIN_STAGE') {
          this.add({
            id: `stage-request-${participant.id}`,
            message: `${participant.name} ${this.t('notifications.requested_to_join_stage')}`,
            duration: notification_duration.webinar,
            button: {
              text: this.t('notifications.accept'),
              variant: 'primary',
              onClick: async () => {
                await this.meeting.stage.grantAccess([participant.userId]);
                this.remove(`stage-request-${participant.id}`);
              },
            },
          });
          if (notification_sounds.webinar) {
            this.audio.play('joined');
          }
        }
        if (participant.stageStatus === 'ON_STAGE') {
          this.add({
            id: `stage-joined-${participant.id}`,
            message: `${participant.name} ${this.t('notifications.joined_stage')}`,
            duration: notification_duration.webinar,
          });
          if (notification_sounds.webinar) {
            this.audio.play('joined');
          }
        }
      };
      this.stageRequestAccepted = () => {
        this.add({
          id: 'stage-request-accepted',
          message: this.t('notifications.request_to_join_accepted'),
          duration: 3000,
        });
      };
      this.stageRequestRejected = () => {
        this.add({
          id: 'stage-request-rejected',
          message: this.t('notifications.request_to_join_rejected'),
          duration: 3000,
        });
      };
      this.newStageRequests = ({ count }) => {
        this.add({
          id: 'new-stage-request',
          message: `You have ${count < 0 ? 'new stage' : `${count} pending`} request${count === 1 ? '' : 's'}`,
          duration: 3000,
        });
      };
      this.stageStatusUpdateListener = (status) => {
        if (status === 'ON_STAGE')
          this.addStagePeersListeners(meeting);
        else
          this.removeStagePeersListeners(meeting);
      };
      !showLivestream(meeting) && ((_a = meeting.chat) === null || _a === undefined ? undefined : _a.addListener('chatUpdate', this.chatUpdateListener));
      // temp fix for viewType mismatch with CHAT
      if (((_b = meeting.self.config.viewType) === null || _b === undefined ? undefined : _b.toString()) === 'CHAT') {
        return;
      }
      // all non Chat viewtype code from here
      const currentDevices = meeting.self.getCurrentDevices();
      if (currentDevices.speaker != null) {
        this.audio.setDevice(currentDevices.speaker.deviceId);
      }
      if (isLivestream)
        (_c = meeting.stage) === null || _c === undefined ? undefined : _c.on('stageStatusUpdate', this.stageStatusUpdateListener);
      else
        this.addStagePeersListeners(meeting);
      if (this.canAcceptWaitingRequests()) {
        meeting.participants.waitlisted.addListener('participantJoined', this.waitlistedParticipantJoinedListener);
        meeting.participants.waitlisted.addListener('participantLeft', this.waitlistedParticipantLeftListener);
      }
      (_d = meeting.polls) === null || _d === undefined ? undefined : _d.addListener('pollsUpdate', this.pollUpdateListener);
      meeting.self.addListener('deviceUpdate', this.deviceUpdateListener);
      meeting.meta.addListener('socketConnectionUpdate', this.socketConnectionUpdateListener);
      (_e = meeting.meta) === null || _e === undefined ? undefined : _e.addListener('activeTabUpdate', this.activeTabUpdateListener);
      (_f = meeting.recording) === null || _f === undefined ? undefined : _f.addListener('recordingUpdate', this.onRecordingUpdate);
      (_g = meeting.stage) === null || _g === undefined ? undefined : _g.addListener('stageRequestApproved', this.stageRequestAccepted);
      (_h = meeting.stage) === null || _h === undefined ? undefined : _h.addListener('stageRequestRejected', this.stageRequestRejected);
      if (meeting.self.permissions.stageEnabled && meeting.self.permissions.acceptStageRequests) {
        (_j = meeting.stage) === null || _j === undefined ? undefined : _j.addListener('newStageRequest', this.newStageRequests);
      }
    }
    configChanged(config) {
      if (config != null) {
        if ((config === null || config === undefined ? undefined : config.config) != null) {
          this.permissions = parseConfig(config.config);
          this.enabledSounds = getEnabledSounds(this.permissions.notification_sounds);
        }
      }
    }
    statesChanged(states) {
      var _a;
      if (states != null) {
        const notificationSoundsEnabled = !((_a = states === null || states === undefined ? undefined : states.prefs) === null || _a === undefined ? undefined : _a.muteNotificationSounds);
        // toggle only the notification sounds values which were enabled in the first place
        for (const permission of this.enabledSounds) {
          if (permission in this.permissions.notification_sounds) {
            this.permissions.notification_sounds[permission] = notificationSoundsEnabled;
          }
        }
      }
    }
    apiErrorListener({ detail }) {
      const { trace, message } = detail;
      this.add({
        id: trace,
        message,
        duration: DEFAULT_NOTIFICATION_DURATION,
        icon: this.iconPack.warning,
      });
    }
    sendNotificationListener({ detail }) {
      const { trace, message } = detail;
      this.add({
        id: trace,
        message,
        duration: DEFAULT_NOTIFICATION_DURATION,
      });
    }
    add(notification) {
      // show notifications only if tab is in focus and a maximum of 5 at a time
      if (document.visibilityState === 'visible' && this.notifications.length < 5) {
        // adds new notification to start of array so they appear at the bottom
        this.notifications = [...this.notifications, notification];
      }
    }
    remove(id) {
      this.notifications = this.notifications.filter((notification) => notification.id !== id);
    }
    handleDismiss(e) {
      e.stopPropagation();
      const id = e.detail;
      const el = this.host.shadowRoot.querySelector(`[data-id="${id}"]`);
      // exit animation
      el === null || el === undefined ? undefined : el.classList.add('exit');
      setTimeout(() => {
        writeTask(() => {
          this.remove(id);
        });
      }, 400);
    }
    canPlayParticipantJoinedSound() {
      return (this.permissions.participant_joined_sound_notification_limit == undefined ||
        this.permissions.participant_joined_sound_notification_limit <= 0 ||
        this.meeting.participants.count <=
          this.permissions.participant_joined_sound_notification_limit);
    }
    canPlayChatSound() {
      return (this.permissions.participant_chat_message_sound_notification_limit == undefined ||
        this.permissions.participant_chat_message_sound_notification_limit <= 0 ||
        this.meeting.participants.count <=
          this.permissions.participant_chat_message_sound_notification_limit);
    }
    canAcceptWaitingRequests() {
      return (this.permissions.notifications.participant_joined_waitlist &&
        this.meeting.self.permissions.acceptWaitingRequests);
    }
    render() {
      return (h(Host, null, this.notifications.map((notification) => (h("dyte-notification", { size: this.size, key: notification.id, "data-id": notification.id, notification: notification, onDyteNotificationDismiss: (e) => this.handleDismiss(e), iconPack: this.iconPack, t: this.t })))));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "config": ["configChanged"],
      "states": ["statesChanged"]
    }; }
  };
  DyteNotifications.style = dyteNotificationsCss;

  var dyteChannelHeader_8_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_channel_header: DyteChannelHeader,
      dyte_channel_selector_view: DyteChannelSelectorView,
      dyte_chat_composer_view: DyteChatComposerView,
      dyte_chat_messages_ui: DyteChatMessagesUi,
      dyte_chat_messages_ui_paginated: DyteChatMessagesUiPaginated,
      dyte_chat_search_results: DyteChatSearchResults,
      dyte_dialog_manager: DyteDialogManager,
      dyte_notifications: DyteNotifications
  });

  /** Method to return media health based on the media & network stats */
  function getNetworkBasedMediaHealth({ stats, }) {
    if (!stats || !stats.length) {
      return null;
    }
    let networkHealth = 'Good';
    const allStatsHealths = stats.map((statsObj) => statsObj.verdict);
    if (allStatsHealths.includes('Poor')) {
      networkHealth = 'Poor';
    }
    else if (allStatsHealths.includes('Average')) {
      networkHealth = 'Average';
    }
    return networkHealth;
  }
  /** Gives verdict based on the packet loss */
  function getPacketLossVerdict({ packetLossPercentage, }) {
    let verdict = 'Good';
    if (packetLossPercentage > 4) {
      verdict = 'Poor';
    }
    else if (packetLossPercentage >= 1 && packetLossPercentage <= 4) {
      verdict = 'Average';
    }
    return verdict;
  }
  /** Gives verdict based on the jitter */
  function getJitterVerdict({ jitterInMS }) {
    let verdict = 'Good';
    if (jitterInMS > 100) {
      verdict = 'Poor';
    }
    else if (jitterInMS >= 50 && jitterInMS <= 100) {
      verdict = 'Average';
    }
    return verdict;
  }
  /** Gives verdict based on the jitter */
  function getBitrateVerdict({ bitrate, }) {
    let verdict = 'Good';
    const bitrateInKbps = Math.round(bitrate / 1024); // it is Kilo bits
    if (bitrateInKbps === 0) {
      verdict = 'Poor';
    }
    return verdict;
  }
  function getOverallBatteryVerdict({ stats }) {
    if (!stats || !stats.length) {
      return null;
    }
    let networkHealth = 'Good';
    const allStatsHealths = stats.map((statsObj) => statsObj.verdict);
    if (allStatsHealths.includes('Poor')) {
      networkHealth = 'Poor';
    }
    else if (allStatsHealths.includes('Average')) {
      networkHealth = 'Average';
    }
    return networkHealth;
  }
  function getBatteryLevelVerdict({ batteryLevelPercentage, }) {
    let batteryLevelVerdict = 'Good';
    if (batteryLevelPercentage < 20) {
      batteryLevelVerdict = 'Poor';
    }
    else if (batteryLevelPercentage < 50) {
      batteryLevelVerdict = 'Average';
    }
    return batteryLevelVerdict;
  }
  function getBatteryChargingVerdict({ charging, dischargingTimeInSeconds, batteryLevelPercentage, }) {
    const MINS_30 = 30 * 60;
    if (batteryLevelPercentage < 20) {
      return 'Poor';
    }
    if (charging) {
      return 'Good';
    }
    if (dischargingTimeInSeconds < MINS_30) {
      return 'Poor';
    }
    return 'Average';
  }

  const dyteDebuggerAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}#header{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-5, 20px);display:flex;align-items:center;justify-content:space-evenly}.tab-body{margin:var(--dyte-space-4, 16px);display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto}.status-container{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;padding:16px}.status-section{margin-bottom:12px}.section-header{display:flex;justify-content:space-between;align-items:center;font-weight:bold;padding:8px 0}.section-header.only-child{justify-content:center}.section-body.missing-stats{display:flex;text-align:center;justify-content:center}.section-header .status{color:rgba(var(--dyte-colors-success));font-weight:bold}.section-header .arrow{font-size:14px}.network-table{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;margin-top:8px;overflow:hidden}.network-row{display:flex;justify-content:space-between;padding:12px;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}.network-row:last-child{border-bottom:none}.network-cell{display:flex;flex-direction:column}.network-cell.label strong{font-size:14px}.network-cell.label .description{font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}.network-cell.value{text-align:right}.status.good{color:rgba(var(--dyte-colors-success))}.status.average{color:rgba(var(--dyte-colors-warning))}.status.poor{color:rgba(var(--dyte-colors-danger))}.value{font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}dyte-settings-audio{display:flex;flex-direction:column}";

  const DyteDebuggerAudio = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      // private toggleSection(section: string) {
      //   if (section === 'network') this.isNetworkOpen = !this.isNetworkOpen;
      //   else if (section === 'devices') this.isDevicesOpen = !this.isDevicesOpen;
      // }
      this.mediaScoreUpdateListener = ({ kind, isScreenshare, scoreStats, }) => {
        if (kind === 'audio' && !isScreenshare) {
          this.audioProducerScoreStats = scoreStats;
        }
      };
      this.deviceListUpdateListener = async () => {
        const audioDevices = await this.meeting.self.getAudioDevices();
        this.devicesHealth = (audioDevices === null || audioDevices === undefined ? undefined : audioDevices.length) > 0 ? 'Good' : 'Poor';
      };
      this.audioUpdateListener = () => {
        if (!this.meeting.self.audioEnabled) {
          this.audioProducerScoreStats = null;
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isNetworkOpen = true;
      this.isDevicesOpen = false;
      this.audioProducerFormattedStats = [];
      this.audioProducerScoreStats = null;
      this.networkBasedMediaHealth = null;
      this.devicesHealth = null;
    }
    async audioProducerScoreStatsChanged(newAudioProducerScoreStats) {
      if (!newAudioProducerScoreStats) {
        this.audioProducerFormattedStats = [];
        return;
      }
      const statsObj = newAudioProducerScoreStats;
      const newStatsList = [];
      newStatsList.push({
        name: this.t('debugger.stats.bitrate.label'),
        value: `${Math.round(statsObj.bitrate / 1024)} kbps`,
        description: this.t('debugger.stats.bitrate.description'),
        verdict: getBitrateVerdict({
          bitrate: statsObj.bitrate,
          kind: 'audio',
          isScreenshare: false,
        }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.packet_loss.label'),
        value: `${statsObj.packetsLostPercentage}%`,
        description: this.t('debugger.stats.packet_loss.description'),
        verdict: getPacketLossVerdict({ packetLossPercentage: statsObj.packetsLostPercentage }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.jitter.label'),
        value: `${Math.round(statsObj.jitter * 1000)} ms`,
        description: this.t('debugger.stats.jitter.description'),
        verdict: getJitterVerdict({ jitterInMS: statsObj.jitter * 1000 }),
      });
      this.audioProducerFormattedStats = newStatsList;
      this.networkBasedMediaHealth = getNetworkBasedMediaHealth({
        kind: 'audio',
        isScreenshare: false,
        stats: newStatsList,
      });
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (!this.meeting) {
        return;
      }
      this.meeting.self.off('mediaScoreUpdate', this.mediaScoreUpdateListener);
      this.meeting.self.off('audioUpdate', this.audioUpdateListener);
      this.meeting.self.off('deviceListUpdate', this.deviceListUpdateListener);
    }
    async meetingChanged(meeting) {
      if (!meeting)
        return;
      meeting.self.on('mediaScoreUpdate', this.mediaScoreUpdateListener);
      meeting.self.on('audioUpdate', this.audioUpdateListener);
      meeting.self.on('deviceListUpdate', this.deviceListUpdateListener);
      await this.deviceListUpdateListener();
    }
    render() {
      var _a, _b;
      if (!this.meeting) {
        return;
      }
      // const defaults = {
      //   meeting: this.meeting,
      //   states: this.states || storeState,
      //   iconPack: this.iconPack,
      //   t: this.t,
      // };
      return (h(Host, null, h("div", { id: "header" }), h("div", { class: "tab-body" }, h("div", { class: "status-container" }, h("div", { class: "status-section" }, h("div", { class: `section-header ${!this.networkBasedMediaHealth ? 'only-child' : ''}` }, h("span", null, this.t('debugger.audio.sections.network_media')), this.networkBasedMediaHealth && (h("span", { class: `status ${(_a = this.networkBasedMediaHealth) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = this.networkBasedMediaHealth) === null || _b === undefined ? undefined : _b.toLowerCase()}`)))), this.isNetworkOpen && !this.audioProducerFormattedStats.length && (h("div", { class: "section-body missing-stats" }, this.meeting.self.audioEnabled ? (h("span", null, this.t('debugger.audio.messages.generating_report'))) : (h("span", null, this.t('debugger.audio.messages.enable_media'))))), this.isNetworkOpen && !!this.audioProducerFormattedStats.length && (h("div", { class: "section-body network-table" }, this.audioProducerFormattedStats.map((formattedStatsObj) => {
        var _a, _b;
        return (h("div", { class: "network-row" }, h("div", { class: "network-cell label" }, h("strong", null, formattedStatsObj.name), h("span", { class: "description" }, formattedStatsObj.description)), h("div", { class: "network-cell value" }, h("span", { class: `status ${(_a = formattedStatsObj.verdict) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = formattedStatsObj.verdict) === null || _b === undefined ? undefined : _b.toLowerCase()}`)), h("span", { class: "value" }, formattedStatsObj.value))));
      }))))))));
    }
    static get watchers() { return {
      "audioProducerScoreStats": ["audioProducerScoreStatsChanged"],
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteDebuggerAudio.style = dyteDebuggerAudioCss;

  const dyteDebuggerScreenshareCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}#header{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-5, 20px);display:flex;align-items:center;justify-content:space-evenly}.tab-body{margin:var(--dyte-space-4, 16px);display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto}.status-container{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;padding:16px}.status-section{margin-bottom:12px}.section-header{display:flex;justify-content:space-between;align-items:center;font-weight:bold;padding:8px 0}.section-header.only-child{justify-content:center}.section-body.missing-stats{display:flex;text-align:center;justify-content:center}.section-header .status{color:rgba(var(--dyte-colors-success));font-weight:bold}.section-header .arrow{font-size:14px}.network-table{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;margin-top:8px;overflow:hidden}.network-row{display:flex;justify-content:space-between;padding:12px;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}.network-row:last-child{border-bottom:none}.network-cell{display:flex;flex-direction:column}.network-cell.label strong{font-size:14px}.network-cell.label .description{font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}.network-cell.value{text-align:right}.status.good{color:rgba(var(--dyte-colors-success))}.status.average{color:rgba(var(--dyte-colors-warning))}.status.poor{color:rgba(var(--dyte-colors-danger))}.value{font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}";

  const DyteDebuggerScreenShare = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      // private toggleSection(section: string) {
      //   if (section === 'network') this.isNetworkOpen = !this.isNetworkOpen;
      //   else if (section === 'devices') this.isDevicesOpen = !this.isDevicesOpen;
      // }
      this.mediaScoreUpdateListener = ({ kind, isScreenshare, scoreStats, }) => {
        if (kind === 'video' && isScreenshare) {
          this.videoProducerScoreStats = scoreStats;
        }
        if (kind === 'audio' && isScreenshare) {
          this.audioProducerScoreStats = scoreStats;
        }
      };
      this.screenShareUpdateListener = () => {
        if (!this.meeting.self.screenShareEnabled) {
          this.videoProducerScoreStats = null;
          this.audioProducerScoreStats = null;
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isNetworkOpen = true;
      this.isDevicesOpen = false;
      this.videoProducerFormattedStats = [];
      this.videoProducerScoreStats = null;
      this.audioProducerFormattedStats = [];
      this.audioProducerScoreStats = null;
      this.networkBasedMediaHealth = null;
    }
    async videoProducerScoreStatsChanged(newVideoProducerScoreStats) {
      if (!newVideoProducerScoreStats) {
        this.videoProducerFormattedStats = [];
        return;
      }
      const statsObj = newVideoProducerScoreStats;
      const newStatsList = [];
      newStatsList.push({
        name: this.t('debugger.stats.cpu_limitations.label'),
        value: statsObj.cpuLimitations ? 'Yes' : 'No',
        description: this.t('debugger.stats.cpu_limitations.description'),
        verdict: statsObj.cpuLimitations ? 'Poor' : 'Good',
      });
      newStatsList.push({
        name: this.t('debugger.stats.bandwidth_limitations.label'),
        value: statsObj.bandwidthLimitations ? 'Yes' : 'No',
        description: this.t('debugger.stats.bandwidth_limitations.description'),
        verdict: statsObj.bandwidthLimitations ? 'Poor' : 'Good',
      });
      newStatsList.push({
        name: this.t('debugger.stats.bitrate.label'),
        value: `${Math.round(statsObj.bitrate / 1024)} kbps`,
        description: this.t('debugger.stats.bitrate.description'),
        verdict: getBitrateVerdict({
          bitrate: statsObj.bitrate,
          kind: 'video',
          isScreenshare: false,
        }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.packet_loss.label'),
        value: `${statsObj.packetsLostPercentage}%`,
        description: this.t('debugger.stats.packet_loss.description'),
        verdict: getPacketLossVerdict({ packetLossPercentage: statsObj.packetsLostPercentage }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.jitter.label'),
        value: `${Math.round(statsObj.jitter * 1000)} ms`,
        description: this.t('debugger.stats.jitter.description'),
        verdict: getJitterVerdict({ jitterInMS: statsObj.jitter * 1000 }),
      });
      this.videoProducerFormattedStats = newStatsList;
      this.networkBasedMediaHealth = getNetworkBasedMediaHealth({
        kind: 'video',
        isScreenshare: false,
        stats: newStatsList,
      });
    }
    async audioProducerScoreStatsChanged(newAudioProducerScoreStats) {
      if (!newAudioProducerScoreStats) {
        this.audioProducerFormattedStats = [];
        return;
      }
      const statsObj = newAudioProducerScoreStats;
      const newStatsList = [];
      newStatsList.push({
        name: this.t('debugger.stats.bitrate.label'),
        value: `${Math.round(statsObj.bitrate / 1024)} kbps`,
        description: this.t('debugger.stats.bitrate.description'),
        verdict: getBitrateVerdict({
          bitrate: statsObj.bitrate,
          kind: 'audio',
          isScreenshare: true,
        }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.packet_loss.label'),
        value: `${statsObj.packetsLostPercentage}%`,
        description: this.t('debugger.stats.packet_loss.description'),
        verdict: getPacketLossVerdict({ packetLossPercentage: statsObj.packetsLostPercentage }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.jitter.label'),
        value: `${Math.round(statsObj.jitter * 1000)} ms`,
        description: this.t('debugger.stats.jitter.description'),
        verdict: getJitterVerdict({ jitterInMS: statsObj.jitter * 1000 }),
      });
      this.audioProducerFormattedStats = newStatsList;
      /** Only screenshare video is deciding the media health currently */
      // this.networkBasedMediaHealth = getNetworkBasedMediaHealth({
      //   kind: 'audio',
      //   isScreenshare: true,
      //   stats: newStatsList,
      // });
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (!this.meeting) {
        return;
      }
      this.meeting.self.off('mediaScoreUpdate', this.mediaScoreUpdateListener);
      this.meeting.self.off('screenShareUpdate', this.screenShareUpdateListener);
    }
    async meetingChanged(meeting) {
      if (!meeting)
        return;
      meeting.self.on('mediaScoreUpdate', this.mediaScoreUpdateListener);
      meeting.self.on('screenShareUpdate', this.screenShareUpdateListener);
    }
    render() {
      var _a, _b;
      if (!this.meeting) {
        return;
      }
      return (h(Host, null, h("div", { id: "header" }), h("div", { class: "tab-body" }, h("div", { class: "status-container" }, h("div", { class: "status-section" }, h("div", { class: `section-header ${!this.networkBasedMediaHealth ? 'only-child' : ''}` }, h("span", null, this.t('debugger.screenshare.sections.network_media')), this.networkBasedMediaHealth && (h("span", { class: `status ${(_a = this.networkBasedMediaHealth) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = this.networkBasedMediaHealth) === null || _b === undefined ? undefined : _b.toLowerCase()}`)))), this.isNetworkOpen && !this.videoProducerFormattedStats.length && (h("div", { class: "section-body missing-stats" }, this.meeting.self.screenShareEnabled ? (h("span", null, this.t('debugger.screenshare.messages.generating_report'))) : (h("span", null, this.t('debugger.screenshare.messages.enable_media'))))), this.isNetworkOpen && !!this.videoProducerFormattedStats.length && (h("div", { class: "section-body network-table" }, this.videoProducerFormattedStats.map((formattedStatsObj) => {
        var _a, _b;
        return (h("div", { class: "network-row" }, h("div", { class: "network-cell label" }, h("strong", null, formattedStatsObj.name), h("span", { class: "description" }, formattedStatsObj.description)), h("div", { class: "network-cell value" }, h("span", { class: `status ${(_a = formattedStatsObj.verdict) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = formattedStatsObj.verdict) === null || _b === undefined ? undefined : _b.toLowerCase()}`)), h("span", { class: "value" }, formattedStatsObj.value))));
      }))))))));
    }
    static get watchers() { return {
      "videoProducerScoreStats": ["videoProducerScoreStatsChanged"],
      "audioProducerScoreStats": ["audioProducerScoreStatsChanged"],
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteDebuggerScreenShare.style = dyteDebuggerScreenshareCss;

  const dyteDebuggerSystemCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}#header{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-5, 20px);display:flex;align-items:center;justify-content:space-evenly}.tab-body{margin:var(--dyte-space-4, 16px);display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto}.status-container{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;padding:16px}.status-section{margin-bottom:12px}.section-header{display:flex;justify-content:space-between;align-items:center;font-weight:bold;padding:8px 0}.section-body.missing-stats{display:flex;text-align:center;justify-content:center}.section-header .status{color:rgba(var(--dyte-colors-success));font-weight:bold}.section-header .arrow{font-size:14px}.battery-table{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;margin-top:8px;overflow:hidden}.battery-row{display:flex;justify-content:space-between;padding:12px;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}.battery-row:last-child{border-bottom:none}.battery-cell{display:flex;flex-direction:column}.battery-cell.label strong{font-size:14px}.battery-cell.label .description{font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}.battery-cell.value{text-align:right}.status.good{color:rgba(var(--dyte-colors-success))}.status.average{color:rgba(var(--dyte-colors-warning))}.status.poor{color:rgba(var(--dyte-colors-danger))}.value{font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}dyte-settings-video{display:flex;flex-direction:column}";

  const DyteDebuggerSystem = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.batteryUpdateListener = () => {
        const batteryLevelPercentage = Math.round(this.battery.level * 100);
        const newBatteryStats = [];
        newBatteryStats.push({
          name: this.t('debugger.system.battery.level.label'),
          value: `${batteryLevelPercentage}%`,
          description: this.t('debugger.system.battery.level.description'),
          verdict: getBatteryLevelVerdict({
            batteryLevelPercentage,
          }),
        });
        newBatteryStats.push({
          name: this.t('debugger.system.battery.charging.label'),
          value: `${this.battery.charging
          ? this.t('debugger.system.battery.charging.is_charging')
          : this.t('debugger.system.battery.charging.is_not_charging')}`,
          description: this.t('debugger.system.battery.charging.description'),
          verdict: getBatteryChargingVerdict({
            batteryLevelPercentage,
            chargingTimeInSeconds: this.battery.chargingTime,
            dischargingTimeInSeconds: this.battery.dischargingTime,
            charging: this.battery.charging,
          }),
        });
        this.batterySectionHealth = getOverallBatteryVerdict({
          stats: newBatteryStats,
        });
        this.batteryFormattedStats = newBatteryStats;
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isBatterySectionOpen = true;
      this.batterySectionHealth = null;
      this.battery = null;
      this.batteryFormattedStats = [];
    }
    toggleSection(section) {
      if (section === 'battery')
        this.isBatterySectionOpen = !this.isBatterySectionOpen;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (!this.meeting) {
        return;
      }
      if (this.battery) {
        this.battery.removeEventListener('levelchange', this.batteryUpdateListener);
        this.battery.removeEventListener('chargingchange', this.batteryUpdateListener);
      }
    }
    async meetingChanged(meeting) {
      if (!meeting)
        return;
      if (typeof navigator.getBattery !== 'undefined') {
        this.battery = await navigator.getBattery();
        this.battery.addEventListener('levelchange', this.batteryUpdateListener);
        this.battery.addEventListener('chargingchange', this.batteryUpdateListener);
        this.batteryUpdateListener();
      }
    }
    render() {
      var _a, _b;
      if (!this.meeting) {
        return;
      }
      return (h(Host, null, h("div", { id: "header" }), h("div", { class: "tab-body" }, h("div", { class: "status-container" }, h("div", { class: "status-section" }, h("div", { class: "section-header", onClick: () => this.toggleSection('battery') }, h("span", null, this.t('debugger.system.sections.battery')), this.batterySectionHealth && (h("span", { class: `status ${(_a = this.batterySectionHealth) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = this.batterySectionHealth) === null || _b === undefined ? undefined : _b.toLowerCase()}`)))), this.isBatterySectionOpen && !!this.batteryFormattedStats.length && (h("div", { class: "section-body battery-table" }, this.batteryFormattedStats.map((formattedStatsObj) => {
        var _a, _b;
        return (h("div", { class: "battery-row" }, h("div", { class: "battery-cell label" }, h("strong", null, formattedStatsObj.name), h("span", { class: "description" }, formattedStatsObj.description)), h("div", { class: "battery-cell value" }, h("span", { class: `status ${(_a = formattedStatsObj.verdict) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = formattedStatsObj.verdict) === null || _b === undefined ? undefined : _b.toLowerCase()}`)), h("span", { class: "value" }, formattedStatsObj.value))));
      }))))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteDebuggerSystem.style = dyteDebuggerSystemCss;

  const dyteDebuggerVideoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;overflow:hidden;height:100%;width:100%;color:rgb(var(--dyte-colors-text-1000, 255 255 255));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.tab-body::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}h3{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);font-size:16px;font-weight:600}#header{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-5, 20px);display:flex;align-items:center;justify-content:space-evenly}.tab-body{margin:var(--dyte-space-4, 16px);display:flex;height:100%;flex-direction:column;justify-content:space-between;overflow-y:auto}.status-container{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;padding:16px}.status-section{margin-bottom:12px}.section-header{display:flex;justify-content:space-between;align-items:center;font-weight:bold;padding:8px 0}.section-header.only-child{justify-content:center}.section-body.missing-stats{display:flex;text-align:center;justify-content:center}.section-header .status{color:rgba(var(--dyte-colors-success));font-weight:bold}.section-header .arrow{font-size:14px}.network-table{border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60));border-radius:8px;margin-top:8px;overflow:hidden}.network-row{display:flex;justify-content:space-between;padding:12px;border-bottom:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}.network-row:last-child{border-bottom:none}.network-cell{display:flex;flex-direction:column}.network-cell.label strong{font-size:14px}.network-cell.label .description{font-size:12px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}.network-cell.value{text-align:right}.status.good{color:rgba(var(--dyte-colors-success))}.status.average{color:rgba(var(--dyte-colors-warning))}.status.poor{color:rgba(var(--dyte-colors-danger))}.value{font-size:14px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));margin-top:4px}dyte-settings-video{display:flex;flex-direction:column}";

  const DyteDebuggerVideo = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      // private toggleSection(section: string) {
      //   if (section === 'network') this.isNetworkOpen = !this.isNetworkOpen;
      //   else if (section === 'devices') this.isDevicesOpen = !this.isDevicesOpen;
      // }
      this.mediaScoreUpdateListener = ({ kind, isScreenshare, scoreStats, }) => {
        if (kind === 'video' && !isScreenshare) {
          this.videoProducerScoreStats = scoreStats;
        }
      };
      this.deviceListUpdateListener = async () => {
        const videoDevices = await this.meeting.self.getVideoDevices();
        this.devicesHealth = (videoDevices === null || videoDevices === undefined ? undefined : videoDevices.length) > 0 ? 'Good' : 'Poor';
      };
      this.videoUpdateListener = () => {
        if (!this.meeting.self.videoEnabled) {
          this.videoProducerScoreStats = null;
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isNetworkOpen = true;
      this.isDevicesOpen = false;
      this.videoProducerFormattedStats = [];
      this.videoProducerScoreStats = null;
      this.networkBasedMediaHealth = null;
      this.devicesHealth = null;
    }
    async videoProducerScoreStatsChanged(newVideoProducerScoreStats) {
      if (!newVideoProducerScoreStats) {
        this.videoProducerFormattedStats = [];
        return;
      }
      const statsObj = newVideoProducerScoreStats;
      const newStatsList = [];
      newStatsList.push({
        name: this.t('debugger.stats.cpu_limitations.label'),
        value: statsObj.cpuLimitations ? 'Yes' : 'No',
        description: this.t('debugger.stats.cpu_limitations.description'),
        verdict: statsObj.cpuLimitations ? 'Poor' : 'Good',
      });
      newStatsList.push({
        name: this.t('debugger.stats.bandwidth_limitations.label'),
        value: statsObj.bandwidthLimitations ? 'Yes' : 'No',
        description: this.t('debugger.stats.bandwidth_limitations.description'),
        verdict: statsObj.bandwidthLimitations ? 'Poor' : 'Good',
      });
      newStatsList.push({
        name: this.t('debugger.stats.bitrate.label'),
        value: `${Math.round(statsObj.bitrate / 1024)} kbps`,
        description: this.t('debugger.stats.bitrate.description'),
        verdict: getBitrateVerdict({
          bitrate: statsObj.bitrate,
          kind: 'video',
          isScreenshare: false,
        }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.packet_loss.label'),
        value: `${statsObj.packetsLostPercentage}%`,
        description: this.t('debugger.stats.packet_loss.description'),
        verdict: getPacketLossVerdict({ packetLossPercentage: statsObj.packetsLostPercentage }),
      });
      newStatsList.push({
        name: this.t('debugger.stats.jitter.label'),
        value: `${Math.round(statsObj.jitter * 1000)} ms`,
        description: this.t('debugger.stats.jitter.description'),
        verdict: getJitterVerdict({ jitterInMS: statsObj.jitter * 1000 }),
      });
      this.videoProducerFormattedStats = newStatsList;
      this.networkBasedMediaHealth = getNetworkBasedMediaHealth({
        kind: 'video',
        isScreenshare: false,
        stats: newStatsList,
      });
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      if (!this.meeting) {
        return;
      }
      this.meeting.self.off('mediaScoreUpdate', this.mediaScoreUpdateListener);
      this.meeting.self.off('videoUpdate', this.videoUpdateListener);
      this.meeting.self.off('deviceListUpdate', this.deviceListUpdateListener);
    }
    async meetingChanged(meeting) {
      if (!meeting)
        return;
      meeting.self.on('mediaScoreUpdate', this.mediaScoreUpdateListener);
      meeting.self.on('videoUpdate', this.videoUpdateListener);
      meeting.self.on('deviceListUpdate', this.deviceListUpdateListener);
      await this.deviceListUpdateListener();
    }
    render() {
      var _a, _b;
      if (!this.meeting) {
        return;
      }
      // const defaults = {
      //   meeting: this.meeting,
      //   states: this.states || storeState,
      //   iconPack: this.iconPack,
      //   t: this.t,
      // };
      return (h(Host, null, h("div", { id: "header" }), h("div", { class: "tab-body" }, h("div", { class: "status-container" }, h("div", { class: "status-section" }, h("div", { class: `section-header ${!this.networkBasedMediaHealth ? 'only-child' : ''}` }, h("span", null, this.t('debugger.video.sections.network_media')), this.networkBasedMediaHealth && (h("span", { class: `status ${(_a = this.networkBasedMediaHealth) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = this.networkBasedMediaHealth) === null || _b === undefined ? undefined : _b.toLowerCase()}`)))), this.isNetworkOpen && !this.videoProducerFormattedStats.length && (h("div", { class: "section-body missing-stats" }, this.meeting.self.videoEnabled ? (h("span", null, this.t('debugger.video.messages.generating_report'))) : (h("span", null, this.t('debugger.video.messages.enable_media'))))), this.isNetworkOpen && !!this.videoProducerFormattedStats.length && (h("div", { class: "section-body network-table" }, this.videoProducerFormattedStats.map((formattedStatsObj) => {
        var _a, _b;
        return (h("div", { class: "network-row" }, h("div", { class: "network-cell label" }, h("strong", null, formattedStatsObj.name), h("span", { class: "description" }, formattedStatsObj.description)), h("div", { class: "network-cell value" }, h("span", { class: `status ${(_a = formattedStatsObj.verdict) === null || _a === undefined ? undefined : _a.toLowerCase()}` }, this.t(`debugger.quality.${(_b = formattedStatsObj.verdict) === null || _b === undefined ? undefined : _b.toLowerCase()}`)), h("span", { class: "value" }, formattedStatsObj.value))));
      }))))))));
    }
    static get watchers() { return {
      "videoProducerScoreStats": ["videoProducerScoreStatsChanged"],
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteDebuggerVideo.style = dyteDebuggerVideoCss;

  var dyteDebuggerAudio_4_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_debugger_audio: DyteDebuggerAudio,
      dyte_debugger_screenshare: DyteDebuggerScreenShare,
      dyte_debugger_system: DyteDebuggerSystem,
      dyte_debugger_video: DyteDebuggerVideo
  });

  const dyteLivestreamIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex}:host[size='sm']{margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px)}.indicator{display:flex;flex-direction:row;align-items:center;font-size:14px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);animation:blink 4s linear infinite}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([size='sm']) .indicator span{display:none}@keyframes blink{0%,10%{opacity:0}11%,100%{opacity:1}}";

  const DyteLivestreamIndicator = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.setIsLivestreaming = (state) => {
        this.isLivestreaming = state === 'LIVESTREAMING';
      };
      this.meeting = undefined;
      this.size = undefined;
      this.t = useLanguage();
      this.isLivestreaming = undefined;
      this.iconPack = defaultIconPack;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.livestream) === null || _b === undefined ? undefined : _b.removeListener('livestreamUpdate', this.setIsLivestreaming);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting == null)
        return;
      this.setIsLivestreaming((_a = this.meeting.livestream) === null || _a === undefined ? undefined : _a.state);
      (_b = this.meeting.livestream) === null || _b === undefined ? undefined : _b.on('livestreamUpdate', this.setIsLivestreaming);
    }
    render() {
      if (!showLivestream(this.meeting) || !this.isLivestreaming)
        return;
      return (h(Host, null, h("div", { class: "indicator", "aria-label": this.t('livestream.indicator'), part: "indicator" }, h("dyte-icon", { icon: this.iconPack.start_livestream, size: this.size }), h("span", null, this.t('LIVE')))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteLivestreamIndicator.style = dyteLivestreamIndicatorCss;

  const dyteLivestreamPlayerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:flex;height:100%;width:100%;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}.player-container{position:relative;margin:var(--dyte-space-4, 16px);display:flex;flex-grow:1;align-items:center;justify-content:center;overflow:hidden;border-radius:var(--dyte-border-radius-md, 8px)}.player{left:var(--dyte-space-0, 0px);z-index:20;aspect-ratio:16 / 9;height:100%;width:auto;border-radius:var(--dyte-border-radius-md, 8px);border-width:0px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}.loader{position:absolute;z-index:10;height:100%;width:100%;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));display:flex;flex-direction:column;align-items:center;justify-content:center}p{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);font-size:16px;color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.latency-controls{position:absolute;bottom:var(--dyte-space-4, 16px);right:var(--dyte-space-4, 16px);z-index:20;display:flex;flex-direction:row;align-items:center}.sync-live-stream{cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);font-size:12px}.unmute-popup{position:absolute;z-index:30 !important;display:flex;width:var(--dyte-space-72, 288px);flex-direction:column;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-4, 16px);text-align:center;max-width:70%}.unmute-popup h3{margin:var(--dyte-space-0, 0px);font-size:16px;font-weight:500}.unmute-popup p{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);font-size:14px}";

  const DyteLivestreamPlayer = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dyteAPIError = createEvent(this, "dyteAPIError", 7);
      this.livestreamUpdateListener = (state) => {
        this.livestreamState = state;
        this.playbackUrl = this.meeting.livestream.playbackUrl;
      };
      this.getLoadingState = () => {
        let loadingMessage = '';
        let isLoading = false;
        let showIcon = false;
        switch (this.livestreamState) {
          case 'IDLE':
            loadingMessage = this.t('livestream.idle');
            isLoading = true;
            showIcon = false;
            break;
          case 'STARTING':
            loadingMessage = this.t('livestream.starting');
            isLoading = true;
            showIcon = true;
            break;
          case 'STOPPING':
            loadingMessage = this.t('livestream.stopping');
            isLoading = true;
            showIcon = true;
            break;
          case 'LIVESTREAMING':
            if (this.playerState !== PlayerState.PLAYING) {
              loadingMessage = this.t('livestream.starting');
              showIcon = true;
              isLoading = true;
            }
            break;
          default:
            isLoading = false;
            loadingMessage = this.t('');
            showIcon = true;
            break;
        }
        return { isLoading, loadingMessage, showIcon };
      };
      this.getErrorState = () => {
        var _a, _b;
        let isError = false;
        let errorMessage = '';
        if (this.livestreamState !== 'LIVESTREAMING') {
          isError = false;
          errorMessage = this.t('');
          return { isError, errorMessage };
        }
        if (!this.isSupported) {
          isError = true;
          errorMessage = this.t('livestream.error.not_supported');
        }
        if (!this.playbackUrl) {
          isError = true;
          errorMessage = this.t('livestream.error.not_found');
        }
        if (this.playerError) {
          isError = true;
          errorMessage = this.t((_b = (_a = this.playerError) === null || _a === undefined ? undefined : _a.message) !== null && _b !== undefined ? _b : 'livestream.error.unknown');
        }
        return { isError, errorMessage };
      };
      /**
       * Make sure to call loadLivestreamPlayer before startLivestreamPlayer.
       */
      this.startLivestreamPlayer = async () => {
        try {
          this.meeting.__internals__.logger.info('dyte-livestream-player:: Initialising player element.');
          // @ts-ignore
          await window.__stream.initElement(this.player);
          this.meeting.__internals__.logger.info('dyte-livestream-player:: About to start player.');
          // @ts-ignore
          await window.dyte_hls.play();
          this.playerState = PlayerState.PLAYING;
          this.audioPlaybackError = false;
          this.meeting.__internals__.logger.info('dyte-livestream-player:: Player has started playing.');
        }
        catch (error) {
          this.meeting.__internals__.logger.error(`dyte-livestream-player:: Player couldn't start.`, {
            error,
          });
          // Retry with user gesture
          this.audioPlaybackError = true;
        }
      };
      this.loadLivestreamPlayer = async () => {
        const playerSrc = `https://cdn.dyte.in/streams/script.js`;
        if (!window.__stream && this.isScriptWithSrcPresent(playerSrc)) {
          // Script loading is ongoing; Do Nothing
          return false;
        }
        if (window.__stream) {
          return true;
        }
        // Since script is not there, let's add script first
        return new Promise((resolve) => {
          const script = document.createElement('script');
          script.src = playerSrc;
          script.onload = () => {
            setTimeout(() => {
              if (window.__stream) {
                this.meeting.__internals__.logger.info(`dyte-livestream-player:: Finished script load. Added window._stream.`);
                resolve(true);
                return;
              }
              this.meeting.__internals__.logger.error(`dyte-livestream-player:: onLoad didn't add window._stream in time.`);
              resolve(false);
            }, 1000);
          };
          script.onerror = (error) => {
            this.meeting.__internals__.logger.error(`dyte-livestream-player:: CDN script didn't load.`, { error });
            resolve(false);
          };
          document.head.appendChild(script);
        });
      };
      this.meeting = undefined;
      this.size = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.playbackUrl = undefined;
      this.isSupported = true;
      this.playerState = PlayerState.IDLE;
      this.livestreamState = 'IDLE';
      this.playerError = undefined;
      this.latency = 0;
      this.livestreamId = null;
      this.audioPlaybackError = false;
    }
    updateLivestreamId() {
      const url = this.meeting.livestream.playbackUrl;
      if (!url || this.livestreamState !== 'LIVESTREAMING') {
        this.livestreamId = null;
        this.player = null;
        // @ts-ignore
        window.dyteLivestreamPlayerElement = null;
        return;
      }
      const parts = url.split('/');
      const manifestIndex = parts.findIndex((part) => part === 'manifest');
      const streamId = parts[manifestIndex - 1];
      this.livestreamId = streamId;
    }
    isScriptWithSrcPresent(srcUrl) {
      const scripts = document.querySelectorAll('script');
      for (let script of scripts) {
        if (script.src === srcUrl) {
          return true;
        }
      }
      return false;
    }
    async connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.meeting.livestream.removeListener('livestreamUpdate', this.livestreamUpdateListener);
      this.player = null;
      // @ts-ignore
      window.dyteLivestreamPlayerElement = null;
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      this.livestreamState = this.meeting.livestream.state;
      this.playbackUrl = this.meeting.livestream.playbackUrl;
      this.meeting.livestream.on('livestreamUpdate', this.livestreamUpdateListener);
    }
    render() {
      if (!showLivestream(this.meeting))
        return;
      const { isError, errorMessage } = this.getErrorState();
      const { isLoading, loadingMessage, showIcon } = this.getLoadingState();
      return (h(Host, null, h("div", { class: "player-container" }, this.livestreamState === 'LIVESTREAMING' && this.livestreamId && (h("div", { class: "flex h-full w-full items-start justify-center pb-20" }, h("stream", { width: "100%", height: "80vh", className: "overflow-hidden rounded-lg", src: this.livestreamId, ref: async (self) => {
          this.player = self;
          // Add player instance on window to satisfy cdn script
          // @ts-ignore
          window.dyteLivestreamPlayerElement = self;
          const isPlayerLoaded = await this.loadLivestreamPlayer();
          if (isPlayerLoaded) {
            await this.startLivestreamPlayer();
          }
        }, cmcd: true, autoplay: true, "force-flavor": "llhls", "customer-domain-prefix": "customer-s8oj0c1n5ek8ah1e" }))), this.audioPlaybackError && (h("div", { class: "unmute-popup" }, h("h3", null, this.t('audio_playback.title')), h("p", null, this.t('audio_playback.description')), h("dyte-button", { kind: "wide", onClick: () => {
          if (this.player) {
            this.player.muted = false;
          }
          this.audioPlaybackError = false;
        }, title: this.t('audio_playback'), iconPack: this.iconPack, t: this.t }, this.t('audio_playback')))), isError && (h("div", { class: "loader" }, h("dyte-icon", { icon: this.iconPack.warning, t: this.t }), h("p", null, errorMessage))), !isError && isLoading && (h("div", { class: "loader" }, showIcon && (h("dyte-spinner", { id: "icon", part: "spinner", iconPack: this.iconPack, t: this.t, size: "md" })), h("p", null, loadingMessage))))));
    }
    static get watchers() { return {
      "livestreamState": ["updateLivestreamId"],
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteLivestreamPlayer.style = dyteLivestreamPlayerCss;

  const dyteViewerCountCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);display:inline-flex;height:var(--dyte-space-10, 40px);-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;font-size:14px}:host([size='sm']){margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px);font-size:12px}dyte-icon{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px)}:host([size='sm']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}:host([variant='embedded']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));opacity:0.5;margin-top:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-1, 4px);height:var(--dyte-space-5, 20px);border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:12px}:host([variant='embedded']) dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

  const DyteViewerCount = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.disconnectMeeting = (meeting) => {
        var _a;
        if (meeting != null && this.countListener != null) {
          (_a = meeting.livestream) === null || _a === undefined ? undefined : _a.removeListener('viewerCountUpdate', this.countListener);
        }
      };
      this.meeting = undefined;
      this.variant = 'primary';
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.viewerCount = 0;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      this.disconnectMeeting(this.meeting);
    }
    meetingChanged(meeting, oldMeeting) {
      var _a;
      this.disconnectMeeting(oldMeeting);
      if (meeting != null) {
        this.countListener = () => {
          var _a;
          this.viewerCount = (_a = meeting.livestream) === null || _a === undefined ? undefined : _a.viewerCount;
        };
        this.countListener();
        (_a = meeting.livestream) === null || _a === undefined ? undefined : _a.addListener('viewerCountUpdate', this.countListener);
      }
    }
    render() {
      if (!showLivestream(this.meeting))
        return null;
      return (h(Host, { tabIndex: 0, role: "log", "aria-label": `${this.viewerCount} ${this.t('viewers')}` }, h("dyte-icon", { icon: this.iconPack.viewers, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t }), this.viewerCount, " ", this.t('viewers')));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteViewerCount.style = dyteViewerCountCss;

  var dyteLivestreamIndicator_3_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_livestream_indicator: DyteLivestreamIndicator,
      dyte_livestream_player: DyteLivestreamPlayer,
      dyte_viewer_count: DyteViewerCount
  });

  const dyteNameTagCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:inline-flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-1\\.5, 6px);font-size:14px;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}span.name{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}::slotted(dyte-audio-visualizer[slot='start']){margin-right:var(--dyte-space-1\\.5, 6px)}::slotted(dyte-audio-visualizer[slot='end']){margin-left:var(--dyte-space-1\\.5, 6px)}:host([size='sm']){font-size:12px;--tw-bg-opacity:0.6}:host([variant='text']){background-color:transparent;padding:var(--dyte-space-0, 0px)}";

  const DyteNameTag = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.participant = undefined;
      this.meeting = undefined;
      this.size = undefined;
      this.isScreenShare = false;
      this.variant = 'default';
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.length = 13;
    }
    sizeChanged(size) {
      this.length = size === 'sm' ? 8 : 13;
    }
    formatNameTag(name, isSelf) {
      return !this.isScreenShare
        ? isSelf
          ? `${shorten(name, this.length - 3)} (${this.t('you')})`
          : shorten(name, this.length)
        : isSelf
          ? `${this.t('screen')} - ${shorten(name, this.length - 3)} (${this.t('you')})`
          : `${this.t('screen')} - ${shorten(name, this.length)}`;
    }
    render() {
      var _a, _b, _c;
      const name = formatName(((_a = this.participant) === null || _a === undefined ? undefined : _a.name) || '');
      const isSelf = ((_b = this.participant) === null || _b === undefined ? undefined : _b.id) === ((_c = this.meeting) === null || _c === undefined ? undefined : _c.self.id);
      return (h(Host, { title: name }, h("slot", { name: "start" }), h("span", { class: "name" }, this.formatNameTag(name, isSelf)), h("slot", { name: "end" })));
    }
    static get watchers() { return {
      "size": ["sizeChanged"]
    }; }
  };
  DyteNameTag.style = dyteNameTagCss;

  var dyteNameTag_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_name_tag: DyteNameTag
  });

  function getSide(placement) {
    return placement.split('-')[0];
  }

  function getAlignment(placement) {
    return placement.split('-')[1];
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
  }

  function getLengthFromAxis(axis) {
    return axis === 'y' ? 'height' : 'width';
  }

  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const mainAxis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(mainAxis);
    const commonAlign = reference[length] / 2 - floating[length] / 2;
    const side = getSide(placement);
    const isVertical = mainAxis === 'x';
    let coords;
    switch (side) {
      case 'top':
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case 'bottom':
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case 'right':
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case 'left':
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case 'start':
        coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case 'end':
        coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a reference element when it is given a certain positioning strategy.
   *
   * This export does not have any `platform` interface logic. You will need to
   * write one for the platform you are using Floating UI with.
   */
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = 'bottom',
      strategy = 'absolute',
      middleware = [],
      platform
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(floating));
    let rects = await platform.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform,
        elements: {
          reference,
          floating
        }
      });
      x = nextX != null ? nextX : x;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === 'object') {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
        continue;
      }
    }
    return {
      x,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };

  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }

  function getSideObjectFromPadding(padding) {
    return typeof padding !== 'number' ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }

  function rectToClientRect(rect) {
    return {
      ...rect,
      top: rect.y,
      left: rect.x,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    };
  }

  /**
   * Resolves with an object of overflow side offsets that determine how much the
   * element is overflowing a given clipping boundary.
   * - positive = overflowing the boundary by that number of pixels
   * - negative = how many pixels left before it will overflow
   * - 0 = lies flush with the boundary
   * @see https://floating-ui.com/docs/detectOverflow
   */
  async function detectOverflow(middlewareArguments, options) {
    var _await$platform$isEle;
    if (options === undefined) {
      options = {};
    }
    const {
      x,
      y,
      platform,
      rects,
      elements,
      strategy
    } = middlewareArguments;
    const {
      boundary = 'clippingAncestors',
      rootBoundary = 'viewport',
      elementContext = 'floating',
      altBoundary = false,
      padding = 0
    } = options;
    const paddingObject = getSideObjectFromPadding(padding);
    const altContext = elementContext === 'floating' ? 'reference' : 'floating';
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform.getClippingRect({
      element: ((_await$platform$isEle = await (platform.isElement == null ? undefined : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? undefined : platform.getDocumentElement(elements.floating))),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === 'floating' ? {
      ...rects.floating,
      x,
      y
    } : rects.reference;
    const offsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(elements.floating));
    const offsetScale = (await (platform.isElement == null ? undefined : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? undefined : platform.getScale(offsetParent))) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }

  const min$1 = Math.min;
  const max$1 = Math.max;

  function within(min$1$1, value, max$1$1) {
    return max$1(min$1$1, min$1(value, max$1$1));
  }

  /**
   * Positions an inner element of the floating element such that it is centered
   * to the reference element.
   * @see https://floating-ui.com/docs/arrow
   */
  const arrow = options => ({
    name: 'arrow',
    options,
    async fn(middlewareArguments) {
      // Since `element` is required, we don't Partial<> the type
      const {
        element,
        padding = 0
      } = options != null ? options : {};
      const {
        x,
        y,
        placement,
        rects,
        platform
      } = middlewareArguments;
      if (element == null) {
        return {};
      }
      const paddingObject = getSideObjectFromPadding(padding);
      const coords = {
        x,
        y
      };
      const axis = getMainAxisFromPlacement(placement);
      const length = getLengthFromAxis(axis);
      const arrowDimensions = await platform.getDimensions(element);
      const minProp = axis === 'y' ? 'top' : 'left';
      const maxProp = axis === 'y' ? 'bottom' : 'right';
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform.getOffsetParent == null ? undefined : platform.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      if (clientSize === 0) {
        clientSize = rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;

      // Make sure the arrow doesn't overflow the floating element if the center
      // point is outside the floating element's bounds
      const min = paddingObject[minProp];
      const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset = within(min, center, max);

      // If the reference is small enough that the arrow's padding causes it to
      // to point to nothing for an aligned placement, adjust the offset of the
      // floating element itself. This stops `shift()` from taking action, but can
      // be worked around by calling it again after the `arrow()` if desired.
      const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;
      return {
        [axis]: coords[axis] - alignmentOffset,
        data: {
          [axis]: offset,
          centerOffset: center - offset
        }
      };
    }
  });

  const hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
  }

  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === undefined) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const mainAxis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(mainAxis);
    let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return {
      main: mainAlignmentSide,
      cross: getOppositePlacement(mainAlignmentSide)
    };
  }

  const hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, matched => hash[matched]);
  }

  const sides = ['top', 'right', 'bottom', 'left'];
  const allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);

  function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter(placement => {
      if (alignment) {
        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
      }
      return true;
    });
  }
  /**
   * Automatically chooses the `placement` which has the most space available.
   * @see https://floating-ui.com/docs/autoPlacement
   */
  const autoPlacement = function (options) {
    if (options === undefined) {
      options = {};
    }
    return {
      name: 'autoPlacement',
      options,
      async fn(middlewareArguments) {
        var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
        const {
          x,
          y,
          rects,
          middlewareData,
          placement,
          platform,
          elements
        } = middlewareArguments;
        const {
          alignment,
          allowedPlacements = allPlacements,
          autoAlignment = true,
          ...detectOverflowOptions
        } = options;
        const placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
        const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
        const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? undefined : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
        const currentPlacement = placements[currentIndex];
        if (currentPlacement == null) {
          return {};
        }
        const {
          main,
          cross
        } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating)));

        // Make `computeCoords` start from the right place
        if (placement !== currentPlacement) {
          return {
            x,
            y,
            reset: {
              placement: placements[0]
            }
          };
        }
        const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
        const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? undefined : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {
          placement: currentPlacement,
          overflows: currentOverflows
        }];
        const nextPlacement = placements[currentIndex + 1];

        // There are more placements to check
        if (nextPlacement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
        const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {
          let {
            overflows
          } = _ref;
          return overflows.every(overflow => overflow <= 0);
        })) == null ? undefined : _placementsSortedByLe.placement;
        const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
        if (resetPlacement !== placement) {
          return {
            data: {
              index: currentIndex + 1,
              overflows: allOverflows
            },
            reset: {
              placement: resetPlacement
            }
          };
        }
        return {};
      }
    };
  };

  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }

  /**
   * Changes the placement of the floating element to one that will fit if the
   * initially specified `placement` does not.
   * @see https://floating-ui.com/docs/flip
   */
  const flip = function (options) {
    if (options === undefined) {
      options = {};
    }
    return {
      name: 'flip',
      options,
      async fn(middlewareArguments) {
        var _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform,
          elements
        } = middlewareArguments;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = 'bestFit',
          flipAlignment = true,
          ...detectOverflowOptions
        } = options;
        const side = getSide(placement);
        const isBasePlacement = side === initialPlacement;
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? undefined : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const {
            main,
            cross
          } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating)));
          overflows.push(overflow[main], overflow[cross]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];

        // One or more sides is overflowing
        if (!overflows.every(side => side <= 0)) {
          var _middlewareData$flip$, _middlewareData$flip2;
          const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? undefined : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            // Try next placement and re-run the lifecycle
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = 'bottom';
          switch (fallbackStrategy) {
            case 'bestFit':
              {
                var _overflowsData$map$so;
                const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? undefined : _overflowsData$map$so[0].placement;
                if (placement) {
                  resetPlacement = placement;
                }
                break;
              }
            case 'initialPlacement':
              resetPlacement = initialPlacement;
              break;
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };

  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some(side => overflow[side] >= 0);
  }
  /**
   * Provides data to hide the floating element in applicable situations, such as
   * when it is not in the same clipping context as the reference element.
   * @see https://floating-ui.com/docs/hide
   */
  const hide = function (options) {
    if (options === undefined) {
      options = {};
    }
    return {
      name: 'hide',
      options,
      async fn(middlewareArguments) {
        const {
          strategy = 'referenceHidden',
          ...detectOverflowOptions
        } = options;
        const {
          rects
        } = middlewareArguments;
        switch (strategy) {
          case 'referenceHidden':
            {
              const overflow = await detectOverflow(middlewareArguments, {
                ...detectOverflowOptions,
                elementContext: 'reference'
              });
              const offsets = getSideOffsets(overflow, rects.reference);
              return {
                data: {
                  referenceHiddenOffsets: offsets,
                  referenceHidden: isAnySideFullyClipped(offsets)
                }
              };
            }
          case 'escaped':
            {
              const overflow = await detectOverflow(middlewareArguments, {
                ...detectOverflowOptions,
                altBoundary: true
              });
              const offsets = getSideOffsets(overflow, rects.floating);
              return {
                data: {
                  escapedOffsets: offsets,
                  escaped: isAnySideFullyClipped(offsets)
                }
              };
            }
          default:
            {
              return {};
            }
        }
      }
    };
  };

  async function convertValueToCoords(middlewareArguments, value) {
    const {
      placement,
      platform,
      elements
    } = middlewareArguments;
    const rtl = await (platform.isRTL == null ? undefined : platform.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getMainAxisFromPlacement(placement) === 'x';
    const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = typeof value === 'function' ? value(middlewareArguments) : value;

    // eslint-disable-next-line prefer-const
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === 'number' ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null,
      ...rawValue
    };
    if (alignment && typeof alignmentAxis === 'number') {
      crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }

  /**
   * Displaces the floating element from its reference element.
   * @see https://floating-ui.com/docs/offset
   */
  const offset = function (value) {
    if (value === undefined) {
      value = 0;
    }
    return {
      name: 'offset',
      options: value,
      async fn(middlewareArguments) {
        const {
          x,
          y
        } = middlewareArguments;
        const diffCoords = await convertValueToCoords(middlewareArguments, value);
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: diffCoords
        };
      }
    };
  };

  function getCrossAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  /**
   * Shifts the floating element in order to keep it in view when it will overflow
   * a clipping boundary.
   * @see https://floating-ui.com/docs/shift
   */
  const shift = function (options) {
    if (options === undefined) {
      options = {};
    }
    return {
      name: 'shift',
      options,
      async fn(middlewareArguments) {
        const {
          x,
          y,
          placement
        } = middlewareArguments;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: _ref => {
              let {
                x,
                y
              } = _ref;
              return {
                x,
                y
              };
            }
          },
          ...detectOverflowOptions
        } = options;
        const coords = {
          x,
          y
        };
        const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
        const mainAxis = getMainAxisFromPlacement(getSide(placement));
        const crossAxis = getCrossAxis(mainAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === 'y' ? 'top' : 'left';
          const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
          const min = mainAxisCoord + overflow[minSide];
          const max = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = within(min, mainAxisCoord, max);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === 'y' ? 'top' : 'left';
          const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
          const min = crossAxisCoord + overflow[minSide];
          const max = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = within(min, crossAxisCoord, max);
        }
        const limitedCoords = limiter.fn({
          ...middlewareArguments,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y
          }
        };
      }
    };
  };

  function getWindow(node) {
    var _node$ownerDocument;
    return ((_node$ownerDocument = node.ownerDocument) == null ? undefined : _node$ownerDocument.defaultView) || window;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function getNodeName(node) {
    return isNode(node) ? (node.nodeName || '').toLowerCase() : '';
  }

  let uaString;
  function getUAString() {
    if (uaString) {
      return uaString;
    }
    const uaData = navigator.userAgentData;
    if (uaData && Array.isArray(uaData.brands)) {
      uaString = uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
      return uaString;
    }
    return navigator.userAgent;
  }

  function isHTMLElement(value) {
    return value instanceof getWindow(value).HTMLElement;
  }
  function isElement(value) {
    return value instanceof getWindow(value).Element;
  }
  function isNode(value) {
    return value instanceof getWindow(value).Node;
  }
  function isShadowRoot(node) {
    // Browsers without `ShadowRoot` support
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }
    const OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
  }
  function isTableElement(element) {
    return ['table', 'td', 'th'].includes(getNodeName(element));
  }
  function isContainingBlock(element) {
    // TODO: Try and use feature detection here instead
    const isFirefox = /firefox/i.test(getUAString());
    const css = getComputedStyle$1(element);
    const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;

    // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    return css.transform !== 'none' || css.perspective !== 'none' || (backdropFilter ? backdropFilter !== 'none' : false) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective'].some(value => css.willChange.includes(value)) || ['paint', 'layout', 'strict', 'content'].some(
    // TS 4.1 compat
    value => {
      const contain = css.contain;
      return contain != null ? contain.includes(value) : false;
    });
  }
  function isLayoutViewport() {
    // Not Safari
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
    // Feature detection for this fails in various ways
    // • Always-visible scrollbar or not
    // • Width of <html>, etc.
    // const vV = win.visualViewport;
    // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
  }

  function isLastTraversableNode(node) {
    return ['html', 'body', '#document'].includes(getNodeName(node));
  }

  const min = Math.min;
  const max = Math.max;
  const round = Math.round;

  function getCssDimensions(element) {
    const css = getComputedStyle$1(element);
    let width = parseFloat(css.width);
    let height = parseFloat(css.height);
    const offsetWidth = element.offsetWidth;
    const offsetHeight = element.offsetHeight;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      fallback: shouldFallback
    };
  }

  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }

  const FALLBACK_SCALE = {
    x: 1,
    y: 1
  };
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return FALLBACK_SCALE;
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      fallback
    } = getCssDimensions(domElement);
    let x = (fallback ? round(rect.width) : rect.width) / width;
    let y = (fallback ? round(rect.height) : rect.height) / height;

    // 0, NaN, or Infinity should always fallback to 1.

    if (!x || !Number.isFinite(x)) {
      x = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x,
      y
    };
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    var _win$visualViewport, _win$visualViewport2;
    if (includeScale === undefined) {
      includeScale = false;
    }
    if (isFixedStrategy === undefined) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = FALLBACK_SCALE;
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const win = domElement ? getWindow(domElement) : window;
    const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? undefined : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
    let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? undefined : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentIFrame = win.frameElement;
      while (currentIFrame && offsetParent && offsetWin !== win) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css = getComputedStyle(currentIFrame);
        iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
        iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
        x *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x += iframeRect.x;
        y += iframeRect.y;
        currentIFrame = getWindow(currentIFrame).frameElement;
      }
    }
    return {
      width,
      height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x,
      y
    };
  }

  function getDocumentElement(node) {
    return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
  }

  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
  }

  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const rect = getBoundingClientRect(element, true, strategy === 'fixed', offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent, true);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function getParentNode(node) {
    if (getNodeName(node) === 'html') {
      return node;
    }
    const result =
    // Step into the shadow DOM of the parent of a slotted node
    node.assignedSlot ||
    // DOM Element detected
    node.parentNode || (
    // ShadowRoot detected
    isShadowRoot(node) ? node.host : null) ||
    // Fallback
    getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else {
        currentNode = getParentNode(currentNode);
      }
    }
    return null;
  }

  // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.
  function getOffsetParent(element) {
    const window = getWindow(element);
    let offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
      return window;
    }
    return offsetParent || getContainingBlock(element) || window;
  }

  function getDimensions(element) {
    return getCssDimensions(element);
  }

  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    if (offsetParent === documentElement) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = {
      x: 1,
      y: 1
    };
    const offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
      if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
      // This doesn't appear to need to be negated.
      // else if (documentElement) {
      //   offsets.x = getWindowScrollBarX(documentElement);
      // }
    }

    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
  }

  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  // Gets the entire size of the scrollable document area, even extending outside
  // of the `<html>` and `<body>` rect bounds if horizontally scrollable
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = (_element$ownerDocumen = element.ownerDocument) == null ? undefined : _element$ownerDocumen.body;
    const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    let x = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$1(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x,
      y
    };
  }

  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      // @ts-ignore assume body is always available
      return node.ownerDocument.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }

  function getOverflowAncestors(node, list) {
    var _node$ownerDocument;
    if (list === undefined) {
      list = [];
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? undefined : _node$ownerDocument.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
  }

  // Returns the inner client rect, subtracting scrollbars if present
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : {
      x: 1,
      y: 1
    };
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x = left * scale.x;
    const y = top * scale.y;
    return {
      top: y,
      left: x,
      right: x + width,
      bottom: y + height,
      x,
      y,
      width,
      height
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    if (clippingAncestor === 'viewport') {
      return rectToClientRect(getViewportRect(element, strategy));
    }
    if (isElement(clippingAncestor)) {
      return getInnerBoundingClientRect(clippingAncestor, strategy);
    }
    return rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }

  // A "clipping ancestor" is an `overflow` element with the characteristic of
  // clipping (or hiding) child elements. This returns all clipping ancestors
  // of the given element up the tree.
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === 'fixed';
    let currentNode = elementIsFixed ? getParentNode(element) : element;

    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const containingBlock = isContainingBlock(currentNode);
      const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position);
      if (shouldDropCurrentNode) {
        // Drop non-containing blocks
        result = result.filter(ancestor => ancestor !== currentNode);
      } else {
        // Record last containing block for next iteration
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }

  // Gets the maximum area that the element is visible in due to any number of
  // clipping ancestors
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }

  const platform = {
    getClippingRect,
    convertOffsetParentRelativeRectToViewportRelativeRect,
    isElement,
    getDimensions,
    getOffsetParent,
    getDocumentElement,
    getScale,
    async getElementRects(_ref) {
      let {
        reference,
        floating,
        strategy
      } = _ref;
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
      const getDimensionsFn = this.getDimensions;
      return {
        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
        floating: {
          x: 0,
          y: 0,
          ...(await getDimensionsFn(floating))
        }
      };
    },
    getClientRects: element => Array.from(element.getClientRects()),
    isRTL: element => getComputedStyle$1(element).direction === 'rtl'
  };

  /**
   * Computes the `x` and `y` coordinates that will place the floating element
   * next to a reference element when it is given a certain CSS positioning
   * strategy.
   */
  const computePosition = (reference, floating, options) => {
    // This caches the expensive `getClippingElementAncestors` function so that
    // multiple lifecycle resets re-use the same result. It only lives for a
    // single call. If other functions become expensive, we can add them as well.
    const cache = new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  const dyteParticipantCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:flex;height:var(--dyte-space-14, 56px);align-items:center;justify-content:space-between;cursor:pointer;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host dyte-avatar{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);font-size:14px}.left{display:flex;align-items:center}.left>*{margin-right:var(--dyte-space-2, 8px)}.left>*:last-child{margin-right:var(--dyte-space-0, 0px)}.right{display:flex;align-items:center;justify-content:flex-end}.right>*{margin-left:var(--dyte-space-2, 8px)}.right>*:first-child{margin-left:var(--dyte-space-0, 0px)}.name{overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}dyte-icon.red{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}dyte-icon.more{cursor:pointer}.menu{position:relative;display:inline-block;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}#menu-list{position:absolute;z-index:20}";

  const DyteParticipant = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dyteSendNotification = createEvent(this, "dyteSendNotification", 7);
      this.pinnedListener = ({ isPinned }) => {
        this.isPinned = isPinned;
      };
      this.stageListener = ({ stageStatus }) => {
        this.isOnStage = stageStatus === 'ON_STAGE';
      };
      this.permissionsUpdateListener = () => {
        this.meetingChanged(this.meeting);
      };
      this.inviteToStageToggle = async () => {
        const p = this.participant;
        const { stage } = this.meeting;
        // If request has been sent once, do nothing.
        if (p.stageStatus === 'ACCEPTED_TO_JOIN_STAGE') {
          // Send a notification to host telling that the user has been invited.
          this.dyteSendNotification.emit({
            message: `${p.name} ${this.t('stage.invited_notification')}`,
            trace: `join-stage-${p.id}`,
          });
          return;
        }
        if (this.isOnStage) {
          // NOTE (@madhugb): when a pinned participnat is removed from stage, we need to unpin them manually
          if (p.isPinned)
            p.unpin();
          await stage.kick([p.userId]);
        }
        else {
          await stage.grantAccess([p.userId]);
          // Send a notification to host telling that the user has been invited.
          this.dyteSendNotification.emit({
            message: `${p.name} ${this.t('stage.invited_notification')}`,
            trace: `join-stage-invite-${p.id}`,
          });
        }
        this.isOnStage = p.stageStatus === 'ON_STAGE';
      };
      this.handleOutsideClick = (event) => {
        const path = event.composedPath();
        const clickedOutside = !path.includes(this.host);
        // handles clicking on other menu triggers
        if (clickedOutside && this.menuOpen) {
          this.menuOpen = false;
        }
      };
      this.update = () => {
        const triggerEl = this.host.shadowRoot.getElementById('trigger');
        const menuListEl = this.host.shadowRoot.getElementById('menu-list');
        computePosition(triggerEl, menuListEl, {
          placement: 'bottom-end',
          middleware: [
            autoPlacement({
              allowedPlacements: ['bottom-end', 'top-end'],
              alignment: 'end', // Align to start of the trigger
            }),
            offset(4),
            shift({ padding: 8 }),
            hide(),
          ],
        }).then(({ x, y, placement }) => {
          let position = null;
          if (placement === 'bottom-end') {
            position = {
              right: `${x}px`,
              top: `${y}px`,
            };
          }
          else {
            position = {
              right: `${x}px`,
              bottom: `${y}px`,
            };
          }
          Object.assign(menuListEl.style, position);
        });
      };
      this.onMenuToggle = () => {
        this.menuOpen = !this.menuOpen;
        if (this.menuOpen) {
          this.update();
        }
      };
      this.meeting = undefined;
      this.view = 'sidebar';
      this.participant = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.config = defaultConfig;
      this.audioEnabled = false;
      this.videoEnabled = false;
      this.isPinned = false;
      this.isOnStage = false;
      this.canDisableParticipantAudio = false;
      this.canDisableParticipantVideo = false;
      this.canKickParticipant = false;
      this.canPinParticipant = false;
      this.canAllowParticipantOnStage = false;
      this.menuOpen = false;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
      this.participantChanged(this.participant);
      document.addEventListener('click', this.handleOutsideClick);
    }
    disconnectedCallback() {
      var _a;
      document.removeEventListener('click', this.handleOutsideClick);
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
      if (this.participant == null || this.participant.removeListener == undefined)
        return;
      this.audioUpdateListener &&
        this.participant.removeListener('audioUpdate', this.audioUpdateListener);
      this.videoUpdateListener &&
        this.participant.removeListener('videoUpdate', this.videoUpdateListener);
      this.participant.removeListener('pinned', this.pinnedListener);
      this.participant.removeListener('unpinned', this.pinnedListener);
      this.participant.removeListener('stageStatusUpdate', this.stageListener);
    }
    meetingChanged(meeting) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (meeting != null) {
        const { self } = meeting;
        this.canDisableParticipantAudio =
          self.permissions.canAllowParticipantAudio || self.permissions.canDisableParticipantAudio;
        this.canDisableParticipantVideo =
          self.permissions.canAllowParticipantVideo || self.permissions.canDisableParticipantVideo;
        this.canKickParticipant =
          self.permissions.kickParticipant &&
            ((_a = this.meeting) === null || _a === undefined ? undefined : _a.__internals__.features.hasFeature(FlagsmithFeatureFlags.DISABLE_KICKING)) !==
              true &&
            (((_b = this.meeting) === null || _b === undefined ? undefined : _b.__internals__.features.hasFeature(FlagsmithFeatureFlags.ADMIN_CANTREMOVE_ADMIN)) !== true ||
              ((_c = this.participant) === null || _c === undefined ? undefined : _c.presetName) !== 'webinar_admin');
        this.canPinParticipant = self.permissions.pinParticipant;
        this.canAllowParticipantOnStage =
          self.permissions.acceptStageRequests &&
            self.permissions.stageEnabled &&
            (((_d = this.meeting) === null || _d === undefined ? undefined : _d.__internals__.features.hasFeature(FlagsmithFeatureFlags.ADMIN_CANTREMOVE_ADMIN)) !== true ||
              ((_e = this.participant) === null || _e === undefined ? undefined : _e.presetName) !== 'webinar_admin') &&
            (((_f = this.meeting) === null || _f === undefined ? undefined : _f.__internals__.features.hasFeature(FlagsmithFeatureFlags.CANTINVITE_VIEWER)) !== true ||
              ((_g = this.participant) === null || _g === undefined ? undefined : _g.presetName) !== 'webinar_viewer');
        meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
      }
    }
    participantChanged(participant) {
      if (participant != null) {
        this.audioEnabled = participant.audioEnabled;
        this.videoEnabled = participant.videoEnabled;
        this.isPinned = participant.isPinned;
        this.isOnStage = participant.stageStatus === 'ON_STAGE';
        this.audioUpdateListener = ({ audioEnabled }) => {
          this.audioEnabled = audioEnabled;
        };
        this.videoUpdateListener = ({ videoEnabled }) => {
          this.videoEnabled = videoEnabled;
        };
        if (participant.addListener == undefined)
          return;
        participant.addListener('audioUpdate', this.audioUpdateListener);
        participant.addListener('videoUpdate', this.videoUpdateListener);
        participant.addListener('pinned', this.pinnedListener);
        participant.addListener('unpinned', this.pinnedListener);
        participant.addListener('stageStatusUpdate', this.stageListener);
      }
    }
    render() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const isAudioRoom = ((_a = this.meeting) === null || _a === undefined ? undefined : _a.meta.viewType) === 'AUDIO_ROOM';
      const isSelf = ((_b = this.meeting) === null || _b === undefined ? undefined : _b.self.id) === this.participant.id;
      const showMenu = (this.canDisableParticipantAudio && this.audioEnabled) ||
        (this.canDisableParticipantVideo && this.videoEnabled && !isAudioRoom) ||
        this.canKickParticipant ||
        (this.canPinParticipant && this.isOnStage) ||
        this.canAllowParticipantOnStage;
      const name = formatName(((_c = this.participant) === null || _c === undefined ? undefined : _c.name) || '');
      // NOTE(@madhugb): Show some actions for only on stage / non-webinar participants
      // NOTE(@vaibhavshn): Update check after listeners are implemented
      const isActiveParticipant = this.isOnStage || ['GROUP_CALL', 'AUDIO_ROOM'].includes((_d = this.meeting) === null || _d === undefined ? undefined : _d.meta.viewType);
      const defaults = {
        meeting: this.meeting,
        size: 'sm',
        states: state,
        config: this.config,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("div", { class: "left", key: (_e = this.participant) === null || _e === undefined ? undefined : _e.id }, h("dyte-avatar", { participant: this.participant, size: "sm", iconPack: this.iconPack, t: this.t }), h("p", { class: "name", title: name }, shorten(name, 16), " ", ((_f = this.meeting) === null || _f === undefined ? undefined : _f.self.id) === ((_g = this.participant) === null || _g === undefined ? undefined : _g.id) && this.t('(you)'))), this.view === 'sidebar' && (h("div", { class: "right" }, isActiveParticipant && (h("dyte-icon", { class: {
          red: !this.audioEnabled,
        }, iconPack: this.iconPack, t: this.t, icon: this.audioEnabled ? this.iconPack.mic_on : this.iconPack.mic_off })), isActiveParticipant && !isAudioRoom && (h("dyte-icon", { class: {
          red: !this.videoEnabled,
        }, iconPack: this.iconPack, t: this.t, icon: this.videoEnabled ? this.iconPack.video_on : this.iconPack.video_off })), (showMenu ||
        lenChildren({
          element: 'dyte-participant',
          defaults: defaults,
          childProps: {
            participant: this.participant,
          },
        }) > 0) && (h("div", { class: "menu" }, h("span", { id: "trigger", onClick: this.onMenuToggle }, h("dyte-button", { variant: "ghost", kind: "icon", slot: "trigger", iconPack: this.iconPack, t: this.t }, h("dyte-icon", { class: "more", icon: this.iconPack.more_vertical }))), h("span", { id: "menu-list" }, this.menuOpen && (h("dyte-menu-list", { iconPack: this.iconPack, t: this.t }, this.canPinParticipant && isActiveParticipant && !isAudioRoom && (h("dyte-menu-item", { onClick: () => {
          if (this.isPinned) {
            this.participant.unpin();
          }
          else {
            this.participant.pin();
          }
        }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.isPinned ? this.iconPack.pin_off : this.iconPack.pin, slot: "start", iconPack: this.iconPack, t: this.t }), this.isPinned ? this.t('unpin') : this.t('pin'))), this.canDisableParticipantAudio && isActiveParticipant && this.audioEnabled && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, onClick: () => {
          this.participant.disableAudio();
        } }, h("dyte-icon", { icon: this.iconPack.mic_off, slot: "start" }), this.t('mute'))), this.canDisableParticipantVideo && isActiveParticipant && this.videoEnabled && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, onClick: () => {
          this.participant.disableVideo();
        } }, h("dyte-icon", { icon: this.iconPack.video_off, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('participants.turn_off_video'))), this.canAllowParticipantOnStage &&
        ((_h = this.participant) === null || _h === undefined ? undefined : _h.id) !== ((_j = this.meeting) === null || _j === undefined ? undefined : _j.self.id) && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, class: this.isOnStage ? 'red' : '', onClick: this.inviteToStageToggle }, h("dyte-icon", { iconPack: this.iconPack, t: this.t, icon: this.isOnStage
          ? this.iconPack.leave_stage
          : this.iconPack.join_stage, slot: "start" }), this.isOnStage
        ? this.t('stage.remove_from_stage')
        : this.t('stage.add_to_stage'))), !isSelf && this.canKickParticipant && (h("dyte-menu-item", { iconPack: this.iconPack, t: this.t, class: "red", onClick: () => {
          var _a, _b;
          (_a = this.meeting) === null || _a === undefined ? undefined : _a.participants.kick((_b = this.participant) === null || _b === undefined ? undefined : _b.id);
        } }, h("dyte-icon", { icon: this.iconPack.dismiss, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('kick'))), h("slot", null, h(Render, { element: "dyte-participant", defaults: defaults, childProps: {
          participant: this.participant,
        }, deepProps: true, onlyChildren: true })))))))))));
    }
    get host() { return getElement(this); }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "participant": ["participantChanged"]
    }; }
  };
  DyteParticipant.style = dyteParticipantCss;

  var dyteParticipant_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_participant: DyteParticipant
  });

  const dytePollCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.ctr{margin-bottom:var(--dyte-space-3, 12px);display:flex;width:100%;flex-direction:column;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.poll-title{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);margin-right:var(--dyte-space-4, 16px);font-size:12px}.poll{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));display:flex;flex-direction:column;padding:var(--dyte-space-4, 16px)}.poll-question{padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:14px;overflow-wrap:break-word}.poll-answers{display:flex;flex-direction:row;justify-content:space-between;font-size:12px;margin-top:var(--dyte-space-4, 16px);margin-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1, 4px);padding-right:var(--dyte-space-3, 12px)}.poll-option{display:flex;flex-direction:column;margin-top:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding:var(--dyte-space-2, 8px);word-break:break-word}.poll-option.open-vote:hover{cursor:pointer}.poll-option label{display:flex;flex-direction:row;cursor:inherit}.poll-option-header{display:flex;flex-direction:row;justify-content:space-between;padding:var(--dyte-space-1, 4px)}.poll-option-header[data-disabled='true']:hover{cursor:default}.poll-option-header input{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px);margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-2, 8px);cursor:inherit}.poll-option-header .counter{color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:12px}.votes{margin-top:var(--dyte-space-1, 4px);display:flex;flex-direction:row;flex-wrap:wrap}.vote{margin-right:var(--dyte-space-1, 4px);height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);display:flex;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));border-radius:var(--dyte-border-radius-none, 0);clip-path:circle()}.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}.active .counter{color:rgb(var(--dyte-colors-text-on-brand-900, var(--dyte-colors-text-900, 255 255 255 / 0.88)))}";

  const DytePolls = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onVote = createEvent(this, "dyteVotePoll", 7);
      this.MAX_VOTES_RENDER = 10;
      this.poll = undefined;
      this.self = undefined;
      this.permissions = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    vote(e, index) {
      if (this.poll.voted.includes(this.self)) {
        e.preventDefault();
      }
      else {
        this.onVote.emit({ id: this.poll.id, index });
      }
    }
    render() {
      const hasVoted = this.poll.voted.includes(this.self);
      return (h(Host, null, h("div", { class: "ctr" }, h("p", { class: "poll-title" }, this.t('polls.by'), " ", shorten(formatName(this.poll.createdBy), 20)), h("div", { class: "poll" }, h("p", { class: "poll-question" }, this.poll.question), h("div", { class: "poll-answers" }, h("span", null, this.t('polls.answers')), h("span", null, this.poll.voted.length)), this.poll.options.map((item, index) => (h("div", { class: {
          active: item.votes.some((x) => x.id === this.self),
          'open-vote': this.permissions.polls.canVote && !hasVoted,
          'poll-option': true,
        } }, h("div", { class: "poll-option-header", "data-disabled": !this.permissions.polls.canVote }, h("label", null, !hasVoted && (h("input", { disabled: !this.permissions.polls.canVote, readOnly: hasVoted, type: "radio", checked: item.votes.some((x) => x.id === this.self), onClick: (e) => this.vote(e, index) })), h("p", null, item.text)), h("span", { class: "counter" }, item.count)), h("div", { class: "votes" }, item.votes.slice(0, this.MAX_VOTES_RENDER).map((vote) => {
        if (this.poll.anonymous && this.self !== this.poll.createdByUserId)
          return;
        return (h("dyte-tooltip", { label: vote.name, iconPack: this.iconPack, t: this.t }, h("div", { class: "vote" }, getInitials(vote.name))));
      }), item.votes.length > this.MAX_VOTES_RENDER && (h("dyte-tooltip", { label: `+${item.votes.length - this.MAX_VOTES_RENDER} more `, iconPack: this.iconPack, t: this.t }, h("div", { class: "vote" }, "+", item.votes.length - this.MAX_VOTES_RENDER)))))))))));
    }
  };
  DytePolls.style = dytePollCss;

  const dytePollFormCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.create-poll{margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);display:flex;flex:1 1 0%;flex-direction:column;padding:var(--dyte-space-3, 12px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.create-poll p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px);text-align:center}.create-poll textarea{display:flex;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);font-family:var(--dyte-font-family, sans-serif);border-width:var(--dyte-border-width-none, 0);border-style:none;font-weight:500;outline:2px solid transparent;outline-offset:2px;margin-top:var(--dyte-space-3, 12px);margin-bottom:var(--dyte-space-3, 12px);resize:vertical;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.create-poll textarea:focus{outline-style:solid;outline-offset:2px;outline-color:rgb(var(--dyte-colors-background-600, 60 60 60))}.option{display:flex;flex-direction:row;align-items:center;margin-bottom:var(--dyte-space-3, 12px);width:100%}.option input{width:100%;border-radius:var(--dyte-border-radius-sm, 4px);padding:var(--dyte-space-2, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;outline:2px solid transparent;outline-offset:2px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.remove-option{margin-left:var(--dyte-space-2, 8px);width:var(--dyte-space-10, 40px);border-radius:var(--dyte-border-radius-sm, 4px)}.add-option{margin-bottom:var(--dyte-space-3, 12px)}label{margin-bottom:var(--dyte-space-3, 12px)}.error-text{margin-top:var(--dyte-space-3, 12px);text-align:center;font-size:12px;--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DytePoll = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onCreate = createEvent(this, "dyteCreatePoll", 7);
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.options = ['', ''];
      this.anonymous = false;
      this.hideVotes = true;
      this.error = undefined;
    }
    removeOption(index) {
      var _a;
      this.options = this.options.filter((_, ind) => ind !== index);
      if (((_a = this.error) === null || _a === undefined ? undefined : _a.code) === 1)
        this.error = undefined;
    }
    addOption() {
      this.options = [...this.options, ''];
    }
    updateOption(ev, index) {
      var _a;
      this.options[index] = ev.target.value;
      if (((_a = this.error) === null || _a === undefined ? undefined : _a.code) === 1)
        this.error = undefined;
    }
    handleSubmit() {
      const pollObject = {
        question: this.question.value,
        options: this.options,
        anonymous: this.anonymous,
        hideVotes: this.anonymous ? true : this.hideVotes,
      };
      if (!pollObject.question) {
        this.error = {
          code: 0,
          message: this.t('polls.errors.question_required'),
        };
        return;
      }
      if (this.options.filter((op) => op.trim() === '').length > 0) {
        this.error = {
          code: 1,
          message: this.t('polls.errors.empty_option'),
        };
        return;
      }
      this.onCreate.emit(pollObject);
    }
    render() {
      return (h(Host, null, h("div", { class: "create-poll" }, h("p", null, this.t('polls.question')), h("textarea", { onInput: () => {
          if (this.error && this.error.code === 0)
            this.error = undefined;
        }, ref: (e) => (this.question = e), placeholder: this.t('polls.question.placeholder') }), this.options.map((item, index) => (h("div", { class: "option" }, h("input", { placeholder: this.t('polls.option.placeholder'), value: item, onInput: (event) => this.updateOption(event, index) }), index > 1 && (h("dyte-button", { kind: "icon", class: "auto remove-option", variant: "secondary", onClick: () => this.removeOption(index), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.subtract, iconPack: this.iconPack, t: this.t })))))), h("dyte-button", { class: "add-option", variant: "secondary", onClick: () => this.addOption(), iconPack: this.iconPack, t: this.t }, this.t('polls.option')), h("label", null, h("input", { id: "anonymous", type: "checkbox", onChange: (e) => (this.anonymous = e.target.checked) }), this.t('polls.results.anon')), h("label", null, h("input", { id: "hideVotes", type: "checkbox", disabled: this.anonymous, checked: this.anonymous ? true : this.hideVotes, onChange: (e) => (this.hideVotes = e.target.checked) }), this.t('polls.results.hide')), h("dyte-button", { kind: "wide", onClick: () => this.handleSubmit(), iconPack: this.iconPack, t: this.t }, this.t('polls.create')), this.error && h("span", { class: "error-text" }, this.error.message))));
    }
  };
  DytePoll.style = dytePollFormCss;

  var dytePoll_2_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_poll: DytePolls,
      dyte_poll_form: DytePoll
  });

  const dyteSettingsAudioCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:100%;flex-direction:column}audio{visibility:hidden}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}dyte-audio-visualizer{flex-shrink:0}dyte-button{border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}dyte-button dyte-icon{margin-right:var(--dyte-space-2, 8px)}";

  const DyteSettingsAudio = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      var _a, _b;
      if (this.meeting == null)
        return null;
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      const states = this.states || state;
      const initialNotificationSoundsPreference = ((_a = states === null || states === undefined ? undefined : states.prefs) === null || _a === undefined ? undefined : _a.muteNotificationSounds) === true ||
        getPreference('mute-notification-sounds') === 'true';
      return (h(Host, null, h("dyte-microphone-selector", Object.assign({}, defaults), h("dyte-audio-visualizer", { participant: (_b = this.meeting) === null || _b === undefined ? undefined : _b.self, iconPack: this.iconPack, t: this.t, slot: "indicator" })), h("dyte-speaker-selector", Object.assign({}, defaults)), h("div", { class: "group", part: "notification-toggle" }, h("div", { class: "row" }, h("label", { htmlFor: "notification-toggle" }, this.t('settings.notification_sound')), h("dyte-switch", { id: "notification-toggle", checked: !initialNotificationSoundsPreference, onDyteChange: (e) => {
          var _a;
          const { checked } = e.target;
          const muteNotificationSounds = !checked;
          this.stateUpdate.emit({ prefs: { muteNotificationSounds } });
          state.prefs = Object.assign(Object.assign({}, ((_a = state.prefs) !== null && _a !== undefined ? _a : {})), { muteNotificationSounds });
          setPreference('mute-notification-sounds', muteNotificationSounds);
        }, iconPack: this.iconPack, t: this.t })))));
    }
  };
  DyteSettingsAudio.style = dyteSettingsAudioCss;

  const dyteSettingsVideoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5)}:host{display:flex;width:100%;flex-direction:column}.dyte-select{width:100%;text-overflow:ellipsis}dyte-participant-tile{margin-left:auto;margin-right:auto;margin-bottom:var(--dyte-space-4, 16px);max-width:100%}#icon{padding-bottom:var(--dyte-space-1, 4px)}.apply-button{height:var(--dyte-space-10, 40px)}label{-webkit-user-select:none;-moz-user-select:none;user-select:none;font-size:14px}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.row{display:flex;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}.section{display:flex;flex-direction:column}@media only screen and (max-height: 480px) and (orientation: landscape){:host{flex-direction:row}:host([size='sm']){flex-direction:row}.section[part='tile-preview']{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);max-height:90%;max-width:40%;flex-shrink:1}.section[part='video-settings']{margin-left:var(--dyte-space-2, 8px);margin-right:var(--dyte-space-2, 8px);flex-grow:1}}";

  const DyteSettingsVideo = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.onVideoUpdate = (videoState) => {
        this.videoEnabled = videoState.videoEnabled;
      };
      this.meeting = undefined;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.videoEnabled = undefined;
    }
    componentDidLoad() {
      this.meetingChanged(this.meeting);
    }
    meetingChanged(meeting) {
      var _a;
      if (meeting == null)
        return;
      this.videoEnabled = meeting.self.videoEnabled;
      (_a = meeting.self) === null || _a === undefined ? undefined : _a.addListener('videoUpdate', this.onVideoUpdate);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting.self) === null || _a === undefined ? undefined : _a.removeListener('videoUpdate', this.onVideoUpdate);
    }
    render() {
      var _a, _b, _c;
      if (this.meeting == null)
        return null;
      const defaults = {
        meeting: this.meeting,
        states: this.states || state,
        size: this.size,
        iconPack: this.iconPack,
        t: this.t,
      };
      const states = this.states || state;
      const initialMirrorPreference = ((_a = states === null || states === undefined ? undefined : states.prefs) === null || _a === undefined ? undefined : _a.mirrorVideo) === true || getPreference('mirror-video') === 'true';
      return (h(Host, null, h("div", { class: "section", part: "tile-preview" }, h("div", { class: "group", part: "tile-preview" }, this.videoEnabled === true ? (h("dyte-participant-tile", { meeting: this.meeting, participant: (_b = this.meeting) === null || _b === undefined ? undefined : _b.self, iconPack: this.iconPack, t: this.t, states: states, size: this.size, isPreview: true })) : (h("div", { class: "camera-off-helper" }, h("dyte-participant-tile", { meeting: this.meeting, participant: (_c = this.meeting) === null || _c === undefined ? undefined : _c.self, size: this.size }, h("div", null, h("dyte-icon", { id: "icon", icon: this.iconPack.video_off, tabIndex: -1, "aria-hidden": true, iconPack: this.iconPack, t: this.t }), h("div", null, this.t('settings.camera_off')))))))), h("dyte-camera-selector", Object.assign({}, defaults)), h("div", { class: "group", part: "mirror-toggle" }, h("div", { class: "row" }, h("label", { htmlFor: "mirror-toggle" }, this.t('settings.mirror_video')), h("dyte-switch", { checked: initialMirrorPreference, iconPack: this.iconPack, t: this.t, onDyteChange: (e) => {
          var _a;
          const { checked } = e.target;
          this.stateUpdate.emit({ prefs: { mirrorVideo: checked } });
          state.prefs = Object.assign(Object.assign({}, ((_a = state.prefs) !== null && _a !== undefined ? _a : {})), { mirrorVideo: checked });
          setPreference('mirror-video', checked);
        } })))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteSettingsVideo.style = dyteSettingsVideoCss;

  var dyteSettingsAudio_2_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_settings_audio: DyteSettingsAudio,
      dyte_settings_video: DyteSettingsVideo
  });

  const dyteTabBarCss = ".scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{box-sizing:border-box;display:flex;height:100%;width:var(--dyte-space-16, 64px);flex-direction:column;gap:var(--dyte-space-2, 8px);overflow-y:auto;font-family:var(--dyte-font-family, sans-serif)}dyte-button{z-index:10}.col{display:flex;flex-direction:column;align-items:center}.tab{display:flex;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);align-items:center;justify-content:center;margin-bottom:var(--dyte-space-2, 8px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.tab.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}.tab img{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);border-radius:var(--dyte-border-radius-sm, 4px)}.tab .name{margin-top:var(--dyte-space-0\\.5, 2px)}:host([size='sm']){flex-direction:column;margin-top:var(--dyte-space-4, 16px);height:var(--dyte-space-16, 64px);width:100%;flex-direction:row;gap:var(--dyte-space-2, 8px);overflow-x:auto}:host([size='sm']) .tab{margin:var(--dyte-space-0, 0px);text-overflow:clip;min-width:100px;height:40px}:host([size='sm']) .tab .col{display:flex;flex-direction:row;align-items:center;gap:var(--dyte-space-2, 8px)}:host([size='sm']) .tab .col img,:host([size='sm']) .tab .col dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']) .tab .col .name{gap:var(--dyte-space-1, 4px)}:host([layout='column']){flex-direction:column}:host([layout='column']) .aside{flex:2;max-width:100%;width:100%}@media (orientation: portrait){:host([size='sm']){margin-top:var(--dyte-space-2, 8px);height:var(--dyte-space-16, 64px);width:100%;flex-direction:row;transition:all 0.3s linear}:host([size='md']){height:var(--dyte-space-24, 96px);width:100%;flex-direction:row;transition:all 0.3s linear}:host .tab{margin:var(--dyte-space-0, 0px)}}@media (orientation: landscape){:host([size='sm']){margin-right:var(--dyte-space-4, 16px);height:100%;width:var(--dyte-space-14, 56px);flex-direction:row;gap:var(--dyte-space-2, 8px);overflow-y:auto;overflow-x:hidden;transition:all 0.3s linear}:host([size='md']){margin-right:var(--dyte-space-4, 16px);height:100%;width:var(--dyte-space-14, 56px);flex-direction:row;gap:var(--dyte-space-2, 8px);overflow-y:auto;overflow-x:hidden;transition:all 0.3s linear}:host .tab{margin:var(--dyte-space-0, 0px)}:host([size='sm']) .tab{margin:var(--dyte-space-0, 0px);width:100%;text-overflow:clip;min-width:0px;min-height:40px}:host([size='sm']) .tab .col{display:flex;flex-direction:column;align-items:center;gap:var(--dyte-space-2, 8px);font-size:10px}:host([size='sm']) .tab .col img,:host([size='sm']) .tab .col dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px)}:host([size='sm']) .tab .col .name{gap:var(--dyte-space-1, 4px)}}";

  const DyteTabBar = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.tabChange = createEvent(this, "tabChange", 7);
      this.size = undefined;
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.layout = 'row';
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.activeTab = undefined;
      this.tabs = [];
    }
    render() {
      return (h(Host, null, h("dyte-spotlight-indicator", { meeting: this.meeting, iconPack: this.iconPack, t: this.t, size: this.size }), this.tabs.map((tab) => {
        var _a, _b, _c, _d, _e;
        let isActive = false;
        if (((_a = this.activeTab) === null || _a === undefined ? undefined : _a.type) === 'plugin' &&
          tab.plugin &&
          ((_b = this.activeTab) === null || _b === undefined ? undefined : _b.plugin.id) === tab.plugin.id)
          isActive = true;
        else if (((_c = this.activeTab) === null || _c === undefined ? undefined : _c.type) === 'screenshare' &&
          tab.participant &&
          ((_d = this.activeTab) === null || _d === undefined ? undefined : _d.participant.id) === tab.participant.id)
          isActive = true;
        if (tab.type === 'screenshare') {
          const participant = tab.participant;
          const name = formatName(participant.name);
          return (h("dyte-button", { title: `${name}'s Screen Share`, key: tab.participant.id, kind: "icon", iconPack: this.iconPack, t: this.t, variant: isActive ? 'primary' : 'secondary', class: {
              tab: true,
              active: isActive,
            }, onClick: () => this.tabChange.emit(tab) }, h("div", { class: "center col" }, h("dyte-icon", { icon: this.iconPack.share_screen_person, iconPack: this.iconPack, t: this.t }), h("span", { class: "name" }, participant.id === ((_e = this.meeting) === null || _e === undefined ? undefined : _e.self.id) ? this.t('you') : shorten(name, 6)))));
        }
        else if (tab.type === 'plugin') {
          const plugin = tab.plugin;
          return (h("dyte-button", { title: plugin.name, key: plugin.id, kind: "icon", iconPack: this.iconPack, t: this.t, variant: isActive ? 'primary' : 'secondary', class: {
              tab: true,
              active: isActive,
            }, onClick: () => this.tabChange.emit(tab) }, h("div", { class: "center col" }, h("img", { src: plugin.picture }), h("span", { class: "name" }, shorten(plugin.name, 6)))));
        }
      })));
    }
  };
  DyteTabBar.style = dyteTabBarCss;

  var dyteTabBar_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_tab_bar: DyteTabBar
  });

  const dyteTranscriptCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{pointer-events:none;display:block;color:rgb(var(--dyte-colors-text-1000, 255 255 255));display:flex;justify-content:center;vertical-align:middle;animation:show 0.4s ease;transition:0.4s;z-index:5;width:100%}.ctr{box-sizing:border-box;display:inline-flex;height:100%;align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);--tw-shadow-color:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-shadow:var(--tw-shadow-colored);pointer-events:auto;padding:var(--dyte-space-3, 12px);overflow:auto;max-width:50%}.message{margin:var(--dyte-space-0, 0px);display:inline-block;justify-content:center;max-width:100%;text-wrap:wrap;line-height:1.5rem}.message .name{font-weight:bold}:host(.exit){animation:exit 0.4s ease}@keyframes show{0%{opacity:0;transform:translateY(120px)}100%{opacity:1;transform:translateY(0px)}}@keyframes exit{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-120px)}}:host([size='sm']){font-size:14px}";

  const DyteTranscript = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dismiss = createEvent(this, "dyteTranscriptDismiss", 7);
      this.transcript = undefined;
      this.t = useLanguage();
      this.timeout = undefined;
    }
    connectedCallback() {
      this.transcriptChanged(this.transcript);
    }
    transcriptChanged(transcript, oldTranscript) {
      if ((oldTranscript === null || oldTranscript === undefined ? undefined : oldTranscript.renderedId) === transcript.renderedId &&
        (oldTranscript === null || oldTranscript === undefined ? undefined : oldTranscript.transcript) === transcript.transcript) {
        return;
      }
      clearTimeout(this.timeout);
      if (!(transcript === null || transcript === undefined ? undefined : transcript.name) || !(transcript === null || transcript === undefined ? undefined : transcript.transcript)) {
        return;
      }
      const { id, renderedId } = transcript;
      this.timeout = setTimeout(() => {
        this.dismiss.emit({ id, renderedId });
      }, 10000);
    }
    render() {
      return (h(Host, null, h("div", { class: "ctr" }, h("p", { class: "message" }, h("span", { class: "name" }, this.transcript.name), ": ", this.transcript.transcript))));
    }
    static get watchers() { return {
      "transcript": ["transcriptChanged"]
    }; }
  };
  DyteTranscript.style = dyteTranscriptCss;

  var dyteTranscript_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_transcript: DyteTranscript
  });

  /**
   * Draws audio visualizer of variant `bars`
   * @param canvas Canvas element
   * @param volume Current volume
   */
  const drawBarsVisualizer = (canvas, volume) => {
    if (canvas == null) {
      return;
    }
    const nSlices = 3;
    const halfwaySlice = Math.round(nSlices / 2);
    const sample = [...Array(nSlices)].map((_, i) => {
      let index = i;
      if (index > halfwaySlice - 1) {
        index = nSlices - index - 1;
      }
      return Math.round(((index + 1) / (halfwaySlice + 1)) * volume);
    });
    const { width, height } = canvas;
    const context = canvas.getContext('2d');
    let x = 2;
    const sliceGraphicWidth = 4;
    const sliceWidth = (width * 1.0) / sample.length;
    const slicePadding = sliceWidth - sliceGraphicWidth;
    context.clearRect(0, 0, width, height);
    context.fillStyle = 'rgb(0,0,0,0.0)';
    context.fillRect(0, 0, width, height);
    const color = getComputedStyle(canvas).getPropertyValue('color');
    context.fillStyle = color;
    context.strokeStyle = color;
    context.lineCap = 'round';
    context.lineWidth = 4;
    context.beginPath();
    for (const item of sample) {
      const y = Math.min(-Math.abs(((item * 1.2) / 10) * height) + height / 2, height / 2 - 2.5);
      const sliceHeight = Math.max((height / 2 - y) * 2, 5);
      context.moveTo(x + slicePadding / 2, y);
      context.lineTo(x + slicePadding / 2, y + sliceHeight);
      x += sliceWidth;
    }
    context.stroke();
  };

  const dyteAudioVisualizerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;width:-moz-fit-content;width:fit-content}.hideMuted{padding:var(--dyte-space-1, 4px)}canvas,dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){transform:scale(0.9)}canvas{display:none}canvas.visible{display:block}canvas.bars{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

  const DyteAudioVisualizer = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.variant = 'bars';
      this.participant = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.hideMuted = false;
      this.isScreenShare = false;
      this.audioEnabled = undefined;
      this.volume = 0;
    }
    connectedCallback() {
      this.participantChanged(this.participant);
    }
    componentDidLoad() {
      drawBarsVisualizer(this.visualizer, 0);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_a = this.hark) === null || _a === undefined ? undefined : _a.stop();
      this.audioUpdateListener &&
        ((_b = this.participant) === null || _b === undefined ? undefined : _b.removeListener('audioUpdate', this.audioUpdateListener));
      this.screenShareUpdateListener &&
        ((_c = this.participant) === null || _c === undefined ? undefined : _c.removeListener('screenShareUpdate', this.screenShareUpdateListener));
    }
    participantChanged(participant) {
      if (participant != null) {
        this.audioUpdateListener = ({ audioEnabled, audioTrack }) => {
          var _a;
          (_a = this.hark) === null || _a === undefined ? undefined : _a.stop();
          if (audioEnabled && audioTrack != null) {
            this.audioEnabled = true;
            const stream = new MediaStream();
            stream.addTrack(audioTrack);
            this.calcVolume(stream);
            // initial draw with volume: 0
            drawBarsVisualizer(this.visualizer, 0);
          }
          else {
            this.volume = 0;
            this.audioEnabled = false;
          }
        };
        if (this.isScreenShare) {
          this.screenShareUpdateListener = ({ screenShareEnabled, screenShareTracks }) => {
            this.audioUpdateListener({
              audioEnabled: screenShareEnabled && screenShareTracks.audio != null,
              audioTrack: screenShareTracks.audio,
            });
          };
          this.screenShareUpdateListener({
            screenShareEnabled: participant.screenShareEnabled,
            screenShareTracks: {
              audio: participant.screenShareTracks.audio,
              video: participant.screenShareTracks.video,
            },
          });
          participant.addListener('screenShareUpdate', this.screenShareUpdateListener);
        }
        else {
          this.audioUpdateListener(participant);
          participant.addListener('audioUpdate', this.audioUpdateListener);
        }
      }
    }
    /**
     * Determines the volume from a given MediaStream and updates the components state
     * @param stream A MediaStream with AudioTrack(s) added
     */
    calcVolume(stream) {
      this.hark = hark(stream, {
        play: false,
        interval: 1000 / 10,
      });
      this.hark.on('volume_change', (dBs) => {
        const prevVolume = this.volume;
        // The exact formula to convert from dBs (-100..0) to linear (0..1) is:
        //   Math.pow(10, dBs / 20)
        // However it does not produce a visually useful output, so let exagerate
        // it a bit. Also, let convert it from 0..1 to 0..10 and avoid value 1 to
        // minimize component renderings.
        // if dBs is -Inifnity, set vol to 0
        let audioVol = Math.round(10 ** (dBs / 115) * 10);
        if (audioVol < 3)
          audioVol = 0;
        let volume = Math.round((prevVolume * 2 + audioVol) / 3);
        if (prevVolume !== volume) {
          this.volume = volume;
          drawBarsVisualizer(this.visualizer, this.volume);
        }
      });
    }
    render() {
      return (h(Host, null, h("div", { class: {
          hideMuted: this.hideMuted,
        } }, h("canvas", { width: "24", height: "24", class: {
          bars: true,
          visible: this.audioEnabled,
        }, ref: (el) => (this.visualizer = el), part: "canvas" }), !this.isScreenShare && !this.audioEnabled && this.hideMuted !== true && (h("dyte-icon", { icon: this.iconPack.mic_off, part: "mic-off-icon", iconPack: this.iconPack, t: this.t })))));
    }
    static get watchers() { return {
      "participant": ["participantChanged"]
    }; }
  };
  DyteAudioVisualizer.style = dyteAudioVisualizerCss;

  const dyteMicrophoneSelectorCss = ".dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5);width:100%;max-width:100%;text-overflow:ellipsis}.inline .dyte-select{margin-top:var(--dyte-space-1, 4px);width:100%;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-8, 32px);font-size:14px}.row{margin-bottom:var(--dyte-space-2, 8px);display:flex;width:100%;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.inline.group{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0\\.5, 2px)}.inline.group>*{margin-bottom:var(--dyte-space-0, 0px)}label{display:flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;gap:var(--dyte-space-1, 4px);font-size:14px}.inline.container{display:flex;align-items:center;justify-content:flex-start;gap:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}";

  const DyteMicrophoneSelector = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stageStateListener = () => {
        this.canProduceAudio = this.meeting.self.permissions.canProduceAudio === 'ALLOWED';
      };
      this.deviceListUpdateListener = ({ devices }) => {
        const result = devices.reduce((res, device) => {
          var _a;
          (_a = res[device.kind]) === null || _a === undefined ? undefined : _a.push(device);
          return res;
        }, { audioinput: [], audiooutput: [] });
        this.audioinputDevices = result.audioinput;
      };
      this.deviceUpdateListener = ({ device }) => {
        if (device.kind === 'audioinput') {
          this.currentDevices = {
            audio: device,
          };
        }
      };
      this.mediaPermissionUpdateListener = async ({ kind, message }) => {
        if (!this.meeting)
          return;
        if (kind === 'audio' && message === 'ACCEPTED') {
          this.audioinputDevices = await this.meeting.self.getAudioDevices();
        }
      };
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.variant = 'full';
      this.t = useLanguage();
      this.audioinputDevices = [];
      this.canProduceAudio = true;
      this.currentDevices = { audio: undefined };
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', this.stageStateListener);
      (_c = this.meeting) === null || _c === undefined ? undefined : _c.self.removeListener('deviceListUpdate', this.deviceListUpdateListener);
      (_d = this.meeting) === null || _d === undefined ? undefined : _d.self.removeListener('deviceUpdate', this.deviceUpdateListener);
      (_e = this.meeting) === null || _e === undefined ? undefined : _e.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      writeTask(async () => {
        var _a, _b;
        const { self, stage } = meeting;
        const audioDevices = await meeting.self.getAudioDevices();
        const currentAudioDevice = (_a = meeting.self.getCurrentDevices()) === null || _a === undefined ? undefined : _a.audio;
        this.currentDevices = {
          audio: currentAudioDevice,
        };
        this.canProduceAudio = this.meeting.self.permissions.canProduceAudio === 'ALLOWED';
        stage === null || stage === undefined ? undefined : stage.addListener('stageStatusUpdate', this.stageStateListener);
        self.addListener('deviceListUpdate', this.deviceListUpdateListener);
        self.addListener('deviceUpdate', this.deviceUpdateListener);
        self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
        if (currentAudioDevice != undefined) {
          this.audioinputDevices = [
            (_b = audioDevices.find((device) => device.deviceId === currentAudioDevice.deviceId)) !== null && _b !== undefined ? _b : currentAudioDevice,
            ...audioDevices.filter((device) => device.deviceId !== currentAudioDevice.deviceId),
          ];
        }
        else {
          this.audioinputDevices = audioDevices;
        }
      });
    }
    setDevice(deviceId) {
      var _a;
      if (disableSettingSinkId(this.meeting))
        return;
      const device = this.audioinputDevices.find((d) => d.deviceId === deviceId);
      if (device != null) {
        this.currentDevices = {
          audio: device,
        };
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.setDevice(device);
      }
    }
    render() {
      if (this.meeting == null)
        return null;
      let unnamedMicCount = 0;
      return (h(Host, null, this.canProduceAudio && (h("div", { part: "microphone-selection", class: 'group container ' + this.variant }, h("label", { slot: "label" }, this.variant !== 'inline' && this.t('settings.microphone_input'), h("dyte-icon", { icon: this.iconPack.mic_on, iconPack: this.iconPack, t: this.t, size: "sm" })), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice(e.target.value) }, this.audioinputDevices.map(({ deviceId, label }) => {
        var _a;
        return (h("option", { value: deviceId, selected: ((_a = this.currentDevices.audio) === null || _a === undefined ? undefined : _a.deviceId) === deviceId }, label || `Microphone ${++unnamedMicCount}`));
      })), h("slot", { name: "indicator" }))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteMicrophoneSelector.style = dyteMicrophoneSelectorCss;

  const dyteSpeakerSelectorCss = ".dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5);width:100%;max-width:100%;text-overflow:ellipsis}.inline .dyte-select{margin-top:var(--dyte-space-1, 4px);width:100%;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-8, 32px);font-size:14px}.row{display:flex;width:100%;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.inline.group{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0\\.5, 2px)}.inline.group>*{margin-bottom:var(--dyte-space-0, 0px)}label{display:flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;gap:var(--dyte-space-1, 4px);font-size:14px}.inline .container{display:flex;align-items:center;justify-content:flex-start;gap:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}";

  const DyteSpeakerSelector = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.deviceListUpdateListener = ({ devices }) => {
        const result = devices.reduce((res, device) => {
          var _a;
          (_a = res[device.kind]) === null || _a === undefined ? undefined : _a.push(device);
          return res;
        }, { audioinput: [], audiooutput: [] });
        this.speakerDevices = result.audiooutput;
      };
      this.deviceUpdateListener = ({ device }) => {
        if (device.kind === 'audiooutput') {
          this.currentDevices = {
            speaker: device,
          };
        }
      };
      this.mediaPermissionUpdate = async ({ kind, message }) => {
        if (!this.meeting)
          return;
        if (kind === 'audio' && message === 'ACCEPTED') {
          this.speakerDevices = await this.meeting.self.getSpeakerDevices();
        }
      };
      this.meeting = undefined;
      this.states = undefined;
      this.variant = 'full';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.speakerDevices = [];
      this.currentDevices = { speaker: undefined };
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.removeListener('deviceListUpdate', this.deviceListUpdateListener);
      (_b = this.meeting) === null || _b === undefined ? undefined : _b.self.removeListener('deviceUpdate', this.deviceUpdateListener);
      (_c = this.meeting) === null || _c === undefined ? undefined : _c.self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdate);
    }
    meetingChanged(meeting) {
      if (meeting == null)
        return;
      writeTask(async () => {
        var _a, _b;
        const { self } = meeting;
        const speakerDevices = await meeting.self.getSpeakerDevices();
        const currentSpeakerDevice = (_a = meeting.self.getCurrentDevices()) === null || _a === undefined ? undefined : _a.speaker;
        this.currentDevices = {
          speaker: currentSpeakerDevice,
        };
        self.addListener('deviceListUpdate', this.deviceListUpdateListener);
        self.addListener('deviceUpdate', this.deviceUpdateListener);
        self.addListener('mediaPermissionUpdate', this.mediaPermissionUpdate);
        if (currentSpeakerDevice != undefined) {
          this.speakerDevices = [
            (_b = speakerDevices.find((device) => device.deviceId === currentSpeakerDevice.deviceId)) !== null && _b !== undefined ? _b : currentSpeakerDevice,
            ...speakerDevices.filter((device) => device.deviceId !== currentSpeakerDevice.deviceId),
          ];
        }
        else {
          this.speakerDevices = speakerDevices;
        }
      });
    }
    testAudio() {
      var _a;
      (_a = this.testAudioEl) === null || _a === undefined ? undefined : _a.play();
    }
    setDevice(deviceId) {
      var _a, _b;
      if (disableSettingSinkId(this.meeting))
        return;
      const device = this.speakerDevices.find((d) => d.deviceId === deviceId);
      this.currentDevices = {
        speaker: device,
      };
      if (device != null) {
        (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.setDevice(device);
        (_b = this.testAudioEl) === null || _b === undefined ? undefined : _b.setSinkId(device.deviceId);
      }
    }
    render() {
      if (this.meeting == null)
        return null;
      let unnamedSpeakerCount = 0;
      return (h(Host, null, h("audio", { preload: "auto", src: "https://assets.dyte.io/ui-kit/speaker-test.mp3", ref: (el) => (this.testAudioEl = el) }), h("div", { class: 'group ' + this.variant, part: "speaker-selection" }, this.speakerDevices.length > 0 && !disableSettingSinkId(this.meeting) && (h("div", { class: "container" }, h("label", null, this.variant !== 'inline' && this.t('settings.speaker_output'), h("dyte-icon", { icon: this.iconPack.speaker, iconPack: this.iconPack, t: this.t, size: "sm" })), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice(e.target.value) }, this.speakerDevices.map(({ deviceId, label }) => {
        var _a;
        return (h("option", { value: deviceId, selected: ((_a = this.currentDevices.speaker) === null || _a === undefined ? undefined : _a.deviceId) === deviceId }, label || `Speaker ${++unnamedSpeakerCount}`));
      }))))), this.variant === 'full' && (h("dyte-button", { variant: "secondary", onClick: () => this.testAudio(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.speaker, slot: "start", iconPack: this.iconPack, t: this.t }), this.t('test'))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteSpeakerSelector.style = dyteSpeakerSelectorCss;

  const dyteSwitchCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:inline-flex;height:var(--dyte-space-6, 24px);width:var(--dyte-space-10, 40px);align-items:center;padding:var(--dyte-space-1, 4px);border-radius:9999px;background-color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));cursor:pointer}.switch{box-sizing:border-box;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);background-color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:9999px;transition-property:var(--dyte-transition-property, all);transition-duration:200ms}:host(.checked){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity))}:host(.checked) .switch{transform:translateX(100%)}:host([readonly]),:host([disabled]){cursor:not-allowed;opacity:0.6}";

  const DyteSwitch = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dyteChange = createEvent(this, "dyteChange", 4);
      this.onClick = () => {
        if (!this.readonly && !this.disabled) {
          this.checked = !this.checked;
        }
      };
      this.onKeyPress = (e) => {
        if (this.readonly)
          return;
        switch (e.key) {
          // Enter or Space
          case 'Enter':
          case ' ':
            this.checked = !this.checked;
            break;
        }
      };
      this.checked = false;
      this.readonly = false;
      this.disabled = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.checkedChange(this.checked);
    }
    checkedChange(checked) {
      this.checked = checked;
      this.dyteChange.emit(checked);
    }
    render() {
      return (h(Host, { role: "switch", tabIndex: this.disabled && 0, "aria-readonly": this.readonly, "aria-checked": this.checked, "aria-disabled": this.disabled, class: { checked: this.checked }, onClick: this.onClick, onKeyPress: this.onKeyPress }, h("div", { class: "switch", part: "switch" })));
    }
    static get watchers() { return {
      "checked": ["checkedChange"]
    }; }
  };
  DyteSwitch.style = dyteSwitchCss;

  var dyteAudioVisualizer_4_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_audio_visualizer: DyteAudioVisualizer,
      dyte_microphone_selector: DyteMicrophoneSelector,
      dyte_speaker_selector: DyteSpeakerSelector,
      dyte_switch: DyteSwitch
  });

  const dyteChannelDetailsCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));display:flex;flex-direction:column;width:var(--dyte-space-72, 288px);padding-top:var(--dyte-space-5, 20px);padding-bottom:var(--dyte-space-5, 20px);padding-left:var(--dyte-space-8, 32px);padding-right:var(--dyte-space-8, 32px)}header{font-size:20px}dyte-spinner{margin-top:var(--dyte-space-10, 40px);margin-bottom:var(--dyte-space-10, 40px);margin-left:auto;margin-right:auto}ul{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);margin-top:var(--dyte-space-6, 24px);margin-bottom:var(--dyte-space-4, 16px);height:var(--dyte-space-48, 192px);padding:var(--dyte-space-0, 0px);overflow-y:auto;list-style-type:none;display:flex;flex-direction:column;gap:var(--dyte-space-2, 8px)}ul li{margin-right:var(--dyte-space-2, 8px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px);padding:var(--dyte-space-2, 8px);cursor:pointer;border-radius:var(--dyte-border-radius-sm, 4px)}ul li:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}ul li dyte-avatar{height:var(--dyte-space-7, 28px);width:var(--dyte-space-7, 28px);font-size:14px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

  const DyteChannelDetails = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.channel = undefined;
      this.t = useLanguage();
      this.iconPack = defaultIconPack;
      this.members = [];
    }
    renderMembers() {
      return (h("ul", { class: "scrollbar" }, this.members.map((member) => {
        return (h("li", null, h("dyte-avatar", { participant: { name: member.name, picture: member.picture }, size: "sm" }), h("span", null, member.name)));
      })));
    }
    render() {
      return (h(Host, null, h("header", null, this.t('chat.channel_members')), this.renderMembers()));
    }
  };
  DyteChannelDetails.style = dyteChannelDetailsCss;

  var dyteChannelDetails_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_channel_details: DyteChannelDetails
  });

  const dyteChatMessageCss = ".message-wrapper{display:flex;gap:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-4, 16px);margin-right:var(--dyte-space-4, 16px);margin-top:var(--dyte-space-4, 16px)}[is-continued] .message-wrapper{margin-top:var(--dyte-space-0, 0px)}.message-wrapper.align-right{flex-direction:row-reverse}.file-picker{display:none}.message{position:relative;display:flex}.show-on-hover dyte-menu{visibility:hidden}.show-on-hover:hover dyte-menu{visibility:visible}.align-right .message{justify-content:flex-end;margin-left:auto}.align-right .message .head{margin-right:var(--dyte-space-1, 4px);margin-left:var(--dyte-space-0, 0px);flex-direction:row-reverse;gap:var(--dyte-space-4, 16px)}.align-right .message dyte-text-message .bubble,.align-right .message dyte-image-message .bubble,.align-right .message dyte-file-message .bubble{padding-right:var(--dyte-space-5, 20px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right .message .actions dyte-icon{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right dyte-menu{left:auto;right:var(--dyte-space-0, 0px)}.head{margin-bottom:var(--dyte-space-2, 8px);margin-left:var(--dyte-space-1, 4px);display:flex;align-items:center;gap:var(--dyte-space-2, 8px)}.head .name{font-size:14px;font-weight:600}.head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}dyte-menu{position:absolute;left:var(--dyte-space-0, 0px);top:var(--dyte-space-6, 24px);border-radius:var(--dyte-border-radius-lg, 12px)}dyte-menu dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);cursor:pointer}[is-continued] dyte-menu{top:var(--dyte-space-2, 8px)}.actions{display:flex;align-items:center;justify-content:center;padding:var(--dyte-space-0\\.5, 2px);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent}.actions dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.body{margin-top:var(--dyte-space-1, 4px);margin-bottom:var(--dyte-space-1, 4px);overflow-wrap:break-word;font-size:14px;line-height:1.375}.body .emoji{font-size:24px}.body.bubble{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-1, 4px);max-width:var(--dyte-space-96, 384px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px);padding-left:var(--dyte-space-5, 20px);padding-right:var(--dyte-space-5, 20px);overflow-wrap:break-word;font-size:14px;line-height:1.375;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.body.bubble p{margin:var(--dyte-space-0, 0px);word-break:break-word}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-text-message,dyte-image-message,dyte-file-message{display:block;font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}*[is-continued]{margin-top:var(--dyte-space-0, 0px)}.image{position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}.file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1\\.5, 6px);padding-bottom:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.file .file-data{flex:1 1 0%}.file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.new-chat-marker{display:flex;width:100%;align-items:center;gap:var(--dyte-space-2, 8px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.new-chat-marker::before{content:'';height:1px;flex:1 1 0%;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / 0.5)}.show-new-messages-ctr{pointer-events:none;display:flex;justify-content:flex-end;padding:var(--dyte-space-3, 12px);z-index:0;margin-top:calc(var(--dyte-space-14, 56px) * -1)}.show-new-messages{pointer-events:auto;--tw-translate-y:calc(var(--dyte-space-6, 24px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}blockquote{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px);background-color:transparent}.block-quote,blockquote{--tw-border-spacing-x:1px;--tw-border-spacing-y:1px;border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-md, 2px);border-right-width:var(--dyte-border-width-none, 0);border-style:solid;border-left-color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));padding:var(--dyte-space-0\\.5, 2px);padding-left:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px) !important;border-radius:var(--dyte-border-radius-sm, 4px);border-top-left-radius:var(--dyte-border-radius-none, 0);border-bottom-left-radius:var(--dyte-border-radius-none, 0)}.link{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.align-right .block-quote{border-color:rgb(var(--dyte-colors-text-on-brand-600, var(--dyte-colors-text-600, 255 255 255 / 0.52)));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity))}.align-right .link{color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.align-right .image .actions dyte-icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}.avatar{display:flex;width:var(--dyte-space-6, 24px)}.avatar dyte-avatar{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);font-size:10px}.message{width:75%}.left-align .body{margin-top:var(--dyte-space-4, 16px)}.left-align [is-continued] .body{margin-top:var(--dyte-space-0, 0px)}.left-align .body{--tw-translate-x:calc(var(--dyte-space-8, 32px) * -1);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}";

  const DyteChatMessage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.edit = createEvent(this, "edit", 7);
      this.reply = createEvent(this, "reply", 7);
      this.pin = createEvent(this, "pin", 7);
      this.delete = createEvent(this, "delete", 7);
      this.renderMessage = () => {
        switch (this.message.type) {
          case 'text':
            return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-text-message", { message: this.message, now: this.now, isContinued: this.isContinued, "data-timestamp": this.message.time.getTime(), iconPack: this.iconPack, t: this.t, showBubble: true })));
          case 'image':
            return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-image-message", { message: this.message, now: this.now, isContinued: this.isContinued, iconPack: this.iconPack, "data-timestamp": this.message.time.getTime(), t: this.t, showBubble: true })));
          case 'file':
            return (h("div", { "is-continued": this.isContinued, key: this.message.id }, this.isUnread && (h("div", { class: "new-chat-marker", part: "new-chat-marker" }, this.t('chat.new'))), h("dyte-file-message", { message: this.message, now: this.now, isContinued: this.isContinued, iconPack: this.iconPack, t: this.t, "data-timestamp": this.message.time.getTime(), showBubble: true })));
          case 'custom':
            this.child.setAttribute('message', JSON.stringify(this.message));
            const node = this.child.cloneNode(true);
            return (h("div", { "is-continued": this.isContinued, key: this.message.id, ref: (el) => el.appendChild(node) }));
        }
      };
      this.onReply = () => {
        this.reply.emit(this.message);
      };
      this.onPinned = () => {
        this.pin.emit(this.message);
      };
      this.onDelete = () => {
        this.delete.emit(this.message);
      };
      this.onEdit = async () => {
        this.edit.emit(this.message);
      };
      this.isTouchDevice = () => {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      };
      this.message = undefined;
      this.isContinued = undefined;
      this.child = undefined;
      this.isUnread = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isSelf = false;
      this.canEdit = false;
      this.canDelete = false;
      this.canReply = false;
      this.canPin = false;
      this.disableControls = false;
      this.alignRight = false;
      this.senderDisplayPicture = undefined;
      this.hideAvatar = false;
      this.now = new Date();
      this.leftAlign = false;
    }
    renderControls() {
      if (this.disableControls)
        return;
      return (h("dyte-menu", { placement: this.alignRight ? 'bottom-end' : 'bottom-start' }, h("button", { slot: "trigger", class: "actions" }, h("dyte-icon", { icon: this.iconPack.chevron_down })), h("dyte-menu-list", null, this.canReply && (h("dyte-menu-item", { onClick: this.onReply }, h("dyte-icon", { icon: this.iconPack.back, slot: "start" }), this.t('chat.reply'))), this.canPin && (h("dyte-menu-item", { onClick: this.onPinned }, h("dyte-icon", { icon: this.iconPack.pin, slot: "start" }), this.t('pin'))), this.canEdit && (h("dyte-menu-item", { onClick: this.onEdit }, h("dyte-icon", { icon: this.iconPack.edit, slot: "start" }), this.t('chat.edit_msg'))), this.canDelete && (h("dyte-menu-item", { onClick: this.onDelete }, h("dyte-icon", { icon: this.iconPack.delete, slot: "start" }), this.t('chat.delete_msg'))))));
    }
    renderAvatar() {
      if (this.hideAvatar)
        return;
      if (this.isContinued) {
        return h("div", { class: "avatar" });
      }
      return (h("div", { class: "avatar" }, h("dyte-avatar", { size: "sm", participant: {
          name: this.message.displayName,
          picture: this.senderDisplayPicture,
        } })));
    }
    render() {
      return (h(Host, null, h("div", { class: {
          'message-wrapper': true,
          'align-right': this.alignRight,
          'left-align': this.leftAlign,
        }, "is-continued": this.isContinued }, this.renderAvatar(), h("div", { class: {
          message: true,
          'show-on-hover': !this.isTouchDevice(),
        }, "is-continued": this.isContinued }, this.renderMessage(), this.renderControls()))));
    }
    get $el() { return getElement(this); }
  };
  DyteChatMessage.style = dyteChatMessageCss;

  const DyteFileMessage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.message = undefined;
      this.now = new Date();
      this.isContinued = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showBubble = false;
    }
    render() {
      const link = sanitizeLink(this.message.link);
      return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
          body: true,
          bubble: this.showBubble,
        }, part: "body" }, h("div", { class: "file" }, h("div", { class: "file-data" }, h("div", { class: "name" }, this.message.name), h("div", { class: "file-data-split" }, h("div", { class: "ext" }, getExtension(this.message.name)), h("span", { class: "divider" }), h("div", { class: "size" }, getFileSize(this.message.size)))), h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => downloadFile(link, { name: this.message.name, fallbackName: 'file' }), part: "button" }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t }))))));
    }
  };

  const dyteImageMessageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.image-spinner{cursor:wait}.image-errored{cursor:not-allowed}";

  const DyteImageMessage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.message = undefined;
      this.now = new Date();
      this.isContinued = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showBubble = false;
      this.status = 'loading';
    }
    render() {
      return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
          body: true,
          bubble: this.showBubble,
        }, part: "body" }, h("div", { class: { image: true, loaded: this.status === 'loaded' } }, h("img", { src: sanitizeLink(this.message.link), onLoad: () => {
          this.status = 'loaded';
        }, onError: () => {
          this.status = 'errored';
        }, onClick: () => {
          if (this.status === 'loaded') {
            this.stateUpdate.emit({ image: this.message });
            state.image = this.message;
          }
        } }), this.status === 'loading' && (h("div", { class: "image-spinner", title: this.t('chat.img.loading'), "aria-label": this.t('chat.img.loading') }, h("dyte-spinner", { iconPack: this.iconPack, t: this.t }))), this.status === 'errored' && (h("div", { class: "image-errored", title: this.t('chat.error.img_not_found'), "aria-label": this.t('chat.error.img_not_found') }, h("dyte-icon", { icon: this.iconPack.image_off, iconPack: this.iconPack, t: this.t }))), this.status === 'loaded' && (h("div", { class: "actions" }, h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => {
          this.stateUpdate.emit({ image: this.message });
          state.image = this.message;
        }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.full_screen_maximize })), h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => downloadFile(this.message.link, { fallbackName: 'image' }), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t }))))))));
    }
  };
  DyteImageMessage.style = dyteImageMessageCss;

  const dytePaginatedListCss = ".scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{position:relative;display:flex;flex-direction:column;flex:1}.container{box-sizing:border-box;display:flex;flex-direction:column-reverse;padding-top:var(--dyte-space-4, 16px);padding-bottom:var(--dyte-space-4, 16px);flex:1 0 0px;overflow-y:scroll;}.file-picker{display:none}.chat *:first-child{margin-top:var(--dyte-space-0, 0px)}.chat .head{display:flex;align-items:center}.chat .head .name{margin-right:var(--dyte-space-4, 16px);font-size:12px;font-weight:700}.chat .head .time{font-size:12px;color:rgb(var(--dyte-colors-text-800, 255 255 255 / 0.76))}.chat .body{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px);overflow-wrap:break-word;font-size:14px;line-height:1.375}.chat .body .emoji{font-size:24px}p{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px)}dyte-text-message,dyte-image-message,dyte-file-message{margin-top:var(--dyte-space-4, 16px);display:block;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));box-sizing:border-box}*[is-continued]{margin-top:var(--dyte-space-3, 12px)}dyte-text-message[is-continued]{margin-top:var(--dyte-space-2, 8px)}.chat .image{position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.chat .image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.chat .image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.chat .image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.chat .image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.chat .image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.chat .image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}.chat .file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1\\.5, 6px);padding-bottom:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.chat .file .file-data{flex:1 1 0%}.chat .file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.chat .file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.chat .file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.chat .file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}.smallest-dom-element{width:1px}#top-scroll{transform:translateY(20vh)}#bottom-scroll{transform:translateY(-20vh)}a{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));-webkit-text-decoration-line:none;text-decoration-line:none}a:hover{-webkit-text-decoration-line:underline;text-decoration-line:underline}.show-new-messages-ctr{pointer-events:none;position:absolute;bottom:var(--dyte-space-2, 8px);right:var(--dyte-space-4, 16px);z-index:10;margin-top:calc(var(--dyte-space-14, 56px) * -1);--tw-translate-y:var(--dyte-space-28, 112px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:0;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.show-new-messages-ctr.active{--tw-translate-y:var(--dyte-space-0, 0px);transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));opacity:1}.show-new-messages{pointer-events:auto;border-radius:9999px}.show-new-messages:hover{border-radius:9999px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-opacity:1;--tw-ring-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-ring-opacity));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}dyte-spinner,.empty-list{margin:auto}.page-wrapper{margin-left:var(--dyte-space-1, 4px);margin-right:var(--dyte-space-1, 4px)}.message-wrapper{margin-bottom:var(--dyte-space-2, 8px)}.pinned .message-wrapper{position:relative}.pinned .pin-icon{position:absolute;right:calc(var(--dyte-space-1, 4px) * -1);top:calc(var(--dyte-space-1, 4px) * -1);display:flex;border-radius:var(--dyte-border-radius-sm, 4px)}.pinned dyte-message-view{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px)}";

  const DytePaginatedList = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      /**
       * This is a private variable not a state
       * since we want to debounce rerenders
       *
       * A list of pages where each page contains a number of Nodes
       * [
       *  [Node 1, Node 2, Node 3.... Node N],
       *  [Node 1, Node 2, Node 3.... Node N],
       * ]
       */
      this.pagesToRender = [[]];
      this.currentTime = () => {
        return new Date().getTime();
      };
      this.observe = (el) => {
        if (!el)
          return;
        this.intersectionObserver.observe(el);
      };
      this.pageSize = undefined;
      this.pagesAllowed = undefined;
      this.fetchData = undefined;
      this.createNodes = undefined;
      this.selectedItemId = undefined;
      this.autoScroll = true;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.emptyListLabel = null;
      this.isLoading = false;
      this.rerenderBoolean = false;
      this.shouldRenderNewNodes = true;
      this.hasNewNodesToRender = false;
      this.showEmptyListLabel = false;
    }
    /**
     * On a new node created
     */
    async onNewNode(node) {
      if (!this.shouldRenderNewNodes) {
        this.hasNewNodesToRender = true;
        return;
      }
      this.addNodeToRender(node, false);
      this.rerender();
    }
    /**
     * On node deleted
     */
    async onNodeDelete(key) {
      const oldLength = this.pagesToRender.flat().length;
      this.pagesToRender = this.pagesToRender.map((page) => page.filter((item) => item.id !== key));
      if (oldLength !== this.pagesToRender.flat().length) {
        this.rerender();
      }
    }
    /**
     * On node updated
     */
    async onNodeUpdate(key, newItem) {
      let shouldRerender = false;
      this.pagesToRender = this.pagesToRender.map((page) => page.map((item) => {
        if (item.id === key) {
          shouldRerender = true;
          return newItem;
        }
        return item;
      }));
      if (shouldRerender)
        this.rerender();
    }
    onItemChanged(newItemId, oldItemId) {
      if (newItemId !== oldItemId) {
        this.pagesToRender = [[]];
        this.loadFirstPage().then(() => this.rerender());
      }
    }
    connectedCallback() {
      this.rerender = debounce(this.rerender.bind(this), 50, { maxWait: 200 });
      this.intersectionObserver = new IntersectionObserver((entries) => {
        writeTask(() => {
          for (const entry of entries) {
            if (entry.target.id === 'bottom-scroll') {
              if (entry.isIntersecting)
                this.loadBottom();
              else
                this.shouldRenderNewNodes = false;
            }
            if (entry.target.id === 'top-scroll' && entry.isIntersecting) {
              this.loadTop();
            }
          }
        });
      });
    }
    disconnectedCallback() {
      this.intersectionObserver.disconnect();
    }
    componentDidLoad() {
      /**
       * Adding observes here so that on the first render we scroll down
       * and shouldRenderNewNodes remains true
       */
      this.loadFirstPage();
      this.observe(this.$topRef);
      this.observe(this.$bottomRef);
    }
    componentDidRender() {
      if (this.shouldRenderNewNodes && this.autoScroll)
        smoothScrollToBottom(this.$paginatedList);
    }
    loadFirstPage() {
      return this.loadPage(this.currentTime(), this.pageSize, true, (data) => {
        if (data.length === 0) {
          this.showEmptyListLabel = true;
        }
      });
    }
    loadTop() {
      /**
       * If there is only one unfilled page or no page, no need to check
       * for top since it will be empty
       */
      if (this.pagesToRender.length === 0)
        return;
      if (this.pagesToRender.length === 1 && this.pagesToRender[0].length < this.pageSize)
        return;
      /**
       * TODO: Make this more flexible currently this only works with chat
       */
      const oldestVNode = this.pagesToRender[0][0];
      const oldestTimestamp = oldestVNode.timeMs;
      // TODO: scrollIntoView
      const onPageRendered = () => { }; // oldestVNode.$elm$?.scrollIntoView();
      this.loadPage(oldestTimestamp - 1, this.pageSize, true, onPageRendered);
    }
    loadBottom() {
      /**
       * If there is only one unfilled page or no page, no need to check
       * for top since it will be empty
       */
      if (this.pagesToRender.length === 0) {
        this.shouldRenderNewNodes = true;
        return;
      }
      if (this.pagesToRender.length === 1 && this.pagesToRender[0].length < this.pageSize) {
        this.shouldRenderNewNodes = true;
        return;
      }
      const newestVNode = this.pagesToRender.at(-1).at(-1);
      const newestTimestamp = newestVNode.timeMs;
      // TODO: scrollIntoView
      const onPageRendered = () => smoothScrollToBottom(this.$paginatedList);
      this.loadPage(newestTimestamp + 1, this.pageSize, false, onPageRendered);
    }
    addNodeToRender(node, addToStart) {
      if (addToStart) {
        const firstPage = this.pagesToRender[0];
        if (firstPage && (firstPage === null || firstPage === undefined ? undefined : firstPage.length) < this.pageSize) {
          /**
           * If first page is not full then just add to that page
           */
          firstPage.unshift(node);
        }
        else {
          /**
           * If first page is full then add a new page to the start
           */
          const newPage = [node];
          this.pagesToRender.unshift(newPage);
          this.removeLastPageIfNeeded(false);
        }
      }
      else {
        const [lastPage] = this.pagesToRender.slice(-1);
        if (lastPage && (lastPage === null || lastPage === undefined ? undefined : lastPage.length) < this.pageSize) {
          /**
           * If last page is not full then just add it
           */
          lastPage.push(node);
        }
        else {
          /**
           * If last page is full add a new page with just
           * this node
           */
          const newPage = [node];
          this.pagesToRender.push(newPage);
          this.removeLastPageIfNeeded(true);
        }
      }
    }
    /**
     * @param start
     * @param end
     * @param reversed Defines whether to add the page at the beginning or the end
     * @param onPageLoaded Callback for when all new nodes are rendered
     */
    async loadPage(timestamp, size, reversed, onPageRendered = () => { }) {
      this.isLoading = true;
      const data = (await this.fetchData(timestamp, size, reversed));
      this.isLoading = false;
      if (!(data === null || data === undefined ? undefined : data.length)) {
        /**
         * While scrolling down if there were no new items found
         * then start rendering new nodes;
         */
        if (!reversed) {
          this.hasNewNodesToRender = false;
          this.shouldRenderNewNodes = true;
        }
        onPageRendered([]);
        return;
      }
      // const page = this.createNodes(data);
      // const lastNodeToBeRendered = page[page.length - 1];
      // let lastNodeToBeRenderedProxy = new Proxy(lastNodeToBeRendered, {
      //   set(obj, prop, value) {
      //     /**
      //      * Whenever the last node has the 'elm' property added to it
      //      * we can assume it has been rendered
      //      */
      //     if (prop === '$elm$' && value && !obj.$elm$) onPageRendered();
      //     obj[prop] = value;
      //     return true;
      //   },
      // });
      // page[page.length - 1] = lastNodeToBeRenderedProxy;
      data.forEach((node) => this.addNodeToRender(node, reversed));
      this.rerender();
      onPageRendered(data);
    }
    rerender() {
      this.rerenderBoolean = !this.rerenderBoolean;
    }
    removeLastPageIfNeeded(removeFromStart) {
      if (this.pagesToRender.length > this.pagesAllowed) {
        if (removeFromStart)
          this.pagesToRender.shift();
        else
          this.pagesToRender.pop();
      }
    }
    onDownArrowClicked() {
      /**
       * Load the freshest pages
       */
      this.loadBottom();
    }
    render() {
      var _a;
      /**
       * div.container is flex=column-reverse
       * which is why div#bottom-scroll comes before div#top-scroll
       * div.page-wrapper prevents reversal of messages
       */
      return (h(Host, null, h("div", { class: "scrollbar container", part: "container", ref: (el) => (this.$paginatedList = el) }, h("div", { class: { 'show-new-messages-ctr': true, active: !this.shouldRenderNewNodes } }, h("dyte-button", { class: "show-new-messages", kind: "icon", variant: "secondary", part: "show-new-messages", onClick: () => this.onDownArrowClicked(), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.chevron_down, iconPack: this.iconPack, t: this.t }))), h("div", { class: "smallest-dom-element", id: "bottom-scroll", ref: (el) => (this.$bottomRef = el) }), this.isLoading && this.pagesToRender.flat().length === 0 && h("dyte-spinner", { size: "lg" }), this.pagesToRender.flat().length === 0 && this.showEmptyListLabel ? (h("div", { class: "empty-list" }, (_a = this.emptyListLabel) !== null && _a !== undefined ? _a : this.t('list.empty'))) : (h("div", { class: "page-wrapper" }, this.pagesToRender.map((page) => this.createNodes(page)))), h("div", { class: "smallest-dom-element", id: "top-scroll", ref: (el) => (this.$topRef = el) }))));
    }
    static get watchers() { return {
      "selectedItemId": ["onItemChanged"]
    }; }
  };
  DytePaginatedList.style = dytePaginatedListCss;

  const DyteTextMessage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.message = undefined;
      this.now = new Date();
      this.isContinued = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.showBubble = false;
    }
    render() {
      return (h(Host, null, !this.isContinued && (h(ChatHead, { name: this.message.displayName, time: this.message.time, now: this.now })), h("div", { class: {
          body: true,
          bubble: this.showBubble,
        }, part: "body" }, h("div", { class: { text: true, emoji: hasOnlyEmojis(this.message.message) } }, h(TextMessageView, { message: this.message.message })))));
    }
  };

  var dyteChatMessage_5_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_chat_message: DyteChatMessage,
      dyte_file_message: DyteFileMessage,
      dyte_image_message: DyteImageMessage,
      dyte_paginated_list: DytePaginatedList,
      dyte_text_message: DyteTextMessage
  });

  const dyteDraftAttachmentViewCss = ":host{display:flex;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));border-top-left-radius:var(--dyte-border-radius-md, 8px);border-top-right-radius:var(--dyte-border-radius-md, 8px)}.preview-overlay{position:absolute;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);background-color:inherit}.preview{position:absolute;top:var(--dyte-space-4, 16px);left:var(--dyte-space-4, 16px);max-width:-moz-fit-content;max-width:fit-content;max-height:var(--dyte-space-20, 80px)}.preview:hover dyte-tooltip{display:block}.preview dyte-tooltip{position:absolute;top:calc(var(--dyte-space-1, 4px) * -1);left:calc(var(--dyte-space-1, 4px) * -1);display:none;margin-left:calc(var(--dyte-space-1, 4px) * -1);margin-top:calc(var(--dyte-space-1, 4px) * -1)}.preview dyte-button{display:flex;height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);align-items:center;justify-content:center;border-radius:9999px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));border:1px solid rgb(var(--dyte-colors-text-1000, 255 255 255))}.preview dyte-icon{height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px);color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.preview-image{height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px);-o-object-fit:cover;object-fit:cover;max-height:100%;max-width:100%;overflow:clip;border-radius:var(--dyte-border-radius-md, 8px)}.preview-file{padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));overflow:hidden;text-overflow:ellipsis;white-space:nowrap;border-radius:var(--dyte-border-radius-md, 8px);max-width:200px}";

  const DyteDraftAttachmentView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onDeleteAttachment = createEvent(this, "deleteAttachment", 7);
      this.fileReader = new FileReader();
      this.generatePreview = () => {
        if (this.attachment.type === 'image') {
          this.fileReader.readAsDataURL(this.attachment.file);
        }
        else if (this.attachment.type === 'file') {
          this.filePreview = this.attachment.file.name;
        }
      };
      this.onDeleteClickHandler = () => {
        this.filePreview = null;
        this.onDeleteAttachment.emit();
      };
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.attachment = null;
      this.filePreview = null;
    }
    onAttachmentChange() {
      this.generatePreview();
    }
    connectedCallback() {
      this.fileReader.onload = (e) => {
        if (typeof e.target.result === 'string') {
          this.filePreview = e.target.result;
        }
      };
      // this.fileReader.onloadstart = () => {};
      // this.fileReader.onloadend = () => {};
    }
    componentWillLoad() {
      this.onAttachmentChange();
    }
    render() {
      return (h(Host, null, h("div", { class: "preview-overlay" }, h("div", { class: "preview" }, h("dyte-tooltip", { label: this.t('chat.cancel_upload') }, h("dyte-button", { variant: "secondary", kind: "icon", onClick: this.onDeleteClickHandler }, h("dyte-icon", { icon: this.iconPack.dismiss }))), this.attachment.type === 'image' ? (h("img", { class: "preview-image", src: this.filePreview })) : (h("div", { class: "preview-file" }, h("span", null, this.filePreview)))))));
    }
    static get watchers() { return {
      "attachment": ["onAttachmentChange"]
    }; }
  };
  DyteDraftAttachmentView.style = dyteDraftAttachmentViewCss;

  const EMOJI_ASSET_URL = 'https://cdn.dyte.in/assets/emojis-data.json';
  /**
   * fetches the latest emoji list from CDN
   * @returns list of emojis
   */
  const fetchEmojis = async () => {
    const emojis = await fetch(EMOJI_ASSET_URL);
    return emojis.json();
  };

  const dyteEmojiPickerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host{width:100%}.emoji-parent{box-sizing:border-box;display:inline-flex;height:var(--dyte-space-64, 256px);width:100%;max-width:640px;flex-direction:column;padding:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-0, 0px);-webkit-user-select:none;-moz-user-select:none;user-select:none;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.close-parent{display:flex;flex:1 1 0%;justify-content:flex-end;padding:var(--dyte-space-0, 0px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}#emoji-grid{margin-top:var(--dyte-space-2, 8px);box-sizing:border-box;display:flex;flex-direction:row;flex-wrap:wrap;overflow-x:hidden;overflow-y:scroll;height:100%;grid-auto-rows:minmax(min-content, max-content)}#loader{display:flex;height:100%;width:100%;align-items:center;justify-content:center}input{display:block;height:var(--dyte-space-8, 32px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);font-size:14px;border-width:var(--dyte-border-width-none, 0);border-style:solid;border-style:none;border-color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}input::-moz-placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input::placeholder{color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}input{border-radius:var(--dyte-border-radius-sm, 4px);outline:2px solid transparent;outline-offset:2px;transition-property:color, background-color, border-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-text-decoration-color, -webkit-backdrop-filter;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;border:var(--dyte-border-width-sm, 1px) solid rgb(var(--dyte-colors-background-600, 60 60 60))}input:focus{--tw-border-opacity:1;border-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-ring-opacity));--tw-ring-opacity:0.3}.emoji{height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px);font-size:20px;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}";

  const DyteEmojiPicker = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.pickerClose = createEvent(this, "pickerClose", 7);
      this.emojiClicked = createEvent(this, "dyteEmojiClicked", 7);
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.emojiList = undefined;
      this.filterVal = '';
      this.filteredEmojis = [];
    }
    componentWillLoad() {
      // Don't use async here as it will block the render
      fetchEmojis().then((e) => {
        this.emojiList = e;
        this.handleInputChange({ value: '' });
      });
    }
    handleInputChange(target) {
      this.filterVal = target.value;
      const regex = new RegExp(`([^,]*?${this.filterVal}[^,]*):(\\d+)`, 'g');
      this.filteredEmojis = Array.from(this.emojiList['search'].matchAll(regex)).map((m) => {
        return { name: m[1], emoji: this.emojiList['emojis'][m[2]] };
      });
    }
    handleEmojiClick(emoji) {
      this.emojiClicked.emit(emoji);
    }
    mapEmojiList() {
      var _a;
      if (((_a = this.emojiList) === null || _a === undefined ? undefined : _a.length) > 0) {
        return (h("div", { id: "loader" }, h("dyte-spinner", { iconPack: this.iconPack, t: this.t })));
      }
      return (h("div", { id: "emoji-grid", class: "scrollbar max-w-40" }, this.filteredEmojis.map((e) => (h("dyte-button", { iconPack: this.iconPack, t: this.t, key: `emoji-button-${e.name}`, class: "emoji", variant: "ghost", kind: "icon", title: e.name, onClick: () => this.handleEmojiClick(e.emoji) }, e.emoji)))));
    }
    render() {
      return (h(Host, null, h("div", { class: 'close-parent' }, h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: () => { var _a; return (_a = this.pickerClose) === null || _a === undefined ? undefined : _a.emit(); }, "aria-label": this.t('close') }, h("dyte-icon", { icon: this.iconPack.dismiss }))), h("div", { class: 'emoji-parent' }, h("input", { value: this.filterVal, onInput: (event) => this.handleInputChange(event.target), placeholder: this.t('search') }), this.mapEmojiList())));
    }
  };
  DyteEmojiPicker.style = dyteEmojiPickerCss;

  const dyteEmojiPickerButtonCss = ":host{}";

  const DyteEmojiPickerButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isActive = undefined;
    }
    render() {
      const uiProps = { iconPack: this.iconPack, t: this.t };
      return (h("dyte-tooltip", Object.assign({ label: this.t('chat.send_emoji') }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", class: { active: this.isActive }, title: this.t('chat.send_emoji'), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.emoji_multiple }))));
    }
  };
  DyteEmojiPickerButton.style = dyteEmojiPickerButtonCss;

  const dyteFilePickerButtonCss = ":host{}";

  const DyteFilePickerButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onFileChange = createEvent(this, "fileChange", 7);
      this.uploadFile = () => {
        const input = this.fileInputField;
        input.type = 'file';
        if (this.filter) {
          input.accept = this.filter;
        }
        input.onchange = (e) => {
          const { validity, files: [file], } = e.target;
          if (validity.valid) {
            this.onFileChange.emit(file);
          }
        };
        input.click();
      };
      this.filter = undefined;
      this.label = undefined;
      this.icon = 'attach';
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.fileInputField = document.createElement('input');
    }
    disconnectedCallback() {
      // For GC
      this.fileInputField = undefined;
    }
    render() {
      const uiProps = { iconPack: this.iconPack, t: this.t };
      const label = this.label || this.t('chat.send_file');
      const icon = this.iconPack[this.icon];
      return (h("dyte-tooltip", Object.assign({ label: label }, uiProps), h("dyte-button", { variant: "ghost", kind: "icon", onClick: () => this.uploadFile(), title: label, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: icon }))));
    }
  };
  DyteFilePickerButton.style = dyteFilePickerButtonCss;

  const dyteTextComposerViewCss = ".chat-input {\n  position: relative;\n  z-index: 10;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  border-top-left-radius: var(--dyte-border-radius-md, 8px);\n  border-top-right-radius: var(--dyte-border-radius-md, 8px)\n}\n\n  .chat-input textarea {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));\n  box-sizing: border-box;\n  padding: var(--dyte-space-3, 12px);\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255))\n}\n\n  .chat-input textarea::-moz-placeholder {\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255))\n}\n\n  .chat-input textarea::placeholder {\n  color: rgb(var(--dyte-colors-text-1000, 255 255 255))\n}\n\n  .chat-input textarea {\n  font-family: var(--dyte-font-family, sans-serif);\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  resize: none;\n  overflow-y: auto;\n  border-width: var(--dyte-border-width-none, 0);\n  border-style: none;\n  min-height: 60px;\n  font-size: 14px\n}\n\n@container chatcontainer (height < 360px) {\n  textarea {\n    height: 30px !important;\n    min-height: 30px !important\n  }\n}\n\n.text-error {\n  left: var(--dyte-space-0, 0px);\n  z-index: 10;\n  margin-top: var(--dyte-space-1, 4px);\n  margin-left: var(--dyte-space-1, 4px);\n  display: flex;\n  width: -moz-fit-content;\n  width: fit-content;\n  align-items: center;\n  justify-content: flex-start;\n  border-radius: var(--dyte-border-radius-sm, 4px);\n  --tw-border-opacity: 1;\n  border-color: rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-border-opacity));\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));\n  padding-left: var(--dyte-space-2, 8px);\n  padding-right: var(--dyte-space-2, 8px);\n  font-size: 12px;\n  font-weight: 600;\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity));\n  border: 1px solid\n}\n\n#warning-indicator {\n  margin-right: var(--dyte-space-1, 4px);\n  height: var(--dyte-space-3, 12px);\n  width: var(--dyte-space-3, 12px)\n}\n\n.text-error.breached {\n  --tw-border-opacity: 1;\n  border-color: rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-border-opacity));\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))\n}";

  const DyteTextComposerView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onTextChange = createEvent(this, "textChange", 7);
      this.onInputHandler = () => {
        const text = this.$textArea.value.trim();
        this.maybeResize(text);
        this.checkLength(text);
        this.onTextChange.emit(text);
      };
      this.maybeResize = (text) => {
        const newLines = [...text.matchAll(/\n/g)].length;
        this.$textArea.style.height = `${Math.min(200, 60 + 20 * newLines)}px`;
      };
      this.disabled = false;
      this.placeholder = undefined;
      this.value = undefined;
      this.maxLength = undefined;
      this.rateLimitBreached = false;
      this.keyDownHandler = () => { };
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.maxLengthBreached = 0;
    }
    componentDidLoad() {
      if (this.maxLength) {
        this.$textArea.maxLength = this.maxLength;
      }
      const text = this.$textArea.value.trim();
      if (text !== '') {
        this.maybeResize(text);
      }
    }
    /** Sets value of the text input */
    async setText(text, focus = false) {
      this.$textArea.value = text;
      this.maybeResize(text);
      if (focus) {
        this.$textArea.focus();
      }
      this.checkLength(text);
      this.onTextChange.emit(text);
    }
    checkLength(text) {
      // unicode code length
      const textLen = text.length;
      if (textLen + 10 >= this.maxLength) {
        this.maxLengthBreached = text.length;
      }
      else if (textLen + 10 < this.maxLength && this.maxLengthBreached > 0) {
        this.maxLengthBreached = 0;
      }
    }
    render() {
      return (h("div", { class: "chat-input", part: "chat-input-container" }, this.maxLengthBreached > 0 && (h("div", { class: 'text-error ' + (this.maxLengthBreached === this.maxLength ? 'breached' : '') }, h("dyte-icon", { id: "warning-indicator", icon: this.iconPack.warning, part: "warning-indicator", iconPack: this.iconPack, t: this.t }), ' ', this.maxLengthBreached, " / ", this.maxLength, " ", this.t('chat.max_limit_warning'))), this.rateLimitBreached && (h("div", { class: 'text-error breached' }, h("dyte-icon", { id: "warning-indicator", icon: this.iconPack.warning, part: "warning-indicator", iconPack: this.iconPack, t: this.t }), ' ', this.t('chat.rate_limit_error'))), h("textarea", { ref: (el) => (this.$textArea = el), placeholder: this.placeholder, disabled: this.disabled, onInput: this.onInputHandler, onKeyDown: this.keyDownHandler, part: "chat-input", value: this.value })));
    }
  };
  DyteTextComposerView.style = dyteTextComposerViewCss;

  var dyteDraftAttachmentView_5_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_draft_attachment_view: DyteDraftAttachmentView,
      dyte_emoji_picker: DyteEmojiPicker,
      dyte_emoji_picker_button: DyteEmojiPickerButton,
      dyte_file_picker_button: DyteFilePickerButton,
      dyte_text_composer_view: DyteTextComposerView
  });

  const dyteJoinStageCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}:host::-webkit-scrollbar{width:var(--dyte-space-1\\.5, 6px);border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity))}:host::-webkit-scrollbar-thumb{border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host(.stage){box-sizing:border-box;display:block;width:512px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));padding:var(--dyte-space-6, 24px);-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:auto;border-radius:var(--dyte-border-radius-md, 8px);line-height:1.25}:host(.stage) dyte-participant-setup{display:flex;flex:1 1 0%;align-items:center;justify-content:space-around;margin-left:auto;margin-right:auto}:host(.stage) .container dyte-button{flex-grow:1;padding:var(--dyte-space-1, 4px);width:50%}:host(.stage) .container dyte-button:nth-child(1){margin-right:var(--dyte-space-1\\.5, 6px)}:host(.stage) .container dyte-button:nth-child(2){margin-left:var(--dyte-space-1\\.5, 6px)}:host(.stage) h2{font-size:24px;font-weight:500;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host(.stage) header{padding-left:var(--dyte-space-4, 16px);padding-right:var(--dyte-space-4, 16px)}:host(.stage) .summary{padding:var(--dyte-space-4, 16px)}.deny-access{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}.container{width:100%;max-width:1080px;display:flex;flex:1 1 0%;align-items:center;justify-content:space-around}header{display:flex;align-items:center;justify-content:space-between}";

  const DyteJoinStage = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.joinStage = createEvent(this, "dyteJoinStage", 7);
      this.leaveStage = createEvent(this, "dyteLeaveStage", 7);
      this.meeting = undefined;
      this.config = defaultConfig;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.dataConfig = {
        title: this.t('stage.join_title'),
        label: {
          accept: this.t('stage.join_confirm'),
          reject: this.t('stage.join_cancel'),
        },
        description: this.t('stage.join_summary'),
      };
      this.isLoading = false;
    }
    render() {
      var _a, _b;
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        states: this.states || state,
        config: this.config,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, { class: { stage: true } }, h("header", null, h("h2", null, this.dataConfig.title)), h(Render, { element: "dyte-participant-setup", defaults: defaults, props: { participant: (_a = this.meeting) === null || _a === undefined ? undefined : _a.self, size: 'md' }, childProps: { participant: (_b = this.meeting) === null || _b === undefined ? undefined : _b.self, size: 'md' }, deepProps: true }), h("div", { class: "summary" }, this.dataConfig.description), h("div", { class: "container" }, h("dyte-button", { variant: "secondary", onClick: () => this.leaveStage.emit(), title: this.dataConfig.label.reject, iconPack: this.iconPack, t: this.t }, this.dataConfig.label.reject), h("dyte-button", { onClick: () => {
          if (this.isLoading)
            return;
          this.isLoading = true;
          this.joinStage.emit();
        }, title: this.dataConfig.label.accept, iconPack: this.iconPack, t: this.t }, this.isLoading ? (h("dyte-icon", { icon: this.iconPack.spinner })) : (this.dataConfig.label.accept)))));
    }
  };
  DyteJoinStage.style = dyteJoinStageCss;

  const dyteOverlayModalCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / 0.6);position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);z-index:50}dyte-icon{height:var(--dyte-space-20, 80px)}h2{margin:var(--dyte-space-2, 8px);font-weight:500}p{margin:var(--dyte-space-0, 0px);font-size:16px}";

  const DyteOverlayModal = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stateUpdate = createEvent(this, "dyteStateUpdate", 7);
      this.meeting = undefined;
      this.states = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    connectedCallback() {
      if (this.states.activeOverlayModal.timeout) {
        setTimeout(() => {
          this.stateUpdate.emit({ activeOverlayModal: { active: false } });
          state.activeOverlayModal = { active: false };
        }, this.states.activeOverlayModal.timeout);
      }
    }
    componentDidLoad() { }
    disconnectedCallback() { }
    render() {
      return (h(Host, null, h("dyte-icon", { icon: this.states.activeOverlayModal.icon, iconPack: this.iconPack, t: this.t }), h("h2", null, this.states.activeOverlayModal.title), h("p", null, this.states.activeOverlayModal.description)));
    }
  };
  DyteOverlayModal.style = dyteOverlayModalCss;

  var dyteJoinStage_2_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_join_stage: DyteJoinStage,
      dyte_overlay_modal: DyteOverlayModal
  });

  const dyteNotificationCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{pointer-events:none;display:block;height:var(--dyte-space-10, 40px);color:rgb(var(--dyte-colors-text-1000, 255 255 255));animation:show 0.4s ease;transition:0.4s;z-index:100}.ctr{box-sizing:border-box;display:inline-flex;height:100%;min-width:var(--dyte-space-40, 160px);align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);--tw-shadow-color:rgb(var(--dyte-colors-background-1000, 8 8 8));--tw-shadow:var(--tw-shadow-colored);pointer-events:auto}img{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-0, 0px);width:var(--dyte-space-0, 0px);border-radius:9999px}img.loaded{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}.message{margin-right:var(--dyte-space-3, 12px);max-width:var(--dyte-space-72, 288px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.message p{margin:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-1, 4px);display:inline-block}.message blockquote{display:none}dyte-icon.icon{margin-right:var(--dyte-space-2, 8px);height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}dyte-icon.dismiss{margin-left:auto;height:var(--dyte-space-5, 20px);width:var(--dyte-space-5, 20px);border-radius:var(--dyte-border-radius-md, 8px);color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}dyte-icon.dismiss:hover{cursor:pointer;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}dyte-icon.dismiss{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}dyte-button{margin-left:var(--dyte-space-4, 16px);margin-right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px)}.right{margin-left:auto;display:flex;align-items:center}.right>*{margin-left:var(--dyte-space-2, 8px)}.right>*:first-child{margin-left:var(--dyte-space-0, 0px)}:host(.exit){animation:exit 0.4s ease}@keyframes show{0%{opacity:0;transform:translateX(-120px)}100%{opacity:1;transform:translateX(0px)}}@keyframes exit{0%{opacity:1;transform:translateX(0)}100%{opacity:0;transform:translateX(-120px)}}:host([size='sm']){font-size:14px}";

  const DyteNotification = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dismiss = createEvent(this, "dyteNotificationDismiss", 7);
      this.notification = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.imageState = 'loading';
    }
    connectedCallback() {
      this.notificationChanged(this.notification);
    }
    notificationChanged(notification) {
      if (notification != null && typeof notification.duration === 'number') {
        setTimeout(() => {
          this.dismiss.emit(notification.id);
        }, notification.duration);
      }
    }
    render() {
      var _a;
      return (h(Host, null, h("div", { class: "ctr" }, this.notification.icon != null && (h("dyte-icon", { class: "icon", icon: this.notification.icon, variant: (_a = this.notification.iconVariant) !== null && _a !== undefined ? _a : 'primary', iconPack: this.iconPack, t: this.t })), this.notification.image != null &&
        this.notification.icon == null &&
        this.imageState !== 'errored' && (h("img", { src: this.notification.image, class: { loaded: this.imageState === 'loaded' }, onLoad: () => (this.imageState = 'loaded'), onError: () => (this.imageState = 'errored') })), h("p", { class: "message" }, h(TextMessageView, { message: this.notification.message })), h("div", { class: "right" }, this.notification.button != null && (h("dyte-button", { size: "sm", variant: this.notification.button.variant, onClick: () => this.notification.button.onClick(), iconPack: this.iconPack, t: this.t }, this.notification.button.text)), h("dyte-icon", { "aria-label": this.t('dismiss'), class: "dismiss", icon: this.iconPack.dismiss, onClick: () => this.dismiss.emit(this.notification.id), iconPack: this.iconPack, t: this.t })))));
    }
    static get watchers() { return {
      "notification": ["notificationChanged"]
    }; }
  };
  DyteNotification.style = dyteNotificationCss;

  var dyteNotification_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_notification: DyteNotification
  });

  const dyteCameraSelectorCss = ".dyte-select{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255))}.dyte-select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.dyte-select{display:block;border-radius:var(--dyte-border-radius-sm, 4px);border-width:var(--dyte-border-width-none, 0);border-style:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;padding:var(--dyte-space-3, 12px);font-size:16px;--icon-size:var(--dyte-select-chevron-size, var(--dyte-space-6, 24px));--icon-right-position:var(--dyte-select-chevron-right-position, var(--dyte-space-2, 8px));background-image:url(\"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e\");background-position:right var(--icon-right-position) center;background-repeat:no-repeat;background-size:var(--icon-size) var(--icon-size);padding-right:calc(var(--icon-right-position) * 5);width:100%;max-width:100%;text-overflow:ellipsis}.inline .dyte-select{margin-top:var(--dyte-space-1, 4px);width:100%;padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-1\\.5, 6px);padding-right:var(--dyte-space-8, 32px);font-size:14px}.row{margin-bottom:var(--dyte-space-2, 8px);display:flex;width:100%;align-items:center;justify-content:space-between;gap:var(--dyte-space-3, 12px)}.group{margin-top:var(--dyte-space-2, 8px);margin-bottom:var(--dyte-space-2, 8px)}.group>*{margin-bottom:var(--dyte-space-2, 8px)}.group>*:last-child{margin-bottom:var(--dyte-space-0, 0px)}.group select{flex:1 1 0%}.group{margin-top:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-0, 0px)}.group>*{margin-bottom:var(--dyte-space-0, 0px)}label{display:flex;-webkit-user-select:none;-moz-user-select:none;user-select:none;align-items:center;gap:var(--dyte-space-1, 4px);font-size:14px}.inline.container{display:flex;align-items:center;justify-content:flex-start;gap:var(--dyte-space-2, 8px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px)}";

  const DyteCameraSelector = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.stageStateListener = () => {
        this.canProduceVideo = this.meeting.self.permissions.canProduceVideo === 'ALLOWED';
      };
      this.deviceListUpdateListener = ({ devices }) => {
        this.videoDevices = devices.filter((device) => device.kind === 'videoinput');
      };
      this.deviceUpdateListener = ({ device }) => {
        if (device.kind !== 'videoinput')
          return;
        this.currentDevice = device;
      };
      this.mediaPermissionUpdateListener = async ({ kind, message }) => {
        if (!this.meeting)
          return;
        if (kind === 'video' && message === 'ACCEPTED') {
          this.videoDevices = await this.meeting.self.getVideoDevices();
        }
      };
      this.meeting = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.variant = 'full';
      this.t = useLanguage();
      this.videoDevices = [];
      this.currentDevice = undefined;
      this.canProduceVideo = true;
    }
    meetingChanged(meeting) {
      var _a, _b, _c;
      if (meeting == null)
        return;
      (_a = meeting.self) === null || _a === undefined ? undefined : _a.addListener('deviceListUpdate', this.deviceListUpdateListener);
      (_b = meeting.self) === null || _b === undefined ? undefined : _b.addListener('deviceUpdate', this.deviceUpdateListener);
      (_c = meeting.self) === null || _c === undefined ? undefined : _c.addListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
      writeTask(async () => {
        var _a, _b;
        const videoDevices = await meeting.self.getVideoDevices();
        const currentVideoDevice = (_a = meeting.self.getCurrentDevices()) === null || _a === undefined ? undefined : _a.video;
        //  NOTE(callmetarush): Setting current video device to show on top of list
        if (currentVideoDevice != undefined) {
          this.videoDevices = [
            (_b = videoDevices.find((device) => device.deviceId === currentVideoDevice.deviceId)) !== null && _b !== undefined ? _b : currentVideoDevice,
            ...videoDevices.filter((device) => device.deviceId !== currentVideoDevice.deviceId),
          ];
        }
        else {
          this.videoDevices = videoDevices;
        }
      });
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a, _b, _c, _d, _e;
      (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.stage) === null || _b === undefined ? undefined : _b.removeListener('stageStatusUpdate', this.stageStateListener);
      (_c = this.meeting) === null || _c === undefined ? undefined : _c.self.removeListener('deviceListUpdate', this.deviceListUpdateListener);
      (_d = this.meeting) === null || _d === undefined ? undefined : _d.self.removeListener('deviceUpdate', this.deviceUpdateListener);
      (_e = this.meeting) === null || _e === undefined ? undefined : _e.self.removeListener('mediaPermissionUpdate', this.mediaPermissionUpdateListener);
    }
    async setDevice(deviceId) {
      var _a;
      const device = this.videoDevices.find((d) => d.deviceId === deviceId);
      this.currentDevice = device;
      if (device != null) {
        await ((_a = this.meeting) === null || _a === undefined ? undefined : _a.self.setDevice(device));
      }
    }
    render() {
      if (this.meeting == null)
        return null;
      let unnamedVideoCount = 0;
      return (h(Host, null, this.canProduceVideo && (h("div", { class: 'group container ' + this.variant, part: "camera-selection" }, h("label", null, this.variant !== 'inline' && this.t('camera'), h("dyte-icon", { icon: this.iconPack.video_on, iconPack: this.iconPack, t: this.t, size: "sm" })), h("div", { class: "row" }, h("select", { class: "dyte-select", onChange: (e) => this.setDevice(e.target.value) }, this.videoDevices.map(({ deviceId, label }) => {
        var _a;
        return (h("option", { selected: ((_a = this.currentDevice) === null || _a === undefined ? undefined : _a.deviceId) === deviceId, value: deviceId }, label || `Camera ${++unnamedVideoCount}`));
      })))))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteCameraSelector.style = dyteCameraSelectorCss;

  const dyteParticipantTileCss = ":host {\n  line-height: initial;\n  font-family: var(--dyte-font-family, sans-serif);\n\n  font-feature-settings: normal;\n  font-variation-settings: normal;\n}\n\np {\n  margin: var(--dyte-space-0, 0px);\n  padding: var(--dyte-space-0, 0px);\n}\n\n\n:host {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  aspect-ratio: 16 / 9;\n  height: var(--dyte-space-56, 224px);\n  overflow: hidden;\n  border-radius: var(--dyte-border-radius-lg, 12px);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-video-bg, 24 24 24) / var(--tw-bg-opacity));\n\n  transition-property: var(--dyte-transition-property, all);\n  transition-duration: 150ms;\n  container-type: inline-size;\n  container-name: participanttile;\n}\n\n@media (prefers-reduced-motion) {\n  /* No transitions when disabled */\n  :host {\n    --dyte-transition-property: none;\n  }\n}\n\ndyte-avatar {\n  z-index: -1;\n}\n\n/**\n  NOTE: provided :slotted(dyte-name-tag) & dyte-name-tag separately\n  because ::slotted isn't applied on default slots.\n*/\n\n::slotted(dyte-name-tag), \ndyte-name-tag {\n  position: absolute;\n  left: var(--dyte-space-3, 12px);\n  bottom: var(--dyte-space-3, 12px);\n}\n\n:host([size='sm'][variant='solid']) ::slotted(dyte-name-tag), \n  :host([size='sm'][variant='solid']) dyte-name-tag {\n  left: var(--dyte-space-2, 8px);\n  bottom: var(--dyte-space-2, 8px);\n  height: var(--dyte-space-4, 16px);\n}\n\n::slotted(dyte-network-indicator), \ndyte-network-indicator {\n  position: absolute;\n  right: var(--dyte-space-3, 12px);\n  bottom: var(--dyte-space-3, 12px);\n}\n\n:host([size='sm']) ::slotted(dyte-network-indicator), \n  :host([size='sm']) dyte-network-indicator {\n  right: var(--dyte-space-2, 8px);\n  bottom: var(--dyte-space-2, 8px);\n}\n\nvideo {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  border-radius: var(--dyte-border-radius-lg, 12px);\n}\n\nvideo.contain {\n  -o-object-fit: contain;\n     object-fit: contain;\n}\n\nvideo.cover {\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n\nvideo::-webkit-media-controls {\n  display: none !important;\n}\n\n.pinned-icon {\n  position: absolute;\n  left: var(--dyte-space-3, 12px);\n  top: var(--dyte-space-3, 12px);\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n  padding: var(--dyte-space-1, 4px);\n  border-radius: var(--dyte-border-radius-md, 8px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));\n}\n\n.network-container {\n  position: absolute;\n  right: var(--dyte-space-3, 12px);\n  bottom: var(--dyte-space-3, 12px);\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: var(--dyte-space-2, 8px);\n  font-size: 12px;\n  border-radius: var(--dyte-border-radius-md, 8px);\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));\n}\n.network-icon {\n  height: var(--dyte-space-5, 20px);\n  width: var(--dyte-space-5, 20px);\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity));\n}\n\n:host([size='sm']) .pinned-icon {\n  top: var(--dyte-space-2, 8px);\n  left: var(--dyte-space-2, 8px);\n}\n\n:host([variant='gradient']) ::slotted(dyte-audio-visualizer), \n  :host([variant='gradient']) dyte-audio-visualizer {\n  position: absolute;\n  top: var(--dyte-space-2, 8px);\n  right: var(--dyte-space-2, 8px);\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n  padding: var(--dyte-space-2, 8px);\n}\n\n:host([variant='gradient']) ::slotted(dyte-name-tag), \n  :host([variant='gradient']) dyte-name-tag {\n  bottom: var(--dyte-space-0, 0px);\n  left: var(--dyte-space-0, 0px);\n  display: flex;\n  width: 100%;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  background-color: transparent;\n  background-image: linear-gradient(to top, var(--tw-gradient-stops));\n  --tw-gradient-from: rgb(var(--dyte-colors-background-1000, 8 8 8));\n  --tw-gradient-to: rgba(var(--dyte-colors-background-1000, 8 8 8) / 0);\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\n  --tw-gradient-to: transparent;\n}\n\nvideo.mirror {\n  transform: scaleX(-1);\n}\n\n/** Name tag positions */\n\n:host([name-tag-position='bottom-right']) ::slotted(dyte-name-tag), \n  :host([name-tag-position='bottom-right']) dyte-name-tag {\n  left: auto;\n  right: var(--dyte-space-3, 12px);\n}\n\n:host([name-tag-position='bottom-center']) ::slotted(dyte-name-tag), \n  :host([name-tag-position='bottom-center']) dyte-name-tag {\n  left: auto;\n  right: auto;\n}\n\n:host([name-tag-position='top-left']) ::slotted(dyte-name-tag), \n  :host([name-tag-position='top-left']) dyte-name-tag {\n  top: var(--dyte-space-3, 12px);\n  bottom: auto;\n}\n\n:host([name-tag-position='top-right']) ::slotted(dyte-name-tag), \n  :host([name-tag-position='top-right']) dyte-name-tag {\n  top: var(--dyte-space-3, 12px);\n  right: var(--dyte-space-3, 12px);\n  left: auto;\n  bottom: auto;\n}\n\n:host([name-tag-position='top-center']) ::slotted(dyte-name-tag), \n  :host([name-tag-position='top-center']) dyte-name-tag {\n  left: auto;\n  right: auto;\n  bottom: auto;\n  top: var(--dyte-space-3, 12px);\n}\n\n@media only screen and (max-height: 480px) and (orientation: landscape) {\n  :host([size='sm']) {\n    border-radius: var(--dyte-border-radius-sm, 4px);\n  }\n\n  :host([size='sm']) > video {\n    border-radius: var(--dyte-border-radius-sm, 4px);\n  }\n\n  ::slotted(dyte-avatar), \n  dyte-avatar {\n    height: var(--dyte-space-12, 48px);\n    width: var(--dyte-space-12, 48px);\n  }\n    :host([size='sm'][variant='solid']) ::slotted(dyte-name-tag),\n    :host([size='sm'][variant='solid']) dyte-name-tag {\n      transform-origin: -2% 100%;\n      transform: scale(0.6);\n      z-index: 10;\n      left: var(--dyte-space-0, 0px);\n      bottom: var(--dyte-space-0, 0px);\n      border-radius: var(--dyte-border-radius-none, 0);\n    }\n}\n\n@media only screen and (max-width: 480px) and (orientation: portrait) {\n  :host([size='sm']) {\n    border-radius: var(--dyte-border-radius-sm, 4px);\n  }\n\n  :host([size='sm']) > video {\n    border-radius: var(--dyte-border-radius-sm, 4px);\n  }\n\n  ::slotted(dyte-avatar), \n  dyte-avatar {\n    height: var(--dyte-space-12, 48px);\n    width: var(--dyte-space-12, 48px);\n  }\n    :host([size='sm'][variant='solid']) ::slotted(dyte-name-tag),\n    :host([size='sm'][variant='solid']) dyte-name-tag {\n      transform-origin: -5% 110%;\n      transform: scale(0.6);\n      z-index: 10;\n      left: var(--dyte-space-0, 0px);\n      bottom: var(--dyte-space-0, 0px);\n      border-radius: var(--dyte-border-radius-none, 0);\n    }\n}\n\n@container participanttile (max-width: 300px) {\n  ::slotted(dyte-name-tag),\n  dyte-name-tag {\n    transform-origin: 0 100%;\n    transform: scale(0.8);\n  }\n\n  ::slotted(dyte-avatar), \n  dyte-avatar {\n    height: var(--dyte-space-8, 32px) !important;\n    width: var(--dyte-space-8, 32px) !important;\n  }\n}\n\n@container participanttile (max-width: 150px) {\n  ::slotted(dyte-name-tag),\n  dyte-name-tag[variant='solid'] {\n    transform-origin: -10% 130%;\n    transform: scale(0.6);\n    z-index: 10;\n    border-radius: 9999px;\n  }\n\n  ::slotted(dyte-avatar), \n  dyte-avatar {\n    height: 6 !important;\n    width: 6 !important;\n  }\n}\n";

  const DyteParticipantTile = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.tileLoad = createEvent(this, "tileLoad", 7);
      this.tileUnload = createEvent(this, "tileUnload", 7);
      this.onPinned = ({ isPinned }) => {
        this.isPinned = isPinned;
      };
      this.isSelf = () => { var _a; return this.isPreview || this.participant.id === ((_a = this.meeting) === null || _a === undefined ? undefined : _a.self.id); };
      this.onPause = (event) => {
        var _a, _b;
        if (this.isSelf() &&
          ((_a = this.meeting) === null || _a === undefined ? undefined : _a.__internals__.features.hasFeature(FlagsmithFeatureFlags.PLAY_PARTICIPANT_TILE_VIDEO_ON_PAUSE))) {
          this.meeting.__internals__.logger.warn(`Video player paused for ${this.participant.id} isSelf: ${this.isSelf()}`);
          // @ts-ignore
          (_b = event === null || event === undefined ? undefined : event.target) === null || _b === undefined ? undefined : _b.play();
        }
      };
      this.onPlaying = () => {
        if (this.playTimeout)
          clearTimeout(this.playTimeout);
      };
      this.isPinned = false;
      this.mediaConnectionError = false;
      this.nameTagPosition = 'bottom-left';
      this.isPreview = false;
      this.participant = undefined;
      this.meeting = undefined;
      this.states = undefined;
      this.config = defaultConfig;
      this.variant = 'solid';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    onVideoRef(el) {
      if (!this.participant || !this.meeting) {
        return;
      }
      this.videoEl = el;
      this.participant.registerVideoElement(this.videoEl, this.isPreview);
      this.tileLoad.emit({ participant: this.participant, videoElement: this.videoEl });
    }
    connectedCallback() {
      // set videoState before initial render and initialize listeners
      if (this.meeting)
        this.meetingChanged(this.meeting);
      else
        this.participantsChanged(this.participant);
      if (this.states === undefined) {
        // This re-renders on any pref change
        // There are currently only two prefs, so it is fine
        // Could not find a way to subscribe to a nested property
        this.removeStateChangeListener = onChange('prefs', () => forceUpdate(this));
      }
    }
    disconnectedCallback() {
      if (this.playTimeout)
        clearTimeout(this.playTimeout);
      if (this.participant == null)
        return;
      this.participant.deregisterVideoElement(this.videoEl, this.isPreview);
      this.participant.removeListener('pinned', this.onPinned);
      this.participant.removeListener('unpinned', this.onPinned);
      this.meeting.meta.off('mediaConnectionUpdate', this.mediaConnectionUpdateListener);
      this.tileUnload.emit(this.participant);
      this.removeStateChangeListener && this.removeStateChangeListener();
    }
    meetingChanged(meeting) {
      if (meeting == undefined)
        return;
      this.participantsChanged(this.participant);
    }
    participantsChanged(participant) {
      if (participant == undefined)
        return;
      if (this.meeting === undefined) {
        if (this.isPreview) {
          this.videoEl && this.participant.registerVideoElement(this.videoEl, this.isPreview);
        }
        return;
      }
      this.isPinned = participant.isPinned;
      this.videoEl && this.participant.registerVideoElement(this.videoEl, this.isPreview);
      participant.addListener('pinned', this.onPinned);
      participant.addListener('unpinned', this.onPinned);
      this.meeting.meta.on('mediaConnectionUpdate', this.mediaConnectionUpdateListener.bind(this));
    }
    mediaConnectionUpdateListener() {
      var _a, _b, _c;
      const { consuming, producing } = (_c = (_b = (_a = this.meeting) === null || _a === undefined ? undefined : _a.meta) === null || _b === undefined ? undefined : _b.mediaState) !== null && _c !== undefined ? _c : {};
      if ((consuming === null || consuming === undefined ? undefined : consuming.state) !== 'connected' && !this.isSelf()) {
        this.mediaConnectionError = true;
      }
      else if ((producing === null || producing === undefined ? undefined : producing.state) !== 'connected' && this.isSelf()) {
        this.mediaConnectionError = true;
      }
      else
        this.mediaConnectionError = false;
    }
    isMirrored() {
      var _a;
      if (this.participant != null) {
        if (this.isSelf()) {
          const states = this.states || state;
          const mirrorVideo = (_a = states === null || states === undefined ? undefined : states.prefs) === null || _a === undefined ? undefined : _a.mirrorVideo;
          if (typeof mirrorVideo === 'boolean') {
            return mirrorVideo;
          }
        }
      }
      return false;
    }
    render() {
      var _a, _b, _c;
      const defaults = {
        meeting: this.meeting,
        size: this.size,
        states: this.states || state,
        config: this.config,
        iconPack: this.iconPack,
        t: this.t,
      };
      return (h(Host, null, h("video", { ref: (el) => this.onVideoRef(el), class: {
          mirror: this.isMirrored(),
          [(_c = (_b = (_a = this.config) === null || _a === undefined ? undefined : _a.config) === null || _b === undefined ? undefined : _b.videoFit) !== null && _c !== undefined ? _c : 'cover']: true,
        }, onPlaying: this.onPlaying, onPause: this.onPause, autoPlay: true, playsInline: true, muted: true, part: "video" }), this.isPinned && (h("dyte-icon", { class: "pinned-icon", icon: this.iconPack.pin, "aria-label": this.t('pinned'), iconPack: this.iconPack, t: this.t, part: "pinned-icon" })), this.mediaConnectionError && (h("div", { class: "network-container", part: "network-indicator" }, h("dyte-icon", { class: "network-icon", icon: this.iconPack.disconnected, "aria-label": this.t('pinned'), iconPack: this.iconPack, t: this.t, part: "pinned-icon" }))), h("slot", null, h(Render, { element: "dyte-participant-tile", defaults: defaults, childProps: {
          participant: this.participant,
        }, deepProps: true, onlyChildren: true }))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"],
      "participant": ["participantsChanged"]
    }; }
  };
  DyteParticipantTile.style = dyteParticipantTileCss;

  var dyteCameraSelector_2_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_camera_selector: DyteCameraSelector,
      dyte_participant_tile: DyteParticipantTile
  });

  const dyteSidebarUiCss = ":host {\n  line-height: initial;\n  font-family: var(--dyte-font-family, sans-serif);\n\n  font-feature-settings: normal;\n  font-variation-settings: normal;\n}\n\np {\n  margin: var(--dyte-space-0, 0px);\n  padding: var(--dyte-space-0, 0px);\n}\n\n\n:host {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  font-family: var(--dyte-font-family, sans-serif);\n  z-index: 50;\n  display: flex;\n  flex-direction: column;\n\n  container-type: size;\n  container-name: sidebarui;\n}\n\n@container sidebarui (height < 370px) {\n  .main-header {\n    height: var(--dyte-space-8, 32px) !important;\n  }\n  .close {\n    top: var(--dyte-space-0\\.5, 2px) !important;\n    left: var(--dyte-space-0, 0px) !important;\n    color: rgba(var(--dyte-colors-danger, 255 45 45) / 0.6);\n  }\n}\n\n:host([view='sidebar']) {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));\n}\n\n:host([view='full-screen']) {\n  position: absolute;\n  top: var(--dyte-space-0, 0px);\n  right: var(--dyte-space-0, 0px);\n  bottom: var(--dyte-space-0, 0px);\n  left: var(--dyte-space-0, 0px);\n  max-width: 100%;\n  border: none;\n}\n\n::slotted(*) {\n  flex-grow: 1;\n}\n\n.close {\n  position: absolute;\n  top: var(--dyte-space-2, 8px);\n  left: var(--dyte-space-2, 8px);\n  z-index: 10;\n}\n\n.main-header {\n  position: relative;\n  display: flex;\n  height: var(--dyte-space-12, 48px);\n  place-items: center;\n  justify-content: center;\n}\n\n.main-header, \n.mobile-tabs {\n  flex-shrink: 0;\n}\n\n.mobile-tabs {\n  display: flex;\n  place-items: center;\n  justify-content: space-evenly;\n  border-bottom: 1px solid rgb(var(--dyte-colors-background-700, 44 44 44));\n}\n\n.mobile-tabs button {\n  margin: var(--dyte-space-0, 0px);\n  border-width: var(--dyte-border-width-none, 0);\n  border-style: none;\n  background-color: transparent;\n  padding: var(--dyte-space-0, 0px);\n  color: rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52));\n  height: var(--dyte-space-10, 40px);\n  cursor: pointer;\n  padding-left: var(--dyte-space-4, 16px);\n  padding-right: var(--dyte-space-4, 16px);\n  font-weight: 500;\n  border-bottom: 1px solid transparent;\n}\n\n.mobile-tabs button.active {\n  --tw-border-opacity: 1;\n  border-color: rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-border-opacity));\n  --tw-text-opacity: 1;\n  color: rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity));\n}\n\nheader h3 {\n  font-size: 14px;\n  font-weight: 500;\n}\n\n@media only screen and (max-device-height: 480px) and (orientation: landscape) {\n  .main-header {\n    display: none !important;\n  }\n}\n\n.tab-participant-count-badge {\n  display: inline-block;\n  padding: 2px 5px;\n  border-radius: 9999px;\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));\n  font-size: 12px;\n  color: rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64));\n}\n\n.tab-participant-count-badge:not(.selected-tab) {\n  --tw-bg-opacity: 1;\n  background-color: rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));\n}\n\n.tab-participant-count-badge.requests-pending{\n  background-color: rgba(var(--dyte-colors-danger));\n}";

  const DyteSidebarUi = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.tabChange = createEvent(this, "tabChange", 7);
      this.sidebarClose = createEvent(this, "sidebarClose", 7);
      this.onClose = () => {
        this.sidebarClose.emit();
      };
      this.view = 'sidebar';
      this.tabs = [];
      this.hideHeader = false;
      this.hideCloseAction = false;
      this.currentTab = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      const isFullScreen = this.view === 'full-screen';
      const activeTab = this.tabs.find((tab) => tab.id === this.currentTab);
      return (h(Host, { class: this.view }, !this.hideCloseAction && (h("dyte-button", { variant: "ghost", kind: "icon", class: "close", onClick: this.onClose, "aria-label": this.t('close') }, h("dyte-icon", { icon: this.iconPack.dismiss }))), activeTab && !this.hideHeader && (h("header", { class: "main-header" }, h("h3", null, activeTab.name), h("slot", { name: "pinned-state" }))), isFullScreen && (h("header", { class: "mobile-tabs" }, this.tabs.map((tab) => (h("button", { onClick: () => {
          this.tabChange.emit(tab.id);
        }, class: {
          active: this.currentTab === tab.id,
        } }, tab.name))))), h("slot", { name: this.currentTab })));
    }
  };
  DyteSidebarUi.style = dyteSidebarUiCss;

  var dyteSidebarUi_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_sidebar_ui: DyteSidebarUi
  });

  const dyteSpotlightIndicatorCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{font-size:12px}#sync-button{flex-direction:row;border-radius:var(--dyte-border-radius-sm, 4px);padding-left:var(--dyte-space-1, 4px);display:flex;align-items:center;justify-content:center;margin-bottom:var(--dyte-space-1, 4px);font-size:12px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([size='sm']) dyte-tooltip,:host([size='md']) dyte-tooltip{width:100%}:host([size='sm'])>#sync-button{height:var(--dyte-space-8, 32px);width:var(--dyte-space-16, 64px);padding-left:var(--dyte-space-0, 0px)}:host([size='md'])>#sync-button{height:var(--dyte-space-8, 32px);width:var(--dyte-space-16, 64px)}:host([size='lg'])>#sync-button{flex-direction:row;height:var(--dyte-space-8, 32px);width:var(--dyte-space-16, 64px)}@media (orientation: portrait){:host([size='lg']) #sync-button{flex-direction:column-reverse;height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px)}:host([size='md']) #sync-button{height:var(--dyte-space-16, 64px);width:var(--dyte-space-16, 64px)}:host([size='sm']) #sync-button{height:var(--dyte-space-10, 40px);width:var(--dyte-space-16, 64px);flex-direction:row}}#sync-button>dyte-icon{max-height:14px}#sync-button dyte-icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([size='sm']) #sync-button>dyte-icon{width:auto}#sync-button.active dyte-icon{color:rgb(var(--dyte-colors-text-1000, 255 255 255))}div{align-content:center;line-height:2rem}dyte-icon{height:var(--dyte-space-6, 24px);width:var(--dyte-space-8, 32px)}#sync-button.active{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-success, 98 165 4) / var(--tw-bg-opacity))}";

  const DyteSpotlightIndicator = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.permissionsUpdateListener = () => {
        this.canSpotlight = this.meeting.self.permissions.canSpotlight;
      };
      this.meeting = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.size = undefined;
      this.canSpotlight = undefined;
      this.isSpotlighted = undefined;
    }
    connectedCallback() {
      this.meetingChanged(this.meeting);
    }
    disconnectedCallback() {
      var _a;
      (_a = this.meeting) === null || _a === undefined ? undefined : _a.self.permissions.removeListener('permissionsUpdate', this.permissionsUpdateListener);
    }
    meetingChanged(meeting) {
      var _a, _b;
      if (meeting != null) {
        this.canSpotlight = meeting.self.permissions.canSpotlight;
        this.isSpotlighted = (_b = (_a = meeting.meta) === null || _a === undefined ? undefined : _a.broadcastTabChanges) !== null && _b !== undefined ? _b : false;
        meeting.self.permissions.addListener('permissionsUpdate', this.permissionsUpdateListener);
      }
    }
    updateSpotlightState(shouldBroadcastTabChanges) {
      var _a;
      try {
        (_a = this.meeting.meta) === null || _a === void 0 ? void 0 : _a.setBroadcastTabChanges(shouldBroadcastTabChanges);
        this.isSpotlighted = shouldBroadcastTabChanges;
      }
      catch (e) {
        // eslint-disable-next-line no-console
        console.error(e);
      }
    }
    render() {
      if (!this.canSpotlight)
        return;
      return (h(Host, null, h("dyte-tooltip", { size: 'md', iconPack: this.iconPack, t: this.t, label: this.t('remote_access.indicator') }, h("div", { id: "sync-button", class: {
          tab: true,
          active: this.isSpotlighted,
        }, onClick: () => this.updateSpotlightState(!this.isSpotlighted) }, h("span", { class: "name" }, "Sync"), h("dyte-icon", { id: "icon", iconPack: this.iconPack, t: this.t, icon: this.isSpotlighted ? this.iconPack.checkmark : this.iconPack.warning, tabIndex: -1, "aria-hidden": true })))));
    }
    static get watchers() { return {
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteSpotlightIndicator.style = dyteSpotlightIndicatorCss;

  var dyteSpotlightIndicator_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_spotlight_indicator: DyteSpotlightIndicator
  });

  const dyteVirtualizedParticipantListCss = ":host{height:100%;width:100%}";

  const DyteVirtualizedParticipantList = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.containerHeight = 0; // Height of the container
      this.lastScrollTop = 0; // To track and restore scrollTop
      this.recalculatePositioning = () => {
        // Measure container height and update visible items
        this.updateContainerHeight();
        // Check for the first item height
        requestAnimationFrame(() => {
          this.updateItemHeight();
        });
      };
      this.updateContainerHeight = () => {
        if (!this.el.querySelector('.virtual-list-container').clientHeight) {
          return;
        }
        // Check for the first item height
        requestAnimationFrame(() => {
          this.updateItemHeight();
        });
        this.containerHeight = this.el.querySelector('.virtual-list-container').clientHeight;
        this.updateVisibleRange();
      };
      this.onScroll = debounce(() => {
        const scrollTop = this.el.querySelector('.virtual-list-container').scrollTop;
        if (scrollTop > this.lastScrollTop && this.visibleEnd === this.items.length) {
          return;
        }
        // Track scrollTop for resetting after re-render
        this.lastScrollTop = scrollTop;
        this.updateVisibleRange();
      });
      this.items = [];
      this.renderItem = undefined;
      this.itemHeight = 55;
      this.bufferedItemsCount = 5;
      this.emptyListElement = null;
      this.visibleStart = 0;
      this.visibleEnd = 0;
    }
    itemsChanged() {
      this.recalculatePositioning();
    }
    componentDidLoad() {
      this.recalculatePositioning();
      // Set up the scroll event listener
      this.el.querySelector('.virtual-list-container').addEventListener('scroll', this.onScroll);
      window.addEventListener('resize', this.recalculatePositioning);
    }
    componentDidUpdate() {
      // Update item height if it changes
      this.updateItemHeight();
    }
    disconnectedCallback() {
      // Remove event listeners to prevent memory leaks
      this.el.querySelector('.virtual-list-container').removeEventListener('scroll', this.onScroll);
      window.removeEventListener('resize', this.recalculatePositioning);
    }
    updateVisibleRange() {
      // Get the current scroll position
      const scrollTop = this.el.querySelector('.virtual-list-container').scrollTop;
      // Calculate the start and end of visible items based on scroll position and item height
      const startIndex = Math.floor(scrollTop / this.itemHeight);
      // Calculate the number of fully visible items and include an extra one if there's a partially visible one
      const visibleCount = Math.ceil(this.containerHeight / this.itemHeight);
      // The end index should include the buffer and partially visible item
      const endIndex = Math.min(this.items.length, startIndex + visibleCount + this.bufferedItemsCount);
      // Update the visible range in the component's state
      this.visibleStart = startIndex;
      this.visibleEnd = endIndex;
      // Reset the scroll position to ensure smooth rendering
      this.el.querySelector('.virtual-list-container').scrollTop = this.lastScrollTop;
    }
    updateItemHeight() {
      // Get the first rendered item
      const firstRenderedItem = this.el.querySelector('.virtual-list-item');
      if (firstRenderedItem) {
        // Temporarily remove the height style to let the browser compute natural height
        const originalHeight = firstRenderedItem.style.height;
        firstRenderedItem.style.height = 'auto'; // Let it take natural height
        // Measure the natural height
        const naturalHeight = firstRenderedItem.getBoundingClientRect().height;
        // Reapply the original height (if needed)
        if (originalHeight) {
          firstRenderedItem.style.height = originalHeight;
        }
        // Check if the measured height differs from the current itemHeight
        if (naturalHeight && Math.floor(naturalHeight) !== Math.floor(this.itemHeight)) {
          this.itemHeight = naturalHeight;
        }
      }
    }
    renderItems() {
      // Slice the items array to only render the visible and buffered items
      const visibleItems = this.items.slice(this.visibleStart, this.visibleEnd);
      // Render each visible item at the correct position using absolute positioning
      return visibleItems.map((item, index) => {
        const itemIndex = this.visibleStart + index;
        return (h("div", { class: "virtual-list-item", key: item.id, style: {
            position: 'absolute',
            top: `${itemIndex * this.itemHeight}px`,
            height: `${this.itemHeight}px`,
            width: '100%',
          } }, this.renderItem(item, itemIndex)));
      });
    }
    render() {
      var _a;
      const totalHeight = this.items.length * this.itemHeight; // Total height of the list
      return (h("div", { class: "virtual-list-container", style: {
          position: 'relative',
          height: '100%',
          overflowX: 'hidden',
          overflowY: 'auto',
        } }, h("div", { style: { height: `${totalHeight}px`, position: 'relative' } }, !((_a = this.items) === null || _a === undefined ? undefined : _a.length) ? this.emptyListElement : this.renderItems()), h("div", { style: { height: `${this.itemHeight}px` } })));
    }
    get el() { return getElement(this); }
    static get watchers() { return {
      "items": ["itemsChanged"]
    }; }
  };
  DyteVirtualizedParticipantList.style = dyteVirtualizedParticipantListCss;

  var dyteVirtualizedParticipantList_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_virtualized_participant_list: DyteVirtualizedParticipantList
  });

  const dyteFileMessageViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.file{display:flex;align-items:center;gap:var(--dyte-space-1, 4px);padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);min-width:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-700, 255 255 255 / 0.64))}.file .file-data{margin-left:var(--dyte-space-1, 4px);flex:1 1 0%}.file .file-data .name{word-break:break-all;color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split{margin-top:var(--dyte-space-0\\.5, 2px);display:flex;align-items:center;font-size:12px}.file .file-data .file-data-split .ext{margin-right:var(--dyte-space-2, 8px);text-transform:uppercase;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}.file .file-data .file-data-split .divider{height:var(--dyte-space-4, 16px);width:var(--dyte-space-0\\.5, 2px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.file .file-data .file-data-split .size{margin-left:var(--dyte-space-2, 8px)}";

  const DyteFileMessageView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.name = undefined;
      this.size = undefined;
      this.url = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h("div", { class: "file" }, h("dyte-button", { variant: "secondary", kind: "icon", iconPack: this.iconPack, t: this.t, onClick: () => downloadFile(sanitizeLink(this.url), { name: this.name, fallbackName: 'file' }), part: "button" }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t })), h("div", { class: "file-data" }, h("div", { class: "name" }, this.name), h("div", { class: "file-data-split" }, h("div", { class: "ext" }, getExtension(this.name)), h("span", { class: "divider" }), h("div", { class: "size" }, getFileSize(this.size))))));
    }
  };
  DyteFileMessageView.style = dyteFileMessageViewCss;

  const dyteImageMessageViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.image-spinner{cursor:wait}.image-errored{cursor:not-allowed}.image{display:block;font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));position:relative;height:var(--dyte-space-40, 160px);max-width:var(--dyte-space-64, 256px);cursor:pointer}.image img{display:none;height:100%;width:100%;border-radius:var(--dyte-border-radius-sm, 4px);-o-object-fit:cover;object-fit:cover}.image .image-spinner{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}.image .image-spinner dyte-spinner{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}.image .image-errored{display:flex;height:100%;width:100%;flex-direction:column;align-items:center;justify-content:center;border-radius:var(--dyte-border-radius-sm, 4px);background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.1);--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}.image .actions{display:none;height:var(--dyte-space-8, 32px);align-items:center;position:absolute;top:var(--dyte-space-2, 8px);right:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action{height:var(--dyte-space-8, 32px);width:var(--dyte-space-8, 32px);border-radius:var(--dyte-border-radius-none, 0);border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.image .actions .action:hover{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}.image.loaded img{display:block}.image.loaded .image-spinner{display:none}.image:hover .actions,.image:focus .actions{display:flex}";

  const DyteImageMessageView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onPreview = createEvent(this, "preview", 7);
      this.url = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.status = 'loading';
    }
    render() {
      return (h("div", { class: { image: true, loaded: this.status === 'loaded' } }, h("img", { src: sanitizeLink(this.url), onLoad: () => {
          this.status = 'loaded';
        }, onError: () => {
          this.status = 'errored';
        }, onClick: () => {
          if (this.status === 'loaded') {
            this.onPreview.emit(this.url);
          }
        } }), this.status === 'loading' && (h("div", { class: "image-spinner", title: this.t('chat.img.loading'), "aria-label": this.t('chat.img.loading') }, h("dyte-spinner", { iconPack: this.iconPack, t: this.t }))), this.status === 'errored' && (h("div", { class: "image-errored", title: this.t('chat.error.img_not_found'), "aria-label": this.t('chat.error.img_not_found') }, h("dyte-icon", { icon: this.iconPack.image_off, iconPack: this.iconPack, t: this.t }))), this.status === 'loaded' && (h("div", { class: "actions" }, h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => {
          this.onPreview.emit(this.url);
        }, iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.full_screen_maximize })), h("dyte-button", { class: "action", variant: "secondary", kind: "icon", onClick: () => downloadFile(this.url, { fallbackName: 'image' }), iconPack: this.iconPack, t: this.t }, h("dyte-icon", { icon: this.iconPack.download, iconPack: this.iconPack, t: this.t }))))));
    }
  };
  DyteImageMessageView.style = dyteImageMessageViewCss;

  const dyteMessageViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.scrollbar{scrollbar-width:thin;scrollbar-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))\n    var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar{height:var(--dyte-space-1\\.5, 6px);width:var(--dyte-space-1\\.5, 6px);border-radius:9999px;background-color:var(--dyte-scrollbar-background, transparent)}.scrollbar::-webkit-scrollbar-thumb{border-radius:9999px;background-color:var(--dyte-scrollbar-color, rgb(var(--dyte-colors-background-600, 60 60 60)))}.message-wrapper{display:flex;flex-direction:row-reverse;gap:var(--dyte-space-2, 8px)}.message-wrapper.incoming{flex-direction:row}.message{display:flex;flex-direction:column}.header{margin-bottom:var(--dyte-space-1, 4px);align-self:flex-end;color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));font-size:14px;font-weight:600}.incoming .header{align-self:flex-start}.body{display:flex;flex-direction:column;min-width:var(--dyte-space-24, 96px);font-family:var(--dyte-font-family, sans-serif);color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88));font-size:14px;line-height:1.375;position:relative}.body .metadata{margin-top:var(--dyte-space-2, 8px);align-self:flex-end;font-size:10px}.bubble{max-width:var(--dyte-space-96, 384px);padding:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));border-radius:var(--dyte-border-radius-md, 8px)}.incoming .bubble{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.avatar{display:none}dyte-menu{position:absolute;right:var(--dyte-space-0, 0px);top:var(--dyte-space-0, 0px);border-radius:var(--dyte-border-radius-lg, 12px)}dyte-menu dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);cursor:pointer}.actions{display:flex;align-items:center;justify-content:center;padding-left:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-right:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-md, 8px);border-width:var(--dyte-border-width-none, 0);border-style:none;background:radial-gradient(\n    at top right,\n    rgb(var(--dyte-colors-brand-300, 73 124 253)) 60%,\n    rgba(255, 255, 255, 0) 80%\n  )}.actions dyte-icon{height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}.incoming .actions{background:radial-gradient(\n      at top right,\n      rgb(var(--dyte-colors-background-800, 30 30 30)) 60%,\n      rgba(255, 255, 255, 0) 80%\n    )}.incoming .actions dyte-icon{color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}.incoming dyte-avatar{--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-900, 255 255 255 / 0.88))}@media (min-width: 400px){.avatar{display:flex;width:var(--dyte-space-6, 24px)}.avatar dyte-avatar{height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px);font-size:10px;overflow:clip;border-radius:9999px}}@media (hover: hover){dyte-menu{visibility:hidden}.body:hover dyte-menu{visibility:visible}}";

  const DyteMessageView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onAction = createEvent(this, "action", 7);
      this.actions = [];
      this.variant = 'bubble';
      this.viewType = 'outgoing';
      this.avatarUrl = undefined;
      this.hideAvatar = false;
      this.authorName = undefined;
      this.hideAuthorName = false;
      this.hideMetadata = false;
      this.time = undefined;
      this.iconPack = defaultIconPack;
    }
    renderActions() {
      return (h("dyte-menu", { placement: "top-end", offset: 1 }, h("button", { slot: "trigger", class: "actions" }, h("dyte-icon", { icon: this.iconPack.chevron_down })), h("dyte-menu-list", null, this.actions.map((action) => (h("dyte-menu-item", { onClick: () => this.onAction.emit(action.id) }, action.icon && h("dyte-icon", { icon: action.icon, slot: "start" }), action.label))))));
    }
    render() {
      return (h(Host, null, h("div", { class: { 'message-wrapper': true, [this.viewType]: true } }, !this.hideAvatar && (h("aside", { class: "avatar", part: "avatar" }, h("dyte-avatar", { participant: { name: this.authorName, picture: this.avatarUrl }, size: "sm" }))), h("div", { class: "message", part: "message" }, !this.hideAuthorName && h("div", { class: "header" }, this.authorName), h("div", { class: { body: true, bubble: this.variant === 'bubble' } }, h("slot", null), !this.hideMetadata && !!this.time && (h("div", { class: "metadata", title: formatDateTime(this.time) }, elapsedDuration(this.time, new Date(Date.now())))), this.actions.length !== 0 && this.renderActions())))));
    }
  };
  DyteMessageView.style = dyteMessageViewCss;

  const dyteTextMessageViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}.text{word-break:break-word;display:block;overflow-wrap:break-word;line-height:1.375}.text.emoji{font-size:24px}";

  const DyteTextMessageView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.text = undefined;
      this.isMarkdown = false;
    }
    render() {
      return (h("p", { class: { text: true, emoji: hasOnlyEmojis(this.text) } }, this.isMarkdown ? h("dyte-markdown-view", { text: this.text }) : this.text));
    }
  };
  DyteTextMessageView.style = dyteTextMessageViewCss;

  var dyteFileMessageView_4_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_file_message_view: DyteFileMessageView,
      dyte_image_message_view: DyteImageMessageView,
      dyte_message_view: DyteMessageView,
      dyte_text_message_view: DyteTextMessageView
  });

  const dyteDialogCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:fixed;top:var(--dyte-space-0, 0px);right:var(--dyte-space-0, 0px);bottom:var(--dyte-space-0, 0px);left:var(--dyte-space-0, 0px);box-sizing:border-box;padding:var(--dyte-space-4, 16px);flex-direction:column;align-items:center;justify-content:center;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / 0.5);color:rgb(var(--dyte-colors-text-1000, 255 255 255));visibility:hidden;display:none;overflow-wrap:break-word;word-wrap:break-word;z-index:60;-webkit-backdrop-filter:blur(12px) saturate(180%);backdrop-filter:blur(12px) saturate(180%)}#dialog{position:relative;max-height:100%;max-width:100%}#dismiss-btn{position:absolute;top:var(--dyte-space-3, 12px);right:var(--dyte-space-3, 12px);z-index:50}::slotted(*){max-height:100%;max-width:100%}:host([open]){visibility:visible;display:flex}:host([open='false']){visibility:hidden;display:none}";

  const DyteDialog = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.onClose = createEvent(this, "dyteDialogClose", 7);
      this.close = () => {
        this.open = false;
        this.onClose.emit();
      };
      this.keydownListener = (e) => {
        if (!this.disableEscapeKey && e.key === 'Escape' && this.open) {
          this.close();
        }
      };
      this.hideCloseButton = false;
      this.disableEscapeKey = false;
      this.meeting = undefined;
      this.config = defaultConfig;
      this.states = undefined;
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.open = true;
    }
    connectedCallback() {
      document.addEventListener('keydown', this.keydownListener);
    }
    disconnectedCallback() {
      document.removeEventListener('keydown', this.keydownListener);
    }
    render() {
      if (!this.open) {
        return null;
      }
      return (h(Host, null, h("div", { id: "dialog", part: "container", role: "dialog", "aria-modal": "true" }, h("slot", null), !this.hideCloseButton && (h("dyte-button", { part: "close-button", id: "dismiss-btn", kind: "icon", variant: "ghost", onClick: () => this.close(), iconPack: this.iconPack, t: this.t, type: "button", "aria-label": this.t('dialog.close'), role: "button" }, h("dyte-icon", { icon: this.iconPack.dismiss, iconPack: this.iconPack, t: this.t }))))));
    }
  };
  DyteDialog.style = dyteDialogCss;

  var dyteDialog_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_dialog: DyteDialog
  });

  const dyteLogoCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;flex-direction:column;align-items:center;justify-content:center;color:rgb(var(--dyte-colors-text-1000, 255 255 255));height:100%;width:auto}svg,img{height:100%;width:auto}.brand-color{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}";

  const DyteLogo = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.logoUrl = undefined;
      this.config = defaultConfig;
      this.meeting = undefined;
      this.t = useLanguage();
    }
    connectedCallback() {
      this.configChanged(this.config);
      this.meetingChanged(this.meeting);
    }
    configChanged(config) {
      var _a;
      if (config != null) {
        const configLogo = (_a = config === null || config === undefined ? undefined : config.designTokens) === null || _a === undefined ? undefined : _a.logo;
        // NOTE(callmetarush): Only update logo if not passed via prop
        if (configLogo != null && this.logoUrl == null) {
          this.logoUrl = configLogo;
        }
      }
    }
    meetingChanged(meeting) {
      var _a, _b, _c, _d;
      if (meeting != null) {
        const meetingLogo = (_d = (_c = (_b = (_a = meeting.self) === null || _a === undefined ? undefined : _a.config) === null || _b === undefined ? undefined : _b.header) === null || _c === undefined ? undefined : _c.elements) === null || _d === undefined ? undefined : _d.logo;
        if (meetingLogo != null && this.logoUrl == null) {
          this.logoUrl = meetingLogo;
        }
      }
    }
    render() {
      if (!this.logoUrl || this.logoUrl === '') {
        return null;
      }
      const logo = this.logoUrl;
      const text = this.t('logo');
      return (h(Host, { class: "loaded" }, h("img", { src: logo, alt: text })));
    }
    static get watchers() { return {
      "config": ["configChanged"],
      "meeting": ["meetingChanged"]
    }; }
  };
  DyteLogo.style = dyteLogoCss;

  var dyteLogo_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_logo: DyteLogo
  });

  const dyteMarkdownViewCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{overflow-wrap:break-word}a{color:currentColor}.block-quote,blockquote{margin:var(--dyte-space-0, 0px);margin-bottom:var(--dyte-space-3, 12px);--tw-border-spacing-x:1px;--tw-border-spacing-y:1px;border-spacing:var(--tw-border-spacing-x) var(--tw-border-spacing-y);border-top-width:var(--dyte-border-width-none, 0);border-bottom-width:var(--dyte-border-width-none, 0);border-left-width:var(--dyte-border-width-md, 2px);border-right-width:var(--dyte-border-width-none, 0);border-style:solid;padding:var(--dyte-space-0\\.5, 2px);padding-left:var(--dyte-space-2, 8px);border-radius:var(--dyte-border-radius-sm, 4px);border-top-left-radius:var(--dyte-border-radius-none, 0);border-bottom-left-radius:var(--dyte-border-radius-none, 0)}pre{white-space:pre-wrap}";

  const DyteMarkdownView = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.restoreEmpty = (content, tag, renderCallback) => {
        return content.trim().length === 0 ? `${tag}${content}${tag}` : renderCallback(content);
      };
      this.renderLink = (content) => {
        return (h("a", { class: "link", href: content, target: "_blank", rel: "noopener noreferrer" }, content));
      };
      this.renderBold = (content) => {
        if (typeof content === 'string') {
          return this.restoreEmpty(content, '*', (c) => h("b", null, c));
        }
        return h("b", null, this.renderTokens(content));
      };
      this.renderItalic = (content) => {
        if (typeof content === 'string') {
          return this.restoreEmpty(content, '_', (c) => h("i", null, c));
        }
        return h("i", null, this.renderTokens(content));
      };
      this.renderStrikethrough = (content) => {
        if (typeof content === 'string') {
          return this.restoreEmpty(content, '~', (c) => h("s", null, c));
        }
        return h("b", null, this.renderTokens(content));
      };
      this.renderPlainText = (content) => {
        if (typeof content === 'string') {
          return content;
        }
        return h("p", null, this.renderTokens(content));
      };
      this.renderTokens = (tokens) => {
        return tokens.map((token) => {
          switch (token.type) {
            case 'a':
              if (typeof token.content === 'string') {
                return this.renderLink(token.content);
              }
            case 'b':
              return this.renderBold(token.content);
            case 'i':
              return this.renderItalic(token.content);
            case 's':
              return this.renderStrikethrough(token.content);
            case 'q':
              return h("span", { class: "block-quote" });
            case 'plain_text':
            default:
              return this.renderPlainText(token.content);
          }
        });
      };
      this.text = undefined;
      this.maxLength = MAX_TEXT_LENGTH;
    }
    renderMessage(text) {
      let lines = text.split('\n');
      let isCodeBlock = false;
      if (lines[0] === '```' && lines[lines.length - 1] === '```') {
        isCodeBlock = true;
        lines = lines.slice(1, -1);
      }
      const message = lines.map((line) => {
        const tokens = parseRichText(line);
        return h("p", null, this.renderTokens(tokens));
      });
      if (isCodeBlock) {
        return h("pre", { style: { whiteSpace: 'pre', overflow: 'scroll' } }, lines.join('\n'));
      }
      return message;
    }
    render() {
      const slicedMessage = this.text.slice(0, this.maxLength);
      const withReply = extractReplyBlock(slicedMessage, true);
      const withoutReply = stripOutReplyBlock(slicedMessage);
      return (h("p", null, withReply.length !== 0 && h("blockquote", null, this.renderMessage(withReply)), withoutReply.length !== 0 && this.renderMessage(withoutReply)));
    }
  };
  DyteMarkdownView.style = dyteMarkdownViewCss;

  var dyteMarkdownView_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_markdown_view: DyteMarkdownView
  });

  const dyteMenuCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{position:relative;display:inline-block;color:rgb(var(--dyte-colors-text-1000, 255 255 255))}#menu-list{position:absolute;z-index:20;display:none}";

  const DyteMenu$1 = class DyteMenu {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.clickedThis = false;
      this.handleOutsideClick = () => {
        // handles clicking on other menu triggers
        if (!this.clickedThis) {
          // if other trigger is clicked, hide this menu-list
          this.menuListEl.style.display = 'none';
        }
        // reset the value
        this.clickedThis = false;
      };
      this.size = undefined;
      this.placement = 'bottom-end';
      this.offset = 10;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    componentDidLoad() {
      document.addEventListener('click', this.handleOutsideClick);
      this.update();
    }
    disconnectedCallback() {
      document.removeEventListener('click', this.handleOutsideClick);
    }
    update() {
      computePosition(this.triggerEl, this.menuListEl, {
        placement: this.placement,
        middleware: [offset(this.offset), flip(), shift({ padding: 5 })],
      }).then(({ x, y }) => {
        Object.assign(this.menuListEl.style, {
          left: `${x}px`,
          top: `${y}px`,
        });
      });
    }
    render() {
      return (h(Host, null, h("span", { id: "trigger", ref: (el) => (this.triggerEl = el), onClick: () => {
          this.clickedThis = true;
          if (this.menuListEl.style.display !== 'block') {
            this.menuListEl.style.display = 'block';
            this.update();
          }
          else {
            this.menuListEl.style.display = 'none';
          }
        } }, h("slot", { name: "trigger" })), h("span", { part: "menu-list", id: "menu-list", ref: (el) => (this.menuListEl = el) }, h("slot", null))));
    }
  };
  DyteMenu$1.style = dyteMenuCss;

  const dyteMenuItemCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;align-items:center;padding-left:var(--dyte-space-3, 12px);padding-right:var(--dyte-space-3, 12px);padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);cursor:pointer;transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px}::slotted([slot='start']){margin-right:var(--dyte-space-2, 8px)}::slotted([slot='end']){margin-left:var(--dyte-space-2, 8px)}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host(.red){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const DyteMenuItem = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("slot", { name: "start" }), h("slot", null), h("slot", { name: "end" })));
    }
  };
  DyteMenuItem.style = dyteMenuItemCss;

  const dyteMenuListCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;width:-moz-max-content;width:max-content;flex-direction:column;padding-top:var(--dyte-space-2, 8px);padding-bottom:var(--dyte-space-2, 8px);--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));overflow:hidden;border-radius:var(--dyte-border-radius-sm, 4px);--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}";

  const DyteMenuList = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("slot", null)));
    }
  };
  DyteMenuList.style = dyteMenuListCss;

  var dyteMenu_3_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_menu: DyteMenu$1,
      dyte_menu_item: DyteMenuItem,
      dyte_menu_list: DyteMenuList
  });

  const dyteAvatarCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:flex;height:var(--dyte-space-32, 128px);width:var(--dyte-space-32, 128px);align-items:center;justify-content:center;font-size:28px;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)));overflow:clip;border-radius:9999px;-webkit-user-select:none;-moz-user-select:none;user-select:none}dyte-icon{height:50%;width:50%}.image-ctr{display:flex;height:100%;width:100%;align-items:center;justify-content:center;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}img{height:var(--dyte-space-0, 0px);width:var(--dyte-space-0, 0px);-o-object-fit:cover;object-fit:cover}img.loaded{height:100%;width:100%}.initials{display:flex;height:100%;width:100%;align-items:center;justify-content:center;text-transform:uppercase}.image{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.image img{display:none;height:100%;width:100%;-o-object-fit:cover;object-fit:cover}.image img.loaded{display:block}:host([variant='hexagon']){border-radius:var(--dyte-border-radius-none, 0);clip-path:polygon(50% 0, 95% 25%, 95% 75%, 50% 100%, 5% 75%, 5% 25%)}:host([variant='square']){border-radius:var(--dyte-border-radius-none, 0);clip-path:polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)}:host([size='sm']){height:var(--dyte-space-14, 56px);width:var(--dyte-space-14, 56px);font-size:12px}:host([size='md']){height:var(--dyte-space-28, 112px);width:var(--dyte-space-28, 112px)}:host([size='lg']){height:var(--dyte-space-32, 128px);width:var(--dyte-space-32, 128px)}";

  const DyteAvatar = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.getAvatar = () => {
        var _a;
        const name = formatName(((_a = this.participant) === null || _a === undefined ? undefined : _a.name) || '');
        let picture;
        if (this.participant != null && 'picture' in this.participant) {
          picture = this.participant.picture;
        }
        if (picture && picture.length > 0 && this.imageState !== 'errored') {
          return (h("div", { class: "image-ctr" }, this.imageState === 'loading' && h("dyte-spinner", { iconPack: this.iconPack, t: this.t }), h("img", { src: picture, class: { loaded: this.imageState === 'loaded' }, loading: "lazy", title: name, onLoad: () => (this.imageState = 'loaded'), onError: () => (this.imageState = 'errored'), part: "image" })));
        }
        const initials = getInitials(name);
        return (h("div", { class: "initials", title: name, part: "initials" }, initials));
      };
      this.participant = undefined;
      this.variant = 'circular';
      this.size = undefined;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.imageState = 'loading';
    }
    render() {
      return (h(Host, null, this.getAvatar(), h("slot", null)));
    }
  };
  DyteAvatar.style = dyteAvatarCss;

  var dyteAvatar_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_avatar: DyteAvatar
  });

  const dyteControlbarButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--background-color:var(\n    --dyte-controlbar-button-background-color,\n    rgb(var(--dyte-colors-background-1000, 8 8 8))\n  );--icon-size:var(--dyte-controlbar-button-icon-size, var(--dyte-space-7, 28px));--button-spacing:var(--dyte-controlbar-button-spacing, var(--dyte-space-1, 4px));position:relative;box-sizing:border-box;display:inline-flex;outline:2px solid transparent !important;outline-offset:2px !important;margin-left:var(--dyte-space-0\\.5, 2px);margin-right:var(--dyte-space-0\\.5, 2px);height:100%;width:auto;min-width:var(--dyte-space-20, 80px);-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-md, 8px);transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms;color:rgb(var(--dyte-colors-text-1000, 255 255 255));border:var(--dyte-border-width-md, 2px) solid transparent;background-color:var(--background-color)}button{padding:var(--dyte-space-1, 4px)}:host(.red-icon) #icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([disabled]){color:rgb(var(--dyte-colors-text-600, 255 255 255 / 0.52))}button{box-sizing:border-box;display:inline-flex;height:100%;width:100%;flex:1 1 0%;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border-width:var(--dyte-border-width-none, 0);border-style:none;background-color:transparent;color:inherit;outline:2px solid transparent;outline-offset:2px}.label{text-align:center;font-size:12px;overflow:hidden;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:1}#warning-indicator{position:absolute;top:var(--dyte-space-1, 4px);right:var(--dyte-space-2, 8px);height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px);--tw-text-opacity:1;color:rgba(var(--dyte-colors-warning, 255 205 7) / var(--tw-text-opacity))}:host([size='sm']) #warning-indicator{right:var(--dyte-space-0, 0px);top:var(--dyte-space-0, 0px);height:var(--dyte-space-3, 12px);width:var(--dyte-space-3, 12px)}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}#icon{margin-bottom:var(--button-spacing);width:var(--icon-size);height:var(--icon-size)}:host([size='sm']),:host([variant='horizontal']){--button-spacing:0px}:host(.leave:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-1000, 8 8 8) / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity));border:var(--dyte-border-width-md, 2px) solid rgb(var(--dyte-colors-danger, 255 45 45))}:host(.active){--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-400, 53 110 253) / var(--tw-text-opacity));border:var(--dyte-border-width-md, 2px) solid rgb(var(--dyte-colors-brand-400, 53 110 253))}:host(.active-livestream){--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}:host([size='sm']){margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px);min-width:var(--dyte-space-14, 56px)}:host([size='sm']) .label{display:none}:host([variant='horizontal']){margin:var(--dyte-space-0, 0px);height:var(--dyte-space-12, 48px);width:100%;padding-left:var(--dyte-space-5, 20px);padding-right:var(--dyte-space-5, 20px);padding-top:var(--dyte-space-3, 12px);padding-bottom:var(--dyte-space-3, 12px)}:host([variant='horizontal']) button{flex-direction:row;justify-content:flex-start}:host([variant='horizontal']) #icon{margin-right:var(--dyte-space-3, 12px);width:var(--dyte-space-6, 24px)}:host([variant='horizontal']) .label{display:block;font-size:14px;line-height:1.25rem}:host([variant='horizontal']) #warning-indicator{right:auto;left:var(--dyte-space-4, 16px)}:host([brand-icon]) dyte-icon#icon{--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-text-opacity))}@media only screen and (max-device-height: 480px) and (orientation: landscape){:host{margin-left:var(--dyte-space-0, 0px);margin-right:var(--dyte-space-0, 0px)}:host .label{display:none}:slotted(dyte-icon){height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}}";

  const DyteControlbarButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.variant = 'button';
      this.showWarning = false;
      this.size = undefined;
      this.label = undefined;
      this.icon = undefined;
      this.isLoading = undefined;
      this.disabled = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.brandIcon = false;
    }
    render() {
      return (h(Host, null, h("button", { "aria-label": this.label, part: "button" }, this.isLoading ? (h("dyte-spinner", { id: "icon", part: "spinner", iconPack: this.iconPack, t: this.t })) : (h("dyte-icon", { id: "icon", icon: this.icon, tabIndex: -1, "aria-hidden": true, part: "icon", iconPack: this.iconPack, t: this.t })), h("span", { class: "label", part: "label" }, this.label), this.showWarning && (h("dyte-icon", { id: "warning-indicator", icon: this.iconPack.warning, part: "warning-indicator", iconPack: this.iconPack, t: this.t })))));
    }
  };
  DyteControlbarButton.style = dyteControlbarButtonCss;

  var dyteControlbarButton_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_controlbar_button: DyteControlbarButton
  });

  const dyteTooltipCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--background-color:var(--dyte-tooltip-background-color, rgb(var(--dyte-colors-background-600, 60 60 60)));--color:var(--dyte-tooltip-color, rgb(var(--dyte-colors-text-1000, 255 255 255)));display:inline-flex}#trigger{display:block;width:100%;flex:1 1 0%}.tooltip{max-width:var(--dyte-space-64, 256px);position:fixed;z-index:20;display:none;width:-moz-max-content;width:max-content;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);padding-top:var(--dyte-space-1, 4px);padding-bottom:var(--dyte-space-1, 4px);border-radius:var(--dyte-border-radius-sm, 4px);--tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);font-size:12px}.tooltip,#arrow{position:absolute;background-color:var(--background-color);color:var(--color)}#arrow{position:absolute;height:var(--dyte-space-2, 8px);width:var(--dyte-space-2, 8px);transform:rotate(45deg)}:host([variant='primary']){--background-color:rgb(var(--dyte-colors-brand-500, 33 96 253));--color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}:host([kind='block']){display:block}";

  const DyteMenu = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.dyteOpenChange = createEvent(this, "dyteOpenChange", 7);
      this.showMenu = () => {
        if (this.disabled)
          return;
        this.isInFocus = true;
        setTimeout(() => {
          if (this.isInFocus) {
            this.tooltipEl.style.display = 'block';
            this.update();
            this.dyteOpenChange.emit(true);
            if (this.size === 'sm') {
              setTimeout(() => {
                if (this.isInFocus) {
                  this.hideMenu();
                }
              }, 1000);
            }
          }
        }, this.delay);
      };
      this.hideMenu = () => {
        if (this.open || this.disabled)
          return;
        this.isInFocus = false;
        this.tooltipEl.style.display = 'none';
        this.dyteOpenChange.emit(false);
      };
      this.label = '';
      this.variant = 'secondary';
      this.disabled = false;
      this.open = false;
      this.kind = 'inline';
      this.size = undefined;
      this.placement = 'top';
      this.delay = 0;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.isInFocus = false;
    }
    componentDidLoad() {
      this.triggerEl.addEventListener('focusin', this.showMenu);
      this.triggerEl.addEventListener('mouseenter', this.showMenu);
      this.triggerEl.addEventListener('focusout', this.hideMenu);
      this.triggerEl.addEventListener('mouseleave', this.hideMenu);
      writeTask(() => {
        this.openChanged(this.open);
      });
    }
    disconnectedCallback() {
      if (!this.triggerEl)
        return;
      this.triggerEl.removeEventListener('focusin', this.showMenu);
      this.triggerEl.removeEventListener('mouseenter', this.showMenu);
      this.triggerEl.removeEventListener('focusout', this.hideMenu);
      this.triggerEl.removeEventListener('mouseleave', this.hideMenu);
      this.triggerEl = undefined;
    }
    openChanged(open) {
      if (open) {
        this.showMenu();
      }
      else {
        this.hideMenu();
      }
    }
    update() {
      computePosition(this.triggerEl, this.tooltipEl, {
        placement: this.placement,
        middleware: [offset(8), flip(), shift({ padding: 5 }), arrow({ element: this.arrowEl })],
      }).then(({ x, y, placement, middlewareData }) => {
        Object.assign(this.tooltipEl.style, {
          left: `${x}px`,
          top: `${y}px`,
        });
        const { x: arrowX, y: arrowY } = middlewareData.arrow;
        const staticSide = {
          top: 'bottom',
          right: 'left',
          bottom: 'top',
          left: 'right',
        }[placement.split('-')[0]];
        Object.assign(this.arrowEl.style, {
          left: arrowX != null ? `${arrowX}px` : '',
          top: arrowY != null ? `${arrowY}px` : '',
          right: '',
          bottom: '',
          [staticSide]: '-4px',
        });
      });
    }
    render() {
      return (h(Host, null, h("span", { part: "trigger", id: "trigger", ref: (el) => (this.triggerEl = el) }, h("slot", null)), h("div", { part: "tooltip", class: "tooltip", id: "tooltip", role: "tooltip", ref: (el) => (this.tooltipEl = el) }, h("div", { id: "arrow", ref: (el) => (this.arrowEl = el), part: "arrow" }), this.label, h("slot", { name: "tooltip" }))));
    }
    static get watchers() { return {
      "open": ["openChanged"]
    }; }
  };
  DyteMenu.style = dyteTooltipCss;

  var dyteTooltip_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_tooltip: DyteMenu
  });

  const dyteSpinnerCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{box-sizing:border-box;display:block;height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px);--dyte-spinner-color:currentColor}.spinner{height:100%;width:100%}@keyframes spin{to{transform:rotate(360deg)}}.spinner{animation:spin 1s linear infinite;border-radius:9999px;background-color:transparent;animation-duration:1.3s}:host([size='md']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}:host([size='sm']){height:var(--dyte-space-4, 16px);width:var(--dyte-space-4, 16px)}";

  const DyteSpinner = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.iconPack = defaultIconPack;
      this.size = 'md';
      this.t = useLanguage();
    }
    render() {
      return (h(Host, null, h("dyte-icon", { class: "spinner", icon: this.iconPack.spinner, iconPack: this.iconPack, t: this.t })));
    }
  };
  DyteSpinner.style = dyteSpinnerCss;

  var dyteSpinner_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_spinner: DyteSpinner
  });

  const dyteButtonCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{--icon-size:var(--dyte-button-icon-size, var(--dyte-space-5, 20px));--transition-property:var(--dyte-transition-property, all);--transition-duration:100ms;display:inline-flex;height:var(--dyte-space-8, 32px);cursor:pointer;--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-500, 33 96 253) / var(--tw-bg-opacity));color:rgb(var(--dyte-colors-text-1000, 255 255 255));font-size:14px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-radius:var(--dyte-border-radius-sm, 4px);transition-property:var(--transition-property);transition-duration:var(--transition-duration)}button{box-sizing:border-box;background-color:transparent;color:inherit;border:var(--dyte-border-width-sm, 1px) solid transparent;padding-left:var(--dyte-space-2, 8px);padding-right:var(--dyte-space-2, 8px);display:inline-flex;flex-grow:1;justify-content:center;vertical-align:baseline;gap:var(--dyte-space-1, 4px);transition-property:var(--transition-property);transition-duration:var(--transition-duration);outline:none;height:inherit;border-radius:inherit;fill:inherit;cursor:inherit;font-weight:inherit;font-family:inherit;font-size:inherit;line-height:inherit}.start,.content,.end{align-self:center}::slotted(dyte-icon),::slotted(dyte-spinner){height:var(--icon-size);width:var(--icon-size)}:host([variant='primary']){color:rgb(var(--dyte-colors-text-on-brand-1000, var(--dyte-colors-text-1000, 255 255 255)))}:host(:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-600, 13 81 253) / var(--tw-bg-opacity))}button:focus-visible{border-color:rgb(var(--dyte-colors-text-1000, 255 255 255))}:host(:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-brand-700, 2 70 253) / var(--tw-bg-opacity))}:host([disabled]:not([disabled='false'])){cursor:not-allowed;opacity:0.6}:host([variant='secondary']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='secondary']:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-800, 30 30 30) / var(--tw-bg-opacity))}:host([variant='secondary']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-900, 26 26 26) / var(--tw-bg-opacity))}:host([variant='danger']){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}:host([variant='danger']:hover){background-color:rgba(var(--dyte-colors-danger, 255 45 45) / 0.7)}:host([variant='danger']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-bg-opacity))}:host([variant='ghost']){background-color:transparent;color:inherit}:host([variant='ghost'].active){--tw-text-opacity:1;color:rgba(var(--dyte-colors-brand-300, 73 124 253) / var(--tw-text-opacity))}:host([variant='ghost']:hover){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-bg-opacity))}:host([variant='ghost']:active){--tw-bg-opacity:1;background-color:rgba(var(--dyte-colors-background-700, 44 44 44) / var(--tw-bg-opacity))}:host([kind='icon']){--icon-size:var(--dyte-space-5, 20px);width:var(--dyte-space-8, 32px)}:host([kind='icon']) button{padding-left:var(--dyte-space-0, 0px);padding-right:var(--dyte-space-0, 0px)}:host([kind='wide']){width:100%}:host([size='lg']){--icon-size:var(--dyte-space-5, 20px);height:var(--dyte-space-10, 40px);font-size:16px}:host([size='lg'][kind='icon']){--icon-size:var(--dyte-space-6, 24px);height:var(--dyte-space-10, 40px);width:var(--dyte-space-10, 40px)}:host([size='sm']){--icon-size:var(--dyte-space-4, 16px);height:var(--dyte-space-6, 24px);font-size:12px}:host([size='sm'][kind='icon']){height:var(--dyte-space-6, 24px);width:var(--dyte-space-6, 24px)}";

  const DyteButton = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.size = undefined;
      this.variant = 'primary';
      this.kind = 'button';
      this.reverse = false;
      this.disabled = false;
      this.iconPack = defaultIconPack;
      this.t = useLanguage();
      this.type = 'button';
    }
    render() {
      return (h(Host, null, h("button", { part: "button", type: this.type, disabled: this.disabled }, h("span", { class: "start" }, h("slot", { name: "start" })), h("span", { class: "content", part: "content" }, h("slot", null)), h("span", { class: "end" }, h("slot", { name: "end" })))));
    }
  };
  DyteButton.style = dyteButtonCss;

  var dyteButton_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_button: DyteButton
  });

  const dyteIconCss = ":host{line-height:initial;font-family:var(--dyte-font-family, sans-serif);font-feature-settings:normal;font-variation-settings:normal}p{margin:var(--dyte-space-0, 0px);padding:var(--dyte-space-0, 0px)}:host{display:block;height:var(--dyte-space-10, 40px);outline:2px solid transparent;outline-offset:2px}:host .icon-wrapper{display:flex;height:100%;width:100%;flex-direction:column;align-items:center}:host svg{height:100%;width:100%;outline:2px solid transparent;outline-offset:2px}:host([size='xl']){box-sizing:border-box;display:block;height:var(--dyte-space-16, 64px) !important;width:var(--dyte-space-16, 64px) !important;--dyte-spinner-color:currentColor}:host([size='md']){box-sizing:border-box;display:block;height:var(--dyte-space-6, 24px) !important;width:var(--dyte-space-6, 24px) !important;--dyte-spinner-color:currentColor}:host([size='sm']){box-sizing:border-box;display:block;height:var(--dyte-space-4, 16px) !important;width:var(--dyte-space-4, 16px) !important;--dyte-spinner-color:currentColor}:host([variant='secondary']) .icon-wrapper{--tw-text-opacity:1;color:rgba(var(--dyte-colors-background-600, 60 60 60) / var(--tw-text-opacity))}:host([variant='danger']) .icon-wrapper{--tw-text-opacity:1;color:rgba(var(--dyte-colors-danger, 255 45 45) / var(--tw-text-opacity))}";

  const parseIcon = (icon) => {
    try {
      return JSON.parse(icon);
    }
    catch (e) {
      return icon;
    }
  };
  const DyteIcon = class {
    constructor(hostRef) {
      registerInstance(this, hostRef);
      this.icon = undefined;
      this.iconPack = defaultIconPack;
      this.variant = 'primary';
      this.t = useLanguage();
      this.size = 'lg';
    }
    render() {
      return (h(Host, null, h("div", { class: "icon-wrapper", innerHTML: parseIcon(this.icon), part: "wrapper" })));
    }
  };
  DyteIcon.style = dyteIconCss;

  var dyteIcon_entry = /*#__PURE__*/Object.freeze({
      __proto__: null,
      dyte_icon: DyteIcon
  });

  (function(){if("undefined"!==typeof window&&undefined!==window.Reflect&&undefined!==window.customElements){var a=HTMLElement;window.HTMLElement=function(){return Reflect.construct(a,[],this.constructor)};HTMLElement.prototype=a.prototype;HTMLElement.prototype.constructor=HTMLElement;Object.setPrototypeOf(HTMLElement,a);}})();

  class Talk extends HTMLElement {
      /** @type {DyteClient} */
      meeting;

      constructor() {
          super();
          // this.style.width = "100%";
          // this.style.height = "100%";
          this.classList.add('fastn-ignore-global-keyboard'); // TODO(siddhantk232): learn what this means?
      }

      async connectedCallback() {
          const data = window.ftd.component_data(this);
          const token = data.token.get();
          const mid = data.mid.get();

          console.log("Meeting ID: ", mid);
          console.log("Token: ", token);

          if (!token) {
              throw new Error("Token not provided. Quitting");
          }

          this.meeting = await FO.init({
              authToken: token,
          });

          document.querySelector("dyte-meeting").meeting = this.meeting;
      }
  }

  function UTCDateStringToFormattedString(dateString) {
      const date = new Date(dateString.get());
      const formatted =  new Intl.DateTimeFormat('en-US', {
          dateStyle: 'medium',
          timeStyle: 'short',
      }).format(date);

      return formatted;
  }

  window.UTCDateStringToFormattedString = UTCDateStringToFormattedString;

  customElements.define('talk-app', Talk);
  defineCustomElements();

})();
//# sourceMappingURL=build.js.map
